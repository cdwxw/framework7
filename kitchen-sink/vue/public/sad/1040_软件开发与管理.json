{
    "msg": "成功",
    "status": 0,
    "data": {
        "data": {
            "question": [
                {
                    "index": 1,
                    "belong_page": 1,
                    "question_id": 43257,
                    "question_title": "在面向对象设计的原则中，（&nbsp;）原则是指抽象不应该依赖于细节，细节应该依赖于抽象，即应针对接口编程，而不是针对实现编程。",
                    "question_type": 1,
                    "answer_type": 1,
                    "show_type_name": null,
                    "new_parent_id": 43257,
                    "score_rule": "",
                    "material_text": null,
                    "sort_son": "0",
                    "analyze": "依赖倒置原则是指抽象不应该依赖于细节，细节应当依赖于抽象。换言之，要针对接口编程，而不是针对实现编程。在程序代码中传递参数时或在组合（或聚合）关系中，尽量引用层次高的抽象层类，即使用接口和抽象类进行变量类型声明、参数类型声明和方法返回类型声明，以及数据类型的转换等，而不要用具体类来做这些事情。为了确保该原则的应用，一个具体类应当只实现接口和抽象类中声明过的方法，而不要给出多余的方法，否则，将无法调用到在子类中增加的新方法。<p><br/></p><p>实现开闭原则的关键是抽象化，并且从抽象化导出具体化实现，如果说开闭原则是&nbsp;OOD&nbsp;的目标的话，那么依赖倒置原则就是&nbsp;OOD&nbsp;的主要机制。有了抽象层，可以使得系统具有很好的灵活性，在程序中尽量使用抽象层进行编程，而将具体类写在配置文件中，这样，如果系统行为发生变化，则只需要扩展抽象层，并修改配置文件，而无须修改原有系统的源代码，在不修改的情况下来扩展系统功能，满足开闭原则的要求。依赖倒置原则是&nbsp;COM、CORBA、EJB、Spring&nbsp;等技术和框架背后的基本原则之一。</p>",
                    "like": 0,
                    "answer": [
                        "D"
                    ],
                    "option": [
                        " 开闭&nbsp; ",
                        " 里氏替换&nbsp; ",
                        " 最少知识&nbsp; ",
                        " 依赖倒置 "
                    ]
                },
                {
                    "index": 2,
                    "belong_page": 1,
                    "question_id": 43300,
                    "question_title": "<p><br/></p><p style=\"margin: 0px;\"><span style=\"margin: 0px; font-family: &quot;Kaiti SC&quot;; font-size: 11pt;\"><span style=\"font-family:Kaiti SC\">螺旋模型每一阶段的组成部分不包括（）</span></span></p><p><br/></p>",
                    "question_type": 1,
                    "answer_type": 1,
                    "show_type_name": null,
                    "new_parent_id": 43300,
                    "score_rule": "",
                    "material_text": null,
                    "sort_son": "0",
                    "analyze": "<p>略<br/></p>",
                    "like": 0,
                    "answer": [
                        "D"
                    ],
                    "option": [
                        " 风险分析 ",
                        " 评审 ",
                        " 有效性验证 ",
                        " 软件描述 "
                    ]
                },
                {
                    "index": 3,
                    "belong_page": 1,
                    "question_id": 43301,
                    "question_title": "<p>以下关于统一过程RUP的叙述中，不正确的是（ ）。</p>",
                    "question_type": 1,
                    "answer_type": 1,
                    "show_type_name": null,
                    "new_parent_id": 43301,
                    "score_rule": "",
                    "material_text": null,
                    "sort_son": "0",
                    "analyze": "<p>统一过程（RUP）的基本特征是以用例和风险驱动，以架构为中心，受控的迭代式的增量开发。UP定义了四个阶段：</p><p>起始阶段（Inception）：该阶段的主要目的是建立项目的范围和版本，确定项目目标的可行性和稳定性，提交结果包括需求和用例。</p><p>精化阶段（Elaboration）：该阶段的目的是对问题域进行分析，建立系统需求和架构，确定实现的可行性和稳定性，提交结果包括系统架构、问题领域、修改后的需求及项目开发计划等相关文档。</p><p>构建阶段（Construction）：增量式开发可以交付给用户的软件产品。</p><p>移交阶段（Transition）：目的是将软件产品交付给用户。</p>",
                    "like": 0,
                    "answer": [
                        "B"
                    ],
                    "option": [
                        " RUP是以用例和风险为驱动，以架构为中心，迭代并且增量的开发过程 ",
                        " RUP定义了四个阶段，即起始、精化、构建和确认阶段 ",
                        " 每次迭代都包含计划、分析、设计、构造、集成、测试以及内部和外部发布 ",
                        " RUP有9个核心工作流 "
                    ]
                },
                {
                    "index": 4,
                    "belong_page": 1,
                    "question_id": 43303,
                    "question_title": "某公司要开发一个软件产品，产品的某些需求是明确的，而某些需求则需要进一步细化。由于市场竞争的压力，产品需要尽快上市，则开发该软件产品最不适合采用（ ）模型！",
                    "question_type": 1,
                    "answer_type": 1,
                    "show_type_name": null,
                    "new_parent_id": 43303,
                    "score_rule": "",
                    "material_text": null,
                    "sort_son": "0",
                    "analyze": "<p>瀑布模型将软件生命周期划分为需求分析、软件设计、程序编写、软件测试和运行维护等基本活动，并且规定了它们自上而下、相互衔接的固定次序，如同瀑布流水，逐级下落。瀑布模型要求待开发的系统需求是完整的、简明的、一致的，其突出的缺点是不适应用户需求的变化，开发模型是线性的，用户只有等到整个过程的末期才能见到开发成果。对于需求不确定的软件产品不适合采用瀑布模型。</p><p><br/></p><p><br/></p>",
                    "like": 0,
                    "answer": [
                        "A"
                    ],
                    "option": [
                        " 瀑布 ",
                        " 原型 ",
                        " 增量 ",
                        " 螺旋 "
                    ]
                },
                {
                    "index": 5,
                    "belong_page": 1,
                    "question_id": 43305,
                    "question_title": "<p><br/></p><p style=\"margin: 0px;\"><span style=\"margin: 0px; font-family: &quot;Kaiti SC&quot;; font-size: 11pt;\"><span style=\"font-family:Kaiti SC\">软件生命周期不包括（）</span></span></p><p><br/></p>",
                    "question_type": 1,
                    "answer_type": 1,
                    "show_type_name": null,
                    "new_parent_id": 43305,
                    "score_rule": "",
                    "material_text": null,
                    "sort_son": "0",
                    "analyze": "<p>略<br/></p>",
                    "like": 0,
                    "answer": [
                        "D"
                    ],
                    "option": [
                        " 软件定义时期 ",
                        " 软件开发时期 ",
                        " 运行和维护 ",
                        " 软件部署时期 "
                    ]
                },
                {
                    "index": 6,
                    "belong_page": 1,
                    "question_id": 43306,
                    "question_title": "<p><br/></p><p style=\"margin: 0px; line-height: 150%; text-indent: 20.15pt; layout-grid-mode: char;\"><span style=\"margin: 0px; line-height: 150%; font-family: &quot;Kaiti SC&quot;; font-size: 11pt;\"><span style=\"font-family:Kaiti SC\">软件开发时期的工作包括</span></span><span style=\"margin: 0px; line-height: 150%; font-family: &quot;Kaiti SC&quot;; font-size: 11pt;\"></span></p><p><br/></p>",
                    "question_type": 1,
                    "answer_type": 1,
                    "show_type_name": null,
                    "new_parent_id": 43306,
                    "score_rule": "",
                    "material_text": null,
                    "sort_son": "0",
                    "analyze": "<p>略<br/></p>",
                    "like": 0,
                    "answer": [
                        "A"
                    ],
                    "option": [
                        " 概要设计 ",
                        " 需求分析 ",
                        " 运行 ",
                        " 维护时期 "
                    ]
                },
                {
                    "index": 7,
                    "belong_page": 1,
                    "question_id": 43310,
                    "question_title": "<p>以下关于结构化开发方法的叙述中，不正确的是（ ）。</p>",
                    "question_type": 1,
                    "answer_type": 1,
                    "show_type_name": null,
                    "new_parent_id": 43310,
                    "score_rule": "",
                    "material_text": null,
                    "sort_son": "0",
                    "analyze": "<p><span style=\"margin: 0px; line-height: 150%; font-family: &quot;Kaiti SC&quot;; font-size: 11pt;\"><span style=\"font-family:Kaiti SC\">结构化开发方法也称结构化系统开发方法（</span>Structured System De-velopment Methodology），是目前应用最普遍的一种开发方法。其基本思想是用系统的思想和系统工程的方法，按照用户至上的原则结构化、模块化，自顶向下对系统进行分析与设计。它不限于数据处理领域项目。</span><span style=\"margin: 0px; line-height: 150%; font-family: &quot;Kaiti SC&quot;; font-size: 11pt;\"></span></p><p><br/></p>",
                    "like": 0,
                    "answer": [
                        "C"
                    ],
                    "option": [
                        " 总的指导思想是自顶向下，逐层分解 ",
                        " 基本原则是功能的分解与抽象 ",
                        " 与面向对象开发方法相比，更适合大规模、特别复杂的项目 ",
                        " 特别适合于数据处理领域的项目 "
                    ]
                },
                {
                    "index": 8,
                    "belong_page": 1,
                    "question_id": 43311,
                    "question_title": "<p><br/></p><p style=\"margin: 0px;\"><span style=\"margin: 0px; font-family: &quot;Kaiti SC&quot;; font-size: 11pt;\"><span style=\"font-family:Kaiti SC\">以下关于增量模型的叙述中，不正确的是（</span> &nbsp;<span style=\"font-family:Kaiti SC\">）。</span></span></p><p><br/></p>",
                    "question_type": 1,
                    "answer_type": 1,
                    "show_type_name": null,
                    "new_parent_id": 43311,
                    "score_rule": "",
                    "material_text": null,
                    "sort_son": "0",
                    "analyze": "<p><br/></p><p style=\"margin: 0px; line-height: 150%; text-indent: 20.15pt; layout-grid-mode: char;\"><span style=\"margin: 0px; line-height: 150%; font-family: &quot;Kaiti SC&quot;; font-size: 11pt;\"><span style=\"font-family:Kaiti SC\">增量模型又称为渐增模型，也称为有计划的产品改进模型，它从一组给定的需求开始，通过构造一系列可执行中间版本来实施开发活动。第一个版本纳入一部分需求，下一个版本纳入更多的需求，依此类推，直到系统完成。每个中间版本都要执行必需的过程、活动和任务。增量模型是瀑布模型和原型进化模型的综合，它对软件过程的考虑是：在整体上按照瀑布模型的流程实施项目开发，以方便对项目的管理；但在软件的实际创建中，则将软件系统按功能分解为许多增量构件，并以构件为单位逐个地创建与交付，直到全部增量构件创建完毕，并都被集成到系统之中交付用户使用。比较瀑布模型、原型进化模型，增量模型具有非常显著的优越性。但增量模型对软件设计有更高的技术要求，特别是对软件体系结构，要求它具有很好的开放性与稳定性，能够顺利地实现构件的集成。</span></span><span style=\"margin: 0px; line-height: 150%; font-family: &quot;Kaiti SC&quot;; font-size: 11pt;\"></span></p><p><br/></p>",
                    "like": 0,
                    "answer": [
                        "A"
                    ],
                    "option": [
                        " 容易理解，管理成本低 ",
                        " 核心的产品往往首先开发，因此经历最充分的“测试” ",
                        " 第一个可交付版本所需要的成本低，时间少 ",
                        " 即使一开始用户需求不清晰，对开发进度和质量也没有影响 "
                    ]
                },
                {
                    "index": 9,
                    "belong_page": 1,
                    "question_id": 43315,
                    "question_title": "<p><span style=\"font-family: &quot;Kaiti SC&quot;; font-size: 11pt;\">螺旋模型是在（</span><span style=\"font-family: &quot;Kaiti SC&quot;; font-size: 11pt;\"> &nbsp;</span><span style=\"font-family: &quot;Kaiti SC&quot;; font-size: 11pt;\">）的基础上扩展而成。</span></p>",
                    "question_type": 1,
                    "answer_type": 1,
                    "show_type_name": null,
                    "new_parent_id": 43315,
                    "score_rule": "",
                    "material_text": null,
                    "sort_son": "0",
                    "analyze": "螺旋模型是在快速原型（又叫原型）模型的基础上扩展而成的。",
                    "like": 0,
                    "answer": [
                        "B"
                    ],
                    "option": [
                        " 瀑布模型 ",
                        " 原型模型 ",
                        " 快速模型 ",
                        " 面向对象模型 "
                    ]
                },
                {
                    "index": 10,
                    "belong_page": 1,
                    "question_id": 43317,
                    "question_title": "<p>（请作答此空）适用于程序开发人员在地域上分布很广的开发团队。（ ）中，编程开发人员分成首席程序员和“类”程序员。</p>",
                    "question_type": 1,
                    "answer_type": 1,
                    "show_type_name": null,
                    "new_parent_id": 43317,
                    "score_rule": "",
                    "material_text": null,
                    "sort_son": "0",
                    "analyze": "<p><br/></p><p style=\"margin: 0px; line-height: 150%; text-indent: 20.15pt; layout-grid-mode: char;\"><span style=\"margin: 0px; line-height: 150%; font-family: &quot;Kaiti SC&quot;; font-size: 11pt;\">(1) XP (Extreme Programming，极限编程)在所有的敏捷型方法中，XP是最引人瞩目的。它源于Smalltalk圈子，特别是Kent Beck和Ward Cunningham在20世纪80年代末的密切合作。XP在一些对费用控制严格的公司中的使用，已经被证明是非常有效的。</span><span style=\"margin: 0px; line-height: 150%; font-family: &quot;Kaiti SC&quot;; font-size: 11pt;\"></span></p><p style=\"margin: 0px; line-height: 150%; text-indent: 20.15pt; layout-grid-mode: char;\"><span style=\"margin: 0px; line-height: 150%; font-family: &quot;Kaiti SC&quot;; font-size: 11pt;\">(2) Cockburn的水晶系列方法，水晶系列方法是由Alistair Cockburn提出的。它与XP方法一样，都有以人为中心的理念，但在实践上有所不同。Alistair考虑到人们一般很难严格遵循一个纪律约束很强的过程，因此，与XP的高度纪律性不同，Alistair探索了用最少纪律约束而仍能成功的方法，从而在产出效率与易于运作上达到一种平衡。也就是说，虽然水晶系列不如XP那样的产出效率，但会有更多的人能够接受并遵循它。</span><span style=\"margin: 0px; line-height: 150%; font-family: &quot;Kaiti SC&quot;; font-size: 11pt;\"></span></p><p style=\"margin: 0px; line-height: 150%; text-indent: 20.15pt; layout-grid-mode: char;\"><span style=\"margin: 0px; line-height: 150%; font-family: &quot;Kaiti SC&quot;; font-size: 11pt;\">(3) 开放式源码，这里提到的开放式源码指的是开放源码界所用的一种运作方式。开放式源码项目有一个特别之处，就是程序开发人员在地域上分布很广，这使得它和其他敏捷方法不同，因为一般的敏捷方法都强调项目组成员在同一地点工作。开放源码的一个突出特点就是查错排障(debug)的高度并行性，任何人发现了错误都可将改正源码的“补丁”文件发给维护者。然后由维护者将这些“补丁”或是新增的代码并入源码库。</span><span style=\"margin: 0px; line-height: 150%; font-family: &quot;Kaiti SC&quot;; font-size: 11pt;\"></span></p><p style=\"margin: 0px; line-height: 150%; text-indent: 20.15pt; layout-grid-mode: char;\"><span style=\"margin: 0px; line-height: 150%; font-family: &quot;Kaiti SC&quot;; font-size: 11pt;\">(4) SCRUM。SCRUM己经出现很久了，像前面所论及的方法一样，该方法强调这样一个事实，即明确定义了的可重复的方法过程只限于在明确定义了的可重复的环境中，为明确定义了的可重复的人员所用，去解决明确定义了的可重复的问题。</span><span style=\"margin: 0px; line-height: 150%; font-family: &quot;Kaiti SC&quot;; font-size: 11pt;\"></span></p><p style=\"margin: 0px; line-height: 150%; text-indent: 20.15pt; layout-grid-mode: char;\"><span style=\"margin: 0px; line-height: 150%; font-family: &quot;Kaiti SC&quot;; font-size: 11pt;\">(5) Coad的功用驱动开发方法(FDD-Feature Driven Development)</span><span style=\"margin: 0px; line-height: 150%; font-family: &quot;Kaiti SC&quot;; font-size: 11pt;\"></span></p><p style=\"margin: 0px; line-height: 150%; text-indent: 20.15pt; layout-grid-mode: char;\"><span style=\"margin: 0px; line-height: 150%; font-family: &quot;Kaiti SC&quot;; font-size: 11pt;\">FDD是由Jeff De Luca和大师Peter Coad提出来的。像其他方法一样，它致力于短时的迭代阶段和可见可用的功能。在FDD中，一个迭代周期一般是两周。</span><span style=\"margin: 0px; line-height: 150%; font-family: &quot;Kaiti SC&quot;; font-size: 11pt;\"></span></p><p style=\"margin: 0px; line-height: 150%; text-indent: 20.15pt; layout-grid-mode: char;\"><span style=\"margin: 0px; line-height: 150%; font-family: &quot;Kaiti SC&quot;; font-size: 11pt;\"><span style=\"font-family:Kaiti SC\">在</span>FDD中，编程开发人员分成两类：首席程序员和“类”程序员(class owner)。首席程序员是最富有经验的开发人员，他们是项目的协调者、设计者和指导者，而“类”程序员则主要做源码编写。</span><span style=\"margin: 0px; line-height: 150%; font-family: &quot;Kaiti SC&quot;; font-size: 11pt;\"></span></p><p style=\"margin: 0px; line-height: 150%; text-indent: 20.15pt; layout-grid-mode: char;\"><span style=\"margin: 0px; line-height: 150%; font-family: &quot;Kaiti SC&quot;; font-size: 11pt;\">(6) ASD方法，ASD (Adaptive Software Development)方法由Jim Highsmith提出，其核心是三个非线性的、重叠的开发阶段：猜测、合作与学习。</span><span style=\"margin: 0px; line-height: 150%; font-family: &quot;Kaiti SC&quot;; font-size: 11pt;\"></span></p><p style=\"margin: 0px; line-height: 150%; text-indent: 20.15pt; layout-grid-mode: char;\"><span style=\"margin: 0px; line-height: 150%; font-family: &quot;Kaiti SC&quot;; font-size: 11pt;\">&nbsp;</span></p><p><br/></p>",
                    "like": 0,
                    "answer": [
                        "B"
                    ],
                    "option": [
                        " 水晶系列（Crystal）开发方法 ",
                        " 开放式源码（Open&nbsp;source）开发方法 ",
                        " SCRUM开发方法 ",
                        " 功用驱动开发方法（FDD） "
                    ]
                },
                {
                    "index": 11,
                    "belong_page": 1,
                    "question_id": 43320,
                    "question_title": "<p>（）适用于程序开发人员在地域上分布很广的开发团队。（请作答此空）中，编程开发人员分成首席程序员和“类”程序员。<span style=\"margin: 0px; line-height: 150%; font-family: &quot;Kaiti SC&quot;; font-size: 11pt;\"></span></p><p><br/></p>",
                    "question_type": 1,
                    "answer_type": 1,
                    "show_type_name": null,
                    "new_parent_id": 43320,
                    "score_rule": "",
                    "material_text": null,
                    "sort_son": "0",
                    "analyze": "<p>(1)&nbsp;XP&nbsp;(Extreme&nbsp;Programming，极限编程)在所有的敏捷型方法中，XP是最引人瞩目的。它源于Smalltalk圈子，特别是Kent&nbsp;Beck和Ward&nbsp;Cunningham在20世纪80年代末的密切合作。XP在一些对费用控制严格的公司中的使用，已经被证明是非常有效的。</p><p>(2)&nbsp;Cockburn的水晶系列方法，水晶系列方法是由Alistair&nbsp;Cockburn提出的。它与XP方法一样，都有以人为中心的理念，但在实践上有所不同。Alistair考虑到人们一般很难严格遵循一个纪律约束很强的过程，因此，与XP的高度纪律性不同，Alistair探索了用最少纪律约束而仍能成功的方法，从而在产出效率与易于运作上达到一种平衡。也就是说，虽然水晶系列不如XP那样的产出效率，但会有更多的人能够接受并遵循它。<br/></p>(3)&nbsp;开放式源码，这里提到的开放式源码指的是开放源码界所用的一种运作方式。开放式源码项目有一个特别之处，就是程序开发人员在地域上分布很广，这使得它和其他敏捷方法不同，因为一般的敏捷方法都强调项目组成员在同一地点工作。开放源码的一个突出特点就是查错排障(debug)的高度并行性，任何人发现了错误都可将改正源码的“补丁”文件发给维护者。然后由维护者将这些“补丁”或是新增的代码并入源码库。<p>(4)&nbsp;SCRUM。SCRUM己经出现很久了，像前面所论及的方法一样，该方法强调这样一个事实，即明确定义了的可重复的方法过程只限于在明确定义了的可重复的环境中，为明确定义了的可重复的人员所用，去解决明确定义了的可重复的问题。<br/></p>(5)&nbsp;Coad的功用驱动开发方法(FDD-Feature&nbsp;Driven&nbsp;Development)<p>FDD是由Jeff&nbsp;De&nbsp;Luca和大师Peter&nbsp;Coad提出来的。像其他方法一样，它致力于短时的迭代阶段和可见可用的功能。在FDD中，一个迭代周期一般是两周。<br/></p>在FDD中，编程开发人员分成两类：首席程序员和“类”程序员(class&nbsp;owner)。首席程序员是最富有经验的开发人员，他们是项目的协调者、设计者和指导者，而“类”程序员则主要做源码编写。<p>(6)&nbsp;ASD方法，ASD&nbsp;(Adaptive&nbsp;Software&nbsp;Development)方法由Jim&nbsp;Highsmith提出，其核心是三个非线性的、重叠的开发阶段：猜测、合作与学习。</p>",
                    "like": 0,
                    "answer": [
                        "D"
                    ],
                    "option": [
                        " 自适应软件开发（ASD） ",
                        " 极限编程（XP）开发方法 ",
                        " 开放统—过程开发方法（OpenUP） ",
                        " 功用驱动开发方法（FDD） "
                    ]
                },
                {
                    "index": 12,
                    "belong_page": 1,
                    "question_id": 43327,
                    "question_title": "<p><br/></p><p style=\"margin: 0px;\"><span style=\"margin: 0px; font-family: 楷体; font-size: 11pt;\"><span style=\"font-family:楷体\">用于管理信息系统规划的方法有很多，其中（</span>1）将整个过程看成是一个“信息集合”，并将组织的战略目标转变为管理信息系统的战略目标。（2）通过自上而下地识别企业目标、企业过程和数据，然后对数据进行分析，自下而上地设计信息系统。【答括号1】</span></p><p><br/></p>",
                    "question_type": 1,
                    "answer_type": 1,
                    "show_type_name": null,
                    "new_parent_id": 43327,
                    "score_rule": "",
                    "material_text": null,
                    "sort_son": "0",
                    "analyze": "<p><br/></p><p style=\"margin: 0px 0px 0px 26.86px; text-indent: 0pt;\"><span style=\"margin: 0px; font-family: 楷体; font-size: 11pt;\"><span style=\"font-family:楷体\">用于管理信息系统规划的方法很多，主要是关键成功因素法（</span></span><span style=\"margin: 0px; font-family: 楷体; font-size: 11pt;\">Critical Success Factors</span><span style=\"margin: 0px; font-family: 楷体; font-size: 11pt;\"><span style=\"font-family:楷体\">，</span></span><span style=\"margin: 0px; font-family: 楷体; font-size: 11pt;\">CSF</span><span style=\"margin: 0px; font-family: 楷体; font-size: 11pt;\"><span style=\"font-family:楷体\">）、战略目标集转化法（</span></span><span style=\"margin: 0px; font-family: 楷体; font-size: 11pt;\">Strategy Set Transformation, SST</span><span style=\"margin: 0px; font-family: 楷体; font-size: 11pt;\"><span style=\"font-family:楷体\">）和企业系统规划法（</span></span><span style=\"margin: 0px; font-family: 楷体; font-size: 11pt;\">Business System Planning, BSP</span><span style=\"margin: 0px; font-family: 楷体; font-size: 11pt;\"><span style=\"font-family:楷体\">）。其它还有企业信息分析与集成技术（</span></span><span style=\"margin: 0px; font-family: 楷体; font-size: 11pt;\">BIAIT</span><span style=\"margin: 0px; font-family: 楷体; font-size: 11pt;\"><span style=\"font-family:楷体\">）、产出／方法分析（</span></span><span style=\"margin: 0px; font-family: 楷体; font-size: 11pt;\">E/MA</span><span style=\"margin: 0px; font-family: 楷体; font-size: 11pt;\"><span style=\"font-family:楷体\">）、投资回收法（</span></span><span style=\"margin: 0px; font-family: 楷体; font-size: 11pt;\">ROI</span><span style=\"margin: 0px; font-family: 楷体; font-size: 11pt;\"><span style=\"font-family:楷体\">）、征费法、零线预算法、阶石法等。用得最多的是前面三种。</span></span><span style=\"margin: 0px; font-family: 楷体; font-size: 11pt;\"></span></p><p style=\"margin: 0px; text-indent: 22pt;\"><span style=\"margin: 0px; font-family: 楷体; font-size: 11pt;\">1. </span><span style=\"margin: 0px; font-family: 楷体; font-size: 11pt;\"><span style=\"font-family:楷体\">关键成功因素法（</span></span><span style=\"margin: 0px; font-family: 楷体; font-size: 11pt;\">CSF</span><span style=\"margin: 0px; font-family: 楷体; font-size: 11pt;\"><span style=\"font-family:楷体\">）</span></span><span style=\"margin: 0px; font-family: 楷体; font-size: 11pt;\"></span></p><p style=\"margin: 0px; text-indent: 22pt;\"><span style=\"margin: 0px; font-family: 楷体; font-size: 11pt;\"><span style=\"font-family:楷体\">在现行系统中，总存在着多个变量影响系统目标的实现，其中若干个因素是关键的和主要的（即关键成功因素）。通过对关键成功因素的识别，找出实现目标所需的关键信息集合，从而确定系统开发的优先次序。</span></span><span style=\"margin: 0px; font-family: 楷体; font-size: 11pt;\"></span></p><p style=\"margin: 0px; text-indent: 22pt;\"><span style=\"margin: 0px; font-family: 楷体; font-size: 11pt;\"><span style=\"font-family:楷体\">关键成功因素来自于组织的目标，通过组织的目标分解和关键成功因素识别、性能指标识别，一直到产生数据字典。</span></span><span style=\"margin: 0px; font-family: 楷体; font-size: 11pt;\"></span></p><p style=\"margin: 0px; text-indent: 22pt;\"><span style=\"margin: 0px; font-family: 楷体; font-size: 11pt;\"><span style=\"font-family:楷体\">识别关键成功因素，就是要识别联系于组织目标的主要数据类型及其关系。不同的组织的关键成功因素不同，不同时期关键成功因素也不相同。当在一个时期内的关键成功因素解决后，新的识别关键成功因素又开始。</span></span><span style=\"margin: 0px; font-family: 楷体; font-size: 11pt;\"></span></p><p style=\"margin: 0px; text-indent: 22pt;\"><span style=\"margin: 0px; font-family: 楷体; font-size: 11pt;\"><span style=\"font-family:楷体\">关键成功因素法能抓住主要矛盾，使目标的识别突出重点。由于经理们比较熟悉这种方法，使用这种方法所确定的目标，因而经理们乐于努力去实现。该方法最有利于确定企业的管理目标。</span></span><span style=\"margin: 0px; font-family: 楷体; font-size: 11pt;\"></span></p><p style=\"margin: 0px; text-indent: 22pt;\"><span style=\"margin: 0px; font-family: 楷体; font-size: 11pt;\">2.</span><span style=\"margin: 0px; font-family: 楷体; font-size: 11pt;\"><span style=\"font-family:楷体\">战略目标集转化法（</span></span><span style=\"margin: 0px; font-family: 楷体; font-size: 11pt;\">SST</span><span style=\"margin: 0px; font-family: 楷体; font-size: 11pt;\"><span style=\"font-family:楷体\">）</span></span><span style=\"margin: 0px; font-family: 楷体; font-size: 11pt;\"></span></p><p style=\"margin: 0px; text-indent: 22pt;\"><span style=\"margin: 0px; font-family: 楷体; font-size: 11pt;\"><span style=\"font-family:楷体\">把整个战略目标看成是一个</span>“信息集合”，由使命、目标、战略等组成，管理信息系统的规划过程即是把组织的战略目标转变成为管理信息系统的战略目标的过程。</span><span style=\"margin: 0px; font-family: 楷体; font-size: 11pt;\"></span></p><p style=\"margin: 0px; text-indent: 22pt;\"><span style=\"margin: 0px; font-family: 楷体; font-size: 11pt;\"><span style=\"font-family:楷体\">战略目标集转化法从另一个角度识别管理目标，它反映了各种人的要求，而且给出了按这种要求的分层，然后转化为信息系统目标的结构化方法。它能保证目标比较全面，疏漏较少，但它在突出重点方面不如关键成功因素法。</span></span><span style=\"margin: 0px; font-family: 楷体; font-size: 11pt;\"></span></p><p style=\"margin: 0px; text-indent: 22pt;\"><span style=\"margin: 0px; font-family: 楷体; font-size: 11pt;\">3. </span><span style=\"margin: 0px; font-family: 楷体; font-size: 11pt;\"><span style=\"font-family:楷体\">企业系统规划法（</span></span><span style=\"margin: 0px; font-family: 楷体; font-size: 11pt;\">BSP</span><span style=\"margin: 0px; font-family: 楷体; font-size: 11pt;\"><span style=\"font-family:楷体\">）</span></span><span style=\"margin: 0px; font-family: 楷体; font-size: 11pt;\"></span></p><p style=\"margin: 0px; text-indent: 22pt;\"><span style=\"margin: 0px; font-family: 楷体; font-size: 11pt;\"><span style=\"font-family:楷体\">信息支持企业运行。通过自上而下地识别系统目标、企业过程和数据，然后对数据进行分析，自下而上地设计信息系统。该管理信息系统支持企业目标的实现，表达所有管理层次的要求，向企业提供一致性信息，对组织机构的变动具有适应性。</span></span><span style=\"margin: 0px; font-family: 楷体; font-size: 11pt;\"></span></p><p style=\"margin: 0px; text-indent: 22pt;\"><span style=\"margin: 0px; font-family: 楷体; font-size: 11pt;\"><span style=\"font-family:楷体\">企业系统规划法虽然也首先强调目标，但它没有明显的目标导引过程。它通过识别企业</span>“过程”引出了系统目标，企业目标到系统目标的转化是通过企业过程</span><span style=\"margin: 0px; font-family: 楷体; font-size: 11pt;\">/</span><span style=\"margin: 0px; font-family: 楷体; font-size: 11pt;\"><span style=\"font-family:楷体\">数据类等矩阵的分析得到的。</span></span><span style=\"margin: 0px; font-family: 楷体; font-size: 11pt;\"></span></p><p><br/></p>",
                    "like": 0,
                    "answer": [
                        "B"
                    ],
                    "option": [
                        " 关键成功因素法 ",
                        " 战略目标集转化法 ",
                        " 征费法 ",
                        " 零线预算法 "
                    ]
                },
                {
                    "index": 13,
                    "belong_page": 1,
                    "question_id": 43331,
                    "question_title": "<p><br/></p><p style=\"margin: 0px; text-indent: 22pt;\"><span style=\"margin: 0px; font-family: 楷体; font-size: 11pt;\"><span style=\"font-family:楷体\">用于管理信息系统规划的方法有很多，其中（</span>1）将整个过程看成是一个“信息集合”，并将组织的战略目标转变为管理信息系统的战略目标。（2）通过自上而下地识别企业目标、企业过程和数据，然后对数据进行分析，自下而上地设计信息系统。【答括号2】</span><span style=\"margin: 0px; font-family: 楷体; font-size: 11pt;\"></span></p><p><br/></p>",
                    "question_type": 1,
                    "answer_type": 1,
                    "show_type_name": null,
                    "new_parent_id": 43331,
                    "score_rule": "",
                    "material_text": null,
                    "sort_son": "0",
                    "analyze": "<p><br/></p><p style=\"margin: 0px 0px 0px 26.86px; text-indent: 0pt;\"><span style=\"margin: 0px; font-family: 楷体; font-size: 11pt;\"><span style=\"font-family:楷体\">用于管理信息系统规划的方法很多，主要是关键成功因素法（</span></span><span style=\"margin: 0px; font-family: 楷体; font-size: 11pt;\">Critical Success Factors</span><span style=\"margin: 0px; font-family: 楷体; font-size: 11pt;\"><span style=\"font-family:楷体\">，</span></span><span style=\"margin: 0px; font-family: 楷体; font-size: 11pt;\">CSF</span><span style=\"margin: 0px; font-family: 楷体; font-size: 11pt;\"><span style=\"font-family:楷体\">）、战略目标集转化法（</span></span><span style=\"margin: 0px; font-family: 楷体; font-size: 11pt;\">Strategy Set Transformation, SST</span><span style=\"margin: 0px; font-family: 楷体; font-size: 11pt;\"><span style=\"font-family:楷体\">）和企业系统规划法（</span></span><span style=\"margin: 0px; font-family: 楷体; font-size: 11pt;\">Business System Planning, BSP</span><span style=\"margin: 0px; font-family: 楷体; font-size: 11pt;\"><span style=\"font-family:楷体\">）。其它还有企业信息分析与集成技术（</span></span><span style=\"margin: 0px; font-family: 楷体; font-size: 11pt;\">BIAIT</span><span style=\"margin: 0px; font-family: 楷体; font-size: 11pt;\"><span style=\"font-family:楷体\">）、产出／方法分析（</span></span><span style=\"margin: 0px; font-family: 楷体; font-size: 11pt;\">E/MA</span><span style=\"margin: 0px; font-family: 楷体; font-size: 11pt;\"><span style=\"font-family:楷体\">）、投资回收法（</span></span><span style=\"margin: 0px; font-family: 楷体; font-size: 11pt;\">ROI</span><span style=\"margin: 0px; font-family: 楷体; font-size: 11pt;\"><span style=\"font-family:楷体\">）、征费法、零线预算法、阶石法等。用得最多的是前面三种。</span></span><span style=\"margin: 0px; font-family: 楷体; font-size: 11pt;\"></span></p><p style=\"margin: 0px; text-indent: 22pt;\"><span style=\"margin: 0px; font-family: 楷体; font-size: 11pt;\">1. </span><span style=\"margin: 0px; font-family: 楷体; font-size: 11pt;\"><span style=\"font-family:楷体\">关键成功因素法（</span></span><span style=\"margin: 0px; font-family: 楷体; font-size: 11pt;\">CSF</span><span style=\"margin: 0px; font-family: 楷体; font-size: 11pt;\"><span style=\"font-family:楷体\">）</span></span><span style=\"margin: 0px; font-family: 楷体; font-size: 11pt;\"></span></p><p style=\"margin: 0px; text-indent: 22pt;\"><span style=\"margin: 0px; font-family: 楷体; font-size: 11pt;\"><span style=\"font-family:楷体\">在现行系统中，总存在着多个变量影响系统目标的实现，其中若干个因素是关键的和主要的（即关键成功因素）。通过对关键成功因素的识别，找出实现目标所需的关键信息集合，从而确定系统开发的优先次序。</span></span><span style=\"margin: 0px; font-family: 楷体; font-size: 11pt;\"></span></p><p style=\"margin: 0px; text-indent: 22pt;\"><span style=\"margin: 0px; font-family: 楷体; font-size: 11pt;\"><span style=\"font-family:楷体\">关键成功因素来自于组织的目标，通过组织的目标分解和关键成功因素识别、性能指标识别，一直到产生数据字典。</span></span><span style=\"margin: 0px; font-family: 楷体; font-size: 11pt;\"></span></p><p style=\"margin: 0px; text-indent: 22pt;\"><span style=\"margin: 0px; font-family: 楷体; font-size: 11pt;\"><span style=\"font-family:楷体\">识别关键成功因素，就是要识别联系于组织目标的主要数据类型及其关系。不同的组织的关键成功因素不同，不同时期关键成功因素也不相同。当在一个时期内的关键成功因素解决后，新的识别关键成功因素又开始。</span></span><span style=\"margin: 0px; font-family: 楷体; font-size: 11pt;\"></span></p><p style=\"margin: 0px; text-indent: 22pt;\"><span style=\"margin: 0px; font-family: 楷体; font-size: 11pt;\"><span style=\"font-family:楷体\">关键成功因素法能抓住主要矛盾，使目标的识别突出重点。由于经理们比较熟悉这种方法，使用这种方法所确定的目标，因而经理们乐于努力去实现。该方法最有利于确定企业的管理目标。</span></span><span style=\"margin: 0px; font-family: 楷体; font-size: 11pt;\"></span></p><p style=\"margin: 0px; text-indent: 22pt;\"><span style=\"margin: 0px; font-family: 楷体; font-size: 11pt;\">2.</span><span style=\"margin: 0px; font-family: 楷体; font-size: 11pt;\"><span style=\"font-family:楷体\">战略目标集转化法（</span></span><span style=\"margin: 0px; font-family: 楷体; font-size: 11pt;\">SST</span><span style=\"margin: 0px; font-family: 楷体; font-size: 11pt;\"><span style=\"font-family:楷体\">）</span></span><span style=\"margin: 0px; font-family: 楷体; font-size: 11pt;\"></span></p><p style=\"margin: 0px; text-indent: 22pt;\"><span style=\"margin: 0px; font-family: 楷体; font-size: 11pt;\"><span style=\"font-family:楷体\">把整个战略目标看成是一个</span>“信息集合”，由使命、目标、战略等组成，管理信息系统的规划过程即是把组织的战略目标转变成为管理信息系统的战略目标的过程。</span><span style=\"margin: 0px; font-family: 楷体; font-size: 11pt;\"></span></p><p style=\"margin: 0px; text-indent: 22pt;\"><span style=\"margin: 0px; font-family: 楷体; font-size: 11pt;\"><span style=\"font-family:楷体\">战略目标集转化法从另一个角度识别管理目标，它反映了各种人的要求，而且给出了按这种要求的分层，然后转化为信息系统目标的结构化方法。它能保证目标比较全面，疏漏较少，但它在突出重点方面不如关键成功因素法。</span></span><span style=\"margin: 0px; font-family: 楷体; font-size: 11pt;\"></span></p><p style=\"margin: 0px; text-indent: 22pt;\"><span style=\"margin: 0px; font-family: 楷体; font-size: 11pt;\">3. </span><span style=\"margin: 0px; font-family: 楷体; font-size: 11pt;\"><span style=\"font-family:楷体\">企业系统规划法（</span></span><span style=\"margin: 0px; font-family: 楷体; font-size: 11pt;\">BSP</span><span style=\"margin: 0px; font-family: 楷体; font-size: 11pt;\"><span style=\"font-family:楷体\">）</span></span><span style=\"margin: 0px; font-family: 楷体; font-size: 11pt;\"></span></p><p style=\"margin: 0px; text-indent: 22pt;\"><span style=\"margin: 0px; font-family: 楷体; font-size: 11pt;\"><span style=\"font-family:楷体\">信息支持企业运行。通过自上而下地识别系统目标、企业过程和数据，然后对数据进行分析，自下而上地设计信息系统。该管理信息系统支持企业目标的实现，表达所有管理层次的要求，向企业提供一致性信息，对组织机构的变动具有适应性。</span></span><span style=\"margin: 0px; font-family: 楷体; font-size: 11pt;\"></span></p><p style=\"margin: 0px; text-indent: 22pt;\"><span style=\"margin: 0px; font-family: 楷体; font-size: 11pt;\"><span style=\"font-family:楷体\">企业系统规划法虽然也首先强调目标，但它没有明显的目标导引过程。它通过识别企业</span>“过程”引出了系统目标，企业目标到系统目标的转化是通过企业过程</span><span style=\"margin: 0px; font-family: 楷体; font-size: 11pt;\">/</span><span style=\"margin: 0px; font-family: 楷体; font-size: 11pt;\"><span style=\"font-family:楷体\">数据类等矩阵的分析得到的。</span></span><span style=\"margin: 0px; font-family: 楷体; font-size: 11pt;\"></span></p><p><br/></p>",
                    "like": 0,
                    "answer": [
                        "C"
                    ],
                    "option": [
                        " 企业信息分析与集成法 ",
                        " 投资回收法 ",
                        " 企业系统规划法 ",
                        " 阶石法 "
                    ]
                },
                {
                    "index": 14,
                    "belong_page": 1,
                    "question_id": 43760,
                    "question_title": "<p><br/></p><p><br/></p><p class=\"MsoNormal\" style=\"text-indent:20.7000pt;text-align:left;\"><span style=\"mso-spacerun:&#39;yes&#39;;font-family:宋体;font-size:10.5000pt;mso-font-kerning:1.0000pt;\"><span style=\"font-family:宋体\">关于项目范围管理描述，正确的是</span></span><span style=\"text-decoration:underline;\"><span style=\"mso-spacerun:&#39;yes&#39;;font-family:宋体;text-decoration:underline;text-underline:single;font-size:10.5000pt;mso-font-kerning:1.0000pt;\"><span style=\"font-family:宋体\">（</span></span></span><span style=\"text-decoration:underline;\"><span style=\"mso-spacerun:&#39;yes&#39;;font-family:宋体;text-decoration:underline;text-underline:single;font-size:10.5000pt;mso-font-kerning:1.0000pt;\">25</span></span><span style=\"text-decoration:underline;\"><span style=\"mso-spacerun:&#39;yes&#39;;font-family:宋体;text-decoration:underline;text-underline:single;font-size:10.5000pt;mso-font-kerning:1.0000pt;\"><span style=\"font-family:宋体\">）</span></span></span><span style=\"mso-spacerun:&#39;yes&#39;;font-family:宋体;font-size:10.5000pt;mso-font-kerning:1.0000pt;\"><span style=\"font-family:宋体\">。</span></span><span style=\"mso-spacerun:&#39;yes&#39;;font-family:宋体;mso-hansi-font-family:&#39;Times New Roman&#39;;font-size:10.5000pt;mso-font-kerning:1.0000pt;\"></span></p><p><br/></p>",
                    "question_type": 1,
                    "answer_type": 1,
                    "show_type_name": null,
                    "new_parent_id": 43760,
                    "score_rule": "",
                    "material_text": null,
                    "sort_son": "0",
                    "analyze": "<p>略</p>",
                    "like": 0,
                    "answer": [
                        "D"
                    ],
                    "option": [
                        " 项目范围是指信息系统产品或者服务所应包含的功能 ",
                        " 项目范围描述是产品范围说明书的重要组成部分 ",
                        " 项目范围定义是信息系统要求的度量 ",
                        " 项目范围定义是生产项目计划的基础 "
                    ]
                },
                {
                    "index": 15,
                    "belong_page": 1,
                    "question_id": 43761,
                    "question_title": "<p><br/></p><p><br/></p><p class=\"MsoNormal\" style=\"text-indent:20.7000pt;text-align:left;\"><span style=\"mso-spacerun:&#39;yes&#39;;font-family:宋体;font-size:10.5000pt;mso-font-kerning:1.0000pt;\"><span style=\"font-family:宋体\">项目配置管理中，配置项的状态通常包括</span></span><span style=\"text-decoration:underline;\"><span style=\"mso-spacerun:&#39;yes&#39;;font-family:宋体;text-decoration:underline;text-underline:single;font-size:10.5000pt;mso-font-kerning:1.0000pt;\"><span style=\"font-family:宋体\">（</span></span></span><span style=\"text-decoration:underline;\"><span style=\"mso-spacerun:&#39;yes&#39;;font-family:宋体;text-decoration:underline;text-underline:single;font-size:10.5000pt;mso-font-kerning:1.0000pt;\">26</span></span><span style=\"text-decoration:underline;\"><span style=\"mso-spacerun:&#39;yes&#39;;font-family:宋体;text-decoration:underline;text-underline:single;font-size:10.5000pt;mso-font-kerning:1.0000pt;\"><span style=\"font-family:宋体\">）</span></span></span><span style=\"mso-spacerun:&#39;yes&#39;;font-family:宋体;font-size:10.5000pt;mso-font-kerning:1.0000pt;\"><span style=\"font-family:宋体\">。</span></span><span style=\"mso-spacerun:&#39;yes&#39;;font-family:宋体;mso-hansi-font-family:&#39;Times New Roman&#39;;font-size:10.5000pt;mso-font-kerning:1.0000pt;\"></span></p><p><br/></p>",
                    "question_type": 1,
                    "answer_type": 1,
                    "show_type_name": null,
                    "new_parent_id": 43761,
                    "score_rule": "",
                    "material_text": null,
                    "sort_son": "0",
                    "analyze": "<p>略</p>",
                    "like": 0,
                    "answer": [
                        "A"
                    ],
                    "option": [
                        " 草稿、正式发布和正在修改&nbsp; ",
                        " 草稿、技术评审和正式发布 ",
                        " 草稿、评审或审批、正式发布&nbsp;&nbsp; ",
                        " 草稿、正式发布和版本变更 "
                    ]
                },
                {
                    "index": 16,
                    "belong_page": 1,
                    "question_id": 43764,
                    "question_title": "<p><br/></p><p><br/></p><p class=\"MsoNormal\" style=\"text-indent:20.7000pt;text-align:left;\"><span style=\"mso-spacerun:&#39;yes&#39;;font-family:宋体;font-size:10.5000pt;mso-font-kerning:1.0000pt;\"><span style=\"font-family:宋体\">一个大型软件系统的需求总是有变化的。为了降低项目开发的风险，需要一个好的变更控制过程。如下图所示的需求变更管理过程中，</span>①②③处对应的内容应是</span><span style=\"text-decoration:underline;\"><span style=\"mso-spacerun:&#39;yes&#39;;font-family:宋体;text-decoration:underline;text-underline:single;font-size:10.5000pt;mso-font-kerning:1.0000pt;\"><span style=\"font-family:宋体\">（</span></span></span><span style=\"text-decoration:underline;\"><span style=\"mso-spacerun:&#39;yes&#39;;font-family:宋体;text-decoration:underline;text-underline:single;font-size:10.5000pt;mso-font-kerning:1.0000pt;\"><span style=\"font-family:宋体\">）</span></span></span><span style=\"mso-spacerun:&#39;yes&#39;;font-family:宋体;font-size:10.5000pt;mso-font-kerning:1.0000pt;\"><span style=\"font-family:宋体\">；自动化工具能够帮助变更控制过程更有效地运作，</span></span><span style=\"text-decoration:underline;\"><span style=\"mso-spacerun:&#39;yes&#39;;font-family:宋体;text-decoration:underline;text-underline:single;font-size:10.5000pt;mso-font-kerning:1.0000pt;\"><span style=\"font-family:宋体\">（请作答此空</span></span></span><span style=\"text-decoration:underline;\"><span style=\"mso-spacerun:&#39;yes&#39;;font-family:宋体;text-decoration:underline;text-underline:single;font-size:10.5000pt;mso-font-kerning:1.0000pt;\"><span style=\"font-family:宋体\">）</span></span></span><span style=\"mso-spacerun:&#39;yes&#39;;font-family:宋体;font-size:10.5000pt;mso-font-kerning:1.0000pt;\"><span style=\"font-family:宋体\">是这类工具应具有的特性之一。</span></span></p><p class=\"MsoNormal\" style=\"text-indent:20.7000pt;text-align:left;\"><img style=\"max-width:100%;height:auto\"  src=\"https://s2.51cto.com/images/201807/0770746275cb98ab4a116305c1005fed5f80a3.png\"/><span style=\"mso-spacerun:&#39;yes&#39;;font-family:宋体;font-size:10.5000pt;mso-font-kerning:1.0000pt;\"><span style=\"font-family:宋体\"></span></span><span style=\"mso-spacerun:&#39;yes&#39;;font-family:宋体;mso-hansi-font-family:&#39;Times New Roman&#39;;font-size:10.5000pt;mso-font-kerning:1.0000pt;\"></span></p><p><br/></p>",
                    "question_type": 1,
                    "answer_type": 1,
                    "show_type_name": null,
                    "new_parent_id": 43764,
                    "score_rule": "",
                    "material_text": null,
                    "sort_son": "0",
                    "analyze": "<p><br/></p><p><br/></p><p>&nbsp;①问题分析和变更描述。这是识别和分析需求问题或者一份明确的变更提议，以检查它的有效性，从而产生一个更明确的需求变更提议。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;②变更分析和成本计算。使用可追溯性信息和系统需求的一般知识，对需求变更提议进行影响分析和评估。变更成本计算应该包括对需求文档的修改、系统修改的设计和实现的成本。一旦分析完成并且确认，应该进行是否执行这一变更的决策。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;③变更实现。这要求需求文档和系统设计以及实现都要同时修改。如果先对系统的程序做变更，然后再修改需求文档，这几乎不可避免地会出现需求文档和程序的不一致。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;自动化工具能够帮助变更控制过程更有效地运作。许多团队使用商业问题跟踪工具来收集、存储和管理需求变更。用这样的工具创建的最近提交的变更建议清单，可以用作CCB会议的议程。问题跟踪工具也可以随时按变更状态分类报告出变更请求的数目。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;因为可用的工具、厂商和特性总在频繁地变化，所以这里无法给出有关工具的具体建议。但工具应该具有以下几个特性，以支持需求变更过程：</p><p>&nbsp;&nbsp;&nbsp;&nbsp;①可以定义变更请求中的数据项；</p><p>&nbsp;&nbsp;&nbsp;&nbsp;②可以定义变更请求生命周期的状态转换模型；</p><p>&nbsp;&nbsp;&nbsp;&nbsp;③可以强制实施状态转换模型，以便只有授权用户可以做出允许的状态变更；</p><p>&nbsp;&nbsp;&nbsp;&nbsp;④可以记录每一个状态变更的日期和做出这一变更的人；</p><p>&nbsp;&nbsp;&nbsp;&nbsp;⑤可以定义当提议者提交新请求或请求状态被更新时，哪些人可以自动接收电子邮件通知；</p><p>&nbsp;&nbsp;&nbsp;&nbsp;⑥可以生成标准的和定制的报告和图表。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;有些商业需求管理工具内置有简单的变更建议系统。这些系统可以将提议的变更与某一特定的需求联系起来，这样无论什么时候，只要有人提交了一个相关的变更请求，负责需求的每个人都会收到电子邮件通知。</p><p><br/></p>",
                    "like": 0,
                    "answer": [
                        "D"
                    ],
                    "option": [
                        " 自动维护系统的不同版本 ",
                        " 支持系统文档的自动更新 ",
                        " 自动判定变更是否能够实施 ",
                        " 记录每一个状态变更的日期及变更者 "
                    ]
                },
                {
                    "index": 17,
                    "belong_page": 1,
                    "question_id": 43765,
                    "question_title": "<p><br/></p><p class=\"MsoNormal\" style=\"text-indent:20.7000pt;text-align:left;\"><span style=\"mso-spacerun:&#39;yes&#39;;font-family:宋体;font-size:10.5000pt;mso-font-kerning:1.0000pt;\"><span style=\"font-family:宋体\">处理流程设计是系统设计的重要内容。以下关于处理流程设计工具的叙述中，不正确的是</span></span><span style=\"text-decoration:underline;\"><span style=\"mso-spacerun:&#39;yes&#39;;font-family:宋体;text-decoration:underline;text-underline:single;font-size:10.5000pt;mso-font-kerning:1.0000pt;\"><span style=\"font-family:宋体\">（</span></span></span><span style=\"text-decoration:underline;\"><span style=\"mso-spacerun:&#39;yes&#39;;font-family:宋体;text-decoration:underline;text-underline:single;font-size:10.5000pt;mso-font-kerning:1.0000pt;\">30</span></span><span style=\"text-decoration:underline;\"><span style=\"mso-spacerun:&#39;yes&#39;;font-family:宋体;text-decoration:underline;text-underline:single;font-size:10.5000pt;mso-font-kerning:1.0000pt;\"><span style=\"font-family:宋体\">）</span></span></span><span style=\"mso-spacerun:&#39;yes&#39;;font-family:宋体;font-size:10.5000pt;mso-font-kerning:1.0000pt;\"><span style=\"font-family:宋体\">。</span></span><span style=\"mso-spacerun:&#39;yes&#39;;font-family:宋体;mso-hansi-font-family:&#39;Times New Roman&#39;;font-size:10.5000pt;mso-font-kerning:1.0000pt;\"></span></p><p><br/></p>",
                    "question_type": 1,
                    "answer_type": 1,
                    "show_type_name": null,
                    "new_parent_id": 43765,
                    "score_rule": "",
                    "material_text": null,
                    "sort_son": "0",
                    "analyze": "<p><br/></p><p><br/></p><p>&nbsp;程序流程图(Program Flow Diagram，PFD)用一些图框表示各种操作，它独立于任何一种程序设计语言，比较直观、清晰，易于学习掌握。流程图中只能包括5种基本控制结构：顺序型、选择型、WHILE循环型(当型循环)、UNTIL循环型(直到型循环)和多分支选择型。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;IPO图是由IBM公司发起并逐步完善的一种流程描述工具，其主体是处理过程说明，可以采用流程图、判定树、判定表、盒图、问题分析图或过程设计语言来进行描述。IPO图中的输入、输出与功能模块、文件及系统外部项都需要通过数据字典来描述，同时需要为其中的某些元素添加注释。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;N-s图与PFD类似，也包括5种控制结构，分别是顺序型、选择型、WHILE循环型(当型循环)、UNTIL循环型(直到型循环)和多分支选择型，任何一个N-S图都是这5种基本控制结构相互组合与嵌套的结果。在N-S图中，过程的作用域明确；它没有箭头，不能随意转移控制；而且容易表示嵌套关系和层次关系；并具有强烈的结构化特征。但是当问题很复杂时，N-S图可能很大。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;问题分析图(Problem Analysis Diagram，PAD)是继PFD和N-S图之后，又一种描述详细设计的工具。PAD也包含5种基本控制结构，并允许递归使用。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;过程设计语言(Process Design Language，PDL)也称为结构化语言或伪代码(pseudo code)，它是一种混合语言，采用自然语言的词汇和结构化程序设计语言的语法，用于描述处理过程怎么做，类似于编程语言。过程设计语言用于描述模块中算法和加工逻辑的具体细节，以便在开发人员之间比较精确地进行交流。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;对于具有多个互相联系的条件和可能产生多种结果的问题，用结构化语言描述则显得不够直观和紧凑，这时可以用以清楚、简明为特征的判定表(Decision Table)来描述。判定表采用表格形式来表达逻辑判断问题，表格分成4个部分，左上部分为条件说明，左下部分为行动说明，右上部分为各种条件的组合说明，右下部分为各条件组合下相应的行动。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;判定树(Decision Tree)也是用来表示逻辑判断问题的一种常用的图形工具，它用树来表达不同条件下的不同处理流程，比语言、表格的方式更为直观。判定树的左侧(称为树根)为加工名，中间是各种条件，所有的行动都列于最右侧。</p><p><br/></p>",
                    "like": 0,
                    "answer": [
                        "A"
                    ],
                    "option": [
                        " 程序流程图(PFD)用于描述系统中每个模块的输入、输出和数据加工 ",
                        " N-S图容易表示嵌套关系和层次关系，并具有强烈的结构化特征 ",
                        " IPO图的主体是处理过程说明，可以采用流程图、判定树/表等来进行描述 ",
                        " 问题分析图(PAD)包含5种基本控制结构，并允许递归使用 "
                    ]
                },
                {
                    "index": 18,
                    "belong_page": 1,
                    "question_id": 43769,
                    "question_title": "<p><br/></p><p class=\"MsoNormal\"><span style=\"mso-spacerun:&#39;yes&#39;;font-family:宋体;font-size:10.5000pt;mso-font-kerning:1.0000pt;\">RUP</span><span style=\"mso-spacerun:&#39;yes&#39;;font-family:宋体;font-size:10.5000pt;mso-font-kerning:1.0000pt;\"><span style=\"font-family:宋体\">强调采用</span></span><span style=\"text-decoration:underline;\"><span style=\"mso-spacerun:&#39;yes&#39;;font-family:宋体;text-decoration:underline;text-underline:single;font-size:10.5000pt;mso-font-kerning:1.0000pt;\">(请作答此空)</span></span><span style=\"mso-spacerun:&#39;yes&#39;;font-family:宋体;font-size:10.5000pt;mso-font-kerning:1.0000pt;\"><span style=\"font-family:宋体\">的方式来开发软件，这样做的好处是</span></span><span style=\"text-decoration:underline;\"><span style=\"mso-spacerun:&#39;yes&#39;;font-family:宋体;text-decoration:underline;text-underline:single;font-size:10.5000pt;mso-font-kerning:1.0000pt;\">()</span></span><span style=\"mso-spacerun:&#39;yes&#39;;font-family:宋体;font-size:10.5000pt;mso-font-kerning:1.0000pt;\"><span style=\"font-family:宋体\">。</span></span></p><p><br/></p>",
                    "question_type": 1,
                    "answer_type": 1,
                    "show_type_name": null,
                    "new_parent_id": 43769,
                    "score_rule": "",
                    "material_text": null,
                    "sort_son": "0",
                    "analyze": "<p><br/></p><p><br/></p><p>RUP将项目管理、业务建模、分析与设计等统一起来，贯穿整个开发过程。RUP中的软件过程在时间上被分解为4个顺序的阶段，分别是初始阶段、细化阶段、构建阶段和移交阶段。每个阶段结束时都要安排一次技术评审，以确定这个阶段的目标是否已经满足。如果评审结果令人满意，就可以允许项目进入下一个阶段。可以看出，基于RUP的软件过程是一个迭代和增量的过程。通过初始、细化、构建和移交4个阶段就是一个开发周期，每次经过这4个阶段就会产生一代软件。除非产品退役，否则通过重复同样的4个阶段，产品将演化为下一代产品，但每一次的侧重点都将放在不同的阶段上。这样做的好处是在软件开发的早期就可以对关键的、影响大的风险进行处理。</p><p><br/></p>",
                    "like": 0,
                    "answer": [
                        "C"
                    ],
                    "option": [
                        " 原型和螺旋&nbsp; ",
                        " 螺旋和增量&nbsp; ",
                        " 迭代和增量&nbsp; ",
                        " 快速和迭代 "
                    ]
                },
                {
                    "index": 19,
                    "belong_page": 1,
                    "question_id": 43772,
                    "question_title": "<p>对于遗留系统的评价框架如下图所示，那么处于“高水平、低价值”区的遗留系统适合于采用的演化策略为（）。<br/><img style=\"max-width:100%;height:auto\"  src=\"https://s2.51cto.com/images/20211130/1638256629526721.png\" title=\"1638256629526721.png\" alt=\"屏幕截图 2021-11-30.png\"/></p>",
                    "question_type": 1,
                    "answer_type": 1,
                    "show_type_name": null,
                    "new_parent_id": 43772,
                    "score_rule": "",
                    "material_text": null,
                    "sort_son": "0",
                    "analyze": "<p>把对遗留系统的评价结果分列在坐标的4个象限内。对处在不同象限的遗留系统采取不同的演化策略。</p><p>①淘汰策略。第三象限为低水平、低价值区，即遗留系统的技术含量较低，且具有较低的业务价值。对这种遗留系统的演化策略为淘汰，即全面重新开发新的系统以代替遗留系统。完全淘汰是一种极端性策略，一般是企业的业务产生了根本变化，遗留系统已经基本上不再适应企业运作的需要；或者是遗留系统的维护人员、维护文档资料都丢失了。经过评价，发现将遗留系统完全淘汰，开发全新的系统比改造旧系统从成本上考虑更合算。</p><p>②继承策略。第二象限为低水平、高价值区，即遗留系统的技术含量较低，已经满足企业运作的功能或性能要求，但具有较高的商业价值，目前企业的业务尚紧密依赖该系统。称这种遗留系统的演化策略为继承。在开发新系统时，需要完全兼容遗留系统的功能模型和数据模型。为了保证业务的连续性，新老系统必须并行运行一段时间，再逐渐切换到新系统上运行。</p><p>③改造策略。第一象限为高水平、高价值区，即遗留系统的技术含量较高，本身还有强大的生命力。系统具有较高的业务价值，基本上能够满足企业业务运作和决策支持的需要。这种系统可能建成的时间还很短，称这种遗留系统的演化策略为改造。改造包括系统功能的增强和数据模型的改造两个方面。系统功能的增强是指在原有系统的基础上增加新的应用要求，对遗留系统本身不做改变；数据模型的改造是指将遗留系统的旧的数据模型向新的数据模型的转化。</p><p>④集成策略。第四象限为高水平、低价值区，即遗留系统的技术含量较高，但其业务价值较低，可能只完成某个部门(或子公司)的业务管理。这种系统在各自的局部领域里工作良好，但对于整个企业来说，存在多个这样的系统，不同的系统基于不同的平台、不同的数据模型，形成了一个个信息孤岛，对这种遗留系统的演化策略为集成。</p>",
                    "like": 0,
                    "answer": [
                        "D"
                    ],
                    "option": [
                        " 淘汰 ",
                        " 继承&nbsp;&nbsp; ",
                        " 改造&nbsp; ",
                        " 集成 "
                    ]
                },
                {
                    "index": 20,
                    "belong_page": 1,
                    "question_id": 43868,
                    "question_title": "<p>基于ODP的架构开发过程按照顺序分别为系统构想、（请作答此空）、原型分析、（ ）、架构原型、项目规划、并行开发、系统转换、（ ）、（ ）。</p>",
                    "question_type": 1,
                    "answer_type": 1,
                    "show_type_name": null,
                    "new_parent_id": 43868,
                    "score_rule": "",
                    "material_text": null,
                    "sort_son": "0",
                    "analyze": "<p>本题第一空正确答案为A。<br/><img style=\"max-width:100%;height:auto\"  src=\"https://s2.51cto.com/images/20200229/1582982206662144.png\" title=\"1582982206662144.png\" alt=\"image.png\"/></p>",
                    "like": 0,
                    "answer": [
                        "A"
                    ],
                    "option": [
                        " 需求分析 ",
                        " 架构规划 ",
                        " 操作维护&nbsp;&nbsp;&nbsp;&nbsp; ",
                        " 系统移植 "
                    ]
                },
                {
                    "index": 21,
                    "belong_page": 1,
                    "question_id": 43869,
                    "question_title": "基于 ODP 的架构开发过程按照顺序分别为系统构想、（ ）、原型分析、（请作答此空）、架构原型、项目规划、并行开发、系统转换、（ ）、（ ）。",
                    "question_type": 1,
                    "answer_type": 1,
                    "show_type_name": null,
                    "new_parent_id": 43869,
                    "score_rule": "",
                    "material_text": null,
                    "sort_son": "0",
                    "analyze": "<p>本题第二空正确答案为B。<img style=\"max-width:100%;height:auto\"  src=\"https://s2.51cto.com/images/20200229/1582982206662144.png\" title=\"1582982206662144.png\" alt=\"image.png\" width=\"723\" height=\"501\"/></p>",
                    "like": 0,
                    "answer": [
                        "B"
                    ],
                    "option": [
                        " 需求分析 ",
                        " 架构规划 ",
                        " 操作维护 ",
                        " 系统移植 "
                    ]
                },
                {
                    "index": 22,
                    "belong_page": 1,
                    "question_id": 43870,
                    "question_title": "基于&nbsp;ODP&nbsp;的架构开发过程按照顺序分别为系统构想、（&nbsp;）、原型分析、（&nbsp;）、架构原型、项目规划、并行开发、系统转换、（请作答此空）、（&nbsp;）。",
                    "question_type": 1,
                    "answer_type": 1,
                    "show_type_name": null,
                    "new_parent_id": 43870,
                    "score_rule": "",
                    "material_text": null,
                    "sort_son": "0",
                    "analyze": "<p>本题第三空正确答案为C。<img style=\"max-width:100%;height:auto\"  src=\"https://s2.51cto.com/images/20200229/1582982206662144.png\" title=\"1582982206662144.png\" alt=\"image.png\" width=\"723\" height=\"501\"/></p>",
                    "like": 0,
                    "answer": [
                        "C"
                    ],
                    "option": [
                        " 需求分析&nbsp;&nbsp;&nbsp;&nbsp; ",
                        " 架构规划&nbsp;&nbsp;&nbsp;&nbsp; ",
                        " 操作维护 ",
                        " 概要设计 "
                    ]
                },
                {
                    "index": 23,
                    "belong_page": 1,
                    "question_id": 43871,
                    "question_title": "<p>基于 ODP 的架构开发过程按照顺序分别为系统构想、（ ）、原型分析、（ ）、架构原型、项目规划、并行开发、系统转换、（ ）、（请作答此空）。</p>",
                    "question_type": 1,
                    "answer_type": 1,
                    "show_type_name": null,
                    "new_parent_id": 43871,
                    "score_rule": "",
                    "material_text": null,
                    "sort_son": "0",
                    "analyze": "<p>本题第四空正确答案为D。<img style=\"max-width:100%;height:auto\"  src=\"https://s2.51cto.com/images/20200229/1582982206662144.png\" title=\"1582982206662144.png\" alt=\"image.png\" width=\"723\" height=\"501\"/></p>",
                    "like": 0,
                    "answer": [
                        "D"
                    ],
                    "option": [
                        " 需求分析 ",
                        " 架构规划 ",
                        " 详细设计 ",
                        " 系统移植 "
                    ]
                },
                {
                    "index": 24,
                    "belong_page": 1,
                    "question_id": 43891,
                    "question_title": "<p><br/></p><p>（）给XSLT和XPointer提供一个共同、整合的定位语法，用来定位XML文档中的各个部位。</p><p><br/></p>",
                    "question_type": 1,
                    "answer_type": 1,
                    "show_type_name": null,
                    "new_parent_id": 43891,
                    "score_rule": "",
                    "material_text": null,
                    "sort_son": "0",
                    "analyze": "<p><br/></p><p>XPath 是一门在 XML 文档中查找信息的语言。XPath 用于在 XML 文档中通过元素和属性进行导航，它给XSLT和XPointer提供了一个共同、整合的定位语法，用来定位XML文档中的各个部位。</p><p><br/></p>",
                    "like": 0,
                    "answer": [
                        "A"
                    ],
                    "option": [
                        " XPath&nbsp; ",
                        " XML&nbsp; ",
                        " DTD&nbsp; ",
                        " XLink "
                    ]
                },
                {
                    "index": 25,
                    "belong_page": 1,
                    "question_id": 43892,
                    "question_title": "<p><br/></p><p><br/></p><p>关于XML的特点和功能，以下（）说法是错误的。</p><p><br/></p>",
                    "question_type": 1,
                    "answer_type": 1,
                    "show_type_name": null,
                    "new_parent_id": 43892,
                    "score_rule": "",
                    "material_text": null,
                    "sort_son": "0",
                    "analyze": "<p><br/></p><p>XML支持客户端或者服务端计算机上的进程，这就允许开发人员分配资源和随时地节省资源。</p><p><br/></p>",
                    "like": 0,
                    "answer": [
                        "D"
                    ],
                    "option": [
                        " XML允许各种各样的文档显示类型，不仅可以显示在许多计算机平台上，而且可以显示蜂窝电话、掌上电脑等其他设备上。 ",
                        " XML支持但并不需要DTD（Document&nbsp;Type&nbsp;Definition,文档类型定义）。 ",
                        " XML标准支持打印文档和电子文档以及其他的为不同用户定义了不同内容和外观的文档。 ",
                        " XML支持客户端，但不允许服务端计算机上的进程。 "
                    ]
                },
                {
                    "index": 26,
                    "belong_page": 1,
                    "question_id": 43893,
                    "question_title": "<p><br/></p><p><br/></p><p>以下哪一项不是引入DTD的原因（）</p><p><br/></p>",
                    "question_type": 1,
                    "answer_type": 1,
                    "show_type_name": null,
                    "new_parent_id": 43893,
                    "score_rule": "",
                    "material_text": null,
                    "sort_son": "0",
                    "analyze": "<p><br/></p><p><br/></p><p>引入DTD的原因：1）提供一种验证的手段；2）实现了文件格式的统一化，提高了文件的重用性；3）使用DTD进行验证，增加了操作时间。使用DTD进行验证，实际上并没有减少操作时间，反而增加的操作时间。</p><p><br/></p>",
                    "like": 0,
                    "answer": [
                        "D"
                    ],
                    "option": [
                        " 提供一种验证的手段 ",
                        " 实现了文件格式的统一化 ",
                        " 提高了文件的重用性 ",
                        " 使用DTD进行验证，减少了操作时间。 "
                    ]
                },
                {
                    "index": 27,
                    "belong_page": 1,
                    "question_id": 43894,
                    "question_title": "<p><br/></p><p><br/></p><p class=\"MsoNormal\"><span style=\"mso-spacerun:&#39;yes&#39;;font-family:宋体;mso-ascii-font-family:Calibri;mso-hansi-font-family:Calibri;mso-bidi-font-family:&#39;Times New Roman&#39;;font-size:10.5000pt;mso-font-kerning:1.0000pt;\">DTD<span style=\"font-family:宋体\">定义了几个方面的内容，以下说法不正确的是（ ）</span></span><span style=\"mso-spacerun:&#39;yes&#39;;font-family:宋体;mso-ascii-font-family:Calibri;mso-hansi-font-family:Calibri;mso-bidi-font-family:&#39;Times New Roman&#39;;font-size:10.5000pt;mso-font-kerning:1.0000pt;\"></span></p><p><br/></p>",
                    "question_type": 1,
                    "answer_type": 1,
                    "show_type_name": null,
                    "new_parent_id": 43894,
                    "score_rule": "",
                    "material_text": null,
                    "sort_son": "0",
                    "analyze": "<p><br/></p><p><br/></p><p class=\"MsoNormal\"><span style=\"mso-spacerun:&#39;yes&#39;;font-family:宋体;mso-ascii-font-family:Calibri;mso-hansi-font-family:Calibri;mso-bidi-font-family:&#39;Times New Roman&#39;;font-size:10.5000pt;mso-font-kerning:1.0000pt;\"><span style=\"font-family:宋体\">元素声明包括元素的内容和元素的排列组合方式。</span></span><span style=\"mso-spacerun:&#39;yes&#39;;font-family:宋体;mso-ascii-font-family:Calibri;mso-hansi-font-family:Calibri;mso-bidi-font-family:&#39;Times New Roman&#39;;font-size:10.5000pt;mso-font-kerning:1.0000pt;\"></span></p><p><br/></p>",
                    "like": 0,
                    "answer": [
                        "A"
                    ],
                    "option": [
                        " 元素声明，但是不包括元素的排列方式 ",
                        " 元素的内容 ",
                        " 实体的声明 ",
                        " 属性的种类 "
                    ]
                },
                {
                    "index": 28,
                    "belong_page": 1,
                    "question_id": 43895,
                    "question_title": "<p><br/></p><p><br/></p><p class=\"MsoNormal\"><span style=\"mso-spacerun:&#39;yes&#39;;font-family:宋体;mso-ascii-font-family:Calibri;mso-hansi-font-family:Calibri;mso-bidi-font-family:&#39;Times New Roman&#39;;font-size:10.5000pt;mso-font-kerning:1.0000pt;\"><span style=\"font-family:宋体\">关于</span>XML<span style=\"font-family:宋体\">的表述正确的是（ ）</span></span><span style=\"mso-spacerun:&#39;yes&#39;;font-family:宋体;mso-ascii-font-family:Calibri;mso-hansi-font-family:Calibri;mso-bidi-font-family:&#39;Times New Roman&#39;;font-size:10.5000pt;mso-font-kerning:1.0000pt;\"></span></p><p><br/></p>",
                    "question_type": 1,
                    "answer_type": 1,
                    "show_type_name": null,
                    "new_parent_id": 43895,
                    "score_rule": "",
                    "material_text": null,
                    "sort_son": "0",
                    "analyze": "<p>略<br/></p>",
                    "like": 0,
                    "answer": [
                        "D"
                    ],
                    "option": [
                        " &nbsp;XML是超文本标记语言，标准通用标记语言下的一个应用 ",
                        " &nbsp;XML&nbsp;的设计宗旨是显示数据 ",
                        " XML&nbsp;标签是被预定义的，用户不需要自己描述 ",
                        " XML&nbsp;标签没有被预定义，用户需要自行定义标签 "
                    ]
                },
                {
                    "index": 29,
                    "belong_page": 1,
                    "question_id": 43896,
                    "question_title": "<p><br/></p><p><br/></p><p class=\"MsoNormal\"><span style=\"mso-spacerun:&#39;yes&#39;;font-family:宋体;mso-ascii-font-family:Calibri;mso-hansi-font-family:Calibri;mso-bidi-font-family:&#39;Times New Roman&#39;;font-size:10.5000pt;mso-font-kerning:1.0000pt;\">XML <span style=\"font-family:宋体\">语法表述正确的是（）</span></span><span style=\"mso-spacerun:&#39;yes&#39;;font-family:宋体;mso-ascii-font-family:Calibri;mso-hansi-font-family:Calibri;mso-bidi-font-family:&#39;Times New Roman&#39;;font-size:10.5000pt;mso-font-kerning:1.0000pt;\"></span></p><p><br/></p>",
                    "question_type": 1,
                    "answer_type": 1,
                    "show_type_name": null,
                    "new_parent_id": 43896,
                    "score_rule": "",
                    "material_text": null,
                    "sort_son": "0",
                    "analyze": "<p>略<br/></p>",
                    "like": 0,
                    "answer": [
                        "A"
                    ],
                    "option": [
                        " 所有&nbsp;XML&nbsp;元素都须有关闭标签 ",
                        " XML&nbsp;标签对大小写不敏感 ",
                        " &nbsp;XML&nbsp;文档不需要根元素 ",
                        " 在&nbsp;XML&nbsp;中，空格不会被保留 "
                    ]
                },
                {
                    "index": 30,
                    "belong_page": 1,
                    "question_id": 43897,
                    "question_title": "<p><br/></p><p class=\"MsoNormal\"><span style=\"mso-spacerun:&#39;yes&#39;;font-family:宋体;mso-ascii-font-family:Calibri;mso-hansi-font-family:Calibri;mso-bidi-font-family:&#39;Times New Roman&#39;;font-size:10.5000pt;mso-font-kerning:1.0000pt;\"><span style=\"font-family:宋体\">关于</span>XML Schema<span style=\"font-family:宋体\">与</span><span style=\"font-family:Calibri\">DTD</span><span style=\"font-family:宋体\">的表述不正确的是（ ）</span></span><span style=\"mso-spacerun:&#39;yes&#39;;font-family:宋体;mso-ascii-font-family:Calibri;mso-hansi-font-family:Calibri;mso-bidi-font-family:&#39;Times New Roman&#39;;font-size:10.5000pt;mso-font-kerning:1.0000pt;\"></span></p><p><br/></p>",
                    "question_type": 1,
                    "answer_type": 1,
                    "show_type_name": null,
                    "new_parent_id": 43897,
                    "score_rule": "",
                    "material_text": null,
                    "sort_son": "0",
                    "analyze": "<p>略<br/></p>",
                    "like": 0,
                    "answer": [
                        "D"
                    ],
                    "option": [
                        " 一个XML文档可以调用多种schema文档 ",
                        " &nbsp;XML&nbsp;Schema在代码的重用性和可扩展方面优于DTD ",
                        " 一个XML文档只能使用一个DTD文档 ",
                        " 一个XML文档可以使用多个DTD文档 "
                    ]
                },
                {
                    "index": 31,
                    "belong_page": 1,
                    "question_id": 43898,
                    "question_title": "<p><br/></p><p><br/></p><p class=\"MsoNormal\"><span style=\"mso-spacerun:&#39;yes&#39;;font-family:宋体;mso-ascii-font-family:Calibri;mso-hansi-font-family:Calibri;mso-bidi-font-family:&#39;Times New Roman&#39;;font-size:10.5000pt;mso-font-kerning:1.0000pt;\">DTD<span style=\"font-family:宋体\">的缺点有（）</span></span><span style=\"mso-spacerun:&#39;yes&#39;;font-family:宋体;mso-ascii-font-family:Calibri;mso-hansi-font-family:Calibri;mso-bidi-font-family:&#39;Times New Roman&#39;;font-size:10.5000pt;mso-font-kerning:1.0000pt;\"></span></p><p><br/></p>",
                    "question_type": 1,
                    "answer_type": 1,
                    "show_type_name": null,
                    "new_parent_id": 43898,
                    "score_rule": "",
                    "material_text": null,
                    "sort_son": "0",
                    "analyze": "<p>略<br/></p>",
                    "like": 0,
                    "answer": [
                        "B"
                    ],
                    "option": [
                        " 数据类型丰富 ",
                        " 数据类型有限 ",
                        " 一个文档可以使用多种DTD文档 ",
                        " DTD的声明不是必须出现的 "
                    ]
                },
                {
                    "index": 32,
                    "belong_page": 1,
                    "question_id": 43899,
                    "question_title": "<p><br/></p><p><br/></p><p class=\"MsoNormal\"><span style=\"mso-spacerun:&#39;yes&#39;;font-family:宋体;mso-ascii-font-family:Calibri;mso-hansi-font-family:Calibri;mso-bidi-font-family:&#39;Times New Roman&#39;;font-size:10.5000pt;mso-font-kerning:1.0000pt;\"><span style=\"font-family:宋体\">当数据对象满足一定条件时属于格式正规的文档，其中不包括（</span> <span style=\"font-family:宋体\">）</span></span><span style=\"mso-spacerun:&#39;yes&#39;;font-family:宋体;mso-ascii-font-family:Calibri;mso-hansi-font-family:Calibri;mso-bidi-font-family:&#39;Times New Roman&#39;;font-size:10.5000pt;mso-font-kerning:1.0000pt;\"></span></p><p><br/></p>",
                    "question_type": 1,
                    "answer_type": 1,
                    "show_type_name": null,
                    "new_parent_id": 43899,
                    "score_rule": "",
                    "material_text": null,
                    "sort_son": "0",
                    "analyze": "<p>略<br/></p>",
                    "like": 0,
                    "answer": [
                        "B"
                    ],
                    "option": [
                        " 语法合乎XML规范 ",
                        " 元素没有根节点 ",
                        " 元素构成一个层次树 ",
                        " 没有对外部实体的引用，除非提供DTD "
                    ]
                },
                {
                    "index": 33,
                    "belong_page": 1,
                    "question_id": 43900,
                    "question_title": "<p><br/></p><p><br/></p><p class=\"MsoNormal\"><span style=\"mso-spacerun:&#39;yes&#39;;font-family:宋体;mso-ascii-font-family:Calibri;mso-hansi-font-family:Calibri;mso-bidi-font-family:&#39;Times New Roman&#39;;font-size:10.5000pt;mso-font-kerning:1.0000pt;\"><span style=\"font-family:宋体\">关于</span>XML<span style=\"font-family:宋体\">的语法要求不正确的是（ ）</span></span><span style=\"mso-spacerun:&#39;yes&#39;;font-family:宋体;mso-ascii-font-family:Calibri;mso-hansi-font-family:Calibri;mso-bidi-font-family:&#39;Times New Roman&#39;;font-size:10.5000pt;mso-font-kerning:1.0000pt;\"></span></p><p><br/></p>",
                    "question_type": 1,
                    "answer_type": 1,
                    "show_type_name": null,
                    "new_parent_id": 43900,
                    "score_rule": "",
                    "material_text": null,
                    "sort_son": "0",
                    "analyze": "<p>略<br/></p>",
                    "like": 0,
                    "answer": [
                        "C"
                    ],
                    "option": [
                        " 在&nbsp;XML&nbsp;中编写注释的语法与&nbsp;HTML&nbsp;的语法很相似 ",
                        " XML&nbsp;文档必须有一个元素是所有其他元素的父元素。该元素称为根元素 ",
                        " &nbsp;XML&nbsp;的属性值与HTML语言不一样，不须加引号 ",
                        " 声明不属于XML本身的组成部分。它不是&nbsp;XML&nbsp;元素，也不需要关闭标签 "
                    ]
                },
                {
                    "index": 34,
                    "belong_page": 1,
                    "question_id": 45327,
                    "question_title": "<p>在项目某阶段的实施过程中，A活动需要2天2人完成，B活动需要2天2人完成，C活动需要5天4人完成，D活动需要3天2人完成，E活动需要1天1人完成，该阶段的时标网络图如下。该项目组共有8人，且负责A、E活动的人因另有安排，无法帮助其他人完成相应工作，且项目整个工期刻不容缓。以下 （ &nbsp;） 安排是恰当的，能够使实施任务顺利完成。</p><p><img style=\"max-width:100%;height:auto\"  src=\"http://s2.51cto.com/images/20180824/1535097503163126.png\" title=\"1535097503163126.png\" alt=\"图片.png\"/></p>",
                    "question_type": 1,
                    "answer_type": 1,
                    "show_type_name": null,
                    "new_parent_id": 45327,
                    "score_rule": "",
                    "material_text": null,
                    "sort_son": "0",
                    "analyze": "<p>略<br/></p>",
                    "like": 0,
                    "answer": [
                        "D"
                    ],
                    "option": [
                        " B活动提前2天开始  <br/> ",
                        " B活动推迟2天开始  <br/> ",
                        " D活动提前2天开始  <br/> ",
                        " D活动推迟2天开始  <br/> "
                    ]
                },
                {
                    "index": 35,
                    "belong_page": 1,
                    "question_id": 45328,
                    "question_title": "<p>下图中活动“G”可以拖延 （ &nbsp;&nbsp;&nbsp;） 周而不会延长项目的最终结束日期。</p><p><img style=\"max-width:100%;height:auto\"  src=\"https://s1.51ctocdn.cn//images/20180824/1535097542153293.png\" title=\"1535097542153293.png\" alt=\"图片.png\"/></p><p>（图中时间单位为周）</p><p><br/></p>",
                    "question_type": 1,
                    "answer_type": 1,
                    "show_type_name": null,
                    "new_parent_id": 45328,
                    "score_rule": "",
                    "material_text": null,
                    "sort_son": "0",
                    "analyze": "<p>本题考查项目工期优化相关知识。<br/>项目关键路径：DHC<br/>项目工期计算：9+0+3 = 12(周)<br/>任务G松弛时间 = DHC - FG = 12 - (5+3) = 4(周)<br/></p>",
                    "like": 0,
                    "answer": [
                        "D"
                    ],
                    "option": [
                        " 0<br/> ",
                        " 1<br/> ",
                        " 3<br/> ",
                        " 4<br/> "
                    ]
                },
                {
                    "index": 36,
                    "belong_page": 1,
                    "question_id": 45332,
                    "question_title": "<p>某软件项目的活动图如下图所示，其中顶点表示项目里程碑，连接顶点的边表示包含的活动，边上的数字表示活动的持续天数，则完成该项目的最少时间为（&nbsp; ）天。活动EH和IJ的松弛时间分别为（&nbsp; ）天。</p><p><img style=\"max-width:100%;height:auto\"  src=\"http://s2.51cto.com/images/20180824/1535097764382767.png\" title=\"1535097764382767.png\" alt=\"图片.png\"/></p>",
                    "question_type": 1,
                    "answer_type": 1,
                    "show_type_name": null,
                    "new_parent_id": 45332,
                    "score_rule": "",
                    "material_text": null,
                    "sort_son": "0",
                    "analyze": "<p>在网络图中的某些活动可以并行地进行，所以完成工程的最少时间是从开始顶点到结束顶点的最长路径长度，从开始顶点到结束顶点的最长（工作时间之和最大）路径为关键路径，关键路径上的活动为关键活动。<br/>本题关键路径为：A-B-D-G-I-K-L，共22天。<br/>EH的松弛时间是22-（2+3+2+4+6）=5天。<br/>IJ的松弛时间是22-（2+5+2+6+3+1）=3天。</p><p><br/></p>",
                    "like": 0,
                    "answer": [
                        "C"
                    ],
                    "option": [
                        " 3和3  <br/> ",
                        " 3和6<br/>  <br/> ",
                        " 5和3  <br/> ",
                        " 5和6  <br/> "
                    ]
                },
                {
                    "index": 37,
                    "belong_page": 1,
                    "question_id": 45333,
                    "question_title": "<p>某软件项目的活动图如下图所示，其中顶点表示项目里程碑，链接顶点的边表示包含的活动，边上的数字表示活动的持续时间（天）。完成该项目的最少时间为（请作答此空）天。由于某种原因，现在需要同一个开发人员完成BC和BD，则完成该项目的最少时间为（&nbsp; ）天。</p><p><br/></p><p><img style=\"max-width:100%;height:auto\"  title=\"1535097817794243.png\" alt=\"图片.png\" src=\"https://s2.51cto.com//images/20180824/1535097817794243.png\"/></p>",
                    "question_type": 1,
                    "answer_type": 1,
                    "show_type_name": null,
                    "new_parent_id": 45333,
                    "score_rule": "",
                    "material_text": null,
                    "sort_son": "0",
                    "analyze": "<p>关键路径为ABCEFJ 和ABDGFJ ，18天。<br/></p><p><br/></p>",
                    "like": 0,
                    "answer": [
                        "B"
                    ],
                    "option": [
                        " 11<br/> ",
                        " 18<br/> ",
                        " 20<br/> ",
                        " 21<br/> "
                    ]
                },
                {
                    "index": 38,
                    "belong_page": 1,
                    "question_id": 45334,
                    "question_title": "<p>某软件项目的活动图如下图所示，其中顶点表示项目里程碑，链接顶点的边表示包含的活动，边上的数字表示活动的持续时间（天）。完成该项目的最少时间为（&nbsp; ）天。由于某种原因，现在需要同一个开发人员完成BC和BD，则完成该项目的最少时间为（请作答此空）天。</p><p><img style=\"max-width:100%;height:auto\"  title=\"1535097863224749.png\" alt=\"图片.png\" src=\"https://s2.51cto.com//images/20180824/1535097863224749.png\"/></p><p><br/></p>",
                    "question_type": 1,
                    "answer_type": 1,
                    "show_type_name": null,
                    "new_parent_id": 45334,
                    "score_rule": "",
                    "material_text": null,
                    "sort_son": "0",
                    "analyze": "<p>BC持续时间3天，BD持续时间2天，由一人完成，则可以把先完成BD，再完成BC，则BC持续时间作为5天，则关键路径为ABCEFJ， 20天。</p><p><br/></p>",
                    "like": 0,
                    "answer": [
                        "C"
                    ],
                    "option": [
                        " 11<br/> ",
                        " 18<br/> ",
                        " 20<br/> ",
                        " 21<br/> "
                    ]
                },
                {
                    "index": 39,
                    "belong_page": 1,
                    "question_id": 45336,
                    "question_title": "<p>某软件项目的活动图如下图所示，其中顶点表示项目里程碑，连接顶点的边表示包含的活动，边上的数字表示活动的持续时间(天)，则完成该项目的最少时间为（ &nbsp;）天。活动BD和HK最早可以从第（ &nbsp;）天开始。(活动AB、AE和AC最早从第1天开始)</p><p><img style=\"max-width:100%;height:auto\"  src=\"http://s2.51cto.com/images/20180824/1535097935504949.png\" title=\"1535097935504949.png\" alt=\"图片.png\"/></p>",
                    "question_type": 1,
                    "answer_type": 1,
                    "show_type_name": null,
                    "new_parent_id": 45336,
                    "score_rule": "",
                    "material_text": null,
                    "sort_son": "0",
                    "analyze": "<p>BD活动在AB活动结束之后便可以开始，同时AB是第1天开始，而非第0天开始，所以最早开始时间为4。HK活动需要在AEGH与ACFH两条路径上的活动均完成之后，才能开始，所以最早开始时间为11。</p><p><br/></p>",
                    "like": 0,
                    "answer": [
                        "B"
                    ],
                    "option": [
                        " 3和10<br/>  <br/> ",
                        " 4和11<br/>  <br/> ",
                        " 3和9  <br/> ",
                        " 4和10  <br/> "
                    ]
                },
                {
                    "index": 40,
                    "belong_page": 1,
                    "question_id": 45337,
                    "question_title": "<p>某软件项目的活动图如下图所示，其中顶点表示项目里程碑，连接顶点的边表示包含的活动，边上的数字表示相应活动的持续时间（天），则完成该项目的最少时间为（ &nbsp;）天。活动BC和BF最多可以晚开始（ &nbsp;）天而不会影响整个项目的进度。</p><p><img style=\"max-width:100%;height:auto\"  src=\"http://s2.51cto.com/images/20180824/1535097974560301.png\" title=\"1535097974560301.png\" alt=\"图片.png\"/></p>",
                    "question_type": 1,
                    "answer_type": 1,
                    "show_type_name": null,
                    "new_parent_id": 45337,
                    "score_rule": "",
                    "material_text": null,
                    "sort_son": "0",
                    "analyze": "<p>项目中关键路径是ABCEFJ，总共需要18天。<br/></p><p><br/></p>",
                    "like": 0,
                    "answer": [
                        "D"
                    ],
                    "option": [
                        " 11<br/> ",
                        " 15<br/> ",
                        " 16<br/> ",
                        " 18<br/> "
                    ]
                },
                {
                    "index": 41,
                    "belong_page": 1,
                    "question_id": 45338,
                    "question_title": "<p>某软件项目的活动图如下图所示，其中顶点表示项目里程碑，连接顶点的边表示包含的活动，边上的数字表示相应活动的持续时间（天），则完成该项目的最少时间为（ &nbsp;）天。活动BC和BF最多可以晚开始（ &nbsp;）天而不会影响整个项目的进度。</p><p><img style=\"max-width:100%;height:auto\"  src=\"http://s2.51cto.com/images/20180824/1535098005576462.png\" title=\"1535098005576462.png\" alt=\"图片.png\"/></p>",
                    "question_type": 1,
                    "answer_type": 1,
                    "show_type_name": null,
                    "new_parent_id": 45338,
                    "score_rule": "",
                    "material_text": null,
                    "sort_son": "0",
                    "analyze": "<p>BC和BF最晚开始的时间可以分别为0天和7天。</p><p><br/></p>",
                    "like": 0,
                    "answer": [
                        "A"
                    ],
                    "option": [
                        " 0和7  <br/> ",
                        " 0和11<br/>  <br/> ",
                        " 2和7  <br/> ",
                        " 2和11  <br/> "
                    ]
                },
                {
                    "index": 42,
                    "belong_page": 1,
                    "question_id": 46872,
                    "question_title": "<p>软件方法学是以软件开发方法为研究对象的学科。其中，&nbsp; &nbsp;( 回答此空)&nbsp; &nbsp;是先对最高居次中的问题进行定义、设计、编程和测试，而将其中未解决的问题作为一个子任务放到下一层次中去解决。&nbsp; &nbsp;(&nbsp;)&nbsp; &nbsp;是根据系统功能要求，从具体的器件、逻辑部件或者相似系统开始，通过对其进行相互连接、修改和扩大，构成所要求的系统。&nbsp; &nbsp;(&nbsp;)&nbsp; &nbsp;是建立在严格数学基础上的软件开发方法。</p>",
                    "question_type": 1,
                    "answer_type": 1,
                    "show_type_name": null,
                    "new_parent_id": 46872,
                    "score_rule": "",
                    "material_text": null,
                    "sort_son": "0",
                    "analyze": "<p>软件方法学是软件开发全过程的指导原则与方法体系。其另一种含义是以软件方法为研究对象的学科。从开发风范上看，软件方法有自顶向下的开发方法、自底向上的开发方法。在实际软件开发中，大都是自顶向下与自底向上两种方法的结合，只不过是以何者为主而已。</p><p>&nbsp;自顶向下开发方法是先对最高居次中的问题进行定义、设计、编程和测试，而将其中未解决的问题作为一个子任务放到下一层次中去解决。</p><p>是根据系统功能要求，从具体的器件、逻辑部件或者相似系统开始，通过对其进行相互连接、修改和扩大，构成所要求的系统。</p>",
                    "like": 0,
                    "answer": [
                        "D"
                    ],
                    "option": [
                        " 面向对象开发方法 ",
                        " 形式化开发方法 ",
                        " 非形式化开发方法 ",
                        " 自顶向下开发方法 "
                    ]
                },
                {
                    "index": 43,
                    "belong_page": 1,
                    "question_id": 46892,
                    "question_title": "<p>用于管理信息系统规划的方法有很多，其中（）将整个过程看成是一个“信息集合”，并将组织的战略目标转变为管理信息系统的战略目标。</p><p><br/></p>",
                    "question_type": 1,
                    "answer_type": 1,
                    "show_type_name": null,
                    "new_parent_id": 46892,
                    "score_rule": "",
                    "material_text": null,
                    "sort_son": "0",
                    "analyze": "<p>用于管理信息系统规划的方法很多，主要是关键成功因素法（Critical Success Factors，CSF）、战略目标集转化法（Strategy Set Transformation, SST）和企业系统规划法（Business System Planning, BSP）。其它还有企业信息分析与集成技术（BIAIT）、产出／方法分析（E/MA）、投资回收法（ROI）、征费法、零线预算法、阶石法等。用得最多的是前面三种。</p><p>1. 关键成功因素法（CSF）</p><p>在现行系统中，总存在着多个变量影响系统目标的实现，其中若干个因素是关键的和主要的（即关键成功因素）。通过对关键成功因素的识别，找出实现目标所需的关键信息集合，从而确定系统开发的优先次序。</p><p>关键成功因素来自于组织的目标，通过组织的目标分解和关键成功因素识别、性能指标识别，一直到产生数据字典。</p><p>识别关键成功因素，就是要识别联系于组织目标的主要数据类型及其关系。不同的组织的关键成功因素不同，不同时期关键成功因素也不相同。当在一个时期内的关键成功因素解决后，新的识别关键成功因素又开始。</p><p>关键成功因素法能抓住主要矛盾，使目标的识别突出重点。由于经理们比较熟悉这种方法，使用这种方法所确定的目标，因而经理们乐于努力去实现。该方法最有利于确定企业的管理目标。</p><p>2.战略目标集转化法（SST）</p><p>把整个战略目标看成是一个“信息集合”，由使命、目标、战略等组成，管理信息系统的规划过程即是把组织的战略目标转变成为管理信息系统的战略目标的过程。</p><p>战略目标集转化法从另一个角度识别管理目标，它反映了各种人的要求，而且给出了按这种要求的分层，然后转化为信息系统目标的结构化方法。它能保证目标比较全面，疏漏较少，但它在突出重点方面不如关键成功因素法。</p><p>3. 企业系统规划法（BSP）</p><p>信息支持企业运行。通过自上而下地识别系统目标、企业过程和数据，然后对数据进行分析，自下而上地设计信息系统。该管理信息系统支持企业目标的实现，表达所有管理层次的要求，向企业提供一致性信息，对组织机构的变动具有适应性。</p><p>企业系统规划法虽然也首先强调目标，但它没有明显的目标导引过程。它通过识别企业“过程”引出了系统目标，企业目标到系统目标的转化是通过企业过程/数据类等矩阵的分析得到的。</p>",
                    "like": 0,
                    "answer": [
                        "B"
                    ],
                    "option": [
                        " 关键成功因素法 ",
                        " 战略目标集转化法 ",
                        " 征费法 ",
                        " 零线预算法 "
                    ]
                },
                {
                    "index": 44,
                    "belong_page": 1,
                    "question_id": 46896,
                    "question_title": "<p>用于管理信息系统规划的方法有很多，其中（）通过自上而下地识别企业目标、企业过程和数据，然后对数据进行分析，自下而上地设计信息系统。</p>",
                    "question_type": 1,
                    "answer_type": 1,
                    "show_type_name": null,
                    "new_parent_id": 46896,
                    "score_rule": "",
                    "material_text": null,
                    "sort_son": "0",
                    "analyze": "<p>用于管理信息系统规划的方法很多，主要是关键成功因素法（Critical Success Factors，CSF）、战略目标集转化法（Strategy Set Transformation, SST）和企业系统规划法（Business System Planning, BSP）。其它还有企业信息分析与集成技术（BIAIT）、产出／方法分析（E/MA）、投资回收法（ROI）、征费法、零线预算法、阶石法等。用得最多的是前面三种。</p><p>1. 关键成功因素法（CSF）</p><p>在现行系统中，总存在着多个变量影响系统目标的实现，其中若干个因素是关键的和主要的（即关键成功因素）。通过对关键成功因素的识别，找出实现目标所需的关键信息集合，从而确定系统开发的优先次序。</p><p>关键成功因素来自于组织的目标，通过组织的目标分解和关键成功因素识别、性能指标识别，一直到产生数据字典。</p><p>识别关键成功因素，就是要识别联系于组织目标的主要数据类型及其关系。不同的组织的关键成功因素不同，不同时期关键成功因素也不相同。当在一个时期内的关键成功因素解决后，新的识别关键成功因素又开始。</p><p>关键成功因素法能抓住主要矛盾，使目标的识别突出重点。由于经理们比较熟悉这种方法，使用这种方法所确定的目标，因而经理们乐于努力去实现。该方法最有利于确定企业的管理目标。</p><p>2.战略目标集转化法（SST）</p><p>把整个战略目标看成是一个“信息集合”，由使命、目标、战略等组成，管理信息系统的规划过程即是把组织的战略目标转变成为管理信息系统的战略目标的过程。</p><p>战略目标集转化法从另一个角度识别管理目标，它反映了各种人的要求，而且给出了按这种要求的分层，然后转化为信息系统目标的结构化方法。它能保证目标比较全面，疏漏较少，但它在突出重点方面不如关键成功因素法。</p><p>3. 企业系统规划法（BSP）</p><p>信息支持企业运行。通过自上而下地识别系统目标、企业过程和数据，然后对数据进行分析，自下而上地设计信息系统。该管理信息系统支持企业目标的实现，表达所有管理层次的要求，向企业提供一致性信息，对组织机构的变动具有适应性。</p><p>企业系统规划法虽然也首先强调目标，但它没有明显的目标导引过程。它通过识别企业“过程”引出了系统目标，企业目标到系统目标的转化是通过企业过程/数据类等矩阵的分析得到的。</p><p><br/></p>",
                    "like": 0,
                    "answer": [
                        "C"
                    ],
                    "option": [
                        " 企业信息分析与集成法 ",
                        " 投资回收法 ",
                        " 企业系统规划法 ",
                        " 阶石法 "
                    ]
                },
                {
                    "index": 45,
                    "belong_page": 1,
                    "question_id": 46906,
                    "question_title": "<p>项目范围管理中，范围定义的输入包括（）</p>",
                    "question_type": 1,
                    "answer_type": 1,
                    "show_type_name": null,
                    "new_parent_id": 46906,
                    "score_rule": "",
                    "material_text": null,
                    "sort_son": "0",
                    "analyze": "<p>在初步项目范围说明书中已文档化的主要的可交付物、假设和约束条件的基础上准备详细的项目范围说明书，是项目成功的关键。范围定义的输入包括以下内容：</p><p>① 项目章程。如果项目章程或初始的范围说明书没有在项目执行组织中使用，同样的信息需要进一步收集和开发，以产生详细的项目范围说明书。</p><p>② 项目范围管理计划。</p><p>③ 组织过程资产。</p><p>④ 批准的变更申请。</p><p><br/></p>",
                    "like": 0,
                    "answer": [
                        "C"
                    ],
                    "option": [
                        " 项目章程、项目范围管理计划、产品范围说明书和变更申请 ",
                        " 项目范围描述、产品范围说明书、生产项目计划和组织过程资产 ",
                        " 项目章程、项目范围管理计划、组织过程资产和批准的变更申请 ",
                        " 生产项目计划、项目可交付物说明、信息系统要求说明和项目质量标准 "
                    ]
                },
                {
                    "index": 46,
                    "belong_page": 1,
                    "question_id": 46909,
                    "question_title": "<p>项目配置管理中，产品配置是指一个产品在其生命周期各个阶段所产生的各种形式和各种版本的文档、计算机程序、部件及数据的集合。该集合中的每一个元素称为该产品配置中的一个配置顶，（）不属于产品组成部分工作成果的配置顶</p>",
                    "question_type": 1,
                    "answer_type": 1,
                    "show_type_name": null,
                    "new_parent_id": 46909,
                    "score_rule": "",
                    "material_text": null,
                    "sort_son": "0",
                    "analyze": "<p>配置项是构成产品配置的主要元素，配置项主要有以下两大类：</p><p>（1）属于产品组成部分的工作成果：如需求文档、设计文档、源代码和测试用例等；</p><p>（2）属于项目管理和机构支撑过程域产生的文档：如工作计划、项目质量报告和项目跟踪报告等。</p><p>这些文档虽然不是产品的组成部分，但是值得保存。所以设备清单不属于配置项。所以选项C的工作计划虽可充当配置项，但不属于产品组成部分工作成果的配置项。</p><p><br/></p>",
                    "like": 0,
                    "answer": [
                        "C"
                    ],
                    "option": [
                        " 需求文档 ",
                        " 设计文档 ",
                        " 工作计划 ",
                        " 源代码 "
                    ]
                },
                {
                    "index": 47,
                    "belong_page": 1,
                    "question_id": 46916,
                    "question_title": "<p>一个好的变更控制过程，给项目风险承担者提供了正式的建议变更机制。如下图所示的需求变更管理过程中，①②③处对应的内容应分别是()</p><p><img style=\"max-width:100%;height:auto\"  width=\"552\" height=\"232\" src=\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAArIAAAEiCAYAAAAF9zFeAAAAAXNSR0ICQMB9xQAAAAlwSFlzAAASdAAAEnQB3mYfeAAAABl0RVh0U29mdHdhcmUATWljcm9zb2Z0IE9mZmljZX/tNXEAACGpSURBVHja7d1tbF1ngeDx02lL89omaSlJsVuGpZqdD7OicWBnpGUWUMaYIdKyu4pEGsyWaTawablLlIU7VdW5pxDCnSqT4jGlDd6oNHFKG/KiAk41k5YmKW/q7mh2u0K7fGiBT2ilDnzky0re89x7j33u9X1N7Pjc69+Hn+zee2OfF9v9+/FznhM9+uij0dUqlca3jETRG1EUzY7sjnc0Ptbe8FtjhdI9Cz5mYeye4Sh6q9d/F5TLe9eNDUUvRUNjL+0tl9f1tA8j9z5zpcfh3pHombBtw6MPHqjbjo7HINGwrZ3+bTjO8e6RHd187PScdLf9I2+Ml0pbFuPrAgBgKS3aB5qPqmoIzYVhm5ishlP7kE2jMOvB0eED2X/X+LnahWyrWGsXsu22pXnQt47slv+mVcg2PJ5uS7M4rexbD/EuZAEAIVuze2SklEbQsoRsLUKXK2Qrr921655eQrBjyHY5yjr3+hYjyt2O3najm+MAANBXIdtNoHUTlb2GbGPEXcuQnQ/OKxvJvNqQTaczdHpdGrLtphl0GpHtJegBAITsSg/ZDlMLug3Z6jGr/nf6/pzaPqfHZlepcHd9RFePtZAFAAYiZJtejJWJwMUK2W4u9spbyC4IxQXmX7soIdtkPxtfJ2QBACHbJO7monMRQzZr375972n3fO8hu3hzQ5c8ZDtsSzZk0+kD2XPS7YoFvZwPAIC+DtlmUXtlIdv5Cv9soPVDyLaaj9rstd0cp47x2RCy4fN2XN2gVRQ3HZHtfgkvAAAh2yRkW8VULyHbch+ucB3ZpQjZbtefDR9/YcjWTwMQoACAkL3SkL2CGyJ0/tN8fcwJ2c4h23nOseW3AAAhe9Ufb6lCtu26tR1CNnux1FKHbDPVj7lw/mo2ZKvbWLshhZAFAITstQ/Z5hFZH6DZWOwtZFusktAhZHuJ08UI2cprh4efT/e5m5DNvt/r1AIrEgAAKz5kK+8Pjz2fRlkIta3R1gvZAKs+Nvxat7dxbRagdRc2dXlnr2sVsouxakHj9iy4M1dDvBYK2z/QKUS7n+7R/TQQAIDBCNmtWy+kobRgwf5MIM5fNd95qadWoVc3H7ThNcsdsj0duw4hm4Zpq5Bt3Ib5FQfarJUrZAEAIdsQsg1zKOfiq90aqR3mhqajm40jjdmQbfw3AxGyc8e0+nFbTS3IHstwjMJ/F0ZH9jQLz8YpGNnPkz2+zaZyNHsMAGCwQrYWSfOjfx0urmpz8VBjzK2kkG0cgd22bdvRVtMrGke8645d5nEhCwAI2RZBuuBP+x0W0s+GWOPrsnHc7GO0C6v2IXt1V+xfq5DNRnd2uxs/fziG3V6gJWQBACHbGGOVGNr6WhpyzebFtjJ/YdR8CGbDLRtYC5eQqo/HBRdZ5Thk2815vZq1ZZtKVzJoMurcKWTrt1PIAgADFrJ1UdvjLVdDoI2OjD6Sjbiw7FSrkdi5GG3y8esvZlrc6FrsqQX1Ydp8abF2I629RHn6ca7kpg9127lEy6sBAOQiZAEAQMgCAICQBQBAyAIAgJAFAAAhCwCAkAUAACELAABCdrnN3WEsc4OA9AYF3d4uFgAAIZuLkHUHLAAAIduXIVsfs73drhYAACG7rCELAICQXVbx7pEdlSkCi2Bkd7zDMQUAELK5YEQWAEDI9nfIDo29tLdcXueYAAAI2dzIrkLQOD1gLmSj4bfGCqV7mj1nSgEAgJBdtpAtjI7sSee6ZteHnQ/Z+qW26pbgsnIBAICQXU7ZaE1jti5kM6Oy6U0RjMYCAAjZ/MTs8NjzYT5s3ajr1q0XRqLojTAqK2IBAIRsfoO2NL6lEq7p8lpJwD44OnygcWQWAAAhm5+IzUwnGBkdfSRdfms+bs2JBQAQsjkzf4OEaqw2riM797zluAAAhGxepHNfs5Ha7IYIzV4HAICQveaarVaw4DlLbwEACNm8qA/S5qsQtLtF7dzIrNFZAAAhe61VQ3X4561WIWgXssH8Sgb1N0wAAEDILro4jjc8dGjyg+3s/di7n5oL1MSWHaVvtHpt8WDpo3sPPPHvOn3MpebcAgBCdsA98PgLj++e+tlse0/N3l2J2PfOjnyl02vzYX/52CecXwBAyA6wbkZk+8n+x6Y/H0L2wGNP3+f8AgBClr4RYlbIAgBCFiELACBkEbIAAEIWIQsACFmELACAkEXIAgAIWYQsAICQFbIAAEIWIQsAIGQRsgAAQhYhCwAIWYQsAICQRcgCAAhZhCwAIGQRsgAAQhYhCwAgZBGyAABCVsgCAAhZhCwAgJBFyAIACFmELAAgZBGyAABCFiELACBkEbIAgJB1EIQsAICQRcgCAAhZhCwAgJAVsgAAQhYhCwAgZBGyAABCFiELAAhZhCwAgJBFyAIACFmELACAkBWyAABCFiELACBkEbIAAEJWyDomAICQRcgCAAhZhCwAgJBFyAIAQpa+85nJC+dCuHZy/zd+9I+OFwAgZMmNhw8efm83IXvg0NGPO14AgJAlVzqNyhqNBQCELLnUaVTWaCwAIGTJrVajsvc99dovHB8AQMiSW61GZfc/Nv15xwcAELLkWuOo7Kee+odfl8vlVY4NACBkybXGUVmjsQCAkKVvpKOyRmMBACFLX0lHZY3GAgBCdgU4cuTIBycmJj40KPZ/4+++OzE5+ZFB2qc4jjf6WgUAhGzGk08++YlLly79eub8+Yup8+TKK6+88ovjx6eTr9rZ6wJftwAgZElMTU19+vTZs98qTEzcSD6dOHnyS8HOU6euP3Xq1O9Fs2IWAITsSj8ISRBNTR37i9Nnzh0PF0Yl1hTL5bXkSxKxX3kmkUTtTRMTEzdUYtbILAAI2RV7AJIQ2rnz1PVHjx3bc/bs2RPFYvHmOI43BEk83UI+hPPxzIlvl49PP/vVELXhF44Qs0ZlAUDIrlhhVC8E0dTUsf945szZ6VIcb0yiaVN4KyDzF7JB+GUjeWx1mG4Qzp9vZAAQsis6ZI9OTe09febcyVrIbgixVC6X19VG/9awfGpTC9anIVsbLV8rZAFAyArZhpCtReya2lzMt7nQanmFcxBGYI9PP3tIyAIAQrZFyIZICiOx6RzM8Pzs7Ox1LI9w/MMqBSFmw8VetTmytwhZAEDINoRsJpJuCgHlYqJl/gKNqjFbW35LyAIAQrZTyIYRQMs75eSLNPllIpwjIQsACFkhK2QBACErZBGyAICQFbIIWQBAyApZIQsACFkh64tFyAIAQlbIXkv3jkTPRNHIG+Ol0hYhCwAIWSGbe/G+7VuHouitsBBrJWTj+I5+XRNXyAIAQnYFhGzY3uoobAjYobeGhqKfR9G2N5OQHa7sTx/GrJAFAITsAIds2M6gVBgbCSOxw6OFL8Zx8fbRu6KLUTTyi11x/K70lrtCFgAQskI2VyGb7kuy/asT6+O4cOfocHQ5it7/y51x/M/CbXeFLAAgZIVs7mJv56lT14ftDttfiuONcXzg3R+5M3o1CdlfjcfxH4TADa/pt+kFQhYAELIDHLKztdgrl8urwmhsErK3luLi3WnI7ozLf5g8t+ZUH4fst6af++uvHf/uyS+Uj37sC4eOjn3h0JPbHzr05IcfOjT5QdorHpz4Yz/wABCyQja3IZuOyIZgDfuRhOzvjw5HP8yGbNjXfg3ZLz796v/cPfWzWa7M/vKxT/ihB4CQFbK5jL00+MJc2LAPYY7s9uoc2YEI2aPHv/N1I7K9CwEbQvbAY0/f54ceAEJWyOZ+f8IUgzgu3jFIIWuO7JV5OD74LiELgJAVsn0RfTt3nro+jMqW4uIWIYuQBUDICtn+OKFRVAnZsP1GZBGyAAhZIStkhayQBQAhK2SXUrFYXD82FL1cvUVtE1t3H++3+BOyQhYAhOyAh2wYjY3j8aGRKHqzZchG294cj+N39tOorJAVsgAgZAc4ZEPsZVcsqN6itnxb4o5SEq6Jd8RxvCFML+i3ABSyQhYAhOwAh+xsk1vUVuM1hGw5hOyWcLevELhhRYPKrWr7KNKFrJAFACE74CGb3gyhFrJvr8Xs5sTtcRxvErJCFgCErJDNa8jemGz/6nK5vK56m9pK0G4M0wpCxGanFghZIQsAQlbILv+JTLYzSGO2NjK7Ois8Fp6rjMa62EvIAoCQFbJ5C9qw3el+ZaWPW0dWyAKAkBWyOY3ZqDI6GwKwTmXUNuq//RGyQhYAhOzKCNmB+yIVskIWAISskBWyQhYAhKyQRcgKWQAQskIWIStkAUDIClkhi5AFQMgKWSErZIUsAAjZvgrZudu49tmaq4MasiFahayQBQAh2yJk//7CS6+HUEocOj49ffDEiZNfOn58+tETJ07ELJ/qOTj5pZmZmctCVsgCgJBtCNk4jrfUIrY+ZKenH2X5TU+f/HI4LwfL5X8hZIUsAAjZTMgmYbS6WCzeXIrjjUnUbiiXy+sSq8IUA5Zfci7WZM+PkBWyACBkG0I2iaRNNRvCfyePrycXbgnnJQnZW4WskAUAIRsOQDR73c6dp66vjfqtC5GUidkQThtZfpmI3VT7BWN1+AVEyApZAITsihZiKIzuhTgKMVsJJfInzI1N3oZpBmF5NKtKCFkAhCyZmK2NzK4in8L5EbFCFgCEbPZAJFEUYjYEEvkWzlPlZhVCVsgCIGSpHYxo9roQR+RcVOVrVsgCIGQBIQsAQhYQsgAgZAEhCwBCFoSs4wGAkAWELAAIWUDIAoCQBYQsAEIWELIAIGQBIQsAQhYQsgDgIICQBQAhCwhZABCywBUJwbrn6xdfSd3/xKs/CSF73zd++n+yj3928u++7XgBIGSB3Ijj8uZPfvP134V4bWf/Y9Ofd7wAELJArjzw+AuPt4vYTz31D78ul8urHCsAhCyQKw8fPPzediEbQtdxAkDIArn0mckL55pFbJh2EKYfOEYACFkgl1qNyhqNBUDIArnXOCprNBYAIQv0hcZRWaOxAAhZoG+ko7JGYwEQskBfSUdljcYCIGRhBTh8+PAfHzly5IMTExMfGgSFp175weHJJ//9oOxPUC6XV/taBRCyQEPE/vCHP/zt+fPnX0lcHATfm3nxcr/vw8xMVXj/5Zdf/t/PPffc12ZnZ6+LEr5uAYQskAijfTNJLCVvbyhMTNxIPiTn421BeH9q6tj9Z86cfWbnqVPXnzp16veiKBKzAEIWVvg3RBJEk5OTH05C9lK4hWtiDflz9Nixz5w+c+54LW5vqMSskVkAIQsr9pshCaEQREnIbp+ZefFysVxeH8fxhuTtLeTL1NSxfUnInkzeX1uYmLgpxOyskAUQsrCSQzb8qXriiSf+7PvnX3y1FMcbE7eGt4I2P8L5ODp17IHTZ889G/47jNCG6QbVKQZiFkDIwgoURvTCyN7k5ORoCNkkXjcFtVhaF0b/yIX1IWS/k4Rs7ReMtWGKQfglxPQCACELQrY2IlsbBUz/fD13sRHLc7FXOA+VObJTT/+n00IWQMg6CNA2ZNeHi77C4yGU0qvkufYq0z6qK0ncVLnY69y5k0IWQMgCjzadWrAhTCnIRlJFxLKoXYwXzsfRqam9tYu9bhGyAEIWhGybkA0B5Rgt8w+rqBqyYZqBkAVAyIKQFbIACFkQsghZAIQsCFmELABCFoSskAVAyIKQRcgCIGRByF4L8e6RHaECK4bGXtqb7JOQBUDIgpDtj4BtMDz64AEhC4CQBSGby315cGz4C1G07c3xOL6zdmvXVQ+O3fWX1ZitPH5HP4WfkAVAyMKAh2x6B6wQfCFewz4Ui8WbQ/TFcfGO0buii6EKR8bjj4fX9Uv8CVkAhCwMeMjWbuN6QxqxYT9KcXxr4u2luHjX6HB0qRKyuw/+2xCF/bJvQhYAIQsrJGSTwFudWJ8E7MY0ZOP4wLu3D0eXo+jO32wvHPxAmHIgZAEQsiBkcxWyIVJD5IWYDcEXgvaR/X++fSiKfhsN77hciMtDyf6t6ZcAFLIACFkY8JDNzpEN216bYrCmFBfeMT+toPzJZP821SLwhn4L2S9OvfzS7qmfzdL/9pePf9bPH0DIgpBdELNBGKkM8bdv7K6HKisWjHz6+VIcvyOEbAjcfgzZiWPTf3Vw+vLrDx45+9XPHTnzlc8d+c6XP3fk9KOFv3k+pj888PgLj4eQDe/7+QMIWRCyC8Ivjb/Sf3jfv6kuu/X+X+6Ky39UnS9b2b9VphawHB6OD75LyAJCFoRs82/u2qhs6cDYtqEoeiuKRn6xMy7/YRyXbw8Xf4W5sy72QsiyVEqFsXtGRgt7mj1XLu9dNzYUvdSPN2fpVtjHQiHe3O41+/bte4+vFSELQrZFyMbx+NBIFL0ZRXf+01jh4L9OIva2zGjsGstvIWRZKnN3Fxy595lmkTtc+QV7+K2xQumexQ7oysde5Fty198tsfN2p7EeRSNvjJdKW1o/3/0xeHB0+ECrOzZ21nw7Oh7HzPm7dyR6Jm93h/TNBgMYsiH6shG7vXDwT+eX4KrMjV0XRmP7Kf6ErJClv1Sjp3k8VZ9b/IjNxt7I7nhHr/+mJx1CuVQa35L8DH6jWcgvRXC3O95X9QtBZvvn47v5LyhCFoTsogXf7q3RiQ4/hH+wt1i8ObxeyCJkWUztIm5+NLbVz6eFgds2NDMhOBdaXcZh/Shrd9vSawi2Cur0c/cS3MsdsvUxu3ifS8iCkJ0TtjWOCxs/MhS90j5kP/pyJWSNyCJkWWTtRkXTP083Pn8lI6mVj5WJ1jS+uv3TdxqTS/Gn8urHbh3C2ePQKaA7B3f3ut3XViGbu/83+IaDwQrZ2nJbN1VvT1uZE7ulFJffGd4m+3RbGn/hNSEKrVqAkGUxzY3G1kbssiOFc+E4truUnR96pdHUGLLdTBHIhtxih2zdn97bjB7PH6Pu5rN2M3rbaUS2MfIXM44Xa1RZyMIKD9kQe2nIFovFm6srFISIrYZsOkc2PFdbQzbsm5BFyLJo5mOyGlWV/04CrlDadXc2cBfGXO9/qs6GbOc4vIYh2zC1ofHxdqPP1efqj0X29QtivRb/acjuKhXuro/p+l8WjMiCkM21EHRhm8PyWrULvN6RBO3mELVhhLZ2R6+5UVkjsghZFkt9TNaHbFhqqrD7fZ/Ixlt2VPBKYjIbsq3isPp48z/xL8aoZHa7uwnZuaBvMY83dyG7yKs/CFkQsm2lsZcE3urqqGy8IYnZjUF4PzwWIjc8308BKGSFLPmXRta2bduONoZsNobqA3Lkja1bowuNYdZLyBYK2z/QavSwWRg2bseVRHQa7b2G7O6x4VK7P8e3296Ox6LHf5edCtG4Pe2WSOt0IZuQBSF75d/Us3PTC26szZVdVYnajPBY5Vavyf6GfeuHlQuErJAl37IjeGHkdcHUgjQ2W8ytXLiawXxAtZ17Orz1ta3D0Wvh9aOjI480RmnjPNpmIbtYQdYxZJNtrWzj8Njz4fm4UNjcuF2dQrbxIrF0f1uPyLbev8pNG0ZH9jQbXa47H62W4MrBygW++WDAQjaN2bDNQW2qwQ1Z4bH0easWIGRZvJjddfeuQunuaiDWh+xHPzp8OA2jBasVNIRfiLKmI51tLowqFHbd0xiRc/+uxSjvlayUcFUh2+TCtMbPvdjLaPX0S0gmZut/sZj/pSIN6TyMxgpZGNCQbQzAEHhzoqp+3A8hK2TpD81CtnHksXEEtt2f97tdH7ZxhLXTvNDs/NluLxZrd0OEblctqGxb+vmaRHxjyHZee/fql9+qfI7aSHHdfmzdeiFdEzhvEStkYQWE7KAQskKWwQjZVrd6DSE1MlrYczUh2/i67tZyXYKQ7WJEdj6k68Ow2VSIaxGyc5+r8TgkATt/gdnS3I1NyIKQFbJCVsiS+5DNjvQ1Wwar1cVevdyxKzsq225+bOMdqjrdUrabbek1ZJutDNBum1vGZ48rEnT6OJXjNzr6SHoBXePawEIWhCxCVsgK2RUXsq1jsv1oXy8h2/jn/ZZ/Sm/4037PIdtDcHd8PBOIrUK25xHjHm+3O//LRC3sG9aRnXs+Z8tx+YYDIStkEbIsbcg2GcnLXn2/8Gr5ra9lX98qBCufp0lQzo8sdn+nq+UI2V6CfSlDdu5cNLndb3Y/m71OyIKQRcgKWQY2ZJvdorbZPNOFF0rNR2hj4LUbyW0MvvYXemUuDMtTyLb72Jnnmk0paHYDiFY3hWi2WsGC53K89JaQBSErZBGyLGnINj7XOOLaLmCbhWB6Q4Fm8ZUN5ZHx8T1p0C6ItCZzPhc1ZHu4QKzpdi1xyDZuZ7NVCNrdorZuLdtlHp31DQdCtj9CdlbICln6K2S7nZPZ+U/fC/6s3njRVN3zrYKtYR5qw4Vl13r5rab72eaircUeka3+2+GftzzmbUJ2/mP2fjc2IQvXIGQvXrz4q2dOfLt8fPrZQ9PTJ798fHr60RMnTsQsr+PHpx+dnp7+8ne/+73vClkhS361+lN2Xfy0GYFtF71t7wbWzSjp1q0Xdo+MlFpOSbiGqxY0D9/mQd9s+zqFbKulzjqfu+6W66rcGawQb17WQQ7fcFAfsnG5vDkJ2K8m/rry9vj0wRMnTn4pxCzLJ5yDIPxiceLkt79SPjzxgTBqLmSFLP0Rsr0EUtOYbbida/0IaucYTj9/WPS/6ZSHRQjZVjc56D4c21yc1uX2tYz4Lv/d/HHN35qxQha6CNlyubyqWCzenETSpjDiF6YXJG9XFyYmbmJ5hXOTWBPOTymONwpZIQusbA4CtAjZJJRuTWM2/He5cqUsyyk5F+vD+QgRWzs/QrZPFA4/95d7vn7xldT9T7z6kxCyn3ryv/0y+/iev/3Bi+F70DEDhCz08s2QRFCIodrI37o0ltKRP/Khdj42ZUbM14QLwMKFYGFlA1/L+fTwwcPvDeHayQOPv/C44wUIWej1m6G2vNPcqGxt9C+MxpJTmdHYWaOxufeZyQvn2kXsJ7/5+u/iuLzZsQKELFxRzEaVUdkQs2FkNsyNJZ/CLxtpxBqN7Q+dRmWNxgJCFq46Zqsjs2nQkl8Ctv+0G5UNoesYAUIWrvYbY3b2ullyL5wnIdtfWo3KhsB1fAAhC0CuNRuVNRoLCFkAcq9xVNZoLCBkAegb2VFZo7GAkAWgb6SjskZjASELsFJ+aEfVC9wGQYjYh+OJewZpn3yNgpAFoMHhw4f/+Y9//OPf/fSnP50dFJd+NDj7kjpx4kQsaEHIApAxMTHxoZnz5y/WbtZxYyrcFCL73yyfqamp+8+cOfPM/E06IkELQhZghf+gjmavm5yc/PD58+cvpXecK5fLa8iXo1NTe0+fPXsinKP0hh2+fkHIAqxoIYiSkN0+MzNzOYnY9Ylb4jjeEN6SH1NTT+87febcyeT9tSFmw8hsuGmHr2EQsgArOmQnnnjiz75//sVXQ8AmNpXieKOYzY9wLo5OHXvg9NlzzxaLxZvDCG2YbmBUFoQswMr9IR3NXhdG9iYnJ0dDyIaADWqxtC6M/pEL6ysjsknI1n7BWBvmLwtZELIAKz5kJyYnP5KOyIaIDaGUhOyq2nzMt7F80nnLR6eOffb0uXMnwzkKv2QIWRCyAEK2MWSr82RXhwuK0ivkWR614399iNajx459JsyRFbIgZAFoErJhPmaIpDAam15MNEg3FOg7yfEPsRrmw1ZWLahe7HWLkAUhC+CHdIuQDX/Orq5V6qr4ZT9HScyG0fEpIQtCFgAhK2QBIQsgZBGyIGQBELIIWRCyAAhZIQsIWQAhi5AFIQuAkL0GHhwdPhB2rmrkjfFSaYuQBYQsgJDNrXj3yI75gK03PPrgASELCFkAIZvLfSmMDv+XaGjsB8U43pTe3jUeH/l4NWa3vTkex3eEMBSyLOovUHF584HHnr7PsRCyAAjZK9iPaO4OWGHbk/1YW7nVbrF4cxwXN4/eFV2Mojv/aXshfn/fBbqQzb2H44Pv2j31s9n7nnrtF/vLxz7hmAhZAIRsz7GXRmwcxxsSm0pxfGsSsneODkeXQsiOHYj/JLyunwJQyPZPyKbu/8aP/vHAoaMfd2yELABCtuvYS7Z9VRiJTQJ2YzViy7c/sv/Ptw9F0W+j4R2Xi3G8pd8CUMj2X8gKWiELgJDtOfbCdoftD/sRYvaR8X95b3V+7J2/2b7/0PYwUhtiN+xzv+2bkO2/kM0G7UOHJj/oWAlZAIRsk/2IKvsR5sjuG7vrofoVC5KILZQ/koTtljDdINnH1f00vSAN2S9PvfCt8an/9f/aBRP5tufrF18RtEIWACHbNPh27qzGbG2KwdqHC2N/OhRFv6kE7Z07Xi3E5aE0ZPtl9YI0ZP/mvz5f/s9P//f/e//XL796/xMXLydRdGnP5KWLIY5YXp+efPUnnSJ2/Oj/+G3hb56Pw18F/OwRsgAI2eb7MjHxtmQf1oR9iePybWEkdtf7olOVtWTH9j8S9s3UAhZTu6kFn/zm67974PEXHhewQhYAIdtS2N7sPNnaqgXvKMXldz48/if3VUZlhz92qRDHtwpZljpk5wO2vNkxErIACNmuQjZduWA+ZOO6kN0bx7cJWZYqZAWskAVAyF5RyBYKhT8IgVe7IUJYueDWELOZqQV/FZ4L82j77WIvIZv/kP3s12aeDu87JkIWACHbk2KxuH5sKHq5MvI6NPaDQhzf/nBhx7+au9grev+vdsXlPwqjtf0UgUI2/8L8VwErZAEQsle4H1FlxYJSYex9Sbi+Vb/8VphSsOPyvtLB94QbJITb1gpZQMgCCNlchF7DhV5hxYK1lRsjJNGazpUNcxbDKga1/TO1ABCyAEI2HyFbWz92TS1eN4Q7e9Ui9u21kL09PNavN0QQsiBkAVgZIbupdqHXrcn7twUhYrMBGKYjCFlAyAII2WUP2XTprcqUgsrNEOINQXg/xG1ttYKwX9f3y129hCwIWQAGOGSr+xGld/WqzJMN0wfC6Gxtvmx4f1Xy3I3hNf0Wf0IWhCwAAxyy6b6EbU6DNhX+Ow3YfhqJFbIgZAFYISGb3acQf3Oiqr49R0IWhCwAKyNkB+4cCVkQsgAIWSELCFkAIYuQBSELgJBFyIKQBUDICllAyAIIWSErZEHIAiBkEbIgZAFYipD9+wsvvX5k8smPHZmc/Ojk5ORo4sNJLH2I5RXOQ2L7s88+d1jIgpAFoCFk47j8+9/7/syFMCobzMy8eHnm/PlLiYssv/PhXMzMXH5y6thfCFkQsgBkQjaJo9XFYvHmOI43hLdJKK0J0wtCLCVvb2R5hOMfVM5Pubw+nJ9AyIKQBfBDuiFkS3G8MROz65LH14aoZfmEc5BGbHp+hCwIWQASIYbC6GuIpVoobZoL2nL5FpZfbSR2U004L2vDiK2QBSELIGSTKKqM/hWLN6fhJCDzF7O199cn52pVGEkPKxr4GgYhC7Byf1CnKxdUY3ZV5s/Z5ExtusGqsByX0VgQsgDUx+wN2YuMyJdCoXJubrDGLwhZADIhOzs7e10IpKydO09d3/gYyyeco5SQBSELQEPQkl++RkHIAgCAkAUAYDD9fycG+mySQbMiAAAAAElFTkSuQmCC\"/></p><p><br/></p>",
                    "question_type": 1,
                    "answer_type": 1,
                    "show_type_name": null,
                    "new_parent_id": 46916,
                    "score_rule": "",
                    "material_text": null,
                    "sort_son": "0",
                    "analyze": "<p>在需求管理过程中需求的变更是受严格管控的，其流程为：</p><p>1、问题分析和变更描述。这是识别和分析需求问题或者一份明确的变更提议，以检查它的有效性，从而产生一个更明确的需求变更提议。</p><p>2、变更分析和成本计算。使用可追溯性信息和系统需求的一般知识，对需求变更提议进行影响分析和评估。变更成本计算应该包括对需求文档的修改、系统修改的设计和实现的成本。一旦分析完成并且确认，应该进行是否执行这一变更的决策。</p><p>3、变更实现。这要求需求文档和系统设计以及实现都要同时修改。如果先对系统的程序做变更，然后再修改需求文档，这几乎不可避免地会出现需求文档和程序的不一致。</p><p><br/></p>",
                    "like": 0,
                    "answer": [
                        "A"
                    ],
                    "option": [
                        " 问题分析与变更描述、变更分析与成本计算、变更实现 ",
                        " 变更描述与成本计算、变更分析、变更实现 ",
                        " 问题分析与变更分析、成本计算、变更实现 ",
                        " 变更描述、变更分析与变更实现、成本计算 "
                    ]
                },
                {
                    "index": 48,
                    "belong_page": 1,
                    "question_id": 46917,
                    "question_title": "<p>软件过程是制作软件产品的一组活动以及结果，这些活动主要由软件人员来完成，主要包括（）</p>",
                    "question_type": 1,
                    "answer_type": 1,
                    "show_type_name": null,
                    "new_parent_id": 46917,
                    "score_rule": "",
                    "material_text": null,
                    "sort_son": "0",
                    "analyze": "<p>软件过程模型的基本概念：软件过程是制作软件产品的一组活动以及结果，这些活动主要由软件人员来完成，软件活动主要有：</p><p>(1) 软件描述。必须定义软件功能以及使用的限制。</p><p>(2) 软件开发。也就是软件的设计和实现，软件工程人员制作出能满足描述的软件。</p><p>(3) 软件有效性验证。软件必须经过严格的验证，以保证能够满足客户的需求。</p><p>(4) 软件进化。软件随着客户需求的变化不断地改进。</p><p><br/></p>",
                    "like": 0,
                    "answer": [
                        "D"
                    ],
                    "option": [
                        " 软件描述、软件开发和软件测试 ",
                        " 软件开发、软件有效性验证和软件测试 ",
                        " 软件描述、软件设计、软件实现和软件测试 ",
                        " 软件描述、软件开发、软件有效性验证和软件进化 "
                    ]
                },
                {
                    "index": 49,
                    "belong_page": 1,
                    "question_id": 46920,
                    "question_title": "<p>软件过程模型是软件开发实际过程的抽象与概括，它应该包括构成软件过程的各种活动。软件过程有各种各样的模型，其中，（）的活动之间存在因果关系，前一阶段工作的结果是后一段阶段工作的输入描述。</p>",
                    "question_type": 1,
                    "answer_type": 1,
                    "show_type_name": null,
                    "new_parent_id": 46920,
                    "score_rule": "",
                    "material_text": null,
                    "sort_son": "0",
                    "analyze": "<p>瀑布模型的特点是因果关系紧密相连，前一个阶段工作的结果是后一个阶段工作的输入。或者说，每一个阶段都是建筑在前一个阶段正确结果之上，前一个阶段的错漏会隐蔽地带到后一个阶段。这种错误有时甚至可能是灾难性的。因此每一个阶段工作完成后，都要进行审查和确认，这是非常重要的。历史上，瀑布模型起到了重要作用，它的出现有利于人员的组织管理，有利于软件开发方法和工具的研究。</p>",
                    "like": 0,
                    "answer": [
                        "A"
                    ],
                    "option": [
                        " 瀑布模型 ",
                        " 原型模式 ",
                        " 螺旋模型 ",
                        " 基于构建的模型 "
                    ]
                },
                {
                    "index": 50,
                    "belong_page": 1,
                    "question_id": 46930,
                    "question_title": "<p>以下关于敏捷方法的叙述中，（）是不正确的。</p>",
                    "question_type": 1,
                    "answer_type": 1,
                    "show_type_name": null,
                    "new_parent_id": 46930,
                    "score_rule": "",
                    "material_text": null,
                    "sort_son": "0",
                    "analyze": "<p>敏捷开发以用户的需求进化为核心，采用迭代、循序渐进的方法进行软件开发。在敏捷开发中，软件项目在构建初期被切分成多个子项目，各个子项目的成果都经过测试，具备可视、可集成和可运行使用的特征。换言之，就是把一个大项目分为多个相互联系，但也可独立运行的小项目，并分别完成，在此过程中软件一直处于可使用状态。</p>",
                    "like": 0,
                    "answer": [
                        "A"
                    ],
                    "option": [
                        " 敏捷型方法的思考角度是&quot;面向开发过程&quot;的 ",
                        " 极限编程是著名的敏捷开发方法 ",
                        " 敏捷型方法是&quot;适应性&quot;而非&quot;预设性&quot; ",
                        " 敏捷开发方法是迭代增量式的开发方法 "
                    ]
                },
                {
                    "index": 51,
                    "belong_page": 1,
                    "question_id": 46932,
                    "question_title": "<p>软件系统工具的种类繁多，通常可以按照软件过程活动将软件工具分为()</p>",
                    "question_type": 1,
                    "answer_type": 1,
                    "show_type_name": null,
                    "new_parent_id": 46932,
                    "score_rule": "",
                    "material_text": null,
                    "sort_son": "0",
                    "analyze": "<p>通常按软件过程活动将软件工具分为软件开发工具、软件维护工具 、软件管理和软件支持工具。 软件开发工具：需求分析工具、设计工具、编码与排错工具。 软件维护工具：版本控制工具、文档分析工具、开发信息库工具、逆向工程工具、再工程工具。 软件管理和软件支持工具：项目管理工具、配置管理工具、软件评价工具、软件开发工具的评价和选择。</p>",
                    "like": 0,
                    "answer": [
                        "B"
                    ],
                    "option": [
                        " 需求分析工具、设计工具和软件实现工具 ",
                        " 软件开发工具、软件维护工具、软件管理工具和软件支持工具 ",
                        " 需求分析工具、设计工具、编码与排错工具和测试工具 ",
                        " 设计规范工具、产编码工具和验证工具 "
                    ]
                },
                {
                    "index": 52,
                    "belong_page": 1,
                    "question_id": 46935,
                    "question_title": "<p>结构化程序设计采用自顶向下、逐步求精及模块化的程序设计方法，通过（）三种基本的控制结构可以构造出任何单入口单出口的程序。</p>",
                    "question_type": 1,
                    "answer_type": 1,
                    "show_type_name": null,
                    "new_parent_id": 46935,
                    "score_rule": "",
                    "material_text": null,
                    "sort_son": "0",
                    "analyze": "<p>结构化程序设计采用自顶向下、逐步求精及模块化的程序设计方法，通过顺序、分支和循环三种基本的控制结构可以构造出任何单入口单出口的程序。</p>",
                    "like": 0,
                    "answer": [
                        "B"
                    ],
                    "option": [
                        " 顺序、选择和嵌套 ",
                        " 顺序、分支和循环 ",
                        " 分支、并发和循环 ",
                        " 跳转、选择和并发 "
                    ]
                },
                {
                    "index": 53,
                    "belong_page": 1,
                    "question_id": 46944,
                    "question_title": "<p>OMG 接口定义语言 IDL 文件包含了六种不同的元素，（ ）是一个 IDL 文件核心的内容。</p>",
                    "question_type": 1,
                    "answer_type": 1,
                    "show_type_name": null,
                    "new_parent_id": 46944,
                    "score_rule": "",
                    "material_text": null,
                    "sort_son": "0",
                    "analyze": "<p><br/></p><p>IDL是一种接口定义语言，具体的定义会涉及到接口以及相关部分。文件包含的主要元素有：接口描述、模块定义、类型定义、常量定义、异常、值类型。接口描述是IDL文件中最核心的内容。</p><p>由于IDL只是一种接口定义语言，最终还是要落地与语言对接的,所以IDL的数据类型要与实现语言进行映射。以Java为例，IDL接口映射为Java类,而该接口的操作映射为相应的成员函数。模块定义映射为Java语言中的\u2029包（package）或C++的命名空间（namespace）。</p><p><br/></p>",
                    "like": 0,
                    "answer": [
                        "C"
                    ],
                    "option": [
                        " 模块定义 ",
                        " 消息结构 ",
                        " 接口描述 ",
                        " 值类型 "
                    ]
                },
                {
                    "index": 54,
                    "belong_page": 1,
                    "question_id": 46946,
                    "question_title": "<p>OMG 接口定义语言 IDL 文件包含了六种不同的元素，（）将映射为 Java 语言中的包 (package) 或 c++语言中的命名空间(Namespace)。</p>",
                    "question_type": 1,
                    "answer_type": 1,
                    "show_type_name": null,
                    "new_parent_id": 46946,
                    "score_rule": "",
                    "material_text": null,
                    "sort_son": "0",
                    "analyze": "<p>IDL是一种接口定义语言，具体的定义会涉及到接口以及相关部分。文件包含的主要元素有：接口描述、模块定义、类型定义、常量定义、异常、值类型。接口描述是IDL文件中最核心的内容。</p><p>由于IDL只是一种接口定义语言，最终还是要落地与语言对接的,所以IDL的数据类型要与实现语言进行映射。以Java为例，IDL接口映射为Java类,而该接口的操作映射为相应的成员函数。模块定义映射为Java语言中的\u2029包（Package）或C++的namespaces。</p><br/><p><br/></p>",
                    "like": 0,
                    "answer": [
                        "A"
                    ],
                    "option": [
                        " 模块定义 ",
                        " 消息结构 ",
                        " 接口描述 ",
                        " 值类型 "
                    ]
                },
                {
                    "index": 55,
                    "belong_page": 1,
                    "question_id": 46948,
                    "question_title": "<p>应用系统构建中可以采用多种不同的技术，()可以将软件某种形式的描述转换为更高级的抽象表现形式。</p>",
                    "question_type": 1,
                    "answer_type": 1,
                    "show_type_name": null,
                    "new_parent_id": 46948,
                    "score_rule": "",
                    "material_text": null,
                    "sort_son": "0",
                    "analyze": "<p>所谓软件的逆向工程就是分析已有的程序，寻求比源代码更高级的抽象表现形式。一般认为，凡是在软件生命周期内将软件某种形式的描述转换成更为抽象形式的活动都可称为逆向工程。</p>",
                    "like": 0,
                    "answer": [
                        "A"
                    ],
                    "option": [
                        " 逆向工程（(Reverse Engineering) ",
                        " 系统改进 (System Improvement) ",
                        " 设计恢复 (DesignRecovery ) ",
                        " 再工程 (Re-engineering) "
                    ]
                },
                {
                    "index": 56,
                    "belong_page": 1,
                    "question_id": 46992,
                    "question_title": "<p>项目的成本管理中，（&nbsp; ）将总的成本估算分配到各项活动和工作包上，来建立一个成本的基线。</p>",
                    "question_type": 1,
                    "answer_type": 1,
                    "show_type_name": null,
                    "new_parent_id": 46992,
                    "score_rule": "",
                    "material_text": null,
                    "sort_son": "0",
                    "analyze": "<p>成本管理过程包括：成本估算、成本预算与成本控制。其中成本预算的含义是将总的成本估算分配到各项活动和工作包上，来建立一个成本的基线。而成本估算是对完成项目活动所需资金进行近似的估算。</p>",
                    "like": 0,
                    "answer": [
                        "B"
                    ],
                    "option": [
                        " 成本估算 ",
                        " 成本预算 ",
                        " 成本跟踪 ",
                        " 成本控制 "
                    ]
                },
                {
                    "index": 57,
                    "belong_page": 1,
                    "question_id": 49845,
                    "question_title": "<p>项目范围管理中，范围定义的输入包括（ ）</p>",
                    "question_type": 1,
                    "answer_type": 1,
                    "show_type_name": null,
                    "new_parent_id": 49845,
                    "score_rule": "",
                    "material_text": null,
                    "sort_son": "0",
                    "analyze": "<p>在初步项目范围说明书中已文档化的主要的可交付物、假设和约束条件的基础上准备详细的项目范围说明书，是项目成功的关键。范围定义的输入包括以下内容：</p><p>① 项目章程。如果项目章程或初始的范围说明书没有在项目执行组织中使用，同样的信息需要进一步收集和开发，以产生详细的项目范围说明书。</p><p>② 项目范围管理计划。</p><p>③ 组织过程资产。</p><p>④ 批准的变更申请。</p>",
                    "like": 0,
                    "answer": [
                        "C"
                    ],
                    "option": [
                        " 项目章程、项目范围管理计划、产品范围说明书和变更申请 ",
                        " 项目范围描述、产品范围说明书、生产项目计划和组织过程资产 ",
                        " 项目章程、项目范围管理计划、组织过程资产和批准的变更申请 ",
                        " 生产项目计划、项目可交付物说明、信息系统要求说明和项目质量标准 "
                    ]
                },
                {
                    "index": 58,
                    "belong_page": 1,
                    "question_id": 49846,
                    "question_title": "<p>项目配置管理中，产品配置是指一个产品在其生命周期各个阶段所产生的各种形式和各种版本的文档、计算机程序、部件及数据的集合。该集合中的每一个元素称为该产品配置中的一个配置项，（ ）不属于产品组成部分工作成果的配置项。</p>",
                    "question_type": 1,
                    "answer_type": 1,
                    "show_type_name": null,
                    "new_parent_id": 49846,
                    "score_rule": "",
                    "material_text": null,
                    "sort_son": "0",
                    "analyze": "<p>配置项是构成产品配置的主要元素，配置项主要有以下两大类：</p><p>（1）属于产品组成部分的工作成果：如需求文档、设计文档、源代码和测试用例等；</p><p>（2）属于项目管理和机构支撑过程域产生的文档：如工作计划、项目质量报告和项目跟踪报告等。</p><p>这些文档虽然不是产品的组成部分，但是值得保存。所以设备清单不属于配置项。所以选项C的工作计划虽可充当配置项，但不属于产品组成部分工作成果的配置项。</p>",
                    "like": 0,
                    "answer": [
                        "C"
                    ],
                    "option": [
                        " 需求文档 ",
                        " 设计文档 ",
                        " 工作计划 ",
                        " 源代码 "
                    ]
                },
                {
                    "index": 59,
                    "belong_page": 1,
                    "question_id": 49848,
                    "question_title": "<p>一个好的变更控制过程，给项目风险承担者提供了正式的建议变更机制。如下图所示的需求变更管理过程中，①②③处对应的内容应分别是( )。</p><p>识别出问题</p><p><img style=\"max-width:100%;height:auto\"  src=\"http://s2.51cto.com/images/20180909/1536468435914311.jpg\" title=\"1536468435914311.jpg\" alt=\"1.jpg\"/></p>",
                    "question_type": 1,
                    "answer_type": 1,
                    "show_type_name": null,
                    "new_parent_id": 49848,
                    "score_rule": "",
                    "material_text": null,
                    "sort_son": "0",
                    "analyze": "<p>在需求管理过程中需求的变更是受严格管控的，其流程为：</p><p>1、问题分析和变更描述。这是识别和分析需求问题或者一份明确的变更提议，以检查它的有效性，从而产生一个更明确的需求变更提议。</p><p>2、变更分析和成本计算。使用可追溯性信息和系统需求的一般知识，对需求变更提议进行影响分析和评估。变更成本计算应该包括对需求文档的修改、系统修改的设计和实现的成本。一旦分析完成并且确认，应该进行是否执行这一变更的决策。</p><p>3、变更实现。这要求需求文档和系统设计以及实现都要同时修改。如果先对系统的程序做变更，然后再修改需求文档，这几乎不可避免地会出现需求文档和程序的不一致。</p>",
                    "like": 0,
                    "answer": [
                        "A"
                    ],
                    "option": [
                        " 问题分析与变更描述、变更分析与成本计算、变更实现 ",
                        " 变更描述与成本计算、变更分析、变更实现 ",
                        " 问题分析与变更分析、成本计算、变更实现 ",
                        " 变更描述、变更分析与变更实现、成本计算 "
                    ]
                },
                {
                    "index": 60,
                    "belong_page": 1,
                    "question_id": 49849,
                    "question_title": "<p>软件过程是制作软件产品的一组活动以及结果，这些活动主要由软件人员来完成，主要包括（请作答此空 ）。软件过程模型是软件开发实际过程的抽象与概括，它应该包括构成软件过程的各种活动。软件过程有各种各样的模型，其中，（）的活动之间存在因果关系，前一阶段工作的结果是后一段阶段工作的输入描述。</p>",
                    "question_type": 1,
                    "answer_type": 1,
                    "show_type_name": null,
                    "new_parent_id": 49849,
                    "score_rule": "",
                    "material_text": null,
                    "sort_son": "0",
                    "analyze": "<p>软件过程模型的基本概念：软件过程是制作软件产品的一组活动以及结果，这些活动主要由软件人员来完成，软件活动主要有：</p><p>(1) 软件描述。必须定义软件功能以及使用的限制。</p><p>(2) 软件开发。也就是软件的设计和实现，软件工程人员制作出能满足描述的软件。</p><p>(3) 软件有效性验证。软件必须经过严格的验证，以保证能够满足客户的需求。</p><p>(4) 软件进化。软件随着客户需求的变化不断地改进。</p><p>瀑布模型的特点是因果关系紧密相连，前一个阶段工作的结果是后一个阶段工作的输入。或者说，每一个阶段都是建筑在前一个阶段正确结果之上，前一个阶段的错漏会隐蔽地带到后一个阶段。这种错误有时甚至可能是灾难性的。因此每一个阶段工作完成后，都要进行审查和确认，这是非常重要的。历史上，瀑布模型起到了重要作用，它的出现有利于人员的组织管理，有利于软件开发方法和工具的研究。</p>",
                    "like": 0,
                    "answer": [
                        "D"
                    ],
                    "option": [
                        " 软件描述、软件开发和软件测试 ",
                        " 软件开发、软件有效性验证和软件测试 ",
                        " 软件描述、软件设计、软件实现和软件测试 ",
                        " 软件描述、软件开发、软件有效性验证和软件进化 "
                    ]
                },
                {
                    "index": 61,
                    "belong_page": 1,
                    "question_id": 49850,
                    "question_title": "<p>软件过程是制作软件产品的一组活动以及结果，这些活动主要由软件人员来完成，主要包括（）。软件过程模型是软件开发实际过程的抽象与概括，它应该包括构成软件过程的各种活动。软件过程有各种各样的模型，其中，（请作答此空 ）的活动之间存在因果关系，前一阶段工作的结果是后一段阶段工作的输入描述。</p>",
                    "question_type": 1,
                    "answer_type": 1,
                    "show_type_name": null,
                    "new_parent_id": 49850,
                    "score_rule": "",
                    "material_text": null,
                    "sort_son": "0",
                    "analyze": "<p>软件过程模型的基本概念：软件过程是制作软件产品的一组活动以及结果，这些活动主要由软件人员来完成，软件活动主要有：</p><p>(1) 软件描述。必须定义软件功能以及使用的限制。</p><p>(2) 软件开发。也就是软件的设计和实现，软件工程人员制作出能满足描述的软件。</p><p>(3) 软件有效性验证。软件必须经过严格的验证，以保证能够满足客户的需求。</p><p>(4) 软件进化。软件随着客户需求的变化不断地改进。</p><p>瀑布模型的特点是因果关系紧密相连，前一个阶段工作的结果是后一个阶段工作的输入。或者说，每一个阶段都是建筑在前一个阶段正确结果之上，前一个阶段的错漏会隐蔽地带到后一个阶段。这种错误有时甚至可能是灾难性的。因此每一个阶段工作完成后，都要进行审查和确认，这是非常重要的。历史上，瀑布模型起到了重要作用，它的出现有利于人员的组织管理，有利于软件开发方法和工具的研究。</p>",
                    "like": 0,
                    "answer": [
                        "A"
                    ],
                    "option": [
                        " 瀑布模型 ",
                        " 原型模式 ",
                        " 螺旋模型 ",
                        " 基于构建的模型 "
                    ]
                },
                {
                    "index": 62,
                    "belong_page": 1,
                    "question_id": 49851,
                    "question_title": "<p>以下关于敏捷方法的叙述中，（ ）是不正确的。</p>",
                    "question_type": 1,
                    "answer_type": 1,
                    "show_type_name": null,
                    "new_parent_id": 49851,
                    "score_rule": "",
                    "material_text": null,
                    "sort_son": "0",
                    "analyze": "<p>敏捷开发以用户的需求进化为核心，采用迭代、循序渐进的方法进行软件开发。在敏捷开发中，软件项目在构建初期被切分成多个子项目，各个子项目的成果都经过测试，具备可视、可集成和可运行使用的特征。换言之，就是把一个大项目分为多个相互联系，但也可独立运行的小项目，并分别完成，在此过程中软件一直处于可使用状态。</p>",
                    "like": 0,
                    "answer": [
                        "A"
                    ],
                    "option": [
                        " 敏捷型方法的思考角度是&quot;面向开发过程&quot;的 ",
                        " 极限编程是著名的敏捷开发方法 ",
                        " 敏捷型方法是&quot;适应性&quot;而非&quot;预设性&quot; ",
                        " 敏捷开发方法是迭代增量式的开发方法 "
                    ]
                },
                {
                    "index": 63,
                    "belong_page": 1,
                    "question_id": 49852,
                    "question_title": "<p>软件系统工具的种类繁多，通常可以按照软件过程活动将软件工具分为( ) 。</p>",
                    "question_type": 1,
                    "answer_type": 1,
                    "show_type_name": null,
                    "new_parent_id": 49852,
                    "score_rule": "",
                    "material_text": null,
                    "sort_son": "0",
                    "analyze": "<p>通常按软件过程活动将软件工具分为软件开发工具、软件维护工具 、软件管理和软件支持工具。 软件开发工具：需求分析工具、设计工具、编码与排错工具。 软件维护工具：版本控制工具、文档分析工具、开发信息库工具、逆向工程工具、再工程工具。 软件管理和软件支持工具：项目管理工具、配置管理工具、软件评价工具、软件开发工具的评价和选择。</p>",
                    "like": 0,
                    "answer": [
                        "B"
                    ],
                    "option": [
                        " 需求分析工具、设计工具和软件实现工具 ",
                        " 软件开发工具、软件维护工具、软件管理工具和软件支持工具 ",
                        " 需求分析工具、设计工具、编码与排错工具和测试工具 ",
                        " 设计规范工具、产编码工具和验证工具 "
                    ]
                },
                {
                    "index": 64,
                    "belong_page": 1,
                    "question_id": 49853,
                    "question_title": "<p>UNIX 的源代码控制工具（source Code control System，SCCS）是软件项目开发中常用的（ ）。</p>",
                    "question_type": 1,
                    "answer_type": 1,
                    "show_type_name": null,
                    "new_parent_id": 49853,
                    "score_rule": "",
                    "material_text": null,
                    "sort_son": "0",
                    "analyze": "<p>版本控制软件提供完备的版本管理功能，用于存储、追踪目录（文件夹）和文件的修改历史，是软件开发者的必备工具，是软件公司的基础设施。版本控制软件的最高目标，是支持软件公司的配置管理活动，追踪多个版本的开发和维护活动，及时发布软件。SCCS是元老级的版本控制软件，也叫配置管理软件。</p>",
                    "like": 0,
                    "answer": [
                        "C"
                    ],
                    "option": [
                        " 源代码静态分析工具 ",
                        " 文档分析工具 ",
                        " 版本控制工具 ",
                        " 再工程工具 "
                    ]
                },
                {
                    "index": 65,
                    "belong_page": 1,
                    "question_id": 49854,
                    "question_title": "<p>结构化程序设计采用自顶向下、逐步求精及模块化的程序设计方法，通过（ ）三种基本的控制结构可以构造出任何单入口单出口的程序。</p>",
                    "question_type": 1,
                    "answer_type": 1,
                    "show_type_name": null,
                    "new_parent_id": 49854,
                    "score_rule": "",
                    "material_text": null,
                    "sort_son": "0",
                    "analyze": "<p>结构化程序设计采用自顶向下、逐步求精及模块化的程序设计方法，通过顺序、分支和循环三种基本的控制结构可以构造出任何单入口单出口的程序。</p>",
                    "like": 0,
                    "answer": [
                        "B"
                    ],
                    "option": [
                        " 顺序、选择和嵌套 ",
                        " 顺序、分支和循环 ",
                        " 分支、并发和循环 ",
                        " 跳转、选择和并发 "
                    ]
                },
                {
                    "index": 66,
                    "belong_page": 1,
                    "question_id": 49860,
                    "question_title": "<p>OMG 接口定义语言 IDL 文件包含了六种不同的元素，（请作答此空）是一个 IDL 文件核心的内容，（ ）将映射为 Java 语言中的包 (package) 或 c++语言中的命名空间(namespace)。</p>",
                    "question_type": 1,
                    "answer_type": 1,
                    "show_type_name": null,
                    "new_parent_id": 49860,
                    "score_rule": "",
                    "material_text": null,
                    "sort_son": "0",
                    "analyze": "<p>IDL是一种接口定义语言，具体的定义会涉及到接口以及相关部分。文件包含的主要元素有：接口描述、模块定义、类型定义、常量定义、异常、值类型。接口描述是IDL文件中最核心的内容。<br/></p><p>由于IDL只是一种接口定义语言，最终还是要落地与语言对接的,所以IDL的数据类型要与实现语言进行映射。以Java为例，IDL接口映射为Java类,而该接口的操作映射为相应的成员函数。模块定义映射为Java语言中的\u2029包（package）或C++的命名空间（namespace）。</p><p><br/></p>",
                    "like": 0,
                    "answer": [
                        "C"
                    ],
                    "option": [
                        " 模块定义 ",
                        " 消息结构 ",
                        " 接口描述 ",
                        " 值类型 "
                    ]
                },
                {
                    "index": 67,
                    "belong_page": 1,
                    "question_id": 49862,
                    "question_title": "<p>应用系统构建中可以采用多种不同的技术，( 请作答此空)可以将软件某种形式的描述转换为更高级的抽象表现形式，而利用这些获取的信息，()能够对现有系统进行修改或 重构，从而产生系统的一个新版本。</p>",
                    "question_type": 1,
                    "answer_type": 1,
                    "show_type_name": null,
                    "new_parent_id": 49862,
                    "score_rule": "",
                    "material_text": null,
                    "sort_son": "0",
                    "analyze": "<p>所谓软件的逆向工程就是分析已有的程序，寻求比源代码更高级的抽象表现形式。一般认为，凡是在软件生命周期内将软件某种形式的描述转换成更为抽象形式的活动都可称为逆向工程。与之相关的概念是：重构（restructuring），指在同一抽象级别上转换系统描述形式；设计恢复（design recovery)，指借助工具从已有程序中抽象出有关数据设计、总体结构设计和过程设计的信息（不一定是原设计）；再工程（re-engineering），也称修复和改造工程，它是在逆向工程所获信息的基础上修改或重构已有的系统，产生系统的一个新版本。</p>",
                    "like": 0,
                    "answer": [
                        "A"
                    ],
                    "option": [
                        " 逆向工程（(Reverse Engineering) ",
                        " 系统改进 (System Improvement) ",
                        " 设计恢复 (DesignRecovery ) ",
                        " 再工程 (Re-engineering) "
                    ]
                },
                {
                    "index": 68,
                    "belong_page": 1,
                    "question_id": 49863,
                    "question_title": "<p>应用系统构建中可以采用多种不同的技术，()可以将软件某种形式的描述转换为更高级的抽象表现形式，而利用这些获取的信息，(请作答此空 )能够对现有系统进行修改或 重构，从而产生系统的一个新版本。</p>",
                    "question_type": 1,
                    "answer_type": 1,
                    "show_type_name": null,
                    "new_parent_id": 49863,
                    "score_rule": "",
                    "material_text": null,
                    "sort_son": "0",
                    "analyze": "<p>所谓软件的逆向工程就是分析已有的程序，寻求比源代码更高级的抽象表现形式。一般认为，凡是在软件生命周期内将软件某种形式的描述转换成更为抽象形式的活动都可称为逆向工程。与之相关的概念是：重构（restructuring），指在同一抽象级别上转换系统描述形式；设计恢复（design recovery)，指借助工具从已有程序中抽象出有关数据设计、总体结构设计和过程设计的信息（不一定是原设计）；再工程（re-engineering），也称修复和改造工程，它是在逆向工程所获信息的基础上修改或重构已有的系统，产生系统的一个新版本。</p>",
                    "like": 0,
                    "answer": [
                        "D"
                    ],
                    "option": [
                        " 逆向工程（(Reverse Engineering) ",
                        " 系统改进 (System Improvement) ",
                        " 设计恢复 (Design Recovery ) ",
                        " 再工程 (Re-engineering) "
                    ]
                },
                {
                    "index": 69,
                    "belong_page": 1,
                    "question_id": 49892,
                    "question_title": "<p>某工程包括 A、B、C、D 四个作业，其衔接关系、正常进度下所需天数和所需直接费用、赶工进度下所需的最少天数和每天需要增加的直接费用见下表。该工程的间接费用为每天 5万元。据此，可以估算出完成该工程最少需要费用（请作答此空 ）万元，以此最低费用完成该工程需要（）天。<br/></p><br/><img style=\"max-width:100%;height:auto\"  src=\"https://s2.51cto.com/images/20190912/1568253417767135.png\" title=\"1568253417767135.png\" alt=\"image.png\"/>",
                    "question_type": 1,
                    "answer_type": 1,
                    "show_type_name": null,
                    "new_parent_id": 49892,
                    "score_rule": "",
                    "material_text": null,
                    "sort_son": "0",
                    "analyze": "<p>A赶工2天，B赶工1天，D赶工3天。此时关键路径长度为7天，总花费为106万。</p>",
                    "like": 0,
                    "answer": [
                        "A"
                    ],
                    "option": [
                        " 106 ",
                        " 108 ",
                        " 109 ",
                        " 115 "
                    ]
                },
                {
                    "index": 70,
                    "belong_page": 1,
                    "question_id": 49893,
                    "question_title": "<p>某工程包括 A、B、C、D 四个作业，其衔接关系、正常进度下所需天数和所需直接费用、赶工进度下所需的最少天数和每天需要增加的直接费用见下表。该工程的间接费用为每天 5万元。据此，可以估算出完成该工程最少需要费用（）万元，以此最低费用完成该工程需要（请作答此空 ）天。</p><br/><img style=\"max-width:100%;height:auto\"  src=\"https://s2.51cto.com/images/20190912/1568253470306269.png\" title=\"1568253470306269.png\" alt=\"image.png\"/>",
                    "question_type": 1,
                    "answer_type": 1,
                    "show_type_name": null,
                    "new_parent_id": 49893,
                    "score_rule": "",
                    "material_text": null,
                    "sort_son": "0",
                    "analyze": "<p>A赶工2天，B赶工1天，D赶工3天。此时关键路径长度为7天，总花费为106万。</p>",
                    "like": 0,
                    "answer": [
                        "A"
                    ],
                    "option": [
                        " 7 ",
                        " 9 ",
                        " 10 ",
                        " 12 "
                    ]
                },
                {
                    "index": 71,
                    "belong_page": 1,
                    "question_id": 49920,
                    "question_title": "<p>项目的成本管理中，（ &nbsp;）将总的成本估算分配到各项活动和工作包上，来建立一个成本的基线。</p>",
                    "question_type": 1,
                    "answer_type": 1,
                    "show_type_name": null,
                    "new_parent_id": 49920,
                    "score_rule": "",
                    "material_text": null,
                    "sort_son": "0",
                    "analyze": "<p>成本管理过程包括：成本估算、成本预算与成本控制。其中成本预算的含义是将总的成本估算分配到各项活动和工作包上，来建立一个成本的基线。而成本估算是对完成项目活动所需资金进行近似的估算。</p>",
                    "like": 0,
                    "answer": [
                        "B"
                    ],
                    "option": [
                        " 成本估算 ",
                        " 成本预算 ",
                        " 成本跟踪 ",
                        " 成本控制 "
                    ]
                },
                {
                    "index": 72,
                    "belong_page": 1,
                    "question_id": 49922,
                    "question_title": "<p>（ &nbsp;）在软件开发机构中被广泛用来指导软件过程改进。</p>",
                    "question_type": 1,
                    "answer_type": 1,
                    "show_type_name": null,
                    "new_parent_id": 49922,
                    "score_rule": "",
                    "material_text": null,
                    "sort_son": "0",
                    "analyze": "<p>CMM能力成熟度模型（Capacity Maturity Model）是用来指导软件过程改进的。</p>",
                    "like": 0,
                    "answer": [
                        "A"
                    ],
                    "option": [
                        " 能力成熟度模型（Capacity Maturity Model） ",
                        " 关键过程领域（Key Process Areas） ",
                        " 需求跟踪能力链（Traceability Link） ",
                        " 工作分解结构（Work Breakdown Structure） "
                    ]
                },
                {
                    "index": 73,
                    "belong_page": 1,
                    "question_id": 49923,
                    "question_title": "<p>（ &nbsp;）是关于需求管理正确的说法。</p>",
                    "question_type": 1,
                    "answer_type": 1,
                    "show_type_name": null,
                    "new_parent_id": 49923,
                    "score_rule": "",
                    "material_text": null,
                    "sort_son": "0",
                    "analyze": "<p>过程能力成熟度模型（CMM）在软件开发机构中被广泛用来指导软件过程改进。为了达到过程能力成熟度模型的第二级，组织机构必须具有 6 个关键过程域。</p><p>需求的属性包括：创建需求的时间、需求的版本号、创建需求的作者、负责认可该软件需求的人员、需求状态、需求的原因和根据、需求涉及的子系统、需求涉及的产品版本号、使用的验证方法或者接受的测试标准、产品的优先级或者重要程度、需求的稳定性。</p><p>需求的变更遵循以下流程：</p><p>(1) 问题分析和变更描述。这是识别和分析需求问题或者一份明确的变更提议，以检查它的有效性，从而产生一个更明确的需求变更提议。</p><p>(2)变更分析和成本计算。使用可追溯性信息和系统需求的一般知识，对需求变更提议进行影响分析和评估。变更成本计算应该包括对需求文档的修改、系统修改的设计和实现的成本。一旦分析完成并且被确认，应该进行是否执行这一变更的决策。</p><p>(3)变更实现。这要求需求文档和系统设计以及实现都要同时修改。如果先对系统的程序做变更，然后再修改需求文档，这几乎不可避免地会出现需求文档和程序的不一致。</p><p>在对变更控制委员会的定义中，变更控制委员会对项目中任何基线工作产品的变更都可以做出决定。</p>",
                    "like": 0,
                    "answer": [
                        "D"
                    ],
                    "option": [
                        " 为达到过程能力成熟度模型第二级，组织机构必须具有3个关键过程域 ",
                        " 需求的稳定性不属于需求属性 ",
                        " 需求变更的管理过程遵循变更分析和成本计算、问题分析和变更描述、变更实现的顺序 ",
                        " 变更控制委员会对项目中任何基线工作产品的变更都可以做出决定 "
                    ]
                },
                {
                    "index": 74,
                    "belong_page": 1,
                    "question_id": 49924,
                    "question_title": "<p>螺旋模型在（ &nbsp;）的基础上扩展而成。</p>",
                    "question_type": 1,
                    "answer_type": 1,
                    "show_type_name": null,
                    "new_parent_id": 49924,
                    "score_rule": "",
                    "material_text": null,
                    "sort_son": "0",
                    "analyze": "<p>螺旋模型是在快速原型的基础上扩展而成的。</p>",
                    "like": 0,
                    "answer": [
                        "C"
                    ],
                    "option": [
                        " 瀑布模型 ",
                        " 原型模型 ",
                        " 快速模型 ",
                        " 面向对象模型 "
                    ]
                },
                {
                    "index": 75,
                    "belong_page": 1,
                    "question_id": 49925,
                    "question_title": "<p>（ ）适用于程序开发人员在地域上分布很广的开发团队。</p>",
                    "question_type": 1,
                    "answer_type": 1,
                    "show_type_name": null,
                    "new_parent_id": 49925,
                    "score_rule": "",
                    "material_text": null,
                    "sort_son": "0",
                    "analyze": "<p>(1) XP (Extreme Programming，极限编程)在所有的敏捷型方法中，XP是最引人瞩目的。它源于Smalltalk圈子，特别是Kent Beck和Ward Cunningham在20世纪80年代末的密切合作。XP在一些对费用控制严格的公司中的使用，已经被证明是非常有效的。</p><p>(2) Cockburn的水晶系列方法，水晶系列方法是由Alistair Cockburn提出的。它与XP方法一样，都有以人为中心的理念，但在实践上有所不同。Alistair考虑到人们一般很难严格遵循一个纪律约束很强的过程，因此，与XP的高度纪律性不同，Alistair探索了用最少纪律约束而仍能成功的方法，从而在产出效率与易于运作上达到一种平衡。也就是说，虽然水晶系列不如XP那样的产出效率，但会有更多的人能够接受并遵循它。</p><p>(3) 开放式源码，这里提到的开放式源码指的是开放源码界所用的一种运作方式。开放式源码项目有一个特别之处，就是程序开发人员在地域上分布很广，这使得它和其他敏捷方法不同，因为一般的敏捷方法都强调项目组成员在同一地点工作。开放源码的一个突出特点就是查错排障(debug)的高度并行性，任何人发现了错误都可将改正源码的&quot;补丁&quot;文件发给维护者。然后由维护者将这些&quot;补丁&quot;或是新增的代码并入源码库。</p><p>(4) SCRUM。SCRUM己经出现很久了，像前面所论及的方法一样，该方法强调这样一个事实，即明确定义了的可重复的方法过程只限于在明确定义了的可重复的环境中，为明确定义了的可重复的人员所用，去解决明确定义了的可重复的问题。</p><p>(5) Coad的功用驱动开发方法(FDD-Feature Driven Development)FDD是由Jeff De Luca和大师Peter Coad提出来的。像其他方法一样，它致力于短时的迭代阶段和可见可用的功能。在FDD中，一个迭代周期一般是两周。</p><p>在FDD中，编程开发人员分成两类：首席程序员和&quot;类&quot;程序员(class owner)。首席程序员是最富有经验的开发人员，他们是项目的协调者、设计者和指导者，而&quot;类&quot;程序员则主要做源码编写。</p><p>(6) ASD方法，ASD (Adaptive Software Development)方法由Jim Highsmith提出，其核心是三个非线性的、重叠的开发阶段：猜测、合作与学习。</p>",
                    "like": 0,
                    "answer": [
                        "B"
                    ],
                    "option": [
                        " 水晶系列（Crystal）开发方法 ",
                        " 开放式源码（Open source）开发方法 ",
                        " SCRUM开发方法 ",
                        " 功用驱动开发方法（FDD） "
                    ]
                },
                {
                    "index": 76,
                    "belong_page": 1,
                    "question_id": 49926,
                    "question_title": "<p>（ &nbsp;）中，编程开发人员分成首席程序员和&quot;类&quot;程序员。</p>",
                    "question_type": 1,
                    "answer_type": 1,
                    "show_type_name": null,
                    "new_parent_id": 49926,
                    "score_rule": "",
                    "material_text": null,
                    "sort_son": "0",
                    "analyze": "<p>(1) XP (Extreme Programming，极限编程)在所有的敏捷型方法中，XP是最引人瞩目的。它源于Smalltalk圈子，特别是Kent Beck和Ward Cunningham在20世纪80年代末的密切合作。XP在一些对费用控制严格的公司中的使用，已经被证明是非常有效的。</p><p>(2) Cockburn的水晶系列方法，水晶系列方法是由Alistair Cockburn提出的。它与XP方法一样，都有以人为中心的理念，但在实践上有所不同。Alistair考虑到人们一般很难严格遵循一个纪律约束很强的过程，因此，与XP的高度纪律性不同，Alistair探索了用最少纪律约束而仍能成功的方法，从而在产出效率与易于运作上达到一种平衡。也就是说，虽然水晶系列不如XP那样的产出效率，但会有更多的人能够接受并遵循它。</p><p>(3) 开放式源码，这里提到的开放式源码指的是开放源码界所用的一种运作方式。开放式源码项目有一个特别之处，就是程序开发人员在地域上分布很广，这使得它和其他敏捷方法不同，因为一般的敏捷方法都强调项目组成员在同一地点工作。开放源码的一个突出特点就是查错排障(debug)的高度并行性，任何人发现了错误都可将改正源码的&quot;补丁&quot;文件发给维护者。然后由维护者将这些&quot;补丁&quot;或是新增的代码并入源码库。</p><p>(4) SCRUM。SCRUM己经出现很久了，像前面所论及的方法一样，该方法强调这样一个事实，即明确定义了的可重复的方法过程只限于在明确定义了的可重复的环境中，为明确定义了的可重复的人员所用，去解决明确定义了的可重复的问题。</p><p>(5) Coad的功用驱动开发方法(FDD-Feature Driven Development)FDD是由Jeff De Luca和大师Peter Coad提出来的。像其他方法一样，它致力于短时的迭代阶段和可见可用的功能。在FDD中，一个迭代周期一般是两周。</p><p>在FDD中，编程开发人员分成两类：首席程序员和&quot;类&quot;程序员(class owner)。首席程序员是最富有经验的开发人员，他们是项目的协调者、设计者和指导者，而&quot;类&quot;程序员则主要做源码编写。</p><p>(6) ASD方法，ASD (Adaptive Software Development)方法由Jim Highsmith提出，其核心是三个非线性的、重叠的开发阶段：猜测、合作与学习。</p>",
                    "like": 0,
                    "answer": [
                        "D"
                    ],
                    "option": [
                        " 自适应软件开发（ASD） ",
                        " 极限编程（XP）开发方法 ",
                        " 开放统-过程开发方法（OpenUP） ",
                        " 功用驱动开发方法（FDD） "
                    ]
                },
                {
                    "index": 77,
                    "belong_page": 1,
                    "question_id": 49927,
                    "question_title": "<p>在软件系统工具中，版本控制工具属于（ ）</p>",
                    "question_type": 1,
                    "answer_type": 1,
                    "show_type_name": null,
                    "new_parent_id": 49927,
                    "score_rule": "",
                    "material_text": null,
                    "sort_son": "0",
                    "analyze": "<p>软件系统工具的种类繁多，很难有统一的分类方法。通常可以按软件过程活动将软件工具分为软件开发工具、软件维护工具 、软件管理和软件支持工具。</p><p>软件开发工具：需求分析工具、设计工具、编码与排错工具。</p><p>软件维护工具：版本控制工具、文档分析工具、开发信息库工具、逆向工程工具、再工程工具。</p><p>软件管理和软件支持工具：项目管理工具、配置管理工具、软件评价工具、软件开发工具的评价和选择。</p>",
                    "like": 0,
                    "answer": [
                        "B"
                    ],
                    "option": [
                        " 软件开发工具 ",
                        " 软件维护工具 ",
                        " 编码与排错工具 ",
                        " 软件管理和软件支持工具 "
                    ]
                },
                {
                    "index": 78,
                    "belong_page": 1,
                    "question_id": 49928,
                    "question_title": "<p>在软件系统工具中，软件评价工具属于（ ）。</p>",
                    "question_type": 1,
                    "answer_type": 1,
                    "show_type_name": null,
                    "new_parent_id": 49928,
                    "score_rule": "",
                    "material_text": null,
                    "sort_son": "0",
                    "analyze": "<p>软件系统工具的种类繁多，很难有统一的分类方法。通常可以按软件过程活动将软件工具分为软件开发工具、软件维护工具 、软件管理和软件支持工具。</p><p>软件开发工具：需求分析工具、设计工具、编码与排错工具。</p><p>软件维护工具：版本控制工具、文档分析工具、开发信息库工具、逆向工程工具、再工程工具。</p><p>软件管理和软件支持工具：项目管理工具、配置管理工具、软件评价工具、软件开发工具的评价和选择。</p>",
                    "like": 0,
                    "answer": [
                        "D"
                    ],
                    "option": [
                        " 逆向工程工具 ",
                        " 开发信息库工具 ",
                        " 编码与排错工具 ",
                        " 软件管理和软件支持工具 "
                    ]
                },
                {
                    "index": 79,
                    "belong_page": 1,
                    "question_id": 49932,
                    "question_title": "<p>软件重用是指在两次或多次不同的软件开发过程中重复使用相同或相似软件元素的过程。软件元素包括（ &nbsp;）、测试用例和领域知识等。</p>",
                    "question_type": 1,
                    "answer_type": 1,
                    "show_type_name": null,
                    "new_parent_id": 49932,
                    "score_rule": "",
                    "material_text": null,
                    "sort_son": "0",
                    "analyze": "<p>软件重用是指在两次或多次不同的软件开发过程中重复使用相同或相似软件元素的过程。软件元素包括需求分析文档、设计过程、设计文档、程序代码、测试用例、领域知识等。</p>",
                    "like": 0,
                    "answer": [
                        "B"
                    ],
                    "option": [
                        " 项目范围定义、需求分析文档、设计文档 ",
                        " 需求分析文档、设计文档、程序代码 ",
                        " 设计文档、程序代码、界面原型 ",
                        " 程序代码、界面原型、数据表结构 "
                    ]
                },
                {
                    "index": 80,
                    "belong_page": 1,
                    "question_id": 49933,
                    "question_title": "<p>&nbsp;面向构件的编程(Component Oriented Programming，COP)关注于如何支持建立面向构件的解决方案。面向构件的编程所需要的基本支持包括（ &nbsp;）。</p>",
                    "question_type": 1,
                    "answer_type": 1,
                    "show_type_name": null,
                    "new_parent_id": 49933,
                    "score_rule": "",
                    "material_text": null,
                    "sort_son": "0",
                    "analyze": "<p>面向构件的编程（COP）关注于如何支持建立面向构件的解决方案。一个基于一般 OOP 风格的 COP 定义如下（Szyperski，1995）： &quot;面向构件的编程需要下列基本的支持：</p><p>--多态性（可替代性）；</p><p>--模块封装性（高层次信息的隐藏）；</p><p>--后期的绑定和装载（部署独立性）；</p><p>--安全性（类型和模块安全性）。&quot;</p>",
                    "like": 0,
                    "answer": [
                        "C"
                    ],
                    "option": [
                        " 继承性、构件管理和绑定、构件标识、访问控制 ",
                        " 封装性、信息隐藏、独立部署、模块安全性 ",
                        " 多态性、模块封装性、后期绑定和装载、安全性 ",
                        " 构件抽象、可替代性、类型安全性、事务管理 "
                    ]
                },
                {
                    "index": 81,
                    "belong_page": 1,
                    "question_id": 49943,
                    "question_title": "<p>DSSA是在一个特定应用领域中为一组应用提供组织结构参考的软件体系结构，参与DSSA的人员可以划分为4种角色，包括领域专家、领域设计人员、领域实现人员和（ &nbsp;请作答此空），其基本活动包括领域分析、领域设计和（ ）。</p>",
                    "question_type": 1,
                    "answer_type": 1,
                    "show_type_name": null,
                    "new_parent_id": 49943,
                    "score_rule": "",
                    "material_text": null,
                    "sort_son": "0",
                    "analyze": "<p>DSSA的基本活动包括：领域分析、领域设计、领域实现：</p><p>1、领域分析</p><p>这个阶段的主要目标是获得领城模型。领域模型描述领域中系统之间的共同的需求，即领域模型所描述的需求为领域需求。在这个阶段中首先要进行一些准备性的活动，包括定义领域的边界。从而明确分析的对象；识别信息源，整个领域工程过程中信息的来源，可能的信息源包括现存系统、技术文献、问题域和系统开发的专家、用户调查和市场分析、领域演化的历史记录等，在此基础上就可以分析领域中系统的需求，确定哪些需求是领域中的系统广泛共享的，从而建立领域模型。当领域中存在大量系统时，需要选择它们的一个子集作为样本系统。对样本系统需求的考察将显示领城需求的一个变化范围。一些需求对所有被考察的系统是共同的，一些需求是单个系统所独有的。很多需求位于这两个极端之间，即被部分系统共享。</p><p>2、领域设计</p><p>这个阶段的目标是获得DSSA。DSSA描述在领域模型中表示的需求的解决方案，它不是单个系统的表示，而是能够适应领域中多个系统的需求的一个高层次的设计。建立了领域模型之后，就可以派生出满足这些被建模的领域需求的DSSA，由于领域模型中的领域需求具有一定的变化性，DSSA也要相应地具有变化性。它可以通过表示多选一的(alternative)、可选的(optional)解决方案等来做到这一点。模型和DSSA来组织的，因此在这个阶段通过获得DSSA，也就同时形成了重用基础设施的规约。</p><p>3、领域实现</p><p>这个阶段的主要目标是依据领域模型和DSSA开发和组织可重用信息。这些可重用信息可能是从现有系统中提取得到，也可能需要通过新的开发得到。它们依据领域模型和DSSA进行组织，也就是领域模型和DSSA定义了这些可重用信息的重用时机，从而支持了系统化的软件重用。这个阶段也可以看作重用基础设施的实现阶段。</p><p>值得注意的是，以上过程是一个反复的、逐渐求精的过程。在实施领域工程的每个阶段中，都可能返回到以前的步骤，对以前的步骤得到的结果进行修改和完善，再回到当前步骤，在新的基础上进行本阶段的活动。</p><p>参与DSSA的人员可以划分为四种角色：领城专家、领城分析师、领域设计人员和领域实现人员。</p><p>1、领域专家</p><p>领域专家可能包括该领域中系统的有经验的用户、从事该领域中系统的需求分析、设计、实现以及项目管理的有经验的软件工程师等。领域专家的主要任务包括提供关于领域中系统的需求规约和实现的知识，帮助组织规范的、一致的领域字典，帮助选择样本系统作为领域工程的依据，复审领域模型、DSSA等领域工程产品等。</p><p>领域专家应该熟悉该领域中系统的软件设计和实现、硬件限制、未来的用户需求及技术走向等。</p><p>2、领域分析人员</p><p>领域分析人员应由具有知识工程背景的有经验的系统分析员来担任。领域分析人员的主要任务包括控制整个领域分析过程，进行知识获取，将获取的知识组织到领域模型中，根据现有系统、标准规范等验证领域模型的准确性和一致性，维护领域模型。</p><p>领域分析人员应熟悉软件重用和领域分析方法；熟悉进行知识获取和知识表示所需的技术、语言和工具；应具有一定的该领域的经验，以便于分析领域中的问题及与领域专家进行交互；应具有较高的进行抽象、关联和类比的能力；应具有较高的与他人交互和合作的能力。</p><p>3、领域设计人员</p><p>领域设计人员应由有经验的软件设计人员来担任。领域设计人员的主要任务包括控制核个软件设计过程，根据领域模型和现有的系统开发出DSSA，对DSSA的准确性和一致性进行验证，建立领域模型和DSSA之间的联系。</p><p>领域设计人员应熟悉软件重用和领域设计方法；熟悉软件设计方法；应有一定的该领域的经验，以便于分析领域中的问题及与领域专家进行交互。</p><p>4、领域实现人员</p><p>领域实现人员应由有经验的程序设计人员来担任。领域实现人员的主要任务包括根据领域模型和DSSA，或者从头开发可重用构件，或者利用再工程的技术从现有系统中提取可重用构件，对可重用构件进行验证，建立DSSA与可重用构件间的联系。</p><p>领域实现人员应熟悉软件重用、领域实现及软件再工程技术；熟悉程序设计；具有一定的该领域的经验。</p>",
                    "like": 0,
                    "answer": [
                        "C"
                    ],
                    "option": [
                        " 领域测试人员 ",
                        " 领域顾问 ",
                        " 领域分析师 ",
                        " 领域经理 "
                    ]
                },
                {
                    "index": 82,
                    "belong_page": 1,
                    "question_id": 50897,
                    "question_title": "<p>下列关于敏捷方法的叙述中，错误的是（）。</p>",
                    "question_type": 1,
                    "answer_type": 1,
                    "show_type_name": null,
                    "new_parent_id": 50897,
                    "score_rule": "",
                    "material_text": null,
                    "sort_son": "0",
                    "analyze": "<p>本题考查敏捷方法的相关概念。敏捷方法是从20世纪90年代开始逐渐引起广泛关注的一些新型软件开发方法，以应对快速变化的需求。敏捷方法的核心思想主要有以下三点。&nbsp;①敏捷方法是“适应性”而非“预设性”的。传统方法试图对一个软件开发项目在很长的时间跨度内做出详细的计划，然后依计划进行开发。这类方法在计划制定完成后拒绝变化。而敏捷方法则欢迎变化，其实它的目的就是成为适应变化的过程，甚至能允许改变自身来适应变化。&nbsp;②敏捷方法是以人为本，而不是以过程为本。传统方法以过程为本，强调充分发挥人的特性，不去限制它，并且软件开发在无过程控制和过于严格繁琐的过程控制中取得一种平衡，以保证软件的质量。③迭代增量式的开发过程。敏捷方法以原型开发思想为基础，采用迭代增量式开发，发行版本小型化。RUP相比，敏捷方法的周期可能更短。敏捷方法在几周或者几个月的时间内完成相对较小的功能，强调的是能尽早将尽量小的可用的功能交付使用，并在整个项目周期中持续改善和增强，并且更加强调团队中的高度写作。相对而言，敏捷方法主要适合于以下场合：①项目团队的人数不能太多，适合于规模较小的项目。②项目经常发生变更。敏捷方法适用于需求萌动并且快速改变的情况，如果系统有比较高的关键性、可靠性、安全性方面的要求，则可能不完全适合。③高风险项目的实施。④从组织结构的角度看，组织结构的文化、人员、沟通性决定了敏捷方法是否使用。</p>",
                    "like": 0,
                    "answer": [
                        "B"
                    ],
                    "option": [
                        " 与传统方法相比，敏捷方法比较适合需求变化大或者开发前期对需求不是很清晰的项目 ",
                        " 敏捷方法尤其适合于开发团队比较庞大的项目 ",
                        " 敏捷方法的思想是适应性，而不是预设性 ",
                        " 敏捷方法以原型开发思想为基础，采用迭代式增量开发 "
                    ]
                },
                {
                    "index": 83,
                    "belong_page": 1,
                    "question_id": 54206,
                    "question_title": "<p>甘特图（Gantt图）不能（ &nbsp;）。</p>",
                    "question_type": 1,
                    "answer_type": 1,
                    "show_type_name": null,
                    "new_parent_id": 54206,
                    "score_rule": "",
                    "material_text": null,
                    "sort_son": "0",
                    "analyze": "<p>甘特图是一种能清晰描述每个任务的开始和截止时间，能有效获得任务并行进行的信息的项目管理工具。</p>",
                    "like": 0,
                    "answer": [
                        "D"
                    ],
                    "option": [
                        " 作为项目进度管理的一个工具 ",
                        " 清晰地描述每个任务的开始和截止时间 ",
                        " 清晰地获得任务并行进行的信息 ",
                        " 清晰地获得各任务之间的依赖关系 "
                    ]
                },
                {
                    "index": 84,
                    "belong_page": 1,
                    "question_id": 54207,
                    "question_title": "<p>以下关于风险管理的叙述中，不正确的是（ &nbsp;）。</p>",
                    "question_type": 1,
                    "answer_type": 1,
                    "show_type_name": null,
                    "new_parent_id": 54207,
                    "score_rule": "",
                    "material_text": null,
                    "sort_son": "0",
                    "analyze": "<p>对风险排优先级是根据风险的曝光度来进行的，曝光度等于风险的产生后果乘以风险发生的概率。</p>",
                    "like": 0,
                    "answer": [
                        "A"
                    ],
                    "option": [
                        " 仅根据风险产生的后果来对风险排优先级 ",
                        " 可以通过改变系统性能或功能需求来避免某些风险 ",
                        " 不可能去除所有风险，但可以通过采取行动来降低或者减轻风险 ",
                        " 在项目开发过程中，需要定期地评估和管理风险 "
                    ]
                },
                {
                    "index": 85,
                    "belong_page": 1,
                    "question_id": 54208,
                    "question_title": "<p>某软件项目的活动图如下图所示，其中顶点表示项目里程碑，链接顶点的边表示包含的活动，边上的数字表示活动的持续时间（天）。完成该项目的最少时间为（请作答此空）天。由于某种原因，现在需要同一个开发人员完成BC和BD，则完成该项目的最少时间为（ &nbsp;）天。<br/><img style=\"max-width:100%;height:auto\"  title=\"1539328855211419.jpg\" alt=\"1.jpg\" src=\"https://s2.51cto.com//images/20181012/1539328855211419.jpg\"/></p>",
                    "question_type": 1,
                    "answer_type": 1,
                    "show_type_name": null,
                    "new_parent_id": 54208,
                    "score_rule": "",
                    "material_text": null,
                    "sort_son": "0",
                    "analyze": "<p>关键路径为ABCEFJ 和ABDGFJ ，18天。</p>",
                    "like": 0,
                    "answer": [
                        "B"
                    ],
                    "option": [
                        " 11 ",
                        " 18 ",
                        " 20 ",
                        " 21 "
                    ]
                },
                {
                    "index": 86,
                    "belong_page": 1,
                    "question_id": 54209,
                    "question_title": "<p>某软件项目的活动图如下图所示，其中顶点表示项目里程碑，链接顶点的边表示包含的活动，边上的数字表示活动的持续时间（天）。完成该项目的最少时间为（ ）天。由于某种原因，现在需要同一个开发人员完成BC和BD，则完成该项目的最少时间为（请作答此空）天。<br/><img style=\"max-width:100%;height:auto\"  title=\"1539328883301383.jpg\" alt=\"1.jpg\" src=\"https://s2.51cto.com//images/20181012/1539328883301383.jpg\"/></p>",
                    "question_type": 1,
                    "answer_type": 1,
                    "show_type_name": null,
                    "new_parent_id": 54209,
                    "score_rule": "",
                    "material_text": null,
                    "sort_son": "0",
                    "analyze": "<p>BC持续时间3天，BD持续时间2天，由一人完成，则可以把先完成BD，再完成BC，则BC持续时间作为5天，则关键路径为ABCEFJ， 20天。</p>",
                    "like": 0,
                    "answer": [
                        "C"
                    ],
                    "option": [
                        " 11 ",
                        " 18 ",
                        " 20 ",
                        " 21 "
                    ]
                },
                {
                    "index": 87,
                    "belong_page": 1,
                    "question_id": 54210,
                    "question_title": "<p>下列关于风险的叙述不正确的是：风险是指（ &nbsp;）。</p>",
                    "question_type": 1,
                    "answer_type": 1,
                    "show_type_name": null,
                    "new_parent_id": 54210,
                    "score_rule": "",
                    "material_text": null,
                    "sort_son": "0",
                    "analyze": "<p>本题主要我们对风险概念的理解。<br/>目前，对风险大致有两种定义：一种定义强调了风险表现为不确定性；而另一种定义则强调风险表现为损失的不确定性。其中广义的定义是：风险表现为损失的不确定性，说明风险产生的结果可能带来损失、获利或是无损失也无获利。<br/>从风险的定义我们不难看出，风险是可能发生的事件，而且是会带来损失的事件，人为对其干预，可能会减少损失。</p>",
                    "like": 0,
                    "answer": [
                        "B"
                    ],
                    "option": [
                        " 可能发生的事件 ",
                        " 一定会发生的事件 ",
                        " 会带来损失的事件 ",
                        " 可能对其进行干预，以减少损失的事件 "
                    ]
                },
                {
                    "index": 88,
                    "belong_page": 1,
                    "question_id": 54222,
                    "question_title": "<p>XP 是一种轻量级（敏捷）、高效、低风险、柔性、可预测的、科学的软件开发方式，其四大价值观包括沟通、简单、（ &nbsp;）。</p>",
                    "question_type": 1,
                    "answer_type": 1,
                    "show_type_name": null,
                    "new_parent_id": 54222,
                    "score_rule": "",
                    "material_text": null,
                    "sort_son": "0",
                    "analyze": "<p>本题考查软件过程基础知识。<br/>XP（极限编程）是一种轻量级（敏捷）、高效、低风险、柔性、可预测的、科学的软件开发方式。它由价值观、原则、实践和行为四个部分组成，彼此相互依赖、关联，并通过行为贯穿于整个生存周期。其四大价值观包括沟通、简单、反馈和勇气。</p>",
                    "like": 0,
                    "answer": [
                        "D"
                    ],
                    "option": [
                        " 隐喻和反馈 ",
                        " 重构和勇气 ",
                        " 隐喻和重构 ",
                        " 反馈和勇气 "
                    ]
                },
                {
                    "index": 89,
                    "belong_page": 1,
                    "question_id": 54225,
                    "question_title": "<p>软件开发商对软件产品进行持续不断改进的动力主要来自（ &nbsp;）。</p>",
                    "question_type": 1,
                    "answer_type": 1,
                    "show_type_name": null,
                    "new_parent_id": 54225,
                    "score_rule": "",
                    "material_text": null,
                    "sort_son": "0",
                    "analyze": "<p>本题考查软件工程方面的基础知识。<br/>软件是为用户设计的。胜任用户的任务，使用户满意是评价软件的最终目标。由于用户最初提出的软件需求一般比较模糊，刚交付的软件一般还隐藏着某些问题，所以需要对软件产品进行持续不断的改进。改进的动力主要来自用户使用过程中的反馈意见，包括，发现的质量问题，功能需要完善，操作需要简便，界面需要改进，需求也会有变化等。题中其他各项也是改进软件的原因，但分析研究用户反馈意见并改进软件是主要的动力。</p>",
                    "like": 0,
                    "answer": [
                        "A"
                    ],
                    "option": [
                        " 用户的反馈意见 ",
                        " 反盗版 ",
                        " 促销 ",
                        " 技术进步 "
                    ]
                },
                {
                    "index": 90,
                    "belong_page": 1,
                    "question_id": 54230,
                    "question_title": "<p>不同的对象收到同一消息可以产生完全不同的结果，这一现象叫做（请作答此空）。绑定是一个把过程调用和响应调用所需要执行的代码加以结合的过程。在一般的程序设计语言中，绑定在编译时进行，叫做（ &nbsp;）；而（ &nbsp;）则在运行时进行，即一个给定的过程调用和执行代码的结合直到调用发生时才进行。</p>",
                    "question_type": 1,
                    "answer_type": 1,
                    "show_type_name": null,
                    "new_parent_id": 54230,
                    "score_rule": "",
                    "material_text": null,
                    "sort_son": "0",
                    "analyze": "<p>本题考查面向对象中的基本概念。<br/>在收到消息时，对象要予以响应。不同的对象收到同一消息可以产生完全不同的结果，这一现象叫做多态（polymorphism）。在使用多态的时候，用户可以发送一个通用的消息，而实现的细节则由接收对象自行决定。这样，同一消息就可以调用不同的方法。绑定是一个把过程调用和响应调用所需要执行的代码加以结合的过程。在一般的程序设计语言中，绑定是在编译时进行的，叫做静态绑定。动态绑定则是在运行时进行的，因此，一个给定的过程调用和代码的结合直到调用发生时才进行。<br/>动态绑定是和类的继承以及多态相联系的。在继承关系中，子类是父类的一个特例，所以，父类对象可以出现的地方，子类对象也可以出现。因此在运行过程中，当一个对象发送消息请求服务时，要根据接收对象的具体情况将请求的操作与实现的方法进行连接，即动态绑定。</p>",
                    "like": 0,
                    "answer": [
                        "B"
                    ],
                    "option": [
                        " 继承 ",
                        " 多态 ",
                        " 动态绑定 ",
                        " 静态绑定 "
                    ]
                },
                {
                    "index": 91,
                    "belong_page": 1,
                    "question_id": 54231,
                    "question_title": "<p>不同的对象收到同一消息可以产生完全不同的结果，这一现象叫做（ ）。绑定是一个把过程调用和响应调用所需要执行的代码加以结合的过程。在一般的程序设计语言中，绑定在编译时进行，叫做（请作答此空）；而（ &nbsp;）则在运行时进行，即一个给定的过程调用和执行代码的结合直到调用发生时才进行。</p>",
                    "question_type": 1,
                    "answer_type": 1,
                    "show_type_name": null,
                    "new_parent_id": 54231,
                    "score_rule": "",
                    "material_text": null,
                    "sort_son": "0",
                    "analyze": "<p>本题考查面向对象中的基本概念。<br/>在收到消息时，对象要予以响应。不同的对象收到同一消息可以产生完全不同的结果，这一现象叫做多态（polymorphism）。在使用多态的时候，用户可以发送一个通用的消息，而实现的细节则由接收对象自行决定。这样，同一消息就可以调用不同的方法。绑定是一个把过程调用和响应调用所需要执行的代码加以结合的过程。在一般的程序设计语言中，绑定是在编译时进行的，叫做静态绑定。动态绑定则是在运行时进行的，因此，一个给定的过程调用和代码的结合直到调用发生时才进行。<br/>动态绑定是和类的继承以及多态相联系的。在继承关系中，子类是父类的一个特例，所以，父类对象可以出现的地方，子类对象也可以出现。因此在运行过程中，当一个对象发送消息请求服务时，要根据接收对象的具体情况将请求的操作与实现的方法进行连接，即动态绑定。</p>",
                    "like": 0,
                    "answer": [
                        "D"
                    ],
                    "option": [
                        " 继承 ",
                        " 多态 ",
                        " 动态绑定 ",
                        " 静态绑定 "
                    ]
                },
                {
                    "index": 92,
                    "belong_page": 1,
                    "question_id": 54232,
                    "question_title": "<p>不同的对象收到同一消息可以产生完全不同的结果，这一现象叫做（ ）。绑定是一个把过程调用和响应调用所需要执行的代码加以结合的过程。在一般的程序设计语言中，绑定在编译时进行，叫做（ ）；而（请作答此空）则在运行时进行，即一个给定的过程调用和执行代码的结合直到调用发生时才进行。</p>",
                    "question_type": 1,
                    "answer_type": 1,
                    "show_type_name": null,
                    "new_parent_id": 54232,
                    "score_rule": "",
                    "material_text": null,
                    "sort_son": "0",
                    "analyze": "<p>本题考查面向对象中的基本概念。<br/>在收到消息时，对象要予以响应。不同的对象收到同一消息可以产生完全不同的结果，这一现象叫做多态（polymorphism）。在使用多态的时候，用户可以发送一个通用的消息，而实现的细节则由接收对象自行决定。这样，同一消息就可以调用不同的方法。绑定是一个把过程调用和响应调用所需要执行的代码加以结合的过程。在一般的程序设计语言中，绑定是在编译时进行的，叫做静态绑定。动态绑定则是在运行时进行的，因此，一个给定的过程调用和代码的结合直到调用发生时才进行。<br/>动态绑定是和类的继承以及多态相联系的。在继承关系中，子类是父类的一个特例，所以，父类对象可以出现的地方，子类对象也可以出现。因此在运行过程中，当一个对象发送消息请求服务时，要根据接收对象的具体情况将请求的操作与实现的方法进行连接，即动态绑定。</p>",
                    "like": 0,
                    "answer": [
                        "C"
                    ],
                    "option": [
                        " 继承 ",
                        " 多态 ",
                        " 动态绑定 ",
                        " 静态绑定 "
                    ]
                },
                {
                    "index": 93,
                    "belong_page": 1,
                    "question_id": 54256,
                    "question_title": "<p>在软件开发项目中，关键路径是项目事件网络中（请作答此空） ，组成关键路径的活动称为关键活动。下图中的关键路径历时（ ）个时间单位。<br/><img style=\"max-width:100%;height:auto\"  src=\"http://s2.51cto.com/images/20181012/1539330277837422.jpg\" title=\"1539330277837422.jpg\" alt=\"1.jpg\"/></p>",
                    "question_type": 1,
                    "answer_type": 1,
                    "show_type_name": null,
                    "new_parent_id": 54256,
                    "score_rule": "",
                    "material_text": null,
                    "sort_son": "0",
                    "analyze": "<p>图论中给出了关键路径的定义，即源点到汇点的最长路径为关键路径。<br/>关键路径的识别与计算：<br/>通过观察法可得出关键路径为1-2-4-5-7-8-10，最长路径的历时为3+3+5+3+3+6=23。<br/><img style=\"max-width:100%;height:auto\"  src=\"http://s2.51cto.com/images/20181012/1539331083693659.jpg\" title=\"1539331083693659.jpg\" alt=\"1.jpg\"/></p>",
                    "like": 0,
                    "answer": [
                        "C"
                    ],
                    "option": [
                        " 最长的回路 ",
                        " 最短的回路 ",
                        " 源点和汇点间的最长路径 ",
                        " 源点和汇点间的最短路径 "
                    ]
                },
                {
                    "index": 94,
                    "belong_page": 1,
                    "question_id": 54257,
                    "question_title": "<p>在软件开发项目中，关键路径是项目事件网络中（ ） ，组成关键路径的活动称为关键活动。下图中的关键路径历时（请作答此空）个时间单位。<br/><img style=\"max-width:100%;height:auto\"  src=\"http://s2.51cto.com/images/20181012/1539330317865736.jpg\" title=\"1539330317865736.jpg\" alt=\"1.jpg\"/></p>",
                    "question_type": 1,
                    "answer_type": 1,
                    "show_type_name": null,
                    "new_parent_id": 54257,
                    "score_rule": "",
                    "material_text": null,
                    "sort_son": "0",
                    "analyze": "<p>图论中给出了关键路径的定义，即源点到汇点的最长路径为关键路径。<br/>关键路径的识别与计算：<br/>通过观察法可得出关键路径为1-2-4-5-7-8-10，最长路径的历时为3+3+5+3+3+6=23。<br/><img style=\"max-width:100%;height:auto\"  src=\"http://s2.51cto.com/images/20181012/1539330363535244.jpg\" title=\"1539330363535244.jpg\" alt=\"1.jpg\"/></p>",
                    "like": 0,
                    "answer": [
                        "C"
                    ],
                    "option": [
                        " 14 ",
                        " 18 ",
                        " 23 ",
                        " 25 "
                    ]
                },
                {
                    "index": 95,
                    "belong_page": 1,
                    "question_id": 54299,
                    "question_title": "<p>统一过程（UP）定义了初启阶段、精化阶段、构建阶段、移交阶段和产生阶段，每个阶段以达到某个里程碑时结束，其中 （ &nbsp;）的里程碑是生命周期架构。</p>",
                    "question_type": 1,
                    "answer_type": 1,
                    "show_type_name": null,
                    "new_parent_id": 54299,
                    "score_rule": "",
                    "material_text": null,
                    "sort_son": "0",
                    "analyze": "<p>本题考查软件开发过程的基础知识。<br/>统一过程（UP）定义了初启阶段、精化阶段、构建阶段、移交阶段和产生阶段，每个阶段达到某个里程碑时结束。其中初启阶段的里程碑是生命周期目标，精化阶段的里程碑是生命周期架构，构建阶段的里程碑是初始运作功能，移交阶段的里程碑是产品发布。</p>",
                    "like": 0,
                    "answer": [
                        "B"
                    ],
                    "option": [
                        " 初启阶段 ",
                        " 精化阶段 ",
                        " 构建阶段 ",
                        " 移交阶段 "
                    ]
                },
                {
                    "index": 96,
                    "belong_page": 1,
                    "question_id": 54300,
                    "question_title": "<p>某小型软件公司欲开发一个基于Web的考勤管理系统，客户对系统的基本功能、表现形式等要求并不明确，在这种情况下，采用 （ &nbsp;）比较合适。</p>",
                    "question_type": 1,
                    "answer_type": 1,
                    "show_type_name": null,
                    "new_parent_id": 54300,
                    "score_rule": "",
                    "material_text": null,
                    "sort_son": "0",
                    "analyze": "<p>是小型软件开发公司在面对客户需求模糊或者多变的情况下，采用极限编程的方法能够在更短的周期内，更早地提供具体、持续的反信息，实现轻量、高效、低风险的软件开发。</p>",
                    "like": 0,
                    "answer": [
                        "D"
                    ],
                    "option": [
                        " 瀑布模型 ",
                        " 螺旋模型 ",
                        " V模型 ",
                        " 原型化模型 "
                    ]
                },
                {
                    "index": 97,
                    "belong_page": 1,
                    "question_id": 54301,
                    "question_title": "<p>软件开发模型大体上可以分为三种类型：第一种是以完全确定软件需求为前提的（请作答此空）；第二种是在软件开发初始阶段只能提供基本需求时采用的 （ &nbsp;）；第三种是以形式化为基础的变换模型。</p>",
                    "question_type": 1,
                    "answer_type": 1,
                    "show_type_name": null,
                    "new_parent_id": 54301,
                    "score_rule": "",
                    "material_text": null,
                    "sort_son": "0",
                    "analyze": "<p>软件开发模型大体上可以分为三种类型。第一种是以软件需求完全确定为前提的瀑布模型；第二种是在软件开发初始阶段只能提供基本需求时采用的迭代式或渐进式模型，例如喷泉模型、螺旋模型、统一开发过程和敏捷方法等；第三种是以形式化为基础的变换模型。</p>",
                    "like": 0,
                    "answer": [
                        "B"
                    ],
                    "option": [
                        " 协同模型 ",
                        " 瀑布模型 ",
                        " 交互式模型 ",
                        " 迭代式模型 "
                    ]
                },
                {
                    "index": 98,
                    "belong_page": 1,
                    "question_id": 54303,
                    "question_title": "<p>软件开发模型大体上可以分为三种类型：第一种是以完全确定软件需求为前提的 （ ）；第二种是在软件开发初始阶段只能提供基本需求时采用的（请作答此空）；第三种是以形式化为基础的变换模型。</p>",
                    "question_type": 1,
                    "answer_type": 1,
                    "show_type_name": null,
                    "new_parent_id": 54303,
                    "score_rule": "",
                    "material_text": null,
                    "sort_son": "0",
                    "analyze": "<p>软件开发模型大体上可以分为三种类型。第一种是以软件需求完全确定为前提的瀑布模型；第二种是在软件开发初始阶段只能提供基本需求时采用的迭代式或渐进式模型，例如喷泉模型、螺旋模型、统一开发过程和敏捷方法等；第三种是以形式化为基础的变换模型。</p>",
                    "like": 0,
                    "answer": [
                        "D"
                    ],
                    "option": [
                        " 协同模型 ",
                        " 瀑布模型 ",
                        " 交互式模型 ",
                        " 迭代式模型 "
                    ]
                },
                {
                    "index": 99,
                    "belong_page": 1,
                    "question_id": 54304,
                    "question_title": "<p>螺旋模型将瀑布模型和（请作答此空）结合起来，强调项目的风险分析，特别适合大型复杂系统的开发过程。螺旋模型沿着螺线进行若干次迭代，依次经历了计划指定、风险分析、工程实施和（ &nbsp;）四个主要活动。</p>",
                    "question_type": 1,
                    "answer_type": 1,
                    "show_type_name": null,
                    "new_parent_id": 54304,
                    "score_rule": "",
                    "material_text": null,
                    "sort_son": "0",
                    "analyze": "<p>本题主要考查对软件开发模型中的螺旋模型的概念。1988年，Barry Boehm正式发表了软件系统开发的&quot;螺旋模型&quot;，它将瀑布模型和快速原型模型结合起来，强调了其他模型所忽视的风险分析，特别适合于大型复杂的系统。螺旋模型沿着螺线进行若干次迭代，图中的四个象限代表了以下活动：<br/>① 制定计划：确定软件目标，选定实施方案，弄清项目开发的限制条件；<br/>② 风险分析：分析评估所选方案，考虑如何识别和消除风险；<br/>③ 实施工程：实施软件开发和验证；<br/>④ 客户评估：评价开发工作，提出修正建议，制定下一步计划。<br/>螺旋模型由风险驱动，强调可选方案和约束条件从而支持软件的重用，有助于将软件质量作为特殊目标融入产品开发之中。但是，螺旋模型也有一定的限制条件，具体如下：<br/>① 螺旋模型强调风险分析，但要求许多客户接受和相信这种分析，并做出相关反应是不容易的，因此，这种模型往往适应于内部的大规模软件开发。<br/>② 如果执行风险分析将大大影响项目的利润，那么进行风险分析毫无意义，因此，螺旋模型只适合于大规模软件项目。<br/>③ 软件开发人员应该擅长寻找可能的风险，准确地分析风险，否则将会带来更大的风险。<br/>首先是确定一个阶段的目标，完成这些目标的选择方案及其约束条件，然后从风险角度分析方案的开发策略，努力排除各种潜在的风险，有时需要通过建造原型来完成。如果某些风险不能排除，该方案立即终止，否则启动下一个开发步骤。最后，评价该阶段的结果，并设计下一个阶段。</p>",
                    "like": 0,
                    "answer": [
                        "D"
                    ],
                    "option": [
                        " 喷泉模型 ",
                        " 增量模型 ",
                        " V模型 ",
                        " 快速原型模型 "
                    ]
                },
                {
                    "index": 100,
                    "belong_page": 1,
                    "question_id": 54305,
                    "question_title": "<p>螺旋模型将瀑布模型和（ ）结合起来，强调项目的风险分析，特别适合大型复杂系统的开发过程。螺旋模型沿着螺线进行若干次迭代，依次经历了计划指定、风险分析、工程实施和 （请作答此空）四个主要活动。</p>",
                    "question_type": 1,
                    "answer_type": 1,
                    "show_type_name": null,
                    "new_parent_id": 54305,
                    "score_rule": "",
                    "material_text": null,
                    "sort_son": "0",
                    "analyze": "<p>本题主要考查对软件开发模型中的螺旋模型的概念。1988年，Barry Boehm正式发表了软件系统开发的&quot;螺旋模型&quot;，它将瀑布模型和快速原型模型结合起来，强调了其他模型所忽视的风险分析，特别适合于大型复杂的系统。螺旋模型沿着螺线进行若干次迭代，图中的四个象限代表了以下活动：<br/>① 制定计划：确定软件目标，选定实施方案，弄清项目开发的限制条件；<br/>② 风险分析：分析评估所选方案，考虑如何识别和消除风险；<br/>③ 实施工程：实施软件开发和验证；<br/>④ 客户评估：评价开发工作，提出修正建议，制定下一步计划。<br/>螺旋模型由风险驱动，强调可选方案和约束条件从而支持软件的重用，有助于将软件质量作为特殊目标融入产品开发之中。但是，螺旋模型也有一定的限制条件，具体如下：<br/>① 螺旋模型强调风险分析，但要求许多客户接受和相信这种分析，并做出相关反应是不容易的，因此，这种模型往往适应于内部的大规模软件开发。<br/>② 如果执行风险分析将大大影响项目的利润，那么进行风险分析毫无意义，因此，螺旋模型只适合于大规模软件项目。<br/>③ 软件开发人员应该擅长寻找可能的风险，准确地分析风险，否则将会带来更大的风险。<br/>首先是确定一个阶段的目标，完成这些目标的选择方案及其约束条件，然后从风险角度分析方案的开发策略，努力排除各种潜在的风险，有时需要通过建造原型来完成。如果某些风险不能排除，该方案立即终止，否则启动下一个开发步骤。最后，评价该阶段的结果，并设计下一个阶段。</p>",
                    "like": 0,
                    "answer": [
                        "A"
                    ],
                    "option": [
                        " 客户评估 ",
                        " 客户使用 ",
                        " 工程交付 ",
                        " 软件测试 "
                    ]
                },
                {
                    "index": 101,
                    "belong_page": 1,
                    "question_id": 54313,
                    "question_title": "<p>某软件项目的活动图如下所示。图中顶点表示项目里程碑，连接顶点的边表示包含的活动，则里程碑（请作答此空 ）在关键路径上，活动FG的松弛时间为（ &nbsp;）。<br/><img style=\"max-width:100%;height:auto\"  src=\"https://s1.51ctocdn.cn//images/20181016/1539654166852440.png\" title=\"1539654166852440.png\" alt=\"QQ截图20181016094235.png\"/></p>",
                    "question_type": 1,
                    "answer_type": 1,
                    "show_type_name": null,
                    "new_parent_id": 54313,
                    "score_rule": "",
                    "material_text": null,
                    "sort_son": "0",
                    "analyze": "<p>关键路径是图中从起点到终点长度最长的那条路径，而关键路径的长度则是整个项目的工期。在本题中，路径START-D-F-H-FINISH的长度为48，是最长的一条路径，因此其是关键路径，因此D点是关键路径上的里程碑。<br/>要求活动的松弛时间，就要求出活动的最早开始时间和最晚开始时间，其最晚开始时间减去最早开始时间，就是活动的松弛时间。对于活动FG，其最早开始时间是10+8=18，而最晚开始时间48-7-3=38，因此该活动的松弛时间是20。</p>",
                    "like": 0,
                    "answer": [
                        "C"
                    ],
                    "option": [
                        " B ",
                        " C ",
                        " D ",
                        " I "
                    ]
                },
                {
                    "index": 102,
                    "belong_page": 1,
                    "question_id": 54315,
                    "question_title": "<p>&nbsp;</p><p><br/></p><p>某软件项目的活动图如下所示。图中顶点表示项目里程碑，连接顶点的边表示包含的活动，则里程碑（ ）在关键路径上，活动FG的松弛时间为（请作答此空）。</p><img style=\"max-width:100%;height:auto\"  title=\"1539334945335361.jpg\" alt=\"1.jpg\" src=\"https://s1.51ctocdn.cn//images/20181012/1539334945335361.jpg\"/>",
                    "question_type": 1,
                    "answer_type": 1,
                    "show_type_name": null,
                    "new_parent_id": 54315,
                    "score_rule": "",
                    "material_text": null,
                    "sort_son": "0",
                    "analyze": "<p>关键路径是图中从起点到终点长度最长的那条路径，而关键路径的长度则是整个项目的工期。在本题中，路径START-D-F-H-FINISH的长度为48，是最长的一条路径，因此其是关键路径，因此D点是关键路径上的里程碑。<br/>要求活动的松弛时间，就要求出活动的最早开始时间和最晚开始时间，其最晚开始时间减去最早开始时间，就是活动的松弛时间。对于活动FG，其最早开始时间是10+8=18，而最晚开始时间48-7-3=38，因此该活动的松弛时间是20。</p>",
                    "like": 0,
                    "answer": [
                        "B"
                    ],
                    "option": [
                        " 19 ",
                        " 20 ",
                        " 32 ",
                        " 24 "
                    ]
                },
                {
                    "index": 103,
                    "belong_page": 1,
                    "question_id": 62501,
                    "question_title": "<p>软件方法学是以软件开发方法为研究对象的学科。其中，（&nbsp;）是先对最高居次中的问题进行定义、设计、编程和测试，而将其中未解决的问题作为一个子任务放到下一层次中去解决。（请作答此空）是根据系统功能要求，从具体的器件、逻辑部件或者相似系统开始，通过对其进行相互连接、修改和扩大，构成所要求的系统。（）是建立在严格数学基础上的软件开发方法。</p><p><br/></p>",
                    "question_type": 1,
                    "answer_type": 1,
                    "show_type_name": null,
                    "new_parent_id": 62501,
                    "score_rule": "",
                    "material_text": null,
                    "sort_son": "0",
                    "analyze": "<p>软件方法学是软件开发全过程的指导原则与方法体系。其另一种含义是以软件方法为研究对象的学科。从开发风范上看，软件方法有自顶向下的开发方法、自底向上的开发方法。在实际软件开发中，大都是自顶向下与自底向上两种方法的结合，只不过是以何者为主而已。</p><p>&nbsp;自顶向下开发方法是先对最高居次中的问题进行定义、设计、编程和测试，而将其中未解决的问题作为一个子任务放到下一层次中去解决。</p><p>是根据系统功能要求，从具体的器件、逻辑部件或者相似系统开始，通过对其进行相互连接、修改和扩大，构成所要求的系统。</p>",
                    "like": 0,
                    "answer": [
                        "A"
                    ],
                    "option": [
                        " 自底向上开发方法 ",
                        " &nbsp;形式化开发方法 ",
                        " 非形式化开发方法 ",
                        " 原型开发方法 "
                    ]
                },
                {
                    "index": 104,
                    "belong_page": 1,
                    "question_id": 63612,
                    "question_title": "<p>系统工程利用计算机作为工具，对系统的结构、元素、（请作答此空）和反馈等进行分析，以达到最优（　）、最优设计、最优管理和最优控制的目的。霍尔（A.D. Hall）于1969年提出了系统方法的三维结构体系，通常称为霍尔三维结构，这是系统工程方法论的基础。霍尔三维结构以时间维、（　）维、知识维组成的立体结构概括性地表示出系统工程的各阶段、各步骤以及所涉及的知识范围。其中时间维是系统的工作进程，对于一个具体的工程项目，可以分为7个阶段，在（　）阶段会做出研制方案及生产计划。</p>",
                    "question_type": 1,
                    "answer_type": 1,
                    "show_type_name": null,
                    "new_parent_id": 63612,
                    "score_rule": "",
                    "material_text": null,
                    "sort_son": "0",
                    "analyze": "<p>系统工程在上个世纪中后期发展起来的一门新兴学科。它最早约产生于20世纪40年代的美国，时至今日，系统工程已经成为现代社会高速发展不可或缺的一部分。系统工程的诞生让自然科学和社会科学中有关的思想、理论和方法根据总体协调的需要联系起来，综合应用，并利用电现代子计算机，对系统的结构、要素、信息和反馈等进行分析，以达到最优规划、最优设计、最优管理和最优控制等目的。</p><p>霍尔三维结构是由逻辑维、时间维和知识维组成的立体空间结构。</p><p>1、逻辑维</p><p>运用系统工程方法解决某一大型工程项目时，一般可分为七个步骤：</p><p>（1）明确问题</p><p>（2）建立价值体系或评价体系</p><p>（3）系统分析</p><p>（4）系统综合</p><p>（5）系统方案的优化选择</p><p>（6）决策&quot;决策就是管理&quot;，&quot;决策就是决定&quot;，人类的决策管理活动面临着被决策系统的日益庞大和日益复杂。</p><p>（7）制定计划有了决策就要付诸实施，实施就要依靠严格的有效的计划。</p><p>2、时间维（工作进程）</p><p>对于一个具体的工作项目，从制定规划起一直到更新为止，全部过程可分为七个阶段：</p><p>（1）规划阶段。即调研、程序设计阶段，目的在于谋求活动的规划与战略；</p><p>（2）拟定方案。提出具体的计划方案。</p><p>（3）研制阶段。作出研制方案及生产计划。</p><p>（4）生产阶段。生产出系统的零部件及整个系统，并提出安装计划。</p><p>（5）安装阶段。将系统安装完毕，并完成系统的运行计划。</p><p>（6）运行阶段。系统按照预期的用途开展服务。</p><p>（7）更新阶段。即为了提高系统功能，取消旧系统而代之以新系统，或改进原有系统，使之更加有效地工作。</p><p>3、知识维（专业科学知识）</p><p>系统工程除了要求为完成上述各步骤、各阶段所需的某些共性知识外，还需要其他学科的知识和各种专业技术，霍尔把这些知识分为工程、医药、建筑、商业、法律、管理、社会科学和艺术等。各类系统工程，如军事系统工程、经济系统工程、信息系统工程等。都需要使用其它相应的专业基础知识。</p>",
                    "like": 0,
                    "answer": [
                        "D"
                    ],
                    "option": [
                        " 知识 ",
                        " 需求 ",
                        " 文档 ",
                        " 信息 "
                    ]
                },
                {
                    "index": 105,
                    "belong_page": 1,
                    "question_id": 63614,
                    "question_title": "<p>系统工程利用计算机作为工具，对系统的结构、元素、（　）和反馈等进行分析，以达到最优（请作答此空）、最优设计、最优管理和最优控制的目的。霍尔（A.D. Hall）于1969年提出了系统方法的三维结构体系，通常称为霍尔三维结构，这是系统工程方法论的基础。霍尔三维结构以时间维、（　）维、知识维组成的立体结构概括性地表示出系统工程的各阶段、各步骤以及所涉及的知识范围。其中时间维是系统的工作进程，对于一个具体的工程项目，可以分为7个阶段，在（　）阶段会做出研制方案及生产计划。</p>",
                    "question_type": 1,
                    "answer_type": 1,
                    "show_type_name": null,
                    "new_parent_id": 63614,
                    "score_rule": "",
                    "material_text": null,
                    "sort_son": "0",
                    "analyze": "<p>系统工程在上个世纪中后期发展起来的一门新兴学科。它最早约产生于20世纪40年代的美国，时至今日，系统工程已经成为现代社会高速发展不可或缺的一部分。系统工程的诞生让自然科学和社会科学中有关的思想、理论和方法根据总体协调的需要联系起来，综合应用，并利用电现代子计算机，对系统的结构、要素、信息和反馈等进行分析，以达到最优规划、最优设计、最优管理和最优控制等目的。</p><p>霍尔三维结构是由逻辑维、时间维和知识维组成的立体空间结构。</p><p>1、逻辑维</p><p>运用系统工程方法解决某一大型工程项目时，一般可分为七个步骤：</p><p>（1）明确问题</p><p>（2）建立价值体系或评价体系</p><p>（3）系统分析</p><p>（4）系统综合</p><p>（5）系统方案的优化选择</p><p>（6）决策&quot;决策就是管理&quot;，&quot;决策就是决定&quot;，人类的决策管理活动面临着被决策系统的日益庞大和日益复杂。</p><p>（7）制定计划有了决策就要付诸实施，实施就要依靠严格的有效的计划。</p><p>2、时间维（工作进程）</p><p>对于一个具体的工作项目，从制定规划起一直到更新为止，全部过程可分为七个阶段：</p><p>（1）规划阶段。即调研、程序设计阶段，目的在于谋求活动的规划与战略；</p><p>（2）拟定方案。提出具体的计划方案。</p><p>（3）研制阶段。作出研制方案及生产计划。</p><p>（4）生产阶段。生产出系统的零部件及整个系统，并提出安装计划。</p><p>（5）安装阶段。将系统安装完毕，并完成系统的运行计划。</p><p>（6）运行阶段。系统按照预期的用途开展服务。</p><p>（7）更新阶段。即为了提高系统功能，取消旧系统而代之以新系统，或改进原有系统，使之更加有效地工作。</p><p>3、知识维（专业科学知识）</p><p>系统工程除了要求为完成上述各步骤、各阶段所需的某些共性知识外，还需要其他学科的知识和各种专业技术，霍尔把这些知识分为工程、医药、建筑、商业、法律、管理、社会科学和艺术等。各类系统工程，如军事系统工程、经济系统工程、信息系统工程等。都需要使用其它相应的专业基础知识。</p>",
                    "like": 0,
                    "answer": [
                        "B"
                    ],
                    "option": [
                        " 战略 ",
                        " 规划 ",
                        " 实现 ",
                        " 处理 "
                    ]
                },
                {
                    "index": 106,
                    "belong_page": 1,
                    "question_id": 63616,
                    "question_title": "<p>系统工程利用计算机作为工具，对系统的结构、元素、（　）和反馈等进行分析，以达到最优（　）、最优设计、最优管理和最优控制的目的。霍尔（A.D. Hall）于1969年提出了系统方法的三维结构体系，通常称为霍尔三维结构，这是系统工程方法论的基础。霍尔三维结构以时间维、（请作答此空）维、知识维组成的立体结构概括性地表示出系统工程的各阶段、各步骤以及所涉及的知识范围。其中时间维是系统的工作进程，对于一个具体的工程项目，可以分为7个阶段，在（　）阶段会做出研制方案及生产计划。</p>",
                    "question_type": 1,
                    "answer_type": 1,
                    "show_type_name": null,
                    "new_parent_id": 63616,
                    "score_rule": "",
                    "material_text": null,
                    "sort_son": "0",
                    "analyze": "<p>系统工程在上个世纪中后期发展起来的一门新兴学科。它最早约产生于20世纪40年代的美国，时至今日，系统工程已经成为现代社会高速发展不可或缺的一部分。系统工程的诞生让自然科学和社会科学中有关的思想、理论和方法根据总体协调的需要联系起来，综合应用，并利用电现代子计算机，对系统的结构、要素、信息和反馈等进行分析，以达到最优规划、最优设计、最优管理和最优控制等目的。</p><p>霍尔三维结构是由逻辑维、时间维和知识维组成的立体空间结构。</p><p>1、逻辑维</p><p>运用系统工程方法解决某一大型工程项目时，一般可分为七个步骤：</p><p>（1）明确问题</p><p>（2）建立价值体系或评价体系</p><p>（3）系统分析</p><p>（4）系统综合</p><p>（5）系统方案的优化选择</p><p>（6）决策&quot;决策就是管理&quot;，&quot;决策就是决定&quot;，人类的决策管理活动面临着被决策系统的日益庞大和日益复杂。</p><p>（7）制定计划有了决策就要付诸实施，实施就要依靠严格的有效的计划。</p><p>2、时间维（工作进程）</p><p>对于一个具体的工作项目，从制定规划起一直到更新为止，全部过程可分为七个阶段：</p><p>（1）规划阶段。即调研、程序设计阶段，目的在于谋求活动的规划与战略；</p><p>（2）拟定方案。提出具体的计划方案。</p><p>（3）研制阶段。作出研制方案及生产计划。</p><p>（4）生产阶段。生产出系统的零部件及整个系统，并提出安装计划。</p><p>（5）安装阶段。将系统安装完毕，并完成系统的运行计划。</p><p>（6）运行阶段。系统按照预期的用途开展服务。</p><p>（7）更新阶段。即为了提高系统功能，取消旧系统而代之以新系统，或改进原有系统，使之更加有效地工作。</p><p>3、知识维（专业科学知识）</p><p>系统工程除了要求为完成上述各步骤、各阶段所需的某些共性知识外，还需要其他学科的知识和各种专业技术，霍尔把这些知识分为工程、医药、建筑、商业、法律、管理、社会科学和艺术等。各类系统工程，如军事系统工程、经济系统工程、信息系统工程等。都需要使用其它相应的专业基础知识。</p>",
                    "like": 0,
                    "answer": [
                        "D"
                    ],
                    "option": [
                        " 空间 ",
                        " 结构 ",
                        " 组织 ",
                        " 逻辑 "
                    ]
                },
                {
                    "index": 107,
                    "belong_page": 1,
                    "question_id": 63618,
                    "question_title": "<p>系统工程利用计算机作为工具，对系统的结构、元素、（　）和反馈等进行分析，以达到最优（　）、最优设计、最优管理和最优控制的目的。霍尔（A.D. Hall）于1969年提出了系统方法的三维结构体系，通常称为霍尔三维结构，这是系统工程方法论的基础。霍尔三维结构以时间维、（　）维、知识维组成的立体结构概括性地表示出系统工程的各阶段、各步骤以及所涉及的知识范围。其中时间维是系统的工作进程，对于一个具体的工程项目，可以分为7个阶段，在（请作答此空）阶段会做出研制方案及生产计划。</p>",
                    "question_type": 1,
                    "answer_type": 1,
                    "show_type_name": null,
                    "new_parent_id": 63618,
                    "score_rule": "",
                    "material_text": null,
                    "sort_son": "0",
                    "analyze": "<p>系统工程在上个世纪中后期发展起来的一门新兴学科。它最早约产生于20世纪40年代的美国，时至今日，系统工程已经成为现代社会高速发展不可或缺的一部分。系统工程的诞生让自然科学和社会科学中有关的思想、理论和方法根据总体协调的需要联系起来，综合应用，并利用电现代子计算机，对系统的结构、要素、信息和反馈等进行分析，以达到最优规划、最优设计、最优管理和最优控制等目的。</p><p>霍尔三维结构是由逻辑维、时间维和知识维组成的立体空间结构。</p><p>1、逻辑维</p><p>运用系统工程方法解决某一大型工程项目时，一般可分为七个步骤：</p><p>（1）明确问题</p><p>（2）建立价值体系或评价体系</p><p>（3）系统分析</p><p>（4）系统综合</p><p>（5）系统方案的优化选择</p><p>（6）决策&quot;决策就是管理&quot;，&quot;决策就是决定&quot;，人类的决策管理活动面临着被决策系统的日益庞大和日益复杂。</p><p>（7）制定计划有了决策就要付诸实施，实施就要依靠严格的有效的计划。</p><p>2、时间维（工作进程）</p><p>对于一个具体的工作项目，从制定规划起一直到更新为止，全部过程可分为七个阶段：</p><p>（1）规划阶段。即调研、程序设计阶段，目的在于谋求活动的规划与战略；</p><p>（2）拟定方案。提出具体的计划方案。</p><p>（3）研制阶段。作出研制方案及生产计划。</p><p>（4）生产阶段。生产出系统的零部件及整个系统，并提出安装计划。</p><p>（5）安装阶段。将系统安装完毕，并完成系统的运行计划。</p><p>（6）运行阶段。系统按照预期的用途开展服务。</p><p>（7）更新阶段。即为了提高系统功能，取消旧系统而代之以新系统，或改进原有系统，使之更加有效地工作。</p><p>3、知识维（专业科学知识）</p><p>系统工程除了要求为完成上述各步骤、各阶段所需的某些共性知识外，还需要其他学科的知识和各种专业技术，霍尔把这些知识分为工程、医药、建筑、商业、法律、管理、社会科学和艺术等。各类系统工程，如军事系统工程、经济系统工程、信息系统工程等。都需要使用其它相应的专业基础知识。</p>",
                    "like": 0,
                    "answer": [
                        "C"
                    ],
                    "option": [
                        " 规划 ",
                        " 拟定 ",
                        " 研制 ",
                        " 生产 "
                    ]
                },
                {
                    "index": 108,
                    "belong_page": 1,
                    "question_id": 63619,
                    "question_title": "<p>项目时间管理中的过程包括（　）。</p>",
                    "question_type": 1,
                    "answer_type": 1,
                    "show_type_name": null,
                    "new_parent_id": 63619,
                    "score_rule": "",
                    "material_text": null,
                    "sort_son": "0",
                    "analyze": "<p>时间管理的过程包括：</p><p>1、活动定义</p><p>2、活动排序</p><p>3、活动的资源估算</p><p>4、活动历时估算</p><p>5、制定计划</p><p>6、进度控制</p>",
                    "like": 0,
                    "answer": [
                        "B"
                    ],
                    "option": [
                        " 活动定义、活动排序、活动的资源估算和工作进度分解 ",
                        " 活动定义、活动排序、活动的资源估算、活动历时估算、制定计划和进度控制 ",
                        " 项目章程、项目范围管理计划、组织过程资产和批准的变更申请 ",
                        " 生产项目计划、项目可交付物说明、信息系统要求说明和项目度量标准 "
                    ]
                },
                {
                    "index": 109,
                    "belong_page": 1,
                    "question_id": 63622,
                    "question_title": "<p>需求管理是一个对系统需求变更、了解和控制的过程。以下活动中，（　）不属于需求管理的主要活动。</p>",
                    "question_type": 1,
                    "answer_type": 1,
                    "show_type_name": null,
                    "new_parent_id": 63622,
                    "score_rule": "",
                    "material_text": null,
                    "sort_son": "0",
                    "analyze": "<p>需求管理的活动包括：</p><p>1、变更控制</p><p>2、版本控制</p><p>3、需求跟踪</p><p>4、需求状态跟踪</p>",
                    "like": 0,
                    "answer": [
                        "A"
                    ],
                    "option": [
                        " 文档管理 ",
                        " 需求跟踪 ",
                        " 版本控制 ",
                        " 变更控制 "
                    ]
                },
                {
                    "index": 110,
                    "belong_page": 1,
                    "question_id": 63626,
                    "question_title": "<p>下面关于变更控制的描述中，（　）是不正确的。</p>",
                    "question_type": 1,
                    "answer_type": 1,
                    "show_type_name": null,
                    "new_parent_id": 63626,
                    "score_rule": "",
                    "material_text": null,
                    "sort_son": "0",
                    "analyze": "<p>变更控制委员会可以由一个小组担任，也可以由多个不同的组担任。变更控制委员会的成员应能代表变更涉及的团体。变更控制委员会可能包括如下方面的代表：</p><p>（1）产品或计划管理部门；</p><p>（2）项目管理部门；</p><p>（3）开发部门；</p><p>（4）测试或质量保证部门；</p><p>（5）市场部或客户代表；</p><p>（6）制作用户文档的部门；</p><p>（7）技术支持部门；</p><p>（8）帮助桌面或用户支持热线部门；</p><p>（9）配置管理部门。</p>",
                    "like": 0,
                    "answer": [
                        "A"
                    ],
                    "option": [
                        " 变更控制委员会只可以由一个小组担任 ",
                        " 控制需求变更与项目的其他配置管理决策有着密切的联系 ",
                        " 变更控制过程中可以使用相应的自动辅助工具 ",
                        " 变更的过程中，允许拒绝变更 "
                    ]
                },
                {
                    "index": 111,
                    "belong_page": 1,
                    "question_id": 63628,
                    "question_title": "<p>软件方法学是以软件开发方法为研究对象的学科。其中，&nbsp; &nbsp;( )&nbsp; &nbsp;是先对最高居次中的问题进行定义、设计、编程和测试，而将其中未解决的问题作为一个子任务放到下一层次中去解决。&nbsp; &nbsp;( )&nbsp; &nbsp;是根据系统功能要求，从具体的器件、逻辑部件或者相似系统开始，通过对其进行相互连接、修改和扩大，构成所要求的系统。 (请作答此空)&nbsp; &nbsp;是建立在严格数学基础上的软件开发方法。</p>",
                    "question_type": 1,
                    "answer_type": 1,
                    "show_type_name": null,
                    "new_parent_id": 63628,
                    "score_rule": "",
                    "material_text": null,
                    "sort_son": "0",
                    "analyze": "<p>软件方法学是软件开发全过程的指导原则与方法体系。其另一种含义是以软件方法为研究对象的学科。从开发风范上看，软件方法有自顶向下的开发方法、自底向上的开发方法。在实际软件开发中，大都是自顶向下与自底向上两种方法的结合，只不过是以何者为主而已。</p><p>&nbsp;自顶向下开发方法是先对最高居次中的问题进行定义、设计、编程和测试，而将其中未解决的问题作为一个子任务放到下一层次中去解决。</p><p>自底向上开发方法是根据系统功能要求，从具体的器件、逻辑部件或者相似系统开始，通过对其进行相互连接、修改和扩大，构成所要求的系统。<br/>形式化方法是一种具有坚实数学基础的方法，从而允许对系统和开发过程做严格处理和论证，适用于那些系统安全级别要求极高的软件的开发。第三空选择B选项。</p>",
                    "like": 0,
                    "answer": [
                        "B"
                    ],
                    "option": [
                        " 自底向上开发方法 ",
                        " 形式化开发方法 ",
                        " 非形式化开发方法 ",
                        " 自顶向下 "
                    ]
                },
                {
                    "index": 112,
                    "belong_page": 1,
                    "question_id": 63630,
                    "question_title": "<p>基于构件的软件开发中，构件分类方法可以归纳为三大类：（请作答此空）根据领域分析的结果将应用领域的概念按照从抽象到具体的顺序逐次分解为树形或有向无回路图结构；（ ）利用Facet描述构件执行的功能、被操作的数据、构件应用的语境或任意其他特征；（ ）使得检索者在阅读文档过程中可以按照人类的联想思维方式任意跳转到包含相关概念或构件的文档。</p>",
                    "question_type": 1,
                    "answer_type": 1,
                    "show_type_name": null,
                    "new_parent_id": 63630,
                    "score_rule": "",
                    "material_text": null,
                    "sort_son": "0",
                    "analyze": "<p>基于构件的软件开发中，已有的构建分类方法可以归纳为三大类∶</p><p>（1）关键字分类法。根据领域分析的结果将应用领域的概念按照从抽象到具体的顺序逐次分解为树形或有向无回路图结构。</p><p>（2）刻面分类法。利用 Facet（刻面）描述构件执行的功能、被操作的数据、构件应用的语境或任意其他特征。</p><p>（3）超文本方法。基于全文检索技术，使得检索者在阅读文档过程中可以按照人类的联想思维方式任意跳转到包含相关概念或构件的文档。</p>",
                    "like": 0,
                    "answer": [
                        "A"
                    ],
                    "option": [
                        " 关键字分类法 ",
                        " 刻面分类法 ",
                        " 语义匹配法 ",
                        " 超文本方法 "
                    ]
                },
                {
                    "index": 113,
                    "belong_page": 1,
                    "question_id": 63631,
                    "question_title": "<p>基于构件的软件开发中，构件分类方法可以归纳为三大类：（ ）根据领域分析的结果将应用领域的概念按照从抽象到具体的顺序逐次分解为树形或有向无回路图结构；（请作答此空）利用Facet描述构件执行的功能、被操作的数据、构件应用的语境或任意其他特征;&nbsp;（ ）使得检索者在阅读文档过程中可以按照人类的联想思维方式任意跳转到包含相关概念或构件的文档。</p>",
                    "question_type": 1,
                    "answer_type": 1,
                    "show_type_name": null,
                    "new_parent_id": 63631,
                    "score_rule": "",
                    "material_text": null,
                    "sort_son": "0",
                    "analyze": "<p>基于构件的软件开发中，已有的构建分类方法可以归纳为三大类∶</p><p>（1）关键字分类法。根据领域分析的结果将应用领域的概念按照从抽象到具体的顺序逐次分解为树形或有向无回路图结构。</p><p>（2）刻面分类法。利用 Facet（刻面）描述构件执行的功能、被操作的数据、构件应用的语境或任意其他特征。</p><p>（3）超文本方法。基于全文检索技术，使得检索者在阅读文档过程中可以按照人类的联想思维方式任意跳转到包含相关概念或构件的文档。</p>",
                    "like": 0,
                    "answer": [
                        "B"
                    ],
                    "option": [
                        " 关键字分类法 ",
                        " 刻面分类法 ",
                        " 语义匹配法 ",
                        " 超文本方法 "
                    ]
                },
                {
                    "index": 114,
                    "belong_page": 1,
                    "question_id": 63640,
                    "question_title": "<p>软件重用可以分为垂直式重用和水平式重用，（　）是一种典型的水平式重用。</p>",
                    "question_type": 1,
                    "answer_type": 1,
                    "show_type_name": null,
                    "new_parent_id": 63640,
                    "score_rule": "",
                    "material_text": null,
                    "sort_son": "0",
                    "analyze": "<p>软件重用分垂直式重用与水平式重用，垂直式重用是指局限于某一垂直领域的重用，如只在电力系统中用到的构件；而水平式重用是指通用领域的重用，如标准函数库，任何软件都能用，所以是水平式重用。</p>",
                    "like": 0,
                    "answer": [
                        "B"
                    ],
                    "option": [
                        " 医学词汇表 ",
                        " 标准函数库 ",
                        " 电子商务标准 ",
                        " 网银支付接口 "
                    ]
                },
                {
                    "index": 115,
                    "belong_page": 1,
                    "question_id": 63689,
                    "question_title": "<p><br/></p><p>某企业准备将四个工人甲、乙、丙、丁分配在A、B、C、D四个岗位。每个工人由于技术水平不同，在不同岗位上每天完成任务所需的工时见下表。适当安排岗位，可使四个工人以最短的总工时（　）全部完成每天的任务。</p><br/><img style=\"max-width:100%;height:auto\"  src=\"http://s2.51cto.com/images/20181127/1543311899691784.jpg\" title=\"1543311899691784.jpg\" alt=\"1.jpg\"/>",
                    "question_type": 1,
                    "answer_type": 1,
                    "show_type_name": null,
                    "new_parent_id": 63689,
                    "score_rule": "",
                    "material_text": null,
                    "sort_son": "0",
                    "analyze": "<p>经分析，表中处于左下到右上对角线的位置，四值相加最少，即4+4+3+3=14</p>",
                    "like": 0,
                    "answer": [
                        "B"
                    ],
                    "option": [
                        " 13 ",
                        " 14 ",
                        " 15 ",
                        " 16 "
                    ]
                },
                {
                    "index": 116,
                    "belong_page": 1,
                    "question_id": 86607,
                    "question_title": "<p>基于构件的软件开发中，构件分类方法可以归纳为三大类：（）根据领域分析的结果将应用领域的概念按照从抽象到具体的顺序逐次分解为树形或有向无回路图结构；（）利用Facet描述构件执行的功能、被操作的数据、构件应用的语境或任意其他特征;&nbsp;（回答此空）使得检索者在阅读文档过程中可以按照人类的联想思维方式任意跳转到包含相关概念或构件的文档。</p>",
                    "question_type": 1,
                    "answer_type": 1,
                    "show_type_name": null,
                    "new_parent_id": 86607,
                    "score_rule": "",
                    "material_text": null,
                    "sort_son": "0",
                    "analyze": "<p>基于构件的软件开发中，已有的构建分类方法可以归纳为三大类∶</p><p>（1）关键字分类法。根据领域分析的结果将应用领域的概念按照从抽象到具体的顺序逐次分解为树形或有向无回路图结构。</p><p>（2）刻面分类法。利用 Facet（刻面）描述构件执行的功能、被操作的数据、构件应用的语境或任意其他特征。</p><p>（3）超文本方法。基于全文检索技术，使得检索者在阅读文档过程中可以按照人类的联想思维方式任意跳转到包含相关概念或构件的文档。</p>",
                    "like": 0,
                    "answer": [
                        "D"
                    ],
                    "option": [
                        " 关键字分类法 ",
                        " 刻面分类法 ",
                        " 语义匹配法 ",
                        " 超文本方法 "
                    ]
                },
                {
                    "index": 117,
                    "belong_page": 1,
                    "question_id": 88858,
                    "question_title": "<p>螺旋模型将整个软件开发过程分为多个阶段，每个阶段都由目标设定、（）、开发和有效性验证以及评审4个部分组成。</p>",
                    "question_type": 1,
                    "answer_type": 1,
                    "show_type_name": null,
                    "new_parent_id": 88858,
                    "score_rule": "",
                    "material_text": null,
                    "sort_son": "0",
                    "analyze": "<p>螺旋模型是在快速原型的基础上扩展而成的一种生存周期模型。这种模型将整个软件开发流程分成多个阶段，每个阶段都由4部分组成，它们是：</p><p>①目标设定。为该项目进行需求分析，定义和确定这一个阶段的专门目标，指定对过程和产品的约束，并且制定详细的管理计划。</p><p>②风险分析。对可选方案进行风险识别和详细分析，制定解决办法，采取有效的措施避免这些风险。</p><p>③开发和有效性验证。风险评估后，可以为系统选择开发模型，并且进行原型开发，即开发软件产品。</p><p>④评审。对项目进行评审，以确定是否需要进入螺旋线的下一次回路，如果决定继续，就要制定下一阶段计划。</p><p>螺旋模型的软件开发过程实际是上述4个部分的迭代过程，每迭代一次，螺旋线就增加一周，软件系统就生成一个新版本，这个新版本实际上是对目标系统的一个逼近。经过若干次的迭代后，系统应该尽快地收敛到用户允许或可以接受的目标范围内，否则也可能中途夭折。</p>",
                    "like": 0,
                    "answer": [
                        "B"
                    ],
                    "option": [
                        " 需求分析 ",
                        " 风险分析 ",
                        " 系统设计 ",
                        " 架构设计 "
                    ]
                },
                {
                    "index": 118,
                    "belong_page": 1,
                    "question_id": 88859,
                    "question_title": "<p>( 回答此空 )的开发过程一般是先把系统功能视作一个大的模块,再根据系统分析与设计的要求对其进行进一步的模块分解或组含。(&nbsp;&nbsp;)使用了建模的思想,讨论如何建立一个实际的应用模型,包括对象模型、动态模型和功能模型,其功能模型主要用(&nbsp;&nbsp;)实现。</p>",
                    "question_type": 1,
                    "answer_type": 1,
                    "show_type_name": null,
                    "new_parent_id": 88859,
                    "score_rule": "",
                    "material_text": null,
                    "sort_son": "0",
                    "analyze": "<p>结构化方法的开发过程一般是先把系统功能视为一个大的模块，再根据系统分析与设计的要求对其进行进一步的模块分解或组合。</p><p>OMT方法使用了建模的思想，讨论如何建立一个实际的应用模型，包括对象模型、动态模型和功能模型。对象模型描述系统中对象的静态结构、对象之间的关系、属性和操作，主要用对象图来实现；动态模型描述与时间和操作顺序有关的系统特征，例如，激发事件、事件序列、确定事件先后关系的状态等，主要用状态图来实现动态模型；功能模型描述一个计算如何从输入值得到输出值，它不考虑计算的次序，主要用DFD来实现功能模型。</p>",
                    "like": 0,
                    "answer": [
                        "C"
                    ],
                    "option": [
                        " 面向对象方法 ",
                        " OMT方法 ",
                        " 结构化方法 ",
                        " Booch方法 "
                    ]
                },
                {
                    "index": 119,
                    "belong_page": 1,
                    "question_id": 88860,
                    "question_title": "<p>（ ）的开发过程一般是先把系统功能视作一个大的模块，再根据系统分析与设计的要求对其进行进一步的模块分解或组含。（请作答此空）使用了建模的思想，讨论如何建立一个实际的应用模型，包括对象模型、动态模型和功能模型，其功能模型主要用（ ）实现。</p>",
                    "question_type": 1,
                    "answer_type": 1,
                    "show_type_name": null,
                    "new_parent_id": 88860,
                    "score_rule": "",
                    "material_text": null,
                    "sort_son": "0",
                    "analyze": "<p>结构化方法的开发过程一般是先把系统功能视为一个大的模块，再根据系统分析与设计的要求对其进行进一步的模块分解或组合。</p><p>OMT方法使用了建模的思想，讨论如何建立一个实际的应用模型，包括对象模型、动态模型和功能模型。对象模型描述系统中对象的静态结构、对象之间的关系、属性和操作，主要用对象图来实现；动态模型描述与时间和操作顺序有关的系统特征，例如，激发事件、事件序列、确定事件先后关系的状态等，主要用状态图来实现动态模型；功能模型描述一个计算如何从输入值得到输出值，它不考虑计算的次序，主要用DFD来实现功能模型。</p>",
                    "like": 0,
                    "answer": [
                        "B"
                    ],
                    "option": [
                        " 面向对象方法 ",
                        " OMT方法 ",
                        " 结构化方法 ",
                        " Booch方法 "
                    ]
                },
                {
                    "index": 120,
                    "belong_page": 1,
                    "question_id": 88861,
                    "question_title": "<p>(&nbsp; )的开发过程一般是先把系统功能视作一个大的模块,再根据系统分析与设计的要求对其进行进一步的模块分解或组含。(&nbsp; )使用了建模的思想,讨论如何建立一个实际的应用模型,包括对象模型、动态模型和功能模型,其功能模型主要用(&nbsp;回答此空&nbsp;)实现。</p>",
                    "question_type": 1,
                    "answer_type": 1,
                    "show_type_name": null,
                    "new_parent_id": 88861,
                    "score_rule": "",
                    "material_text": null,
                    "sort_son": "0",
                    "analyze": "<p>结构化方法的开发过程一般是先把系统功能视为一个大的模块，再根据系统分析与设计的要求对其进行进一步的模块分解或组合。</p><p>OMT方法使用了建模的思想，讨论如何建立一个实际的应用模型，包括对象模型、动态模型和功能模型。对象模型描述系统中对象的静态结构、对象之间的关系、属性和操作，主要用对象图来实现；动态模型描述与时间和操作顺序有关的系统特征，例如，激发事件、事件序列、确定事件先后关系的状态等，主要用状态图来实现动态模型；功能模型描述一个计算如何从输入值得到输出值，它不考虑计算的次序，主要用DFD来实现功能模型。</p>",
                    "like": 0,
                    "answer": [
                        "B"
                    ],
                    "option": [
                        " 状态图  <br/> ",
                        " DFD ",
                        " 类图 ",
                        " 流程图 "
                    ]
                },
                {
                    "index": 121,
                    "belong_page": 1,
                    "question_id": 151192,
                    "question_title": "项目时间管理中的过程包括（ &nbsp;）。",
                    "question_type": 1,
                    "answer_type": 1,
                    "show_type_name": null,
                    "new_parent_id": 151192,
                    "score_rule": "",
                    "material_text": null,
                    "sort_son": "0",
                    "analyze": "<p>时间管理的过程包括：</p><p>⑦活动定义</p><p>⑧活动排序</p><p>⑨活动的资源估算</p><p>⑩活动历时估算</p><p>制定计划</p><p>进度控制</p>",
                    "like": 0,
                    "answer": [
                        "B"
                    ],
                    "option": [
                        " 活动定义、活动排序、活动的资源估算和工作进度分解 ",
                        " 活动定义、活动排序、活动的资源估算、活动历时估算、制定计划和进度控制 ",
                        " 项目章程、项目范围管理计划、组织过程资产和批准的变更申请 ",
                        " 生产项目计划、项目可交付物说明、信息系统要求说明和项目度量标准 "
                    ]
                },
                {
                    "index": 122,
                    "belong_page": 1,
                    "question_id": 208418,
                    "question_title": "以下关于软件生存周期模型的叙述，正确的是（ ）。",
                    "question_type": 1,
                    "answer_type": 1,
                    "show_type_name": "单选题",
                    "new_parent_id": 208418,
                    "score_rule": "",
                    "material_text": "",
                    "sort_son": "0",
                    "analyze": "<p>软件产品从形成概念开始，经过开发、使用和维护，直到最后退役的全过程成为软件生存周期。一个完整的软件生存周期是以需求为出发点，从提出软件开发计划的那一刻开始，直到软件在实际应用中完全报废为止。软件生存周期的提出了是为了更好地管理、维护和升级软件，其中更大的意义在于管理软件开发的步骤和方法。</p><p>软件生存周期模型又称软件开发模型(software develop model)或软件过程模型(software process model)，它是从某个特定角度提出的软件过程的简化描述。软件生存周期模型主要有瀑布模型、演化模型、原型模型、螺旋模型喷泉模型和基于可重用构件的模型等。</p><p>瀑布模型是最早使用的软件生存周期模型之一。瀑布模型的特点是因果关系紧密相连，前一个阶段工作的结果是后一个阶段工作的输入。或者说，每一个阶段都是建立在前一个阶段的正确结果之上，前一个阶段的错误和疏漏会隐蔽地带入后一个阶段。这种错误有时甚至可能是灾难性的，因此每一个阶段工作完成后，都要进行审查和确认。</p><p>演化模型主要针对事先不能完整定义需求的软件开发，是在快速开发一个原型的基础上，根据用户在调用原型的过程中提出的反馈意见和建议，对原型进行改进，获得原型的新版本，重复这一过程，直到演化成最终的软件产品。演化模型的主要优点是，任何功能一经开发就能进入测试，以便验证是否符合产品需求，可以帮助引导出高质量的产品要求。其主要缺点是，如果不控制地让用户接触开发中尚未稳定的功能，可能对开发人员及用户都会产生负面的影响。</p>",
                    "like": 0,
                    "answer": [
                        "A"
                    ],
                    "option": [
                        " 在瀑布模型中，前一个阶段的错误和疏漏会隐蔽地带到后一个阶段 ",
                        " 在任何情况下使用演化模型，都能在一定周期内由原型演化到最终产品 ",
                        " 软件生存周期模型的主要目标是为了加快软件开发的速度 ",
                        " 当一个软件系统的生存周期结束之后，它就进入到一个新的生存周期模型 "
                    ]
                },
                {
                    "index": 123,
                    "belong_page": 1,
                    "question_id": 208419,
                    "question_title": "螺旋模型将整个软件开发过程分为多个阶段，每个阶段都由目标设定、（ ）、开发和有效性验证以及评审4个部分组成。",
                    "question_type": 1,
                    "answer_type": 1,
                    "show_type_name": "单选题",
                    "new_parent_id": 208419,
                    "score_rule": "",
                    "material_text": "",
                    "sort_son": "0",
                    "analyze": "<p>螺旋模型是在快速原型的基础上扩展而成的一种生存周期模型。这种模型将整个软件开发流程分成多个阶段，每个阶段都由4部分组成，它们是：</p><p>①目标设定。为该项目进行需求分析，定义和确定这一个阶段的专门目标，指定对过程和产品的约束，并且制定详细的管理计划。</p><p>②风险分析。对可选方案进行风险识别和详细分析，制定解决办法，采取有效的措施避免这些风险。</p><p>③开发和有效性验证。风险评估后，可以为系统选择开发模型，并且进行原型开发，即开发软件产品。</p><p>④评审。对项目进行评审，以确定是否需要进入螺旋线的下一次回路，如果决定继续，就要制定下一阶段计划。</p><p>螺旋模型的软件开发过程实际是上述4个部分的迭代过程，每迭代一次，螺旋线就增加一周，软件系统就生成一个新版本，这个新版本实际上是对目标系统的一个逼近。经过若干次的迭代后，系统应该尽快地收敛到用户允许或可以接受的目标范围内，否则也可能中途夭折。</p>",
                    "like": 0,
                    "answer": [
                        "B"
                    ],
                    "option": [
                        " 需求分析 ",
                        " 风险分析 ",
                        " 系统设计 ",
                        " 架构设计 "
                    ]
                },
                {
                    "index": 124,
                    "belong_page": 1,
                    "question_id": 208422,
                    "question_title": "快速应用开发(Rapid Application development，RAD)通过使用基于（请作答此空）的开发方法获得快速开发。当（ ）时，最适合于采用RAD方法。",
                    "question_type": 1,
                    "answer_type": 1,
                    "show_type_name": "单选题",
                    "new_parent_id": 208422,
                    "score_rule": "",
                    "material_text": "",
                    "sort_son": "0",
                    "analyze": "<p>快速应用开发(Rapid Application Development，RAD)是一种比传统生存周期法快得多的开发方法，它强调极短的开发周期。RAD模型是瀑布模型的一个高速变种，通过使用基于构件的开发方法获得快速开发。如果需求理解得很好，且约束了项目范围，利用这种模型可以很快地开发出功能完善的信息系统。但是RAD也具有以下局限性：</p><p>①并非所有应用都适合RAD。RAD对模块化要求比较高，如果有哪一项功能不能被模块化，那么RAD所需要的构建就会有问题；如果高性能是一个指标，且该指标必须通过调整接口使其适应系统构件才能获得，则RAD也有可能不能奏效。</p><p>②开发者和客户必须在很短的时间完成一系列的需求分析，任何一方配合不当，都会导致RAD项目失败。</p><p>③RAD只能用于管理信息系统的开发，不适合技术风险很高的情况。例如，当一个新系统要采用很多新技术，或当新系统与现有系统有较高的互操作性时，就不适合使用RAD。</p>",
                    "like": 0,
                    "answer": [
                        "D"
                    ],
                    "option": [
                        " 用例 ",
                        " 数据结构 ",
                        " 剧情 ",
                        " 构件 "
                    ]
                },
                {
                    "index": 125,
                    "belong_page": 1,
                    "question_id": 208423,
                    "question_title": "快速应用开发(Rapid Application development，RAD)通过使用基于（ ）的开发方法获得快速开发。当（请作答此空）时，最适合于采用RAD方法。",
                    "question_type": 1,
                    "answer_type": 1,
                    "show_type_name": "单选题",
                    "new_parent_id": 208423,
                    "score_rule": "",
                    "material_text": "",
                    "sort_son": "0",
                    "analyze": "<p>快速应用开发(Rapid Application Development，RAD)是一种比传统生存周期法快得多的开发方法，它强调极短的开发周期。RAD模型是瀑布模型的一个高速变种，通过使用基于构件的开发方法获得快速开发。如果需求理解得很好，且约束了项目范围，利用这种模型可以很快地开发出功能完善的信息系统。但是RAD也具有以下局限性：</p><p>①并非所有应用都适合RAD。RAD对模块化要求比较高，如果有哪一项功能不能被模块化，那么RAD所需要的构建就会有问题；如果高性能是一个指标，且该指标必须通过调整接口使其适应系统构件才能获得，则RAD也有可能不能奏效。</p><p>②开发者和客户必须在很短的时间完成一系列的需求分析，任何一方配合不当，都会导致RAD项目失败。</p><p>③RAD只能用于管理信息系统的开发，不适合技术风险很高的情况。例如，当一个新系统要采用很多新技术，或当新系统与现有系统有较高的互操作性时，就不适合使用RAD。</p>",
                    "like": 0,
                    "answer": [
                        "C"
                    ],
                    "option": [
                        " 一个新系统要采用很多新技术 ",
                        " 系统与现有系统有较高的互操作性 ",
                        " 系统模块化程度较高 ",
                        " 用户不能很好地参与到需求分析中 "
                    ]
                },
                {
                    "index": 126,
                    "belong_page": 1,
                    "question_id": 208424,
                    "question_title": "以下关于软件开发方法的叙述，错误的是（ ）。",
                    "question_type": 1,
                    "answer_type": 1,
                    "show_type_name": "单选题",
                    "new_parent_id": 208424,
                    "score_rule": "",
                    "material_text": "",
                    "sort_son": "0",
                    "analyze": "<p>软件开发方法是指软件开发过程所遵循的办法和步骤，从不同的角度可以对软件开发方法进行不同的分类。</p><p>形式化方法是一种具有坚实数学基础的方法，从而允许对系统和开发过程做严格处理和论证，适用于那些系统安全级别要求极高的软件的开发。形式化方法的主要优越性在于它能够数学地表述和研究应用问题及软件实现。但是它要求开发人员具备良好的数学基础。用形式化语言书写的大型应用问题的软件规格说明往往过于细节化，并且难于为用户和软件设计人员所理解。由于这些缺陷，形式化方法在目前的软件开发实践中并未得到普遍应用。</p><p>净室软件工程(Cleanroom Software Engineering，CSE)是软件开发的一种形式化方法，可以开发较高质量的软件。它使用盒结构规约进行分析和建模，并且将正确性验证作为发现和排除错误的主要机制，使用统计测试来获取认证软件可靠性所需要的信息。CSE强调在规约和设计上的严格性，还强调统计质量控制技术，包括基于客户对软件的预期使用测试。</p>",
                    "like": 0,
                    "answer": [
                        "A"
                    ],
                    "option": [
                        " 对于较为复杂的应用问题，适合采用形式化方法进行需求分析 ",
                        " 形式化方法的优势在于能够精确地表述和研究应用问题及其软件实现 ",
                        " 净室软件工程将正确性验证作为发现和排除错误的主要机制 ",
                        " 净室软件工程强调统计质量控制技术，包括对客户软件使用预期的测试 "
                    ]
                },
                {
                    "index": 127,
                    "belong_page": 1,
                    "question_id": 208425,
                    "question_title": "软件开发环境应支持多种集成机制。根据功能不同，可以将集成机制分为三个部分：（请作答此空 ），用以存储与系统开发有关的信息，并支持信息的交流与共享；（ ），是实现过程集成和控制集成的基础；（ ），它的统一性和一致性是软件开发环境的重要特征。",
                    "question_type": 1,
                    "answer_type": 1,
                    "show_type_name": "单选题",
                    "new_parent_id": 208425,
                    "score_rule": "",
                    "material_text": "",
                    "sort_son": "0",
                    "analyze": "<p>软件开发环境(Software Development Environment，SDE)是指支持软件的工程化开发和维护而使用的一组软件，由软件工具集和环境集成机制构成。</p><p>软件开发环境应支持多种集成机制，根据功能的不同，集成机制可以划分为环境信息库、过程控制与消息服务器、环境用户界面三个部分。</p><p>①环境信息库。环境信息库是软件开发环境的核心，用以存储与系统开发有关的信息，并支持信息的交流与共享。环境信息库中主要存储两类信息，一类是开发过程中产生的有关被开发系统的信息，例如分析文档、设计文档和测试报告等；另一类是环境提供的支持信息，如文档模板、系统配置、过程模型和可复用构件等。</p><p>②过程控制与消息服务器。过程控制与消息服务器是实现过程集成和控制集成的基础。过程集成时按照具体软件开发过程的要求进行工具的选择与组合，控制集成使各工具之间进行并行通信和协同工作。</p><p>③环境用户界面。环境用户界面包括环境总界面和由它实行统一控制的各环境部件及工具的界面。统一的、具有一致性的用户界面是软件开发环境的重要特征，是充分发挥环境的优越性、高效地使用工具并减轻用户的学习负担的保证。</p>",
                    "like": 0,
                    "answer": [
                        "B"
                    ],
                    "option": [
                        " 算法模型库 ",
                        " 环境信息库 ",
                        " 信息模型库 ",
                        " 用户界面库 "
                    ]
                },
                {
                    "index": 128,
                    "belong_page": 1,
                    "question_id": 208426,
                    "question_title": "软件开发环境应支持多种集成机制。根据功能不同，可以将集成机制分为三个部分：（ ），用以存储与系统开发有关的信息，并支持信息的交流与共享；（请作答此空），是实现过程集成和控制集成的基础；（ ），它的统一性和一致性是软件开发环境的重要特征。",
                    "question_type": 1,
                    "answer_type": 1,
                    "show_type_name": "单选题",
                    "new_parent_id": 208426,
                    "score_rule": "",
                    "material_text": "",
                    "sort_son": "0",
                    "analyze": "<p>软件开发环境(Software Development Environment，SDE)是指支持软件的工程化开发和维护而使用的一组软件，由软件工具集和环境集成机制构成。</p><p>软件开发环境应支持多种集成机制，根据功能的不同，集成机制可以划分为环境信息库、过程控制与消息服务器、环境用户界面三个部分。</p><p>①环境信息库。环境信息库是软件开发环境的核心，用以存储与系统开发有关的信息，并支持信息的交流与共享。环境信息库中主要存储两类信息，一类是开发过程中产生的有关被开发系统的信息，例如分析文档、设计文档和测试报告等；另一类是环境提供的支持信息，如文档模板、系统配置、过程模型和可复用构件等。</p><p>②过程控制与消息服务器。过程控制与消息服务器是实现过程集成和控制集成的基础。过程集成时按照具体软件开发过程的要求进行工具的选择与组合，控制集成使各工具之间进行并行通信和协同工作。</p><p>③环境用户界面。环境用户界面包括环境总界面和由它实行统一控制的各环境部件及工具的界面。统一的、具有一致性的用户界面是软件开发环境的重要特征，是充分发挥环境的优越性、高效地使用工具并减轻用户的学习负担的保证。</p>",
                    "like": 0,
                    "answer": [
                        "C"
                    ],
                    "option": [
                        " 工作流与日志服务器 ",
                        " 进程通信与数据共享服务器 ",
                        " 过程控制与消息服务器 ",
                        " 同步控制与恢复服务器 "
                    ]
                },
                {
                    "index": 129,
                    "belong_page": 1,
                    "question_id": 208427,
                    "question_title": "软件开发环境应支持多种集成机制。根据功能不同，可以将集成机制分为三个部分：（ ），用以存储与系统开发有关的信息，并支持信息的交流与共享；（ ），是实现过程集成和控制集成的基础；（请作答此空），它的统一性和一致性是软件开发环境的重要特征。",
                    "question_type": 1,
                    "answer_type": 1,
                    "show_type_name": "单选题",
                    "new_parent_id": 208427,
                    "score_rule": "",
                    "material_text": "",
                    "sort_son": "0",
                    "analyze": "<p>软件开发环境(Software Development Environment，SDE)是指支持软件的工程化开发和维护而使用的一组软件，由软件工具集和环境集成机制构成。</p><p>软件开发环境应支持多种集成机制，根据功能的不同，集成机制可以划分为环境信息库、过程控制与消息服务器、环境用户界面三个部分。</p><p>①环境信息库。环境信息库是软件开发环境的核心，用以存储与系统开发有关的信息，并支持信息的交流与共享。环境信息库中主要存储两类信息，一类是开发过程中产生的有关被开发系统的信息，例如分析文档、设计文档和测试报告等；另一类是环境提供的支持信息，如文档模板、系统配置、过程模型和可复用构件等。</p><p>②过程控制与消息服务器。过程控制与消息服务器是实现过程集成和控制集成的基础。过程集成时按照具体软件开发过程的要求进行工具的选择与组合，控制集成使各工具之间进行并行通信和协同工作。</p><p>③环境用户界面。环境用户界面包括环境总界面和由它实行统一控制的各环境部件及工具的界面。统一的、具有一致性的用户界面是软件开发环境的重要特征，是充分发挥环境的优越性、高效地使用工具并减轻用户的学习负担的保证。</p>",
                    "like": 0,
                    "answer": [
                        "D"
                    ],
                    "option": [
                        " 底层数据结构 ",
                        " 数据处理方法 ",
                        " 业务过程模型 ",
                        " 环境用户界面 "
                    ]
                },
                {
                    "index": 130,
                    "belong_page": 1,
                    "question_id": 208493,
                    "question_title": "详细的项目范围说明书是项目成功的关键，（ ）不属于项目范围定义的输入。",
                    "question_type": 1,
                    "answer_type": 1,
                    "show_type_name": "单选题",
                    "new_parent_id": 208493,
                    "score_rule": "",
                    "material_text": "",
                    "sort_son": "0",
                    "analyze": "<p>在初始项目范围说明书中已文档化的主要的可交付物、假设和约束条件的基础上准备详细的项目范围说明书，是项目成功的关键。范围定义的输入包括以下内容：</p><p>①项目章程。如果项目章程或初始的范围说明书没有在项目执行组织中使用，同样的信息需要进一步收集和开发，以产生详细的项目范围说明书。</p><p>②项目范围管理计划。</p><p>③组织过程资产。</p><p>④批准的变更申请。</p>",
                    "like": 0,
                    "answer": [
                        "D"
                    ],
                    "option": [
                        " 项目章程 ",
                        " 项目范围管理计划 ",
                        " 批准的变更申请 ",
                        " 项目文档管理方法 "
                    ]
                },
                {
                    "index": 131,
                    "belong_page": 1,
                    "question_id": 208494,
                    "question_title": "活动定义是项目时间管理中的过程之一，（ ）是进行活动定义时通常使用的一种工具。",
                    "question_type": 1,
                    "answer_type": 1,
                    "show_type_name": "单选题",
                    "new_parent_id": 208494,
                    "score_rule": "",
                    "material_text": "",
                    "sort_son": "0",
                    "analyze": "项目时间管理包括使项目按时完成所必须的管理过程。项目时间管理中的过程包括：活动定义、活动排序、活动的资源估算、活动历时估算、制定进度计划以及进度控制。为了得到工作分解结构(Work Breakdown Structure，WBS)中最底层的交付物，必须执行一系列的活动，对这些活动的识别以及归档的过程就叫做活动定义。",
                    "like": 0,
                    "answer": [
                        "C"
                    ],
                    "option": [
                        " Gantt图 ",
                        " 活动图 ",
                        " 工作分解结构(WBS) ",
                        " PERT图 "
                    ]
                },
                {
                    "index": 132,
                    "belong_page": 1,
                    "question_id": 208495,
                    "question_title": "以下叙述中，（ ）不属于可行性分析的范畴。",
                    "question_type": 1,
                    "answer_type": 1,
                    "show_type_name": "单选题",
                    "new_parent_id": 208495,
                    "score_rule": "",
                    "material_text": "",
                    "sort_son": "0",
                    "analyze": "<p>可行性分析是所有项目投资、工程建设或重大改革在开始阶段必须进行的一项工作。项目的可行性分析是对多因素、多目标系统进行的分析、评价和决策的过程。可行性 &nbsp;研究通常从经济可行性、技术可行性、法律可行性和用户使用可行性4个方面来进行分析。</p><p>经济可行性也称为投资收益分析或成本效益分析，主要评价项目的建设成本、运行成本和项目建成后可能的经济收益。经济收益可以分为直接收益、间接收益、有形收益和无形收益等。</p><p>技术可行性也称为技术风险分析，研究的对象是信息系统需要实现的功能和性能，以及技术能力约束。</p><p>法律可行性也称为社会可行性，具有比较广泛的内容，它需要从政策、法律、道德、制度等社会因素来论证信息系统建设的现实性。</p><p>用户使用可行性也称为执行可行性，是从信息系统用户的角度来评估系统的可行性，包括企业的行政管理和工作制度、使用人员的素质和培训要求等。</p>",
                    "like": 0,
                    "answer": [
                        "B"
                    ],
                    "option": [
                        " 对系统开发的各种候选方案进行成本/效益分析 ",
                        " 分析现有系统存在的运行问题 ",
                        " 评价该项目实施后可能取得的无形收益 ",
                        " 评估现有技术能力和信息技术是否足以支持系统目标的实现 "
                    ]
                },
                {
                    "index": 133,
                    "belong_page": 1,
                    "question_id": 208501,
                    "question_title": "基于RUP的软件过程是一个迭代过程。一个开发周期包括初始、细化、构建和移交四个阶段，每次通过这四个阶段就会产生一代软件，其中建立完善的架构是（请作答此空）阶段的任务。采用迭代式开发，（ ）。",
                    "question_type": 1,
                    "answer_type": 1,
                    "show_type_name": "单选题",
                    "new_parent_id": 208501,
                    "score_rule": "",
                    "material_text": "",
                    "sort_son": "0",
                    "analyze": "<p>RUP中的软件过程在时间上被分解为4个顺序的阶段，分别是初始阶段、细化阶段、构建阶段和移交阶段。</p><p>初始阶段的任务是为系统建立业务模型并确定项目的边界。细化阶段的任务是分析问题领域，建立完善的架构，淘汰项目中最高风险的元素。在构建阶段，要开发所有剩余的构件和应用程序功能，把这些构件集成为产品。移交阶段的重点是确保软件对最终用户是可用的。</p><p>基于RUP的软件过程是一个迭代过程，通过初始、细化、构建和移交4个阶段就是一个开发周期，每次经过这4个阶段就会产生一代产品，在每一轮迭代中都要进行测试与集成。</p>",
                    "like": 0,
                    "answer": [
                        "B"
                    ],
                    "option": [
                        " 初始 ",
                        " 细化 ",
                        " 构建 ",
                        " 移交 "
                    ]
                },
                {
                    "index": 134,
                    "belong_page": 1,
                    "question_id": 208502,
                    "question_title": "基于RUP的软件过程是一个迭代过程。一个开发周期包括初始、细化、构建和移交四个阶段，每次通过这四个阶段就会产生一代软件，其中建立完善的架构是（ ）阶段的任务。采用迭代式开发，（请作答此空）。",
                    "question_type": 1,
                    "answer_type": 1,
                    "show_type_name": "单选题",
                    "new_parent_id": 208502,
                    "score_rule": "",
                    "material_text": "",
                    "sort_son": "0",
                    "analyze": "<p>RUP中的软件过程在时间上被分解为4个顺序的阶段，分别是初始阶段、细化阶段、构建阶段和移交阶段。</p><p>初始阶段的任务是为系统建立业务模型并确定项目的边界。细化阶段的任务是分析问题领域，建立完善的架构，淘汰项目中最高风险的元素。在构建阶段，要开发所有剩余的构件和应用程序功能，把这些构件集成为产品。移交阶段的重点是确保软件对最终用户是可用的。</p><p>基于RUP的软件过程是一个迭代过程，通过初始、细化、构建和移交4个阶段就是一个开发周期，每次经过这4个阶段就会产生一代产品，在每一轮迭代中都要进行测试与集成。</p>",
                    "like": 0,
                    "answer": [
                        "A"
                    ],
                    "option": [
                        " 在每一轮迭代中都要进行测试与集成 ",
                        " 每一轮迭代的重点是对特定的用例进行部分实现 ",
                        " 在后续迭代中强调用户的主动参与 ",
                        " 通常以功能分解为基础 "
                    ]
                },
                {
                    "index": 135,
                    "belong_page": 1,
                    "question_id": 208505,
                    "question_title": "<p>以下关于自顶向下开发方法的叙述中，正确的是（ ）。</p>",
                    "question_type": 1,
                    "answer_type": 1,
                    "show_type_name": "单选题",
                    "new_parent_id": 208505,
                    "score_rule": "",
                    "material_text": "",
                    "sort_son": "0",
                    "analyze": "<p>自顶向下方法是一种决策策略。软件开发涉及作什么决策、如何决策和决策顺序等决策问题。</p><p>自顶向下方法在任何时刻所作的决定都是当时对整个设计影响最大的那些决定。如果把所有决定分组或者分级，那么决策顺序是首先作最高级的决定，然后依次地作较低级的决定。同级的决定则按照随机的顺序或者按别的方法。一个决策的级别是看它距离要达到的最终目的(因此是软件的实际实现)的远近程度。从问题本身来看，或是由外(用户所见的)向内(系统的实现)看，以距离实现近的决定为低级决定，远的为高级决定。</p><p>在这个自顶向下的过程中，一个复杂的问题(任务)被分解成若干个较小较简单的问题(子任务)，并且一直继续下去，直到每个小问题(子任务)都简单到能够直接解决(实现)为止。</p><p>自顶向下方法的优点是：</p><p>可为企业或机构的重要决策和任务实现提供信息。</p><p>支持企业信息系统的整体性规划，并对系统的各子系统的协调和通信提供保证。</p><p>方法的实践有利于提高企业人员整体观察问题的能力，从而有利于寻找到改进企业组织的途径。</p><p>自顶向下方法的缺点是：</p><p>对系统分析和设计人员的要求较高。</p><p>开发周期长，系统复杂，一般属于一种高成本、大投资的工程。</p><p>对于大系统而言，自上而下的规划对于下层系统的实施往往缺乏约束力。</p><p>从经济角度来看，很难说自顶向下的做法在经济上是合算的。</p>",
                    "like": 0,
                    "answer": [
                        "C"
                    ],
                    "option": [
                        " 自顶向下过程因为单元测试而比较耗费时间 ",
                        " 自顶向下过程可以更快地发现系统性能方面的问题 ",
                        " 相对于自底向上方法，自顶向下方法可以更快地得到系统的演示原型 ",
                        " 在自顶向下的设计中，如发现了一个错误，通常是因为底层模块没有满足其规格说明(因为高层模块已经被测试过了) "
                    ]
                },
                {
                    "index": 136,
                    "belong_page": 1,
                    "question_id": 281198,
                    "question_title": "<p>统一软件开发过程是一种基于面向对象技术的软件开发过程，其特点是“用例驱动，以架构为核心，迭代并增量”。统一软件开发过程定义了4种通用的开发阶段，它们按照过程顺序分别是：起始阶段、（ ）、构建阶段和（ ），其中在构建阶段主要产生的文档有（ ）。</p>",
                    "question_type": 9,
                    "answer_type": 1,
                    "show_type_name": "单选题",
                    "new_parent_id": 281197,
                    "score_rule": "",
                    "material_text": null,
                    "sort_son": "1",
                    "analyze": "<p>统一过程适合于大、中型项目的开发，可以分为4个顺序的阶段，分别是初始阶段、细化阶段、构建阶段和移交阶段。</p><p>初始阶段的任务是为系统建立业务模型并确定项目的边界。在初始阶段，必须识别所有与系统交互的外部实体，定义系统与外部实体交互的特性。在这个阶段中所关注的是整个项目的业务和需求方面的主要风险。对于建立在原有系统基础上的开发项目来说，初始阶段可能很短。</p><p>细化阶段的任务是分析问题领域，建立健全的架构基础，淘汰项目中最高风险的元素。在细化阶段，必须在理解整个系统的基础上，对架构做出决策，包括其范围、主要功能和诸如性能等非功能需求，同时为项目建立支持环境。</p><p>在构建阶段，要开发所有剩余的构件和应用程序功能，把这些构件集成为产品，并进行详细测试。从某种意义上说，构建阶段是一个制造过程，其重点放在管理资源及控制操作，以优化成本、进度和质量。构建阶段的主要任务是通过优化资源和避免不必要的报废和返工，使开发成本降到最低；完成所有所需功能的分析、开发和测试，快速完成可用的版本；确定软件、场地和用户是否已经为部署软件做好准备。在构建阶段，开发团队的工作可以实现某种程度的并行。即使是较小的项目，也通常包括可以相互独立开发的构件，从而使各团队之间实现并行开发。</p><p>当基线已经足够完善，可以安装到最终用户实际环境中时，则进入交付阶段。交付阶段的重点是确保软件对最终用户是可用的。交付阶段的主要任务是进行β测试，制作产品发布版本；对最终用户支持文档定稿；按用户的需求确认新系统；培训用户和维护人员；获得用户对当前版本的反馈，基于反馈调整产品，如进行调试、性能或可用性的增强等。根据产品的种类，交付阶段可能非常简单，也可能非常复杂。例如，发布现有桌面产品的新发布版本可能十分简单，而替换一个国家的航空交通管制系统可能就非常复杂。交付阶段结束时也要进行技术评审，评审目标是否实现，是否应该开始演化过程，用户对交付的产品是否满意等。</p>",
                    "like": 0,
                    "answer": [
                        "B"
                    ],
                    "option": [
                        "分析阶段",
                        "细化阶段",
                        "设计阶段",
                        "交付阶段"
                    ]
                },
                {
                    "index": 137,
                    "belong_page": 1,
                    "question_id": 281199,
                    "question_title": "<p>统一软件开发过程是一种基于面向对象技术的软件开发过程，其特点是“用例驱动，以架构为核心，迭代并增量”。统一软件开发过程定义了4种通用的开发阶段，它们按照过程顺序分别是：起始阶段、（ ）、构建阶段和（ ），其中在构建阶段主要产生的文档有（ ）。</p>",
                    "question_type": 9,
                    "answer_type": 1,
                    "show_type_name": "单选题",
                    "new_parent_id": 281197,
                    "score_rule": "",
                    "material_text": null,
                    "sort_son": "2",
                    "analyze": "<p>统一过程适合于大、中型项目的开发，可以分为4个顺序的阶段，分别是初始阶段、细化阶段、构建阶段和移交阶段。</p><p>初始阶段的任务是为系统建立业务模型并确定项目的边界。在初始阶段，必须识别所有与系统交互的外部实体，定义系统与外部实体交互的特性。在这个阶段中所关注的是整个项目的业务和需求方面的主要风险。对于建立在原有系统基础上的开发项目来说，初始阶段可能很短。</p><p>细化阶段的任务是分析问题领域，建立健全的架构基础，淘汰项目中最高风险的元素。在细化阶段，必须在理解整个系统的基础上，对架构做出决策，包括其范围、主要功能和诸如性能等非功能需求，同时为项目建立支持环境。</p><p>在构建阶段，要开发所有剩余的构件和应用程序功能，把这些构件集成为产品，并进行详细测试。从某种意义上说，构建阶段是一个制造过程，其重点放在管理资源及控制操作，以优化成本、进度和质量。构建阶段的主要任务是通过优化资源和避免不必要的报废和返工，使开发成本降到最低；完成所有所需功能的分析、开发和测试，快速完成可用的版本；确定软件、场地和用户是否已经为部署软件做好准备。在构建阶段，开发团队的工作可以实现某种程度的并行。即使是较小的项目，也通常包括可以相互独立开发的构件，从而使各团队之间实现并行开发。</p><p>当基线已经足够完善，可以安装到最终用户实际环境中时，则进入交付阶段。交付阶段的重点是确保软件对最终用户是可用的。交付阶段的主要任务是进行β测试，制作产品发布版本；对最终用户支持文档定稿；按用户的需求确认新系统；培训用户和维护人员；获得用户对当前版本的反馈，基于反馈调整产品，如进行调试、性能或可用性的增强等。根据产品的种类，交付阶段可能非常简单，也可能非常复杂。例如，发布现有桌面产品的新发布版本可能十分简单，而替换一个国家的航空交通管制系统可能就非常复杂。交付阶段结束时也要进行技术评审，评审目标是否实现，是否应该开始演化过程，用户对交付的产品是否满意等。</p>",
                    "like": 0,
                    "answer": [
                        "D"
                    ],
                    "option": [
                        "分析阶段",
                        "细化阶段",
                        "设计阶段",
                        "交付阶段"
                    ]
                },
                {
                    "index": 138,
                    "belong_page": 1,
                    "question_id": 281200,
                    "question_title": "<p>统一软件开发过程是一种基于面向对象技术的软件开发过程，其特点是“用例驱动，以架构为核心，迭代并增量”。统一软件开发过程定义了4种通用的开发阶段，它们按照过程顺序分别是：起始阶段、（ ）、构建阶段和（ ），其中在构建阶段主要产生的文档有（ ）。</p>",
                    "question_type": 9,
                    "answer_type": 1,
                    "show_type_name": "单选题",
                    "new_parent_id": 281197,
                    "score_rule": "",
                    "material_text": null,
                    "sort_son": "3",
                    "analyze": "<p>统一过程适合于大、中型项目的开发，可以分为4个顺序的阶段，分别是初始阶段、细化阶段、构建阶段和移交阶段。</p><p>初始阶段的任务是为系统建立业务模型并确定项目的边界。在初始阶段，必须识别所有与系统交互的外部实体，定义系统与外部实体交互的特性。在这个阶段中所关注的是整个项目的业务和需求方面的主要风险。对于建立在原有系统基础上的开发项目来说，初始阶段可能很短。</p><p>细化阶段的任务是分析问题领域，建立健全的架构基础，淘汰项目中最高风险的元素。在细化阶段，必须在理解整个系统的基础上，对架构做出决策，包括其范围、主要功能和诸如性能等非功能需求，同时为项目建立支持环境。</p><p>在构建阶段，要开发所有剩余的构件和应用程序功能，把这些构件集成为产品，并进行详细测试。从某种意义上说，构建阶段是一个制造过程，其重点放在管理资源及控制操作，以优化成本、进度和质量。构建阶段的主要任务是通过优化资源和避免不必要的报废和返工，使开发成本降到最低；完成所有所需功能的分析、开发和测试，快速完成可用的版本；确定软件、场地和用户是否已经为部署软件做好准备。在构建阶段，开发团队的工作可以实现某种程度的并行。即使是较小的项目，也通常包括可以相互独立开发的构件，从而使各团队之间实现并行开发。</p><p>当基线已经足够完善，可以安装到最终用户实际环境中时，则进入交付阶段。交付阶段的重点是确保软件对最终用户是可用的。交付阶段的主要任务是进行β测试，制作产品发布版本；对最终用户支持文档定稿；按用户的需求确认新系统；培训用户和维护人员；获得用户对当前版本的反馈，基于反馈调整产品，如进行调试、性能或可用性的增强等。根据产品的种类，交付阶段可能非常简单，也可能非常复杂。例如，发布现有桌面产品的新发布版本可能十分简单，而替换一个国家的航空交通管制系统可能就非常复杂。交付阶段结束时也要进行技术评审，评审目标是否实现，是否应该开始演化过程，用户对交付的产品是否满意等。</p>",
                    "like": 0,
                    "answer": [
                        "D"
                    ],
                    "option": [
                        "初始用户手册",
                        "用例模型",
                        "项目计划",
                        "设计模型"
                    ]
                },
                {
                    "index": 139,
                    "belong_page": 1,
                    "question_id": 281201,
                    "question_title": "<p>某开发组在开发某个系统时，各个阶段具有严格的界限，只有一个阶段的获得认可才能进行下一个阶段的工作，则该开发组最可能采用的软件开发方法是（ ）。</p>",
                    "question_type": 1,
                    "answer_type": 1,
                    "show_type_name": "单选题",
                    "new_parent_id": 281201,
                    "score_rule": "",
                    "material_text": "",
                    "sort_son": "0",
                    "analyze": "<p>结构化方法要求各个阶段具有严格的界限，一个阶段获得认可后才能进行下一个阶段的工作。</p>",
                    "like": 0,
                    "answer": [
                        "B"
                    ],
                    "option": [
                        " 构件化方法 ",
                        " 结构化方法 ",
                        " 面向对象方法 ",
                        " 快速原型法 "
                    ]
                },
                {
                    "index": 140,
                    "belong_page": 1,
                    "question_id": 281327,
                    "question_title": "<p>（ ）是互联网时代信息基础设施与应用服务模式的重要形态，是新一代信息技术集约化发展的必然趋势。它以资源聚合和虚拟化、应用服务和专业化、按需供给和灵便使用的服务模式，提供高效能、低成本、低功耗的计算与数据服务，支撑各类信息化的应用。</p>",
                    "question_type": 1,
                    "answer_type": 1,
                    "show_type_name": "单选题",
                    "new_parent_id": 281327,
                    "score_rule": "",
                    "material_text": "",
                    "sort_son": "0",
                    "analyze": "<p>云计算是互联网时代信息基础设施与应用服务模式的重要形态，是新一代信息技术集约化发展的必然趋势。它以资源聚合和虚拟化、应用服务和专业化、按需供给和灵便使用的服务模式，提供高效能、低成本、低功耗的计算与数据服务，支撑各类信息化的应用。</p><p>云计算具有重要特征：资源、平台和应用专业服务，使用户摆脱对具体设备的依赖，专注于创造和体验业务价值；资源聚集与集中管理，实现规模效应与可控质量保障；按需扩展与弹性租赁，降低信息化成本等特征。</p>",
                    "like": 0,
                    "answer": [
                        "B"
                    ],
                    "option": [
                        " 物联网 ",
                        " 云计算 ",
                        " 智慧城市 ",
                        " 商业智能 "
                    ]
                },
                {
                    "index": 141,
                    "belong_page": 1,
                    "question_id": 281329,
                    "question_title": "<p>以下关于企业资源规划(ERP)的叙述中，错误的是______。</p>",
                    "question_type": 1,
                    "answer_type": 1,
                    "show_type_name": "单选题",
                    "new_parent_id": 281329,
                    "score_rule": "",
                    "material_text": "",
                    "sort_son": "0",
                    "analyze": "<p>企业资源规划(ERP)是一个有效组织、计划和实施企业的内外部资源的管理系统。它集信息技术和先进的管理思想于一身，是统一的集成系统、面向业务流程的系统、模块化可配置的系统、开放的系统。其功能包括财会管理、生产控制管理(如制造业等)、物流管理和人力资源管理等。</p><p>虽然企业具有一些相同或相似的基本业务，但由于企业具有不同的规模、不同的部门设置和不同的业务流程，因此简单地购买使用一个商业化的ERP软件，其转化成本高，且失败的风险也很大。ERP的关键是事前规划管理。<span style=\"font-size: 16px;\"></span></p>",
                    "like": 0,
                    "answer": [
                        "D"
                    ],
                    "option": [
                        " 购买使用一个商业化的ERP软件，转化成本高，失败的风险也很大 ",
                        " 除了制造和财务，ERP系统可以支持人力资源、销售和配送 ",
                        " ERP为组织提供了升级和简化其所用的信息技术的机会 ",
                        " ERP的关键是事后监控企业的各项业务功能，使得质量、客户满意度、工作成果等可控 "
                    ]
                },
                {
                    "index": 142,
                    "belong_page": 1,
                    "question_id": 281345,
                    "question_title": "<p>系统的硬件环境、软件环境和数据环境发生变化时需要对系统进行维护，这种维护属于______。</p>",
                    "question_type": 1,
                    "answer_type": 1,
                    "show_type_name": "单选题",
                    "new_parent_id": 281345,
                    "score_rule": "",
                    "material_text": "",
                    "sort_son": "0",
                    "analyze": "<p>&nbsp;<img style=\"max-width:100%;height:auto\"  src=\"https://s2.51cto.com/images/20200912/1599885265977244.jpg\" title=\"1599885265977244.jpg\" alt=\"1.jpg\"/></p>",
                    "like": 0,
                    "answer": [
                        "B"
                    ],
                    "option": [
                        " 支持性维护 ",
                        " 适应性维护 ",
                        " 完善性维护 ",
                        " 预防性维护 "
                    ]
                },
                {
                    "index": 143,
                    "belong_page": 1,
                    "question_id": 281354,
                    "question_title": "<p>敏捷软件过程强调：让客户满意和软件尽早增量发布；小而高度自主的项目团队；非正式的方法；最小化软件工程工作产品及整体精简开发。______不是采用这种软件开发过程的原因。</p>",
                    "question_type": 1,
                    "answer_type": 1,
                    "show_type_name": "单选题",
                    "new_parent_id": 281354,
                    "score_rule": "",
                    "material_text": "",
                    "sort_son": "0",
                    "analyze": "<p>敏捷开发是一种以人为核心、迭代、循序渐进的开发方法。在敏捷开发中，软件项目的构建被切分成多个子项目，各个子项目成果都经过测试，具备集成和可运行的特征。通过任何一个敏捷过程都可以由其所强调的3个关键假设而识别出来，即：①难以提前预测哪些需求是稳定的和哪些需求会变化，同样，预测项目进行中客户优先级的变化也是困难的；②对于软件项目开发来说，设计和实现是交错进行的；③从制定计划的角度来看，分析、设计、实现和测试并不容易预测。</p><p>如何建立能解决不可预测性的过程?这就要求敏捷过程必须具有自适应性。但原地踏步式的连续适应性变化收效甚微。因而，敏捷软件过程还必须增量地适应。为了达到这一目的，敏捷团队需要客户的反馈以做出正确的适应性改变。可执行原型和部分实现的可运行系统是了解用户需求和反馈的有效媒介。</p>",
                    "like": 0,
                    "answer": [
                        "B"
                    ],
                    "option": [
                        " 难以提前预测哪些需求是稳定的和哪些需求会变化 ",
                        " 对于软件项目开发来说，设计和实现可以做到基本分离 ",
                        " 从制定计划的角度来看，分析、设计、实现和测试并不容易预测 ",
                        " 可执行原型和部分实现的可运行系统是了解用户需求和反馈的有效媒介 "
                    ]
                },
                {
                    "index": 144,
                    "belong_page": 1,
                    "question_id": 284648,
                    "question_title": "<p>某开发组在开发某个系统时，各个阶段具有严格的界限，只有一个阶段的获得认可才能进行下一个阶段的工作，则该开发组最可能采用的软件开发方法是（9）。</p>",
                    "question_type": 1,
                    "answer_type": 1,
                    "show_type_name": "单选题",
                    "new_parent_id": 284648,
                    "score_rule": "",
                    "material_text": "",
                    "sort_son": "0",
                    "analyze": "<p>结构化方法要求各个阶段具有严格的界限，一个阶段获得认可后才能进行下一个阶段的工作。</p>",
                    "like": 0,
                    "answer": [
                        "B"
                    ],
                    "option": [
                        " 构件化方法 ",
                        " 结构化方法 ",
                        " 面向对象方法 ",
                        " 快速原型法 "
                    ]
                },
                {
                    "index": 145,
                    "belong_page": 1,
                    "question_id": 284680,
                    "question_title": "<p>（34）是互联网时代信息基础设施与应用服务模式的重要形态，是新一代信息技术集约化发展的必然趋势。它以资源聚合和虚拟化、应用服务和专业化、按需供给和灵便使用的服务模式，提供高效能、低成本、低功耗的计算与数据服务，支撑各类信息化的应用。</p>",
                    "question_type": 1,
                    "answer_type": 1,
                    "show_type_name": "单选题",
                    "new_parent_id": 284680,
                    "score_rule": "",
                    "material_text": "",
                    "sort_son": "0",
                    "analyze": "<p>云计算是互联网时代信息基础设施与应用服务模式的重要形态，是新一代信息技术集约化发展的必然趋势。它以资源聚合和虚拟化、应用服务和专业化、按需供给和灵便使用的服务模式，提供高效能、低成本、低功耗的计算与数据服务，支撑各类信息化的应用。</p><p>云计算具有重要特征：资源、平台和应用专业服务，使用户摆脱对具体设备的依赖，专注于创造和体验业务价值；资源聚集与集中管理，实现规模效应与可控质量保障；按需扩展与弹性租赁，降低信息化成本等特征。</p>",
                    "like": 0,
                    "answer": [
                        "B"
                    ],
                    "option": [
                        " 物联网 ",
                        " 云计算 ",
                        " 智慧城市 ",
                        " 商业智能 "
                    ]
                },
                {
                    "index": 146,
                    "belong_page": 1,
                    "question_id": 284681,
                    "question_title": "<p>CRM是一个集成化的信息管理系统，以下不属于CRM系统具备的主要功能的是（35）。</p>",
                    "question_type": 1,
                    "answer_type": 1,
                    "show_type_name": "单选题",
                    "new_parent_id": 284681,
                    "score_rule": "",
                    "material_text": "",
                    "sort_son": "0",
                    "analyze": "<p>选项B、选项C和选项D都是CRM系统应具备的主要功能。选项A是企业资源计划(ERP)的主要功能之一。</p>",
                    "like": 0,
                    "answer": [
                        "A"
                    ],
                    "option": [
                        " 能用于识别和规划企业资源，对采购、生产、成本、库存、销售、运输、财务和人力资源等进行规划和优化 ",
                        " 具有整合各种客户联系渠道的能力，并把客户数据分为描述性、促销性和交易性数据三大类 ",
                        " 系统必须实现基本的数据挖掘模块，能对客户信息进行全方位的统一管理 ",
                        " 能够提供销售、客户服务和营销三个业务的自动化工具，并具有可扩展性和可复用性 "
                    ]
                },
                {
                    "index": 147,
                    "belong_page": 1,
                    "question_id": 284699,
                    "question_title": "<p>人们根据软件维护的性质不同，将软件维护分为更正性维护、适应性维护、完善性维护、预防性维护等四类， （49） 是这四类软件维护的共同特征。</p>",
                    "question_type": 1,
                    "answer_type": 1,
                    "show_type_name": "单选题",
                    "new_parent_id": 284699,
                    "score_rule": "",
                    "material_text": "",
                    "sort_son": "0",
                    "analyze": "<p>这四类软件维护的共同特征为都是交付后进行的。</p>",
                    "like": 0,
                    "answer": [
                        "B"
                    ],
                    "option": [
                        " 发现原产品中存在问题后采取的补救措施 ",
                        " 交付软件产品后进行的修改 ",
                        " 测试发现问题之后的应对措施 ",
                        " 软件产品交付前进行的质量管理活动 "
                    ]
                },
                {
                    "index": 148,
                    "belong_page": 1,
                    "question_id": 284701,
                    "question_title": "<p>某软件项目的活动图如下所示。图中顶点表示项目里程碑，连接顶点的边表示包含的活动，则里程碑（50）在关键路径上，活动FG的松弛时间为（51）。<br/><img style=\"max-width:100%;height:auto\"  src=\"https://s2.51cto.com/images/20201014/1602644629974691.jpg\" title=\"1602644629974691.jpg\" alt=\"1.jpg\"/></p>",
                    "question_type": 9,
                    "answer_type": 1,
                    "show_type_name": "单选题",
                    "new_parent_id": 284700,
                    "score_rule": "",
                    "material_text": null,
                    "sort_son": "1",
                    "analyze": "<p>关键路径是图中从起点到终点长度最长的那条路径，而关键路径的长度则是整个项目的工期。在本题中，路径START-D-F-H-FINISH的长度为48，是最长的一条路径，因此其是关键路径，因此D点是关键路径上的里程碑。</p><p>要求活动的松弛时间，就要求出活动的最早开始时间和最晚开始时间，其最晚开始时间减去最早开始时间，就是活动的松弛时间。对于活动FG，其最早开始时间是10+8=18，而最晚开始时间48-7-3=38，因此该活动的松弛时间是20。</p>",
                    "like": 0,
                    "answer": [
                        "C"
                    ],
                    "option": [
                        "B&nbsp;",
                        "C",
                        "D",
                        " I "
                    ]
                },
                {
                    "index": 149,
                    "belong_page": 1,
                    "question_id": 284702,
                    "question_title": "<p>某软件项目的活动图如下所示。图中顶点表示项目里程碑，连接顶点的边表示包含的活动，则里程碑（50）在关键路径上，活动FG的松弛时间为（51）。<br/><img style=\"max-width:100%;height:auto\"  src=\"https://s2.51cto.com/images/20201014/1602644629974691.jpg\" title=\"1602644629974691.jpg\" alt=\"1.jpg\"/></p>",
                    "question_type": 9,
                    "answer_type": 1,
                    "show_type_name": "单选题",
                    "new_parent_id": 284700,
                    "score_rule": "",
                    "material_text": null,
                    "sort_son": "2",
                    "analyze": "<p>关键路径是图中从起点到终点长度最长的那条路径，而关键路径的长度则是整个项目的工期。在本题中，路径START-D-F-H-FINISH的长度为48，是最长的一条路径，因此其是关键路径，因此D点是关键路径上的里程碑。</p><p>要求活动的松弛时间，就要求出活动的最早开始时间和最晚开始时间，其最晚开始时间减去最早开始时间，就是活动的松弛时间。对于活动FG，其最早开始时间是10+8=18，而最晚开始时间48-7-3=38，因此该活动的松弛时间是20。</p>",
                    "like": 0,
                    "answer": [
                        "B"
                    ],
                    "option": [
                        "19",
                        "20",
                        "32",
                        "24"
                    ]
                },
                {
                    "index": 150,
                    "belong_page": 1,
                    "question_id": 284706,
                    "question_title": "<p>螺旋模型是一种演进式的软件过程模型， 结合了原型开发方法的系统性和瀑布模型可控性特点。它有两个显著特 点，一是采用（ ）的方式逐步加深系统定义和实现的深度，降低风险；二是确定一系列 （ ） ，确保项目开发过 程中的相关利益者都支持可行的和令人满意</p>",
                    "question_type": 9,
                    "answer_type": 1,
                    "show_type_name": "单选题",
                    "new_parent_id": 284705,
                    "score_rule": "",
                    "material_text": null,
                    "sort_son": "1",
                    "analyze": "螺旋模型是一种演进式的软件过程模型，结合了原型开发方法的瀑布模型的系统性和可控性特点。它有两个显著 特点，一是采用循环的方式逐步加深系统定义和实现的深度，同时降低风险；二是确定一系列里程碑，确保项目开发过 程中的相关利益者都支持可行的和令人满意的系统解决方案。",
                    "like": 0,
                    "answer": [
                        "C"
                    ],
                    "option": [
                        "逐步交付",
                        "顺序",
                        "循环",
                        "增量的系统解决方案"
                    ]
                },
                {
                    "index": 151,
                    "belong_page": 1,
                    "question_id": 284707,
                    "question_title": "<p>螺旋模型是一种演进式的软件过程模型， 结合了原型开发方法的系统性和瀑布模型可控性特点。它有两个显著特 点，一是采用（ ）的方式逐步加深系统定义和实现的深度，降低风险；二是确定一系列 （ ） ，确保项目开发过 程中的相关利益者都支持可行的和令人满意</p>",
                    "question_type": 9,
                    "answer_type": 1,
                    "show_type_name": "单选题",
                    "new_parent_id": 284705,
                    "score_rule": "",
                    "material_text": null,
                    "sort_son": "2",
                    "analyze": "螺旋模型是一种演进式的软件过程模型，结合了原型开发方法的瀑布模型的系统性和可控性特点。它有两个显著 特点，一是采用循环的方式逐步加深系统定义和实现的深度，同时降低风险；二是确定一系列里程碑，确保项目开发过 程中的相关利益者都支持可行的和令人满意的系统解决方案。",
                    "like": 0,
                    "answer": [
                        "D"
                    ],
                    "option": [
                        "实现方案",
                        "设计方案",
                        "关键点",
                        "里程碑"
                    ]
                },
                {
                    "index": 152,
                    "belong_page": 1,
                    "question_id": 284709,
                    "question_title": "<p>敏捷软件过程强调：让客户满意和软件尽早增量发布；小而高度自主的项目团队；非正式的方法；最小化软件工程工作产品及整体精简开发。_____不是采用这种软件开发过程的原因。</p>",
                    "question_type": 1,
                    "answer_type": 1,
                    "show_type_name": "单选题",
                    "new_parent_id": 284709,
                    "score_rule": "",
                    "material_text": "",
                    "sort_son": "0",
                    "analyze": "<p>敏捷开发是一种以人为核心、迭代、循序渐进的开发方法。在敏捷开发中，软件项目的构建被切分成多个子项目，各个子项目成果都经过测试，具备集成和可运行的特征。通过任何一个敏捷过程都可以由其所强调的3个关键假设而识别出来，即：①难以提前预测哪些需求是稳定的和哪些需求会变化，同样，预测项目进行中客户优先级的变化也是困难的；②对于软件项目开发来说，设计和实现是交错进行的；③从制定计划的角度来看，分析、设计、实现和测试并不容易预测。</p><p>如何建立能解决不可预测性的过程?这就要求敏捷过程必须具有自适应性。但原地踏步式的连续适应性变化收效甚微。因而，敏捷软件过程还必须增量地适应。为了达到这一目的，敏捷团队需要客户的反馈以做出正确的适应性改变。可执行原型和部分实现的可运行系统是了解用户需求和反馈的有效媒介。</p>",
                    "like": 0,
                    "answer": [
                        "B"
                    ],
                    "option": [
                        " 难以提前预测哪些需求是稳定的和哪些需求会变化 ",
                        " 对于软件项目开发来说，设计和实现可以做到基本分离 ",
                        " 从制定计划的角度来看，分析、设计、实现和测试并不容易预测 ",
                        " 可执行原型和部分实现的可运行系统是了解用户需求和反馈的有效媒介 "
                    ]
                },
                {
                    "index": 153,
                    "belong_page": 1,
                    "question_id": 303645,
                    "question_title": "信息系统规划方法中，关键成功因素法通过对关键成功因素的识别，找出实现罔标所需要的关键信息集合，从而确定系统开发的 （18） 。关键成功因素来源于组织的目标，通过组织的目标分解和关键成功因素识别、(19）识别，一直到产生数据字典。",
                    "question_type": 9,
                    "answer_type": 1,
                    "show_type_name": "单选题",
                    "new_parent_id": 303644,
                    "score_rule": "",
                    "material_text": null,
                    "sort_son": "1",
                    "analyze": "<p>关键成功因素法是由John Rockart提出的一种信息系统规划方法。该方法能够帮助企业找到影响系统成功的关键因素，通过分析来确定企业的信息需求，从而为管理部门控制信息技术及其处理过程提供实施指南。</p><p>关键成功因素法通过对关键成功因素的识别，找出实现目标所需要的关键信息集合，从而确定系统开发的优先次序。关键成功因素来源于组织的目标，通过组织的目标分解和关键成功因素识别、性能指标识别，一直到产生数据字典。</p>",
                    "like": 0,
                    "answer": [
                        "C"
                    ],
                    "option": [
                        "系统边界",
                        "功能指标",
                        "优先次序",
                        "性能指标"
                    ]
                },
                {
                    "index": 154,
                    "belong_page": 1,
                    "question_id": 303646,
                    "question_title": "信息系统规划方法中，关键成功因素法通过对关键成功因素的识别，找出实现罔标所需要的关键信息集合，从而确定系统开发的 （18） 。关键成功因素来源于组织的目标，通过组织的目标分解和关键成功因素识别、(19）识别，一直到产生数据字典。",
                    "question_type": 9,
                    "answer_type": 1,
                    "show_type_name": "单选题",
                    "new_parent_id": 303644,
                    "score_rule": "",
                    "material_text": null,
                    "sort_son": "2",
                    "analyze": "<p>关键成功因素法是由John Rockart提出的一种信息系统规划方法。该方法能够帮助企业找到影响系统成功的关键因素，通过分析来确定企业的信息需求，从而为管理部门控制信息技术及其处理过程提供实施指南。</p><p>关键成功因素法通过对关键成功因素的识别，找出实现目标所需要的关键信息集合，从而确定系统开发的优先次序。关键成功因素来源于组织的目标，通过组织的目标分解和关键成功因素识别、性能指标识别，一直到产生数据字典。</p>",
                    "like": 0,
                    "answer": [
                        "D"
                    ],
                    "option": [
                        "系统边界",
                        "优先次序",
                        "功能指标",
                        "性能指标"
                    ]
                },
                {
                    "index": 155,
                    "belong_page": 1,
                    "question_id": 303648,
                    "question_title": "系统应用集成构建统一标准的基础平台，在各个应用系统的接口之间共享数据和功能，基本原则是保证应用程序的 （20） 。系统应用集成提供了4个不同层次的服务，最上层服务是 （21） 服务。",
                    "question_type": 9,
                    "answer_type": 1,
                    "show_type_name": "单选题",
                    "new_parent_id": 303647,
                    "score_rule": "",
                    "material_text": null,
                    "sort_son": "1",
                    "analyze": "<p>应用集成是指两个或多个应用系统根据业务逻辑的需要而进行的功能之间的相互调用和互操作。应用集成需要在数据集成的基础上完成。应用集成在底层的网络集成和数据集成的基础上实现异构应用系统之间语用层次上的互操作。它们共同构成了实现企业集成化运行最顶层会聚集成所需要的，技术层次上的基础支持。</p><p>系统应用集成构建统一标准的基础平台，在各个应用系统的接口之间共享数据和功能，基本原则是保证应用程序的独立性。系统应用集成提供了4个不同层次的服务，最上层服务是流程控制服务。</p>",
                    "like": 0,
                    "answer": [
                        "A"
                    ],
                    "option": [
                        "独立性",
                        "相关性",
                        "互操作性",
                        "排他性"
                    ]
                },
                {
                    "index": 156,
                    "belong_page": 1,
                    "question_id": 303649,
                    "question_title": "系统应用集成构建统一标准的基础平台，在各个应用系统的接口之间共享数据和功能，基本原则是保证应用程序的 （20） 。系统应用集成提供了4个不同层次的服务，最上层服务是 （21） 服务。",
                    "question_type": 9,
                    "answer_type": 1,
                    "show_type_name": "单选题",
                    "new_parent_id": 303647,
                    "score_rule": "",
                    "material_text": null,
                    "sort_son": "2",
                    "analyze": "<p>应用集成是指两个或多个应用系统根据业务逻辑的需要而进行的功能之间的相互调用和互操作。应用集成需要在数据集成的基础上完成。应用集成在底层的网络集成和数据集成的基础上实现异构应用系统之间语用层次上的互操作。它们共同构成了实现企业集成化运行最顶层会聚集成所需要的，技术层次上的基础支持。</p><p>系统应用集成构建统一标准的基础平台，在各个应用系统的接口之间共享数据和功能，基本原则是保证应用程序的独立性。系统应用集成提供了4个不同层次的服务，最上层服务是流程控制服务。</p>",
                    "like": 0,
                    "answer": [
                        "D"
                    ],
                    "option": [
                        "通信",
                        "信息传递与转化",
                        "应用连接",
                        "流程控制"
                    ]
                },
                {
                    "index": 157,
                    "belong_page": 1,
                    "question_id": 303651,
                    "question_title": "按照传统的软件生命周期方法学，可以把软件生命周期划分为软件定义、软件开发和 （22） 三个阶段。其中，可行性研究属于 （23） 阶段的主要任务。",
                    "question_type": 9,
                    "answer_type": 1,
                    "show_type_name": "单选题",
                    "new_parent_id": 303650,
                    "score_rule": "",
                    "material_text": null,
                    "sort_son": "1",
                    "analyze": "<p>结构化范型也称软件生命周期方法学，属于传统方法学。把软件生命周期划分成若干个阶段，每个阶段的任务相对独立，而且比较简单，便于不同人员分工协作，从而降低了整个软件开发过程的困难程度。在传统的软件工程方法中，软件的生存周期分为定义时期、开发时期、运行和维护时期这几个阶段。</p><p>可行性研究属于软件定义阶段的主要任务。</p>",
                    "like": 0,
                    "answer": [
                        "A"
                    ],
                    "option": [
                        "软件运行与维护",
                        "软件对象管理",
                        "软件详细设计",
                        "问题描述"
                    ]
                },
                {
                    "index": 158,
                    "belong_page": 1,
                    "question_id": 303652,
                    "question_title": "按照传统的软件生命周期方法学，可以把软件生命周期划分为软件定义、软件开发和 （22） 三个阶段。其中，可行性研究属于 （23） 阶段的主要任务。",
                    "question_type": 9,
                    "answer_type": 1,
                    "show_type_name": "单选题",
                    "new_parent_id": 303650,
                    "score_rule": "",
                    "material_text": null,
                    "sort_son": "2",
                    "analyze": "<p>结构化范型也称软件生命周期方法学，属于传统方法学。把软件生命周期划分成若干个阶段，每个阶段的任务相对独立，而且比较简单，便于不同人员分工协作，从而降低了整个软件开发过程的困难程度。在传统的软件工程方法中，软件的生存周期分为定义时期、开发时期、运行和维护时期这几个阶段。</p><p>可行性研究属于软件定义阶段的主要任务。</p>",
                    "like": 0,
                    "answer": [
                        "A"
                    ],
                    "option": [
                        "软件定义",
                        "软件开发",
                        "软件评估",
                        "软件运行与维护"
                    ]
                },
                {
                    "index": 159,
                    "belong_page": 1,
                    "question_id": 303657,
                    "question_title": "软件方法学是以软件开发方法为研究对象的学科。其中， （26） 是先对最高居次中的问题进行定义、设计、编程和测试，而将其中未解决的问题作为一个子任务放到下一层次中去解决。 （27） 是根据系统功能要求，从具体的器件、逻辑部件或者相似系统开始，通过对其进行相互连接、修改和扩大，构成所要求的系统。 （28） 是建立在严格数学基础上的软件开发方法。",
                    "question_type": 9,
                    "answer_type": 1,
                    "show_type_name": "单选题",
                    "new_parent_id": 303656,
                    "score_rule": "",
                    "material_text": null,
                    "sort_son": "1",
                    "analyze": "软件方法学是软件开发全过程的指导原则与方法体系。其另一种含义是以软件方法为研究对象的学科。从开发风范上看，软件方法有自顶向下的开发方法、自底向上的开发方法。在实际软件开发中，大都是自顶向下与自底向上两种方法的结合，只不过是以何者为主而已。自顶向下是指将一个大问题分化成多个可以解决的小问题，然后逐一进行解决。每个问题都会有一个模块去解决它，且每个问题包括抽象步骤和具体步骤。形式化方法是指采用严格的数学方法，使用形式化规约语言来精确定义软件系统。非形式化的开发方法是通过自然语言、图形或表格描述软件系统的行为和特性，然后基于这些描述进行设计和开发，而形式化开发则是基于数学的方式描述、开发和验证系统。",
                    "like": 0,
                    "answer": [
                        "D"
                    ],
                    "option": [
                        "面向对象开发方法",
                        "形式化开发方法",
                        "非形式化开发方法",
                        "自顶向下开发方法"
                    ]
                },
                {
                    "index": 160,
                    "belong_page": 1,
                    "question_id": 303658,
                    "question_title": "软件方法学是以软件开发方法为研究对象的学科。其中， （26） 是先对最高居次中的问题进行定义、设计、编程和测试，而将其中未解决的问题作为一个子任务放到下一层次中去解决。 （27） 是根据系统功能要求，从具体的器件、逻辑部件或者相似系统开始，通过对其进行相互连接、修改和扩大，构成所要求的系统。 （28） 是建立在严格数学基础上的软件开发方法。",
                    "question_type": 9,
                    "answer_type": 1,
                    "show_type_name": "单选题",
                    "new_parent_id": 303656,
                    "score_rule": "",
                    "material_text": null,
                    "sort_son": "2",
                    "analyze": "软件方法学是软件开发全过程的指导原则与方法体系。其另一种含义是以软件方法为研究对象的学科。从开发风范上看，软件方法有自顶向下的开发方法、自底向上的开发方法。在实际软件开发中，大都是自顶向下与自底向上两种方法的结合，只不过是以何者为主而已。自顶向下是指将一个大问题分化成多个可以解决的小问题，然后逐一进行解决。每个问题都会有一个模块去解决它，且每个问题包括抽象步骤和具体步骤。形式化方法是指采用严格的数学方法，使用形式化规约语言来精确定义软件系统。非形式化的开发方法是通过自然语言、图形或表格描述软件系统的行为和特性，然后基于这些描述进行设计和开发，而形式化开发则是基于数学的方式描述、开发和验证系统。",
                    "like": 0,
                    "answer": [
                        "A"
                    ],
                    "option": [
                        "自底向上开发方法",
                        "形式化开发方法",
                        "非形式化开发方法",
                        "原型开发方法"
                    ]
                },
                {
                    "index": 161,
                    "belong_page": 1,
                    "question_id": 303659,
                    "question_title": "软件方法学是以软件开发方法为研究对象的学科。其中， （26） 是先对最高居次中的问题进行定义、设计、编程和测试，而将其中未解决的问题作为一个子任务放到下一层次中去解决。 （27） 是根据系统功能要求，从具体的器件、逻辑部件或者相似系统开始，通过对其进行相互连接、修改和扩大，构成所要求的系统。 （28） 是建立在严格数学基础上的软件开发方法。",
                    "question_type": 9,
                    "answer_type": 1,
                    "show_type_name": "单选题",
                    "new_parent_id": 303656,
                    "score_rule": "",
                    "material_text": null,
                    "sort_son": "3",
                    "analyze": "软件方法学是软件开发全过程的指导原则与方法体系。其另一种含义是以软件方法为研究对象的学科。从开发风范上看，软件方法有自顶向下的开发方法、自底向上的开发方法。在实际软件开发中，大都是自顶向下与自底向上两种方法的结合，只不过是以何者为主而已。自顶向下是指将一个大问题分化成多个可以解决的小问题，然后逐一进行解决。每个问题都会有一个模块去解决它，且每个问题包括抽象步骤和具体步骤。形式化方法是指采用严格的数学方法，使用形式化规约语言来精确定义软件系统。非形式化的开发方法是通过自然语言、图形或表格描述软件系统的行为和特性，然后基于这些描述进行设计和开发，而形式化开发则是基于数学的方式描述、开发和验证系统。",
                    "like": 0,
                    "answer": [
                        "B"
                    ],
                    "option": [
                        "自底向上开发方法",
                        "形式化开发方法",
                        "原型开发方法",
                        "非形式化开发方法"
                    ]
                },
                {
                    "index": 162,
                    "belong_page": 1,
                    "question_id": 303661,
                    "question_title": "软件开发工具是指用于辅助软件开发过程活动的各种软件，其中， （29） 是辅助建立软件系统的抽象模型的，例如Rose、Together、WinA&amp;D、 （30） 等。",
                    "question_type": 9,
                    "answer_type": 1,
                    "show_type_name": "单选题",
                    "new_parent_id": 303660,
                    "score_rule": "",
                    "material_text": null,
                    "sort_son": "1",
                    "analyze": "软件开发工具是指用于辅助软件开发过程活动的各种软件。其中，软件建模工具是辅助建立软件系统的抽象模型的。常见的软件建模工具包括 Rational Rose、Together、 WinA&amp;D、QuickUML、EclipseUML 等。",
                    "like": 0,
                    "answer": [
                        "D"
                    ],
                    "option": [
                        "编程工具",
                        "设计工具",
                        "测试工具",
                        "建模工具"
                    ]
                },
                {
                    "index": 163,
                    "belong_page": 1,
                    "question_id": 303662,
                    "question_title": "软件开发工具是指用于辅助软件开发过程活动的各种软件，其中， （29） 是辅助建立软件系统的抽象模型的，例如Rose、Together、WinA&amp;D、 （30） 等。",
                    "question_type": 9,
                    "answer_type": 1,
                    "show_type_name": "单选题",
                    "new_parent_id": 303660,
                    "score_rule": "",
                    "material_text": null,
                    "sort_son": "2",
                    "analyze": "软件开发工具是指用于辅助软件开发过程活动的各种软件。其中，软件建模工具是辅助建立软件系统的抽象模型的。常见的软件建模工具包括 Rational Rose、Together、 WinA&amp;D、QuickUML、EclipseUML 等。",
                    "like": 0,
                    "answer": [
                        "B"
                    ],
                    "option": [
                        "LoadRunner",
                        "QuickUML",
                        "Delphi",
                        "WinRunner"
                    ]
                },
                {
                    "index": 164,
                    "belong_page": 1,
                    "question_id": 303664,
                    "question_title": "软件概要设计将软件需求转化为软件设计的 （31） 和软件的 （32） 。",
                    "question_type": 9,
                    "answer_type": 1,
                    "show_type_name": "单选题",
                    "new_parent_id": 303663,
                    "score_rule": "",
                    "material_text": null,
                    "sort_son": "1",
                    "analyze": "从工程管理角度来看，软件设计可分为概要设计和详细设计两个阶段。概要设计也称为高层设计或总体设计，即将软件需求转化为数据结构和软件的系统结构;详细设计也称为低层设计，即对结构图进行细化，得到详细的数据结构与算法。",
                    "like": 0,
                    "answer": [
                        "B"
                    ],
                    "option": [
                        "算法流程",
                        "数据结构",
                        "交互原型",
                        "操作接口"
                    ]
                },
                {
                    "index": 165,
                    "belong_page": 1,
                    "question_id": 303665,
                    "question_title": "软件概要设计将软件需求转化为软件设计的 （31） 和软件的 （32） 。",
                    "question_type": 9,
                    "answer_type": 1,
                    "show_type_name": "单选题",
                    "new_parent_id": 303663,
                    "score_rule": "",
                    "material_text": null,
                    "sort_son": "2",
                    "analyze": "从工程管理角度来看，软件设计可分为概要设计和详细设计两个阶段。概要设计也称为高层设计或总体设计，即将软件需求转化为数据结构和软件的系统结构;详细设计也称为低层设计，即对结构图进行细化，得到详细的数据结构与算法。",
                    "like": 0,
                    "answer": [
                        "A"
                    ],
                    "option": [
                        "系统结构",
                        "算法流程",
                        "内部接口",
                        "程序流程"
                    ]
                },
                {
                    "index": 166,
                    "belong_page": 1,
                    "question_id": 303669,
                    "question_title": "基于构件的软件开发中，构件分类方法可以归纳为三大类： （35） 根据领域分析的结果将应用领域的概念按照从抽象到具体的顺序逐次分解为树形或有向无回路图结构； （36） 利用Facet描述构件执行的功能、被操作的数据、构件应用的语境或任意其他特征； （37） 使得检索者在阅读文档过程中可以按照人类的联想思维方式任意跳转到包含相关概念或构件的文档。",
                    "question_type": 9,
                    "answer_type": 1,
                    "show_type_name": "单选题",
                    "new_parent_id": 303668,
                    "score_rule": "",
                    "material_text": null,
                    "sort_son": "1",
                    "analyze": "<p>基于构件的软件开发中，已有的构件分类方法可以归纳为三大类∶</p><p>（1）关键字分类法</p><p>根据领域分析的结果将应用领域的概念按照从抽象到具体的顺序逐次分解为树形或有向无回路图结构。</p><p>（2）刻面分类法</p><p>利用 Facet（刻面）描述构件执行的功能、被操作的数据、构件应用的语境或任意其他特征。</p><p>（3）超文本方法</p><p>基于全文检索技术，使得检索者在阅读文档过程中可以按照人类的联想思维方式任意跳转到包含相关概念或构件的文档。</p>",
                    "like": 0,
                    "answer": [
                        "A"
                    ],
                    "option": [
                        "关键字分类法",
                        "刻面分类法",
                        "语义匹配法",
                        "超文本方法"
                    ]
                },
                {
                    "index": 167,
                    "belong_page": 1,
                    "question_id": 303670,
                    "question_title": "基于构件的软件开发中，构件分类方法可以归纳为三大类： （35） 根据领域分析的结果将应用领域的概念按照从抽象到具体的顺序逐次分解为树形或有向无回路图结构； （36） 利用Facet描述构件执行的功能、被操作的数据、构件应用的语境或任意其他特征； （37） 使得检索者在阅读文档过程中可以按照人类的联想思维方式任意跳转到包含相关概念或构件的文档。",
                    "question_type": 9,
                    "answer_type": 1,
                    "show_type_name": "单选题",
                    "new_parent_id": 303668,
                    "score_rule": "",
                    "material_text": null,
                    "sort_son": "2",
                    "analyze": "<p>基于构件的软件开发中，已有的构件分类方法可以归纳为三大类∶</p><p>（1）关键字分类法</p><p>根据领域分析的结果将应用领域的概念按照从抽象到具体的顺序逐次分解为树形或有向无回路图结构。</p><p>（2）刻面分类法</p><p>利用 Facet（刻面）描述构件执行的功能、被操作的数据、构件应用的语境或任意其他特征。</p><p>（3）超文本方法</p><p>基于全文检索技术，使得检索者在阅读文档过程中可以按照人类的联想思维方式任意跳转到包含相关概念或构件的文档。</p>",
                    "like": 0,
                    "answer": [
                        "B"
                    ],
                    "option": [
                        "关键字分类法",
                        "刻面分类法",
                        "超文本方法",
                        "语义匹配法"
                    ]
                },
                {
                    "index": 168,
                    "belong_page": 1,
                    "question_id": 303671,
                    "question_title": "基于构件的软件开发中，构件分类方法可以归纳为三大类： （35） 根据领域分析的结果将应用领域的概念按照从抽象到具体的顺序逐次分解为树形或有向无回路图结构； （36） 利用Facet描述构件执行的功能、被操作的数据、构件应用的语境或任意其他特征； （37） 使得检索者在阅读文档过程中可以按照人类的联想思维方式任意跳转到包含相关概念或构件的文档。",
                    "question_type": 9,
                    "answer_type": 1,
                    "show_type_name": "单选题",
                    "new_parent_id": 303668,
                    "score_rule": "",
                    "material_text": null,
                    "sort_son": "3",
                    "analyze": "<p>基于构件的软件开发中，已有的构件分类方法可以归纳为三大类∶</p><p>（1）关键字分类法</p><p>根据领域分析的结果将应用领域的概念按照从抽象到具体的顺序逐次分解为树形或有向无回路图结构。</p><p>（2）刻面分类法</p><p>利用 Facet（刻面）描述构件执行的功能、被操作的数据、构件应用的语境或任意其他特征。</p><p>（3）超文本方法</p><p>基于全文检索技术，使得检索者在阅读文档过程中可以按照人类的联想思维方式任意跳转到包含相关概念或构件的文档。</p>",
                    "like": 0,
                    "answer": [
                        "D"
                    ],
                    "option": [
                        "刻面分类法",
                        "关键字分类法",
                        "语义匹配法",
                        "超文本方法"
                    ]
                },
                {
                    "index": 169,
                    "belong_page": 1,
                    "question_id": 303672,
                    "question_title": "构件组装是指将库中的构件经适当修改后相互连接构成新的目标软件。 （38） 不属于构件组装技术。",
                    "question_type": 1,
                    "answer_type": 1,
                    "show_type_name": "单选题",
                    "new_parent_id": 303672,
                    "score_rule": "",
                    "material_text": "",
                    "sort_son": "0",
                    "analyze": "<p>构件组装是将库中的构件经适当修改后相互连接，或者将它们与当前开发项目中的软件元素相连接，最终构成新的目标软件。构件组装技术大致可分为基于功能的组装技术、基于数据的组装技术和面向对象的组装技术。</p><p>（1）基于功能的组装技术</p><p>基于功能的组装技术采用子程序调用和参数传递的方式将构件组装起来。它要求库中的构件以子程序/过程/函数的形式出现，并且接口说明必须清晰。当使用这种组装技术进行软件开发时，开发人员首先要对新系统进行功能分解，将系统分解为强内聚、松耦合的功能模块；然后根据各模块的功能需求提取构件，进行适应性修改后，再挂接到上述功能分解框架中。</p><p>（2）基于数据的组装技术</p><p>基于数据的组装技术首先根据当前软件问题的核心数据结构设计出一个框架，然后根据框架中各结点的需求提取构件并进行适应性修改，再将构件逐个分配至框架中的适当位置。此后，构件的组装方式仍然是传统的子程序调用与参数传递。这种组装技术也要求库中构件以子程序形式出现，但它所依赖的软件设计方法不再是功能分解，而是面向数据的设计方法，例如，Jackson系统开发方法。</p><p>（3）面向对象的组装技术</p><p>由于封装和继承特征，面向对象方法比其他软件开发方法更适合支持软件复用。在面向对象的软件开发方法中，如果从类库中检索出来的基类能够完全满足新系统的需求，则可以直接应用。否则，必须以基类为父类，生成相应的子类，以满足新系统的需求。</p>",
                    "like": 0,
                    "answer": [
                        "C"
                    ],
                    "option": [
                        "基于功能的构件组装技术",
                        "基于数据的构件组装技术",
                        "基于实现的构件组装技术",
                        "面向对象的构件组装技术"
                    ]
                },
                {
                    "index": 170,
                    "belong_page": 1,
                    "question_id": 303674,
                    "question_title": "软件逆向工程就是分析己有的程序，寻求比源代码更高级的抽象表现形式。在逆向工程导出信息的四个抽象层次中， （39） 包括反映程序各部分之间相互依赖关系的信息； （40） 包括反映程序段功能及程序段之间关系的信息。",
                    "question_type": 9,
                    "answer_type": 1,
                    "show_type_name": "单选题",
                    "new_parent_id": 303673,
                    "score_rule": "",
                    "material_text": null,
                    "sort_son": "1",
                    "analyze": "逆向工程过程能够导出过程的设计模型（实现级）、程序和数据结构信息（结构级）、对象模型、数据和控制流模型（功能级）以及 UML 状态图和部署图（领域级）。其中，结构级包括反映程序各部分之间相关依赖关系的信息; 功能级包括反映程序段功能及程序段之间关系的信息。",
                    "like": 0,
                    "answer": [
                        "B"
                    ],
                    "option": [
                        "实现级",
                        "结构级",
                        "功能级",
                        "领域级"
                    ]
                },
                {
                    "index": 171,
                    "belong_page": 1,
                    "question_id": 303675,
                    "question_title": "软件逆向工程就是分析己有的程序，寻求比源代码更高级的抽象表现形式。在逆向工程导出信息的四个抽象层次中， （39） 包括反映程序各部分之间相互依赖关系的信息； （40） 包括反映程序段功能及程序段之间关系的信息。",
                    "question_type": 9,
                    "answer_type": 1,
                    "show_type_name": "单选题",
                    "new_parent_id": 303673,
                    "score_rule": "",
                    "material_text": null,
                    "sort_son": "2",
                    "analyze": "逆向工程过程能够导出过程的设计模型（实现级）、程序和数据结构信息（结构级）、对象模型、数据和控制流模型（功能级）以及 UML 状态图和部署图（领域级）。其中，结构级包括反映程序各部分之间相关依赖关系的信息; 功能级包括反映程序段功能及程序段之间关系的信息。",
                    "like": 0,
                    "answer": [
                        "C"
                    ],
                    "option": [
                        "结构级",
                        "实现级",
                        "功能级",
                        "领域级"
                    ]
                },
                {
                    "index": 172,
                    "belong_page": 1,
                    "question_id": 303676,
                    "question_title": "（41） 是在逆向工程所获取信息的基础上修改或重构已有的系统，产生系统的一个新版本。",
                    "question_type": 1,
                    "answer_type": 1,
                    "show_type_name": "单选题",
                    "new_parent_id": 303676,
                    "score_rule": "",
                    "material_text": "",
                    "sort_son": "0",
                    "analyze": "重组是指在同一抽象级别上转换系统描述形式;设计恢复是指借助工具从已有程序中抽象出有关数据设计、总体结构设计和过程设计等方面的信息;重构工程是指在逆向工程所获得信息的基础上，修改或重构已有的系统，产生系统的一个新版本。",
                    "like": 0,
                    "answer": [
                        "D"
                    ],
                    "option": [
                        "逆向分析(Reverse Analysis)",
                        "重组 （Restructuring)",
                        "设计恢复（Design Recovery)",
                        "重构工程（Re-engineering)"
                    ]
                },
                {
                    "index": 173,
                    "belong_page": 1,
                    "question_id": 303678,
                    "question_title": "软件性能测试有多种不同类型的测试方法，其中， （42） 用于测试在限定的系统下考査软件系统极限运行的情况， （43） 可用于测试系统同时处理的在线最大用户数量。",
                    "question_type": 9,
                    "answer_type": 1,
                    "show_type_name": "单选题",
                    "new_parent_id": 303677,
                    "score_rule": "",
                    "material_text": null,
                    "sort_son": "1",
                    "analyze": "<p>软件性能测试类型包括负载测试、强度测试和容量测试等。其中：</p><p>（1）负载测试用于测试超负荷环境中程序是否能够承担；</p><p>（2）强度测试是在系统资源特别低的情况下考查软件系统极限运行情况；</p><p>（3）容量测试可用于测试系统同时处理的在线最大用户数量。</p>",
                    "like": 0,
                    "answer": [
                        "A"
                    ],
                    "option": [
                        "强度测试",
                        "负载测试",
                        "压力测试",
                        "容量测试"
                    ]
                },
                {
                    "index": 174,
                    "belong_page": 1,
                    "question_id": 303679,
                    "question_title": "软件性能测试有多种不同类型的测试方法，其中， （42） 用于测试在限定的系统下考査软件系统极限运行的情况， （43） 可用于测试系统同时处理的在线最大用户数量。",
                    "question_type": 9,
                    "answer_type": 1,
                    "show_type_name": "单选题",
                    "new_parent_id": 303677,
                    "score_rule": "",
                    "material_text": null,
                    "sort_son": "2",
                    "analyze": "<p>软件性能测试类型包括负载测试、强度测试和容量测试等。其中：</p><p>（1）负载测试用于测试超负荷环境中程序是否能够承担；</p><p>（2）强度测试是在系统资源特别低的情况下考查软件系统极限运行情况；</p><p>（3）容量测试可用于测试系统同时处理的在线最大用户数量。</p>",
                    "like": 0,
                    "answer": [
                        "D"
                    ],
                    "option": [
                        "强度测试",
                        "压力测试",
                        "负载测试",
                        "容量测试"
                    ]
                },
                {
                    "index": 175,
                    "belong_page": 1,
                    "question_id": 303712,
                    "question_title": "某工程项目包括六个作业A～F，各个作业的衔接关系以及所需时间见下表，作业D最多能拖延 （70）天，而不会影响该项目的总工期。<br/><img style=\"max-width:100%;height:auto\"  src=\"https://s2.51cto.com/images/20210717/1626519443431477.jpg\" title=\"1626519443431477.jpg\" alt=\"1.jpg\"/>",
                    "question_type": 1,
                    "answer_type": 1,
                    "show_type_name": "单选题",
                    "new_parent_id": 303712,
                    "score_rule": "",
                    "material_text": "",
                    "sort_son": "0",
                    "analyze": "<p>关键路径（所需天数最多的路径）∶ ABE，总工期=5 天+7天+2 天=14天。</p><p><img style=\"max-width:100%;height:auto\"  src=\"https://s2.51cto.com/images/20210717/1626519472505414.jpg\" title=\"1626519472505414.jpg\" alt=\"1.jpg\"/></p><p>作业 D、F 与作业 B、E可并行实施，为不影响总工期，作业 D、F可以在7天+ 2 天=9 天内完成，所以作业 D最多可以延迟 2 天。</p>",
                    "like": 0,
                    "answer": [
                        "C"
                    ],
                    "option": [
                        "0",
                        " 1 ",
                        "2",
                        "3"
                    ]
                },
                {
                    "index": 176,
                    "belong_page": 1,
                    "question_id": 307122,
                    "question_title": "<p>面向服务（Service-Oriented，SO）的开发方法将（回答此空）的定义与实现进行解耦，并将跨构件的功能调用暴露出来。该方法有三个主要的抽象级别，最低层的（）代表单个逻辑单元的事物，包含特定的结构化接口，并且返回结构化的响应；第二层的服务代表操作的逻辑分组；最高层的（）则是为了实现特定业务目标而执行的一组长期运行的动作或者活动。</p>",
                    "question_type": 1,
                    "answer_type": 1,
                    "show_type_name": "单选题",
                    "new_parent_id": 307122,
                    "score_rule": "",
                    "material_text": "",
                    "sort_son": "0",
                    "analyze": "<p>OO的应用构建在类和对象之上，随后发展起来的建模技术将相关对象按照业务功能进行分组，就形成了构件（Component）的概念。对于跨构件的功能调用，则采用接口的形式暴露出来。进一步将接口的定义与实现进行解耦，则催生了服务和面向服务（Service-Oriented，SO）的开发方法。由此可见，面向对象、基于构件、面向服务是三个递进的抽象层次。</p><p>SO方法有三个主要的抽象级别，分别是操作、服务和业务流程。位于最低层的操作代表单个逻辑单元的事物，执行操作通常会导致读、写或修改一个或多个持久性数据。服务的操作类似于对象的方法，它们都有特定的结构化接口，并且返回结构化的响应；位于第二层的服务代表操作的逻辑分组；最高层的业务流程则是为了实现特定业务目标而执行的一组长期运行的动作或活动，包括依据一组业务规则按照有序序列执行的一系列操作。其中操作的排序、选择和执行成为服务或流程的编排，典型的情况是调用已编排的服务来响应业务事件。</p>",
                    "like": 0,
                    "answer": [
                        "A"
                    ],
                    "option": [
                        " 接口 ",
                        "功能",
                        "活动",
                        "用例"
                    ]
                },
                {
                    "index": 177,
                    "belong_page": 1,
                    "question_id": 307123,
                    "question_title": "面向服务（Service-Oriented，SO）的开发方法将（）的定义与实现进行解耦，并将跨构件的功能调用暴露出来。该方法有三个主要的抽象级别，最低层的（回答此空）代表单个逻辑单元的事物，包含特定的结构化接口，并且返回结构化的响应；第二层的服务代表操作的逻辑分组；最高层的（）则是为了实现特定业务目标而执行的一组长期运行的动作或者活动。",
                    "question_type": 1,
                    "answer_type": 1,
                    "show_type_name": "单选题",
                    "new_parent_id": 307123,
                    "score_rule": "",
                    "material_text": "",
                    "sort_son": "0",
                    "analyze": "<p>OO的应用构建在类和对象之上，随后发展起来的建模技术将相关对象按照业务功能进行分组，就形成了构件（Component）的概念。对于跨构件的功能调用，则采用接口的形式暴露出来。进一步将接口的定义与实现进行解耦，则催生了服务和面向服务（Service-Oriented，SO）的开发方法。由此可见，面向对象、基于构件、面向服务是三个递进的抽象层次。</p><p>SO方法有三个主要的抽象级别，分别是操作、服务和业务流程。位于最低层的操作代表单个逻辑单元的事物，执行操作通常会导致读、写或修改一个或多个持久性数据。服务的操作类似于对象的方法，它们都有特定的结构化接口，并且返回结构化的响应；位于第二层的服务代表操作的逻辑分组；最高层的业务流程则是为了实现特定业务目标而执行的一组长期运行的动作或活动，包括依据一组业务规则按照有序序列执行的一系列操作。其中操作的排序、选择和执行成为服务或流程的编排，典型的情况是调用已编排的服务来响应业务事件。</p>",
                    "like": 0,
                    "answer": [
                        "C"
                    ],
                    "option": [
                        " 类 ",
                        " 对象 ",
                        " 操作 ",
                        " 状态 "
                    ]
                },
                {
                    "index": 178,
                    "belong_page": 1,
                    "question_id": 307124,
                    "question_title": "面向服务（Service-Oriented，SO）的开发方法将（）的定义与实现进行解耦，并将跨构件的功能调用暴露出来。该方法有三个主要的抽象级别，最低层的（）代表单个逻辑单元的事物，包含特定的结构化接口，并且返回结构化的响应；第二层的服务代表操作的逻辑分组；最高层的（回答此空）则是为了实现特定业务目标而执行的一组长期运行的动作或者活动。",
                    "question_type": 1,
                    "answer_type": 1,
                    "show_type_name": "单选题",
                    "new_parent_id": 307124,
                    "score_rule": "",
                    "material_text": "",
                    "sort_son": "0",
                    "analyze": "<p>OO的应用构建在类和对象之上，随后发展起来的建模技术将相关对象按照业务功能进行分组，就形成了构件（Component）的概念。对于跨构件的功能调用，则采用接口的形式暴露出来。进一步将接口的定义与实现进行解耦，则催生了服务和面向服务（Service-Oriented，SO）的开发方法。由此可见，面向对象、基于构件、面向服务是三个递进的抽象层次。</p><p>SO方法有三个主要的抽象级别，分别是操作、服务和业务流程。位于最低层的操作代表单个逻辑单元的事物，执行操作通常会导致读、写或修改一个或多个持久性数据。服务的操作类似于对象的方法，它们都有特定的结构化接口，并且返回结构化的响应；位于第二层的服务代表操作的逻辑分组；最高层的业务流程则是为了实现特定业务目标而执行的一组长期运行的动作或活动，包括依据一组业务规则按照有序序列执行的一系列操作。其中操作的排序、选择和执行成为服务或流程的编排，典型的情况是调用已编排的服务来响应业务事件。</p>",
                    "like": 0,
                    "answer": [
                        "B"
                    ],
                    "option": [
                        " 业务规则 ",
                        " 业务流程 ",
                        " 数据流 ",
                        " 控制流 "
                    ]
                },
                {
                    "index": 179,
                    "belong_page": 1,
                    "question_id": 307125,
                    "question_title": "<p>以下关于信息系统开发方法的叙述中，正确的是（）。</p>",
                    "question_type": 1,
                    "answer_type": 1,
                    "show_type_name": "单选题",
                    "new_parent_id": 307125,
                    "score_rule": "",
                    "material_text": "",
                    "sort_son": "0",
                    "analyze": "<p>可用排除法。结构化开发方法是自顶向下的开发方式，适用于那些需求不明确，但技术难度不大的系统开发；原型化开发方法适用于需求不明确的情况。</p>",
                    "like": 0,
                    "answer": [
                        "C"
                    ],
                    "option": [
                        " 原型化方法是自顶向下的，它提出了一组提高系统结构合理性的准则 ",
                        " 结构化方法与原型化方法的共同点是在系统开发初期必须明确系统的功能要求，确定系统边界 ",
                        " 面向服务方法以粗粒度、松散耦合和标准的服务为基础，加强了系统的可复用性和可演化性 ",
                        " 面向服务的方法适用于那些需求不明确，但技术难度不大的系统开发 "
                    ]
                },
                {
                    "index": 180,
                    "belong_page": 1,
                    "question_id": 307126,
                    "question_title": "<p>在系统开发中，原型可以划分为不同的种类。从原型是否实现功能来分，可以分为水平原型和垂直原型；从原型最终结果来分，可以分为抛弃式原型和演化式原型。以下关于原型的叙述中，正确的是（）。</p>",
                    "question_type": 1,
                    "answer_type": 1,
                    "show_type_name": "单选题",
                    "new_parent_id": 307126,
                    "score_rule": "",
                    "material_text": "",
                    "sort_son": "0",
                    "analyze": "<p>从原型是否实现功能来分，可分为水平原型和垂直原型两种。水平原型也称为行为原型，用来探索预期系统的一些特定行为，并达到细化需求的目的。水平原型通常只是功能的导航，但未真实实现功能。水平原型主要用在界面上。垂直原型也称为结构化原型，实现了一部分功能。垂直原型主要用在复杂的算法实现上。</p><p>从原型的最终结果来分，可分为抛弃式原型和演化式原型。抛弃式原型也称为探索式原型，是指达到预期目的后，原型本身被抛弃。抛弃式原型主要用在解决需求不确定性、二义性、不完整性、含糊性等。演化式原型为开发增量式产品提供基础，逐步将原型演化成最终系统，主要用在易于升级和优化的场合，适合于Web项目。</p>",
                    "like": 0,
                    "answer": [
                        "C"
                    ],
                    "option": [
                        " 水平原型适合于算法较为复杂的项目 ",
                        " 垂直原型适合于Web项目 ",
                        " 抛弃式原型适合于需求不确定、不完整、含糊不清的项目 ",
                        " 演化式原型主要用于界面设计 "
                    ]
                },
                {
                    "index": 181,
                    "belong_page": 1,
                    "question_id": 310848,
                    "question_title": "软件开发团队欲开发一套管理信息系统，在项目初期，用户提出了软件的一些基本功能，但是没有详细定义输入、处理和输出需求。在这种情况下，该团队在开发过程应采用（19）。",
                    "question_type": 1,
                    "answer_type": 1,
                    "show_type_name": "单选题",
                    "new_parent_id": 310848,
                    "score_rule": "",
                    "material_text": "",
                    "sort_son": "0",
                    "analyze": "在软件开发过程中,如果用户仅仅提出软件的—些基本功能,但是没有详细定义输入、处理和输出需求。在这种情况下,该软件开发团队应该采取原型开发方法最为合适。因此本题应该选C。",
                    "like": 0,
                    "answer": [
                        "C"
                    ],
                    "option": [
                        "瀑布模型",
                        "增量模型",
                        "原型开发模型",
                        "快速应用程序开发（RAD）"
                    ]
                },
                {
                    "index": 182,
                    "belong_page": 1,
                    "question_id": 310850,
                    "question_title": "统一软件开发过程是一种基于面向对象技术的软件开发过程，其特点是“用例驱动，以架构为核心，迭代并增量”。统一软件开发过程定义了四种通用的开发阶段，它们按照过程顺序分别是：起始阶段、（20）、构建阶段和（21），其中在构建阶段主要产生的文档有（22）。",
                    "question_type": 9,
                    "answer_type": 1,
                    "show_type_name": "单选题",
                    "new_parent_id": 310849,
                    "score_rule": "",
                    "material_text": null,
                    "sort_son": "1",
                    "analyze": "统一软件开发过程(UP)是一种基于面向对象技术的软件开发过程。其特点是“用例驱动，以架构为核心,迭代并增量”。统一软件过程定义了5种通用的框架活动,它们按照过程顺序分别是:起始阶段、细化阶段、构建阶段、交付阶段和生产价段.其中在构阶段主要产生的文档包括设计模型。因此20题应该选择B,21题选D,22题选D.",
                    "like": 0,
                    "answer": [
                        "B"
                    ],
                    "option": [
                        "分析阶段",
                        "细化阶段",
                        "设计阶段",
                        "交付阶段"
                    ]
                },
                {
                    "index": 183,
                    "belong_page": 1,
                    "question_id": 310851,
                    "question_title": "统一软件开发过程是一种基于面向对象技术的软件开发过程，其特点是“用例驱动，以架构为核心，迭代并增量”。统一软件开发过程定义了四种通用的开发阶段，它们按照过程顺序分别是：起始阶段、（20）、构建阶段和（21），其中在构建阶段主要产生的文档有（22）。",
                    "question_type": 9,
                    "answer_type": 1,
                    "show_type_name": "单选题",
                    "new_parent_id": 310849,
                    "score_rule": "",
                    "material_text": null,
                    "sort_son": "2",
                    "analyze": "统一软件开发过程(UP)是一种基于面向对象技术的软件开发过程。其特点是“用例驱动，以架构为核心,迭代并增量”。统一软件过程定义了5种通用的框架活动,它们按照过程顺序分别是:起始阶段、细化阶段、构建阶段、交付阶段和生产价段.其中在构阶段主要产生的文档包括设计模型。因此20题应该选择B,21题选D,22题选D.",
                    "like": 0,
                    "answer": [
                        "D"
                    ],
                    "option": [
                        "细化阶段",
                        "分析阶段",
                        "设计阶段",
                        "交付阶段"
                    ]
                },
                {
                    "index": 184,
                    "belong_page": 1,
                    "question_id": 310852,
                    "question_title": "统一软件开发过程是一种基于面向对象技术的软件开发过程，其特点是“用例驱动，以架构为核心，迭代并增量”。统一软件开发过程定义了四种通用的开发阶段，它们按照过程顺序分别是：起始阶段、（20）、构建阶段和（21），其中在构建阶段主要产生的文档有（22）。",
                    "question_type": 9,
                    "answer_type": 1,
                    "show_type_name": "单选题",
                    "new_parent_id": 310849,
                    "score_rule": "",
                    "material_text": null,
                    "sort_son": "3",
                    "analyze": "统一软件开发过程(UP)是一种基于面向对象技术的软件开发过程。其特点是“用例驱动，以架构为核心,迭代并增量”。统一软件过程定义了5种通用的框架活动,它们按照过程顺序分别是:起始阶段、细化阶段、构建阶段、交付阶段和生产价段.其中在构阶段主要产生的文档包括设计模型。因此20题应该选择B,21题选D,22题选D.",
                    "like": 0,
                    "answer": [
                        "D"
                    ],
                    "option": [
                        "初始用户手册",
                        "用例模型",
                        "项目计划",
                        "设计模型"
                    ]
                },
                {
                    "index": 185,
                    "belong_page": 1,
                    "question_id": 310854,
                    "question_title": "<p>螺旋模型将瀑布模型和（ ）结合起来，强调项目的风险分析，特别适合大型复杂系统的开发过程。螺旋模型沿着螺线进行若干次迭代，依次经历了计划指定、风险分析、工程实施和（ ）四个主要活动。</p>",
                    "question_type": 9,
                    "answer_type": 1,
                    "show_type_name": "单选题",
                    "new_parent_id": 310853,
                    "score_rule": "",
                    "material_text": null,
                    "sort_son": "1",
                    "analyze": "<p>本题主要考查对软件开发模型中的螺旋模型的概念。1988年，Barry Boehm正式发表了软件系统开发的“螺旋模型”，它将瀑布模型和快速原型模型结合起来，强调了其他模型所忽视的风险分析，特别适合于大型复杂的系统。螺旋模型沿着螺线进行若干次迭代，图中的四个象限代表了以下活动：</p><p>① 制定计划：确定软件目标，选定实施方案，弄清项目开发的限制条件；</p><p>② 风险分析：分析评估所选方案，考虑如何识别和消除风险；</p><p>③ 实施工程：实施软件开发和验证；</p><p>④ 客户评估：评价开发工作，提出修正建议，制定下一步计划。</p><p>螺旋模型由风险驱动，强调可选方案和约束条件从而支持软件的重用，有助于将软件质量作为特殊目标融入产品开发之中。但是，螺旋模型也有一定的限制条件，具体如下：</p><p>① 螺旋模型强调风险分析，但要求许多客户接受和相信这种分析，并做出相关反应是不容易的，因此，这种模型往往适应于内部的大规模软件开发。</p><p>② 如果执行风险分析将大大影响项目的利润，那么进行风险分析毫无意义，因此，螺旋模型只适合于大规模软件项目。</p><p>③ 软件开发人员应该擅长寻找可能的风险，准确地分析风险，否则将会带来更大的风险。</p><p>首先是确定一个阶段的目标，完成这些目标的选择方案及其约束条件，然后从风险角度分析方案的开发策略，努力排除各种潜在的风险，有时需要通过建造原型来完成。如果某些风险不能排除，该方案立即终止，否则启动下一个开发步骤。最后，评价该阶段的结果，并设计下一个阶段。</p>",
                    "like": 0,
                    "answer": [
                        "D"
                    ],
                    "option": [
                        "喷泉模型",
                        "增量模型",
                        "V模型",
                        "快速原型模型"
                    ]
                },
                {
                    "index": 186,
                    "belong_page": 1,
                    "question_id": 310855,
                    "question_title": "<p>螺旋模型将瀑布模型和（ ）结合起来，强调项目的风险分析，特别适合大型复杂系统的开发过程。螺旋模型沿着螺线进行若干次迭代，依次经历了计划指定、风险分析、工程实施和（ ）四个主要活动。</p>",
                    "question_type": 9,
                    "answer_type": 1,
                    "show_type_name": "单选题",
                    "new_parent_id": 310853,
                    "score_rule": "",
                    "material_text": null,
                    "sort_son": "2",
                    "analyze": "<p>本题主要考查对软件开发模型中的螺旋模型的概念。1988年，Barry Boehm正式发表了软件系统开发的“螺旋模型”，它将瀑布模型和快速原型模型结合起来，强调了其他模型所忽视的风险分析，特别适合于大型复杂的系统。螺旋模型沿着螺线进行若干次迭代，图中的四个象限代表了以下活动：</p><p>① 制定计划：确定软件目标，选定实施方案，弄清项目开发的限制条件；</p><p>② 风险分析：分析评估所选方案，考虑如何识别和消除风险；</p><p>③ 实施工程：实施软件开发和验证；</p><p>④ 客户评估：评价开发工作，提出修正建议，制定下一步计划。</p><p>螺旋模型由风险驱动，强调可选方案和约束条件从而支持软件的重用，有助于将软件质量作为特殊目标融入产品开发之中。但是，螺旋模型也有一定的限制条件，具体如下：</p><p>① 螺旋模型强调风险分析，但要求许多客户接受和相信这种分析，并做出相关反应是不容易的，因此，这种模型往往适应于内部的大规模软件开发。</p><p>② 如果执行风险分析将大大影响项目的利润，那么进行风险分析毫无意义，因此，螺旋模型只适合于大规模软件项目。</p><p>③ 软件开发人员应该擅长寻找可能的风险，准确地分析风险，否则将会带来更大的风险。</p><p>首先是确定一个阶段的目标，完成这些目标的选择方案及其约束条件，然后从风险角度分析方案的开发策略，努力排除各种潜在的风险，有时需要通过建造原型来完成。如果某些风险不能排除，该方案立即终止，否则启动下一个开发步骤。最后，评价该阶段的结果，并设计下一个阶段。</p>",
                    "like": 0,
                    "answer": [
                        "A"
                    ],
                    "option": [
                        "客户评估",
                        "客户使用",
                        "工程交付",
                        "软件测试"
                    ]
                },
                {
                    "index": 187,
                    "belong_page": 1,
                    "question_id": 310859,
                    "question_title": "软件的逆向工程是一个恢复设计的过程，从现有的程序中抽取数据、体系结构和过程的设计信息。逆向工程的完备性可以用在某一个抽象层次上提供信息的详细程度来描述，在大多数情况下，抽象层次越高，完备性就越低。下列可以通过逆向工程恢复的制品中，完备性最低的是（27）。",
                    "question_type": 1,
                    "answer_type": 1,
                    "show_type_name": "单选题",
                    "new_parent_id": 310859,
                    "score_rule": "",
                    "material_text": "",
                    "sort_son": "0",
                    "analyze": "软件的逆向工程是一个设计恢复的过程，从现有的程序中抽取数据、体系结构和过程的设计信息。逆向工程的完备性是指在某一个抽象层次上提供信息的详细程度，在大多数情况下，抽象层次越高，完备性就越低。逆向过程和实现该过程的工具的抽象层次是指可从源代码中抽取出来的设计信息的精密程度。理想情况下，抽象程度应该尽可能高。逆向工程过程应该能够导出过程的设计模型（一种底层的抽象）；程序和数据结构信息（稍高层次的抽象）；对象模型、数据和控制流模（相对高层的抽象）；UML图，状态及部署图（高层抽象）。随着抽象层次增高，完备性就会降低。因此本题应该选择D。",
                    "like": 0,
                    "answer": [
                        "D"
                    ],
                    "option": [
                        "过程的设计模型",
                        "程序和数据结构",
                        "对象模型、数据和控制流",
                        "UML状态图和部署图"
                    ]
                },
                {
                    "index": 188,
                    "belong_page": 1,
                    "question_id": 310878,
                    "question_title": "在客户关系管理（CRM）中，管理的对象是客户与企业之间的双向关系，那么在开发过程中， （42） 是开发的主要目标。",
                    "question_type": 1,
                    "answer_type": 1,
                    "show_type_name": "单选题",
                    "new_parent_id": 310878,
                    "score_rule": "",
                    "material_text": "",
                    "sort_son": "0",
                    "analyze": "CRM是一种以客户为中心的商业策略，注重的是与客户的交流，企业的经营是以客户为中心，而不是传统的以产品或以市场为中心。在注重提高客户的满意度的同时，一定要把帮助企业提高获取利润的能力作为重要指标。CRM的实施要求企业对其业务功能进行重新设计，并对工作流程进行重组，将业务的中心转移到客户，同时要针对不同的客户群体有重点的采取不同的策略。",
                    "like": 0,
                    "answer": [
                        "C"
                    ],
                    "option": [
                        "客户关系的生命周期管理",
                        "客户有关系的培育和维护",
                        "最大程度地帮助企业实现其经营目标",
                        "为客户扮演积极的角色，树立企业形象"
                    ]
                },
                {
                    "index": 189,
                    "belong_page": 1,
                    "question_id": 310889,
                    "question_title": "基于构件的软件开发中，构件分类方法可以归纳为三大类： (50) 根据领域分析的结果将应用领域的概念按照从抽象到具体的顺序逐次分解为树形或有向无回路图结构； (51) 利用Facet描述构件执行的功能、被操作的数据、构件应用的语境或任意其他特征; (52) 使得检索者在阅读文档过程中可以按照人类的联想思维方式任意跳转到包含相关概念或构件的文档。",
                    "question_type": 9,
                    "answer_type": 1,
                    "show_type_name": "单选题",
                    "new_parent_id": 310888,
                    "score_rule": "",
                    "material_text": null,
                    "sort_son": "1",
                    "analyze": "<p>基于构件的软件开发中，已有的构件分类方法可以归纳为三大类∶</p><p>（1）关键字分类法。根据领域分析的结果将应用领域的概念按照从抽象到具体的顺序逐次分解为树形或有向无回路图结构。</p><p>（2）刻面分类法。利用 Facet（刻面）描述构件执行的功能、被操作的数据、构件应用的语境或任意其他特征。</p><p>（3）超文本方法。基于全文检索技术，使得检索者在阅读文档过程中可以按照人类的联想思维方式任意跳转到包含相关概念或构件的文档。</p>",
                    "like": 0,
                    "answer": [
                        "A"
                    ],
                    "option": [
                        "关键字分类法",
                        "刻面分类法",
                        "语义匹配法",
                        "超文本方法"
                    ]
                },
                {
                    "index": 190,
                    "belong_page": 1,
                    "question_id": 310890,
                    "question_title": "基于构件的软件开发中，构件分类方法可以归纳为三大类： (50) 根据领域分析的结果将应用领域的概念按照从抽象到具体的顺序逐次分解为树形或有向无回路图结构； (51) 利用Facet描述构件执行的功能、被操作的数据、构件应用的语境或任意其他特征; (52) 使得检索者在阅读文档过程中可以按照人类的联想思维方式任意跳转到包含相关概念或构件的文档。",
                    "question_type": 9,
                    "answer_type": 1,
                    "show_type_name": "单选题",
                    "new_parent_id": 310888,
                    "score_rule": "",
                    "material_text": null,
                    "sort_son": "2",
                    "analyze": "<p>基于构件的软件开发中，已有的构件分类方法可以归纳为三大类∶</p><p>（1）关键字分类法。根据领域分析的结果将应用领域的概念按照从抽象到具体的顺序逐次分解为树形或有向无回路图结构。</p><p>（2）刻面分类法。利用 Facet（刻面）描述构件执行的功能、被操作的数据、构件应用的语境或任意其他特征。</p><p>（3）超文本方法。基于全文检索技术，使得检索者在阅读文档过程中可以按照人类的联想思维方式任意跳转到包含相关概念或构件的文档。</p>",
                    "like": 0,
                    "answer": [
                        "B"
                    ],
                    "option": [
                        "关键字分类法",
                        "刻面分类法",
                        "超文本方法",
                        "语义匹配法"
                    ]
                },
                {
                    "index": 191,
                    "belong_page": 1,
                    "question_id": 310891,
                    "question_title": "基于构件的软件开发中，构件分类方法可以归纳为三大类： (50) 根据领域分析的结果将应用领域的概念按照从抽象到具体的顺序逐次分解为树形或有向无回路图结构； (51) 利用Facet描述构件执行的功能、被操作的数据、构件应用的语境或任意其他特征; (52) 使得检索者在阅读文档过程中可以按照人类的联想思维方式任意跳转到包含相关概念或构件的文档。",
                    "question_type": 9,
                    "answer_type": 1,
                    "show_type_name": "单选题",
                    "new_parent_id": 310888,
                    "score_rule": "",
                    "material_text": null,
                    "sort_son": "3",
                    "analyze": "<p>基于构件的软件开发中，已有的构件分类方法可以归纳为三大类∶</p><p>（1）关键字分类法。根据领域分析的结果将应用领域的概念按照从抽象到具体的顺序逐次分解为树形或有向无回路图结构。</p><p>（2）刻面分类法。利用 Facet（刻面）描述构件执行的功能、被操作的数据、构件应用的语境或任意其他特征。</p><p>（3）超文本方法。基于全文检索技术，使得检索者在阅读文档过程中可以按照人类的联想思维方式任意跳转到包含相关概念或构件的文档。</p>",
                    "like": 0,
                    "answer": [
                        "D"
                    ],
                    "option": [
                        "刻面分类法",
                        "关键字分类法",
                        "语义匹配法",
                        "超文本方法"
                    ]
                },
                {
                    "index": 192,
                    "belong_page": 1,
                    "question_id": 312914,
                    "question_title": "某开发组在开发某个系统时，各个阶段具有严格的界限，只有一个阶段的获得认可才能进行下一个阶段的工作，则该开发组最可能采用的软件开发方法是 &nbsp;（） &nbsp;。",
                    "question_type": 1,
                    "answer_type": 1,
                    "show_type_name": "单选题",
                    "new_parent_id": 312914,
                    "score_rule": "",
                    "material_text": "",
                    "sort_son": "0",
                    "analyze": "结构化方法要求各个阶段具有严格的界限，一个阶段获得认可后才能进行下一个阶段的工作。",
                    "like": 0,
                    "answer": [
                        "B"
                    ],
                    "option": [
                        "构件化方法",
                        "结构化方法",
                        "面向对象方法",
                        "快速原型法"
                    ]
                },
                {
                    "index": 193,
                    "belong_page": 1,
                    "question_id": 312953,
                    "question_title": "软件开发模型大体上可以分为三种类型：第一种是以完全确定软件需求为前提的（） ；第二种是在软件开发初始 阶段只能提供基本需求时采用的（）；第三种是以形式化为基础的变换模型。",
                    "question_type": 9,
                    "answer_type": 1,
                    "show_type_name": "单选题",
                    "new_parent_id": 312952,
                    "score_rule": "",
                    "material_text": null,
                    "sort_son": "1",
                    "analyze": "软件开发模型大体上可以分为三种类型。第一种是以软件需求完全确定为前提的瀑布模型;第二种是在软件开发初 始阶段只能提供基本需求时采用的迭代式或渐进式模型，例如喷泉模型、螺旋模型、统一开发过程和敏捷方法等；第三 种是以形式化为基础的变换模型。",
                    "like": 0,
                    "answer": [
                        "B"
                    ],
                    "option": [
                        "协同模型",
                        "瀑布模型",
                        "交互式模型&nbsp;",
                        "迭代式模型"
                    ]
                },
                {
                    "index": 194,
                    "belong_page": 1,
                    "question_id": 312954,
                    "question_title": "软件开发模型大体上可以分为三种类型：第一种是以完全确定软件需求为前提的（） ；第二种是在软件开发初始 阶段只能提供基本需求时采用的（）；第三种是以形式化为基础的变换模型。",
                    "question_type": 9,
                    "answer_type": 1,
                    "show_type_name": "单选题",
                    "new_parent_id": 312952,
                    "score_rule": "",
                    "material_text": null,
                    "sort_son": "2",
                    "analyze": "<p>软件开发模型大体上可以分为三种类型。第一种是以软件需求完全确定为前提的瀑布模型;第二种是在软件开发初 始阶段只能提供基本需求时采用的迭代式或渐进式模型，例如喷泉模型、螺旋模型、统一开发过程和敏捷方法等；第三 种是以形式化为基础的变换模型。</p>",
                    "like": 0,
                    "answer": [
                        "D"
                    ],
                    "option": [
                        "瀑布模型",
                        "协同模型",
                        "交互式模型",
                        "迭代式模型"
                    ]
                },
                {
                    "index": 195,
                    "belong_page": 1,
                    "question_id": 312976,
                    "question_title": "某公司内部的库存管理系统和财务系统均为独立开发且具有C/S结构，公司在进行信息系统改造时，明确指出要采用最 小的代价实现库存系统和财务系统的一体化操作与管理。针对这种应用集成需求，以下集成方法中，最适合的是（ ）",
                    "question_type": 1,
                    "answer_type": 1,
                    "show_type_name": "单选题",
                    "new_parent_id": 312976,
                    "score_rule": "",
                    "material_text": "",
                    "sort_son": "0",
                    "analyze": "根据题干条件，库存管理系统和财务系统都是独立开发且具有C/S结构，并且集成时要求采用最小的代价实现库存系统和 财务系统的一体化操作与管理，因此只需要将两个系统的用户界面集成在一起即可在最小代价的条件下满足集成要求。",
                    "like": 0,
                    "answer": [
                        "B"
                    ],
                    "option": [
                        "数据集成",
                        "界面集成",
                        "方法集成",
                        "接口集成"
                    ]
                },
                {
                    "index": 196,
                    "belong_page": 1,
                    "question_id": 312977,
                    "question_title": "以下关于系统性能评估方法的描述，错误的是（）。 &nbsp;&nbsp;",
                    "question_type": 1,
                    "answer_type": 1,
                    "show_type_name": "单选题",
                    "new_parent_id": 312977,
                    "score_rule": "",
                    "material_text": "",
                    "sort_son": "0",
                    "analyze": "本题主要考查对各种系统性能评估方法的理解与掌握。指令执行速度法常用每秒百万次指令运算（MIPS)评估系统 性能；等效指令速度法评估系统性能时需要计算各类指令在程序中所占的比例；综合理论性能法（CPT)采用每秒百万次 理论运算（MTOPS) 评估系统性能；基准程序法主要针对CPU (有时包括主存）的性能，通常也会考虑I/O结构、操作系统、编译程序的效率等对系统性能的影响。",
                    "like": 0,
                    "answer": [
                        "B"
                    ],
                    "option": [
                        "指令执行速度法常用每秒百万次指令运算（MIPS)评估系统性能",
                        "基准程序法主要针对CPU (有时包括主存）的性能，但没有考虑I/O结构、 操作系统、编译程序的效率等对系统性能 的影响",
                        "等效指令速度法评估系统性能时需要计算各类指令在程序中所占的比例",
                        "综合理论性能法（CPT)采用每秒百万次理论运算（MTOPS)评估系统性能"
                    ]
                },
                {
                    "index": 197,
                    "belong_page": 1,
                    "question_id": 312982,
                    "question_title": "<p>在软件开发项目中，关键路径是项目事件网络中 （63） ，组成关键路径的活动称为关键活动。下图中的关键路径历时 （64） 个时间单位。<br/></p><img style=\"max-width:100%;height:auto\"  src=\"https://s2.51cto.com/images/20211014/1634141211828061.jpg\" title=\"1634141211828061.jpg\" alt=\"1.jpg\"/>",
                    "question_type": 9,
                    "answer_type": 1,
                    "show_type_name": "单选题",
                    "new_parent_id": 312981,
                    "score_rule": "",
                    "material_text": null,
                    "sort_son": "1",
                    "analyze": "<p>图论中给出了关键路径的定义，即源点到汇点的最长路径为关键路径。</p><p>关键路径的识别与计算：</p><p>通过观察法可得出关键路径为1—2—4—5—7—8—10，最长路径的历时为3+3+5+3+3+6=23。<br/><img style=\"max-width:100%;height:auto\"  src=\"https://s2.51cto.com/images/20211014/1634141331154646.jpg\" title=\"1634141331154646.jpg\" alt=\"1.jpg\"/></p>",
                    "like": 0,
                    "answer": [
                        "C"
                    ],
                    "option": [
                        "最长的回路",
                        "最短的回路",
                        "源点和汇点间的最长路径",
                        "源点和汇点间的最短路径"
                    ]
                },
                {
                    "index": 198,
                    "belong_page": 1,
                    "question_id": 312983,
                    "question_title": "<p>在软件开发项目中，关键路径是项目事件网络中 （63） ，组成关键路径的活动称为关键活动。下图中的关键路径历时 （64） 个时间单位。<br/></p><img style=\"max-width:100%;height:auto\"  src=\"https://s2.51cto.com/images/20211014/1634141211828061.jpg\" title=\"1634141211828061.jpg\" alt=\"1.jpg\"/>",
                    "question_type": 9,
                    "answer_type": 1,
                    "show_type_name": "单选题",
                    "new_parent_id": 312981,
                    "score_rule": "",
                    "material_text": null,
                    "sort_son": "2",
                    "analyze": "<p>图论中给出了关键路径的定义，即源点到汇点的最长路径为关键路径。</p><p>关键路径的识别与计算：</p><p>通过观察法可得出关键路径为1—2—4—5—7—8—10，最长路径的历时为3+3+5+3+3+6=23。<br/><img style=\"max-width:100%;height:auto\"  src=\"https://s2.51cto.com/images/20211014/1634141331154646.jpg\" title=\"1634141331154646.jpg\" alt=\"1.jpg\"/></p><p><br/></p>",
                    "like": 0,
                    "answer": [
                        "C"
                    ],
                    "option": [
                        "14",
                        "18",
                        "23",
                        "25"
                    ]
                },
                {
                    "index": 199,
                    "belong_page": 1,
                    "question_id": 312995,
                    "question_title": "<p>下图中的程序由A、B、C、D、E五个模块组成，下表中描述了这些模块之间的接口，每一个接口有一个编号。此外，模块A、D和E都要引用一个专用数据区。那么A和E之间耦合关系是（）。</p><p><img style=\"max-width:100%;height:auto\"  src=\"https://s2.51cto.com/images/20211014/1634142650184397.jpg\" title=\"1634142650184397.jpg\" alt=\"1.jpg\"/></p>",
                    "question_type": 1,
                    "answer_type": 1,
                    "show_type_name": "单选题",
                    "new_parent_id": 312995,
                    "score_rule": "",
                    "material_text": "",
                    "sort_son": "0",
                    "analyze": "由于模块A和模块E都引用了专用数据区的内容，所以是公共耦合。",
                    "like": 0,
                    "answer": [
                        "A"
                    ],
                    "option": [
                        " 公共耦合 ",
                        " 数据耦合 ",
                        "内容耦合",
                        "无耦合"
                    ]
                },
                {
                    "index": 200,
                    "belong_page": 1,
                    "question_id": 315924,
                    "question_title": "某软件企业在项目开发过程中目标明确，实施过程遵守既定的计划与流程，资源准备充分，权责到人，对整个流程进行严格的监测，控制与审查，符合企业管理体系与流程制度。因此，该企业达到了CMMI评估的（22）",
                    "question_type": 1,
                    "answer_type": 1,
                    "show_type_name": "单选题",
                    "new_parent_id": 315924,
                    "score_rule": "",
                    "material_text": "",
                    "sort_son": "0",
                    "analyze": "<p>在CMMI的已定义级中，开发过程，包括技术工作和管理工作，均已实现标准化、文档化。建立了完善的培训制度和专家评审制度，全部技术活动和管理活动均可控制，对项目进行中的过程、岗位和职责均有共同的理解。</p>",
                    "like": 0,
                    "answer": [
                        "B"
                    ],
                    "option": [
                        "可重复级",
                        "已定义级",
                        "量化级",
                        "优化级"
                    ]
                },
                {
                    "index": 201,
                    "belong_page": 1,
                    "question_id": 315925,
                    "question_title": "<p>产品配置是指一个产品在其生命周期各个阶段所产生的各种形式（机器可读或人工可读）和各种版本的(23)的集合</p>",
                    "question_type": 1,
                    "answer_type": 1,
                    "show_type_name": "单选题",
                    "new_parent_id": 315925,
                    "score_rule": "",
                    "material_text": "",
                    "sort_son": "0",
                    "analyze": "<p>产品配置是指一个产品在其生命周期各个阶段所产生的各种形式（机器可读或人工 可读）和各种版本的文挡、计算机程序、部件及数据的集合。</p>",
                    "like": 0,
                    "answer": [
                        "D"
                    ],
                    "option": [
                        " 需求规格说明、设计说明、测试报告 ",
                        "需求规格说明、设计说明、计算机程序",
                        "设计说明、用户手册、计算机程序",
                        "文档、计算机程序、部件及数据"
                    ]
                },
                {
                    "index": 202,
                    "belong_page": 1,
                    "question_id": 315926,
                    "question_title": "<p>需求管理的主要活动包括(24)</p>",
                    "question_type": 1,
                    "answer_type": 1,
                    "show_type_name": "单选题",
                    "new_parent_id": 315926,
                    "score_rule": "",
                    "material_text": "",
                    "sort_son": "0",
                    "analyze": "需求管理包括变更控制、版本控制、需求跟踪、需求状态跟踪。",
                    "like": 0,
                    "answer": [
                        "A"
                    ],
                    "option": [
                        "变更控制、版本控制、需求跟踪、需求状态跟踪",
                        "需求获取、变更控制、版本控制、需求跟踪",
                        "需求获取、需求建模、变更控制、版本控制",
                        "需求获取、需求建模、需求评审、需求跟踪"
                    ]
                },
                {
                    "index": 203,
                    "belong_page": 1,
                    "question_id": 315927,
                    "question_title": "<p>(25)包括编制每个需求与系统元素之间的联系文档，这些元素包括其它需求、体系结构、设计部件、源代码模块、测试、帮助文件和文档等。</p>",
                    "question_type": 1,
                    "answer_type": 1,
                    "show_type_name": "单选题",
                    "new_parent_id": 315927,
                    "score_rule": "",
                    "material_text": "",
                    "sort_son": "0",
                    "analyze": "<p>需求跟踪包括编制每个需求与系统元素之间的联系文档，这些元素包括其它需求、体系结构、设计部件、源代码模块、测试、帮助文件和文档等。</p>",
                    "like": 0,
                    "answer": [
                        "D"
                    ],
                    "option": [
                        "需求描述",
                        "需求分析",
                        "需求获取",
                        "需求跟踪"
                    ]
                },
                {
                    "index": 204,
                    "belong_page": 1,
                    "question_id": 315928,
                    "question_title": "<p>根据传统的软件生命周期方法学，可以把软件生命周期划分为（26）</p>",
                    "question_type": 1,
                    "answer_type": 1,
                    "show_type_name": "单选题",
                    "new_parent_id": 315928,
                    "score_rule": "",
                    "material_text": "",
                    "sort_son": "0",
                    "analyze": "<p>根据传统的软件生命周期方法学，可以把软件生命周期划分为软件定义、软件开发、软件运行、软件维护。</p>",
                    "like": 0,
                    "answer": [
                        "B"
                    ],
                    "option": [
                        "软件定义、软件开发、软件测试、软件维护",
                        "软件定义、软件开发、软件运行、软件维护",
                        "软件分析、软件设计、软件开发、软件维护",
                        "需求获取、软件设计、软件开发、软件测试"
                    ]
                },
                {
                    "index": 205,
                    "belong_page": 1,
                    "question_id": 315929,
                    "question_title": "以下关于敏捷方法的描述中,不属于敏捷方法核心思想的是（27）",
                    "question_type": 1,
                    "answer_type": 1,
                    "show_type_name": "单选题",
                    "new_parent_id": 315929,
                    "score_rule": "",
                    "material_text": "",
                    "sort_son": "0",
                    "analyze": "<p>敏捷方法是一种以人为核心、迭代、循序渐进的开发方法。</p><p>结构化开发方法是面向过程的。</p>",
                    "like": 0,
                    "answer": [
                        "B"
                    ],
                    "option": [
                        "&nbsp;敏捷方法是适应型,而非可预测型",
                        "敏捷方法以过程为本",
                        "敏捷方法是以人为本,而非以过程为本",
                        "敏捷方法是迭代代增量式的开发过程"
                    ]
                },
                {
                    "index": 206,
                    "belong_page": 1,
                    "question_id": 315930,
                    "question_title": "<p>RUP(Rational Unified Process)软件开发生命周期是一个二维的软件开发模型，其中，RUP的9个核心工作流中不包括（28）</p>",
                    "question_type": 1,
                    "answer_type": 1,
                    "show_type_name": "单选题",
                    "new_parent_id": 315930,
                    "score_rule": "",
                    "material_text": "",
                    "sort_son": "0",
                    "analyze": "<p>RUP(Rational Unified Process)软件开发生命周期是一个二维的软件开发模型，RUP的9个核心工作流有：</p><p>● 业务建模∶理解待开发系统所在的机构及其商业运作，确保所有参与人员对待开发系统所在的机构有共同的认识，评估待开发系统对所在机构的影响。</p><p>● 需求∶定义系统功能及用户界面，使客户知道系统的功能，使开发人员理解系统的需求，为项目预算及计划提供基础。</p><p>●分析与设计：把需求分析的结果转化为分析与设计模型。</p><p>● 实现∶把设计模型转换为实现结果，对开发的代码做单元测试，将不同实现人员开发的模块集成为可执行系统。</p><p>●测试∶检查各子系统的交互与集成，，验证所有需求是否均被正确实现，对发现的软件质量上的缺陷进行归档，对软件质量提出改进建议。</p><p>● 部署∶打包、分发、安装软件，升级旧系统;培训用户及销售人员，并提供技术支持。</p><p>● 配置与变更管理：跟踪并维护系统开发过程中产生的所有制品的完整性和一致性。</p><p>●项目管理∶为软件开发项目提供计划、人员分配、执行、监控等方面的指导，为风险管理提供框架。</p><p>●环境∶为软件开发机构提供软件开发环境，即提供过程管理和工具的支持。</p>",
                    "like": 0,
                    "answer": [
                        "C"
                    ],
                    "option": [
                        "业务建模",
                        "配置与变更管理",
                        "成本",
                        "环境"
                    ]
                },
                {
                    "index": 207,
                    "belong_page": 1,
                    "question_id": 315987,
                    "question_title": "某项目包括A~G七个作业，各作业之间的衔接关系和所需时间如下表：<br/><img style=\"max-width:100%;height:auto\"  src=\"https://s2.51cto.com/images/20211118/1637237501691111.png\" title=\"1637237501691111.png\" alt=\"image.png\"/><br/>其中，作业C所需的时间，乐观估计为5天，最可能为14天，保守估计为17天。假设其他作业都按计划进度实施，为使该项目按进度计划如期全部完成。作业C（70）。",
                    "question_type": 1,
                    "answer_type": 1,
                    "show_type_name": "单选题",
                    "new_parent_id": 315987,
                    "score_rule": "",
                    "material_text": "",
                    "sort_son": "0",
                    "analyze": "关键路径ABDEG=27天<br/>作业C的期望时间=（乐观时间+4×最可能时间+保守时间）/6=13。<p>项目的总工期，即关键路径为ABDEG=27天，活动C所在的路径ABCEG，需要25天，因此活动C比期望时间最多可拖延2天。</p>",
                    "like": 0,
                    "answer": [
                        "D"
                    ],
                    "option": [
                        "必须在期望时间内完成",
                        "必须在14天内完成",
                        "比期望时间最多可拖延1天",
                        "比期望时间最多可拖延2天"
                    ]
                },
                {
                    "index": 208,
                    "belong_page": 1,
                    "question_id": 350302,
                    "question_title": "<p>成本是信息系统生命周期内各阶段的所有投入之和，按照成本性态分类，可以分为固定成本、变动成本和混合成本。其中&nbsp;（19） 属于固定成本，&nbsp;（20） 属于变动成本。</p>",
                    "question_type": 9,
                    "answer_type": 1,
                    "show_type_name": "单选题",
                    "new_parent_id": 350301,
                    "score_rule": "",
                    "material_text": null,
                    "sort_son": "1",
                    "analyze": "<p>（1）固定成本。固定成本是指其总额在一定期间和一定业务量范围内，不受业务量变动的影响而保持固定不变的成本。例如，管理人员的工资、办公费、固定资产折旧费、员工培训费等。固定成本又可分为酌量性固定成本和约束性固定成本。酌量性固定成本是指管理层的决策可以影响其数额的固定成本，例如，广告费、员工培训费、技术开发经费等；约束性固定成本是指管理层无法决定其数额的固定成本，即必须开支的成本，例如，办公场地及机器设备的折旧费、房屋及设备租金、管理人员的工资等。</p><p>（2）变动成本。变动成本也称为可变成本，是指在一定时期和一定业务量范围内其总额随着业务量的变动而成正比例变动的成本。例如，直接材料费、产品包装费、外包费用、开发奖金等。变动成本也可以分为酌量性变动成本和约束性变动成本。开发奖金、外包费用等可看作是酌量性变动成本；约束性变动成本通常表现为系统建设的直接物耗成本，以直接材料成本最为典型。</p>",
                    "like": 0,
                    "answer": [
                        "A"
                    ],
                    "option": [
                        " 固定资产折旧费 ",
                        " 直接材料费 ",
                        " 产品包装费 ",
                        " 开发奖金 "
                    ]
                },
                {
                    "index": 209,
                    "belong_page": 1,
                    "question_id": 350303,
                    "question_title": "<p>成本是信息系统生命周期内各阶段的所有投入之和，按照成本性态分类，可以分为固定成本、变动成本和混合成本。其中&nbsp;（19） 属于固定成本，&nbsp;（20） 属于变动成本。</p>",
                    "question_type": 9,
                    "answer_type": 1,
                    "show_type_name": "单选题",
                    "new_parent_id": 350301,
                    "score_rule": "",
                    "material_text": null,
                    "sort_son": "2",
                    "analyze": "<p>（1）固定成本。固定成本是指其总额在一定期间和一定业务量范围内，不受业务量变动的影响而保持固定不变的成本。例如，管理人员的工资、办公费、固定资产折旧费、员工培训费等。固定成本又可分为酌量性固定成本和约束性固定成本。酌量性固定成本是指管理层的决策可以影响其数额的固定成本，例如，广告费、员工培训费、技术开发经费等；约束性固定成本是指管理层无法决定其数额的固定成本，即必须开支的成本，例如，办公场地及机器设备的折旧费、房屋及设备租金、管理人员的工资等。</p><p>（2）变动成本。变动成本也称为可变成本，是指在一定时期和一定业务量范围内其总额随着业务量的变动而成正比例变动的成本。例如，直接材料费、产品包装费、外包费用、开发奖金等。变动成本也可以分为酌量性变动成本和约束性变动成本。开发奖金、外包费用等可看作是酌量性变动成本；约束性变动成本通常表现为系统建设的直接物耗成本，以直接材料成本最为典型。</p>",
                    "like": 0,
                    "answer": [
                        "D"
                    ],
                    "option": [
                        " 员工培训费 ",
                        " 房屋租金 ",
                        " 技术开发经费 ",
                        " 外包费用 "
                    ]
                },
                {
                    "index": 210,
                    "belong_page": 1,
                    "question_id": 350308,
                    "question_title": "<p>下列关于联合需求计划（Joint Requirement Planning， JRP）的叙述中，不正确的是&nbsp;（24） 。</p>",
                    "question_type": 1,
                    "answer_type": 1,
                    "show_type_name": "单选题",
                    "new_parent_id": 350308,
                    "score_rule": "",
                    "material_text": "",
                    "sort_son": "0",
                    "analyze": "<p>本题考查 JRP 的相关概念。</p><p>JRP 是一个通过高度组织的群体会议来分析企业内的问题并获取需求的过程，它是联合 应用开发（JAD）的一部分。 JRP的主要意图是收集需求，而不是对需求进行分析和验证。 实施JRP时应把握的主要原则一是在JRP实施之前，应制定详细的议程，并严格遵照议程进 行；二是按照既定的时间安排进行；三是尽量完整地记录会议期间的内容；四是在讨论期间 尽量避免使用专业术语；五是充分运用解决冲突的技能；六是会议期间应设置充分的间歇时 间；七是鼓励团队取得一致意见，保证参加JRP的所有人员能够遵守实现约定的规则。</p>",
                    "like": 0,
                    "answer": [
                        "D"
                    ],
                    "option": [
                        " 在JRP实施之前，应制定详细的议程，并严格遵照议程进行 ",
                        " 在讨论期间尽量避免使用专业术语 ",
                        " JRP是一种相对来说成本较高，但十分有效的需求获取方法 ",
                        " JRP的主要目的是对需求进行分析和验证 "
                    ]
                },
                {
                    "index": 211,
                    "belong_page": 1,
                    "question_id": 350309,
                    "question_title": "<p>系统开发中，原型可以划分为不同的种类。从原型是否实现功能来分，可以分为水平原型和垂直原型；从原型最终结果来分，可以分为抛弃式原型和演化式原型。以下关于原型的叙述中，正确的是&nbsp;（25） 。</p>",
                    "question_type": 1,
                    "answer_type": 1,
                    "show_type_name": "单选题",
                    "new_parent_id": 350309,
                    "score_rule": "",
                    "material_text": "",
                    "sort_son": "0",
                    "analyze": "<p>本题考查原型开发方法的相关概念。</p><p>（A）水平原型主要用在界面上。</p><p>（B）垂直原型主要用在复杂的算法实现上,抛弃式原型主要用于界面设计。</p><p>（C） 抛弃式原型基本思路就是开始就做一个简单的界面设计，用来让用户有直观感受，从而可以提得出需求，等需求获取到之后，可以把这个界面原型抛弃不用。</p><p>（D）演化式原型主要用在必须易于升级和优化的场合，适合于Web项目。</p>",
                    "like": 0,
                    "answer": [
                        "C"
                    ],
                    "option": [
                        " 水平原型适合于算法较为复杂的项目 ",
                        " 垂直原型适合于Web项目 ",
                        " 抛弃式原型适合于需求不确定、不完整、含糊不清的项目 ",
                        " 演化式原型主要用于界面设计 "
                    ]
                },
                {
                    "index": 212,
                    "belong_page": 1,
                    "question_id": 350311,
                    "question_title": "<p>快速应用开发（Rapid Application Developmen1，RAD）通过使用基于&nbsp;（26） 的开发方法获得快速开发，当&nbsp;（27） 时，最适合采用RAD方法。</p>",
                    "question_type": 9,
                    "answer_type": 1,
                    "show_type_name": "单选题",
                    "new_parent_id": 350310,
                    "score_rule": "",
                    "material_text": null,
                    "sort_son": "1",
                    "analyze": "<p>快速应用开发是一种比传统生存周期法快得多的开发方法，它强调极短的开发周期。 RAD 模型是瀑布模型的一个高速变种，通过使用基于构件的开发方法获得快速开发。如果对 需求理解得很好且约束了项目范围， 利用这种模型可以很快地开发出功能完善的信息系统。 但是 RAD 也具有以下局限性。</p><p>（1）&nbsp;并非所有应用都适合 RAD，RAD 对模块化要求比较高。如果有哪一项功能不能被 模块化， 那么 RAD 所需要的构件就会有问题； 如果高性能是一个指标且该指标必须通过调 整接口使其适应系统构件才能获得， 则 RAD 也可能不能奏效。</p><p>（2）&nbsp;开发者和客户必须在很短的时间完成一系列的需求分析， 任何一方配合不当都会导致 RAD 项目失败。</p><p>（3）&nbsp;RAD只能用于管理信息系统的开发，不适合技术风险很高的情况。例如，当一个新系统要采用很多新技术，或当新系统与现有系统有较高的互操作性时就不适合使用RAD。</p>",
                    "like": 0,
                    "answer": [
                        "D"
                    ],
                    "option": [
                        " 用例 ",
                        " 数据结构 ",
                        " 剧情 ",
                        " 构件 "
                    ]
                },
                {
                    "index": 213,
                    "belong_page": 1,
                    "question_id": 350312,
                    "question_title": "<p>快速应用开发（Rapid Application Developmen1，RAD）通过使用基于&nbsp;（26） 的开发方法获得快速开发，当&nbsp;（27） 时，最适合采用RAD方法。</p>",
                    "question_type": 9,
                    "answer_type": 1,
                    "show_type_name": "单选题",
                    "new_parent_id": 350310,
                    "score_rule": "",
                    "material_text": null,
                    "sort_son": "2",
                    "analyze": "<p>快速应用开发是一种比传统生存周期法快得多的开发方法，它强调极短的开发周期。 RAD 模型是瀑布模型的一个高速变种，通过使用基于构件的开发方法获得快速开发。如果对 需求理解得很好且约束了项目范围， 利用这种模型可以很快地开发出功能完善的信息系统。 但是 RAD 也具有以下局限性。</p><p>（1）&nbsp;并非所有应用都适合 RAD，RAD 对模块化要求比较高。如果有哪一项功能不能被 模块化， 那么 RAD 所需要的构件就会有问题； 如果高性能是一个指标且该指标必须通过调 整接口使其适应系统构件才能获得， 则 RAD 也可能不能奏效。</p><p>（2）&nbsp;开发者和客户必须在很短的时间完成一系列的需求分析， 任何一方配合不当都会导致 RAD 项目失败。</p><p>（3）&nbsp;RAD只能用于管理信息系统的开发，不适合技术风险很高的情况。例如，当一个新系统要采用很多新技术，或当新系统与现有系统有较高的互操作性时就不适合使用RAD。</p>",
                    "like": 0,
                    "answer": [
                        "C"
                    ],
                    "option": [
                        " 一个新系统要采用很多新技术 ",
                        " 新系统与现有系统有较高的互操作性 ",
                        " 系统模块化程度较高 ",
                        " 用户不能很好地参与到需求分析中 "
                    ]
                },
                {
                    "index": 214,
                    "belong_page": 1,
                    "question_id": 350314,
                    "question_title": "<p>软件过程是制作软件产品的一组活动，以及结果，这些活动主要由软件人员来完成， 主要包括&nbsp;（28） 。软件过程模型是软件开发实际过程的抽象与概括，它应该包括构成软件过程的各种活动。软件过程有各种各样的模型，其中&nbsp;（29） 的活动之间存在因果关系，前一阶段工作的结果是后一段阶段工作的输入描述。</p>",
                    "question_type": 9,
                    "answer_type": 1,
                    "show_type_name": "单选题",
                    "new_parent_id": 350313,
                    "score_rule": "",
                    "material_text": null,
                    "sort_son": "1",
                    "analyze": "<p>软件过程是制作软件产品的一组活动，以及结果，这些活动主要由软件人员来完成，软件活动主要包括如下内容。</p><p>（1）软件描述：定义软件功能，以及使用的限制。</p><p>（2）软件开发：软件的设计和实现，软件工程人员制作出能满足描述的软件。</p><p>（3）软件有效性验证：软件必须经过严格的验证，以保证能够满足客户的需求。</p><p>（4）软件进化：软件随着客户需求的变化不断地改进。</p><p>瀑布模型的特点是因果关系紧密相连，前一个阶段工作的结果是后一个阶段工作的输入。或者说每一个阶段都建立在前一个阶段正确结果之上的，前一个阶段的错漏会隐蔽地带到后一个阶段，这种错误有时甚至可能是灾难性的。因此每一个阶段工作完成后都要进行审查和确认，这是非常重要的。历史上，瀑布模型起到了重要作用，它的出现有利于人员的组织管理，以及软件开发方法和工具的研究。</p>",
                    "like": 0,
                    "answer": [
                        "D"
                    ],
                    "option": [
                        " 软件描述、软件开发和软件测试 ",
                        " 软件开发、软件有效性验证和软件测试 ",
                        " 软件描述、软件设计、软件实现和软件测试 ",
                        " 软件描述、软件开发、软件有效性验证和软件进化 "
                    ]
                },
                {
                    "index": 215,
                    "belong_page": 1,
                    "question_id": 350315,
                    "question_title": "<p>软件过程是制作软件产品的一组活动，以及结果，这些活动主要由软件人员来完成， 主要包括&nbsp;（28） 。软件过程模型是软件开发实际过程的抽象与概括，它应该包括构成软件过程的各种活动。软件过程有各种各样的模型，其中&nbsp;（29） 的活动之间存在因果关系，前一阶段工作的结果是后一段阶段工作的输入描述。</p>",
                    "question_type": 9,
                    "answer_type": 1,
                    "show_type_name": "单选题",
                    "new_parent_id": 350313,
                    "score_rule": "",
                    "material_text": null,
                    "sort_son": "2",
                    "analyze": "<p>软件过程是制作软件产品的一组活动，以及结果，这些活动主要由软件人员来完成，软件活动主要包括如下内容。</p><p>（1）软件描述：定义软件功能，以及使用的限制。</p><p>（2）软件开发：软件的设计和实现，软件工程人员制作出能满足描述的软件。</p><p>（3）软件有效性验证：软件必须经过严格的验证，以保证能够满足客户的需求。</p><p>（4）软件进化：软件随着客户需求的变化不断地改进。</p><p>瀑布模型的特点是因果关系紧密相连，前一个阶段工作的结果是后一个阶段工作的输入。或者说每一个阶段都建立在前一个阶段正确结果之上的，前一个阶段的错漏会隐蔽地带到后一个阶段，这种错误有时甚至可能是灾难性的。因此每一个阶段工作完成后都要进行审查和确认，这是非常重要的。历史上，瀑布模型起到了重要作用，它的出现有利于人员的组织管理，以及软件开发方法和工具的研究。</p>",
                    "like": 0,
                    "answer": [
                        "A"
                    ],
                    "option": [
                        " 瀑布模型 ",
                        " 原型模式 ",
                        " 螺旋模型 ",
                        " 基于构建的模型 "
                    ]
                },
                {
                    "index": 216,
                    "belong_page": 1,
                    "question_id": 350317,
                    "question_title": "<p>&nbsp;（30） 适用于程序开发人员在地域上分布很广的开发团队，&nbsp;（31） 中，程序开发人员分成首席程序员和“类”程序员。</p>",
                    "question_type": 9,
                    "answer_type": 1,
                    "show_type_name": "单选题",
                    "new_parent_id": 350316,
                    "score_rule": "",
                    "material_text": null,
                    "sort_son": "1",
                    "analyze": "<p>（1） 极限编程在所有的敏捷型方法中是最引人瞩目的，它源于 Smalltalk 圈子，特别是 Kent Beck 和 Ward Cunningham 在 20 世纪 80 年代末的密切合作。该方法在一些对费用控制 严格的公司中的使用，已经被证明是非常有效的。</p><p>（2）水晶系列（Crystal）方法是由 Alistair Cockburn 提出的， 它与 XP 方法一样，都有 以人为中心的理念，但在实践上有所不同。Alistair 考虑到人们一般很难严格遵循一个纪律约 束很强的过程，因此与 XP 的高度纪律性不同， Alistair 探索了用最少纪律约束而仍能成功的 方法，从而在产出效率与易于运作上达到一种平衡。也就是说， 虽然水晶系列没有 XP 那样 的产出效率， 但会有更多的人能够接受并遵循它。</p><p>（3）开放式源码指的是开放源码界所用的一种运作方式，开放式源码项目的一个特别之 处就是程序开发人员在地域上分布很广。这使得它和其他敏捷方法不同，因为一般的敏捷方 法都强调项目组成员在同一地点工作。开放源码的一个突出特点就是查错排障的高度并行性， 任何人发现了错误都可将改正源码的“补丁”文件发给维护者，然后由维护者将这些“补丁” 或新增的代码并入源码库。</p><p>（4）SCRUM 已经出现很久， 该方法强调这样一个事实，即明确定义的可重复的方法过 程只限于在明确定义的可重复的环境中， 为明确定义的可重复的人员用来解决明确定义的可 重复的问题。</p><p>（5）功用驱动开发方法（FDD）由 Jeff De Luca 和大师 Peter Coad 提出，它致力于短时 的迭代阶段和可见可用的功能，在 FDD 中一个迭代周期一般是两周。在 FDD 中程序开发人 员分成两类， 即首席程序员和“类”程序员（Class Owner） 。首席程序员是最富有经验的开 发人员，他们是项目的协调者、设计者和指导者；“类”程序员则主要做源码编写。</p><p>（6）自适应软件开发（ASD）方法由Jim Highsmith提出，其核心是3个非线性且重叠 的开发阶段，即猜测、合作与学习。</p>",
                    "like": 0,
                    "answer": [
                        "B"
                    ],
                    "option": [
                        " 水晶系列（Crystal）开发方法 ",
                        " 开放式源码（Open Source）开发方法 ",
                        " SCRUM开发方法&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; ",
                        " 功用驱动开发方法（FDD） "
                    ]
                },
                {
                    "index": 217,
                    "belong_page": 1,
                    "question_id": 350318,
                    "question_title": "<p>&nbsp;（30） 适用于程序开发人员在地域上分布很广的开发团队，&nbsp;（31） 中，程序开发人员分成首席程序员和“类”程序员。</p>",
                    "question_type": 9,
                    "answer_type": 1,
                    "show_type_name": "单选题",
                    "new_parent_id": 350316,
                    "score_rule": "",
                    "material_text": null,
                    "sort_son": "2",
                    "analyze": "<p>（1） 极限编程在所有的敏捷型方法中是最引人瞩目的，它源于 Smalltalk 圈子，特别是 Kent Beck 和 Ward Cunningham 在 20 世纪 80 年代末的密切合作。该方法在一些对费用控制 严格的公司中的使用，已经被证明是非常有效的。</p><p>（2）水晶系列（Crystal）方法是由 Alistair Cockburn 提出的， 它与 XP 方法一样，都有 以人为中心的理念，但在实践上有所不同。Alistair 考虑到人们一般很难严格遵循一个纪律约 束很强的过程，因此与 XP 的高度纪律性不同， Alistair 探索了用最少纪律约束而仍能成功的 方法，从而在产出效率与易于运作上达到一种平衡。也就是说， 虽然水晶系列没有 XP 那样 的产出效率， 但会有更多的人能够接受并遵循它。</p><p>（3）开放式源码指的是开放源码界所用的一种运作方式，开放式源码项目的一个特别之 处就是程序开发人员在地域上分布很广。这使得它和其他敏捷方法不同，因为一般的敏捷方 法都强调项目组成员在同一地点工作。开放源码的一个突出特点就是查错排障的高度并行性， 任何人发现了错误都可将改正源码的“补丁”文件发给维护者，然后由维护者将这些“补丁” 或新增的代码并入源码库。</p><p>（4）SCRUM 已经出现很久， 该方法强调这样一个事实，即明确定义的可重复的方法过 程只限于在明确定义的可重复的环境中， 为明确定义的可重复的人员用来解决明确定义的可 重复的问题。</p><p>（5）功用驱动开发方法（FDD）由 Jeff De Luca 和大师 Peter Coad 提出，它致力于短时 的迭代阶段和可见可用的功能，在 FDD 中一个迭代周期一般是两周。在 FDD 中程序开发人 员分成两类， 即首席程序员和“类”程序员（Class Owner） 。首席程序员是最富有经验的开 发人员，他们是项目的协调者、设计者和指导者；“类”程序员则主要做源码编写。</p><p>（6）自适应软件开发（ASD）方法由Jim Highsmith提出，其核心是3个非线性且重叠 的开发阶段，即猜测、合作与学习。</p>",
                    "like": 0,
                    "answer": [
                        "D"
                    ],
                    "option": [
                        " 自适应软件开发（ASD）&nbsp; &nbsp;&nbsp; ",
                        " 极限编程（XP）开发方法&nbsp; ",
                        " 开放统一过程开发方法（OpenUP）&nbsp; ",
                        " 功用驱动开发方法（FDD） "
                    ]
                },
                {
                    "index": 218,
                    "belong_page": 1,
                    "question_id": 350364,
                    "question_title": "<p>在程序的执行过程中，系统用&nbsp;（67） 实现嵌套调用（递归调用）函数的正确返回。</p>",
                    "question_type": 1,
                    "answer_type": 1,
                    "show_type_name": "单选题",
                    "new_parent_id": 350364,
                    "score_rule": "",
                    "material_text": "",
                    "sort_son": "0",
                    "analyze": "<p>在程序执行过程中进行函数的嵌套调用，例如A调用B，B又调用C，C执行结束后应返回到B，B执行结束后再返回到A，这种情况下后调用的先返回，符合栈的后进先出原则。</p>",
                    "like": 0,
                    "answer": [
                        "C"
                    ],
                    "option": [
                        " 队列 ",
                        " 优先队列 ",
                        " 栈 ",
                        " 散列表 "
                    ]
                },
                {
                    "index": 219,
                    "belong_page": 1,
                    "question_id": 350367,
                    "question_title": "<p>某项目的双代号网络图如下所示，该项目的工期为&nbsp;（70） 。</p><img style=\"max-width:100%;height:auto\"  src=\"https://s2.51cto.com/images/20220909/1662697277510401.png\" title=\"1662697277510401.png\" alt=\"image.png\"/>",
                    "question_type": 1,
                    "answer_type": 1,
                    "show_type_name": "单选题",
                    "new_parent_id": 350367,
                    "score_rule": "",
                    "material_text": "",
                    "sort_son": "0",
                    "analyze": "<p>双代号网络图亦称“箭线图法”。关键路径即持续时间最长的线路，网络图中至少有一条关键路径。项目的工期就是找图中的关键路径，本题中关键路径有多条，例如：ADHKMP、ADILOP、BEHKMP、BEILOP，他们的工期都是19，因此本项目的工期为19。</p>",
                    "like": 0,
                    "answer": [
                        "C"
                    ],
                    "option": [
                        " 17 ",
                        " 18 ",
                        " 19 ",
                        " 20 "
                    ]
                },
                {
                    "index": 220,
                    "belong_page": 1,
                    "question_id": 352265,
                    "question_title": "<p>&nbsp;系统工程利用计算机作为工具，对系统的结构、&nbsp;（20） 、信息和反馈等进行分析， 以达到最优规划、最优&nbsp;（21） 、最优管理和最优控制的目的。</p>",
                    "question_type": 9,
                    "answer_type": 1,
                    "show_type_name": "单选题",
                    "new_parent_id": 352264,
                    "score_rule": "",
                    "material_text": null,
                    "sort_son": "1",
                    "analyze": "<p>系统工程是在 20 世纪中后期发展起来的一门新兴学科，最早产生于 20 世纪 40 年代左右 的美国。时至今日，系统工程已经成为现代社会高速发展不可或缺的一部分。它的诞生让自 然科学和社会科学中有关的思想、理论和方法根据总体协调的需要联系起来，综合应用并利 用现代电子计算机，对系统的结构、要素、信息和反馈等进行分析，以达到最优规划、最优 设计、最优管理和最优控制等目的。</p>",
                    "like": 0,
                    "answer": [
                        "D"
                    ],
                    "option": [
                        " 知识 ",
                        " 需求 ",
                        " 文档 ",
                        " 要素 "
                    ]
                },
                {
                    "index": 221,
                    "belong_page": 1,
                    "question_id": 352266,
                    "question_title": "<p>&nbsp;系统工程利用计算机作为工具，对系统的结构、&nbsp;（20） 、信息和反馈等进行分析， 以达到最优规划、最优&nbsp;（21） 、最优管理和最优控制的目的。</p>",
                    "question_type": 9,
                    "answer_type": 1,
                    "show_type_name": "单选题",
                    "new_parent_id": 352264,
                    "score_rule": "",
                    "material_text": null,
                    "sort_son": "2",
                    "analyze": "<p>系统工程是在 20 世纪中后期发展起来的一门新兴学科，最早产生于 20 世纪 40 年代左右 的美国。时至今日，系统工程已经成为现代社会高速发展不可或缺的一部分。它的诞生让自 然科学和社会科学中有关的思想、理论和方法根据总体协调的需要联系起来，综合应用并利 用现代电子计算机，对系统的结构、要素、信息和反馈等进行分析，以达到最优规划、最优 设计、最优管理和最优控制等目的。</p>",
                    "like": 0,
                    "answer": [
                        "B"
                    ],
                    "option": [
                        " 战略 ",
                        " 设计 ",
                        " 实现 ",
                        " 处理 "
                    ]
                },
                {
                    "index": 222,
                    "belong_page": 1,
                    "question_id": 352270,
                    "question_title": "<p>&nbsp;详细的项目范围说明书是项目成功的关键，&nbsp;（24） 不属于项目范围定义的输入。</p>",
                    "question_type": 1,
                    "answer_type": 1,
                    "show_type_name": "单选题",
                    "new_parent_id": 352270,
                    "score_rule": "",
                    "material_text": "",
                    "sort_son": "0",
                    "analyze": "<p>本题考查 JRP 的相关概念。</p><p>在初始项目范围说明书中已文档化的主要的可交付物、假设和约束条件的基础上准备详 细的项目范围说明书是项目成功的关键。范围定义的输入包括以下内容：</p><p>(1) 项目章程。如果项目章程或初始的范围说明书没有在项目执行组织中使用，信息需要进一步搜集和开发，以产生详细的项目范围说明书。</p><p>(2) &nbsp;项目范围管理计划。</p><p>(3) &nbsp;组织过程资产。</p><p>(4) &nbsp;批准的变更申请。</p>",
                    "like": 0,
                    "answer": [
                        "D"
                    ],
                    "option": [
                        " 项目章程 ",
                        " 项目范围管理计划 ",
                        " 批准的变更申请 ",
                        " 采购验收报告 "
                    ]
                },
                {
                    "index": 223,
                    "belong_page": 1,
                    "question_id": 352271,
                    "question_title": "<p>&nbsp;螺旋模型是原型模型与&nbsp;（25） 的结合。</p>",
                    "question_type": 1,
                    "answer_type": 1,
                    "show_type_name": "单选题",
                    "new_parent_id": 352271,
                    "score_rule": "",
                    "material_text": "",
                    "sort_son": "0",
                    "analyze": "<p>螺旋模型是原型模型与生命周期模型的一个结合。</p>",
                    "like": 0,
                    "answer": [
                        "A"
                    ],
                    "option": [
                        " 生命周期模型 ",
                        " 迭代模型 ",
                        " 演化模型 ",
                        " 喷泉模型 "
                    ]
                },
                {
                    "index": 224,
                    "belong_page": 1,
                    "question_id": 352272,
                    "question_title": "<p>&nbsp;以下关于需求陈述的描述中，&nbsp;（26） 是不正确的。</p>",
                    "question_type": 1,
                    "answer_type": 1,
                    "show_type_name": "单选题",
                    "new_parent_id": 352272,
                    "score_rule": "",
                    "material_text": "",
                    "sort_son": "0",
                    "analyze": "<p>需求应按照重要程度进行区别对待，并不是所有需求都应该被同等重视和满足。</p>",
                    "like": 0,
                    "answer": [
                        "D"
                    ],
                    "option": [
                        " 每一项需求都必须完整且准确地描述即将要开发的功能 ",
                        " 需求必须能够在系统及其运行环境的能力和约束条件内实现 ",
                        " 每一项需求记录的功能都必须是用户的真正需要 ",
                        " 所有需求都应该被重视和满足 "
                    ]
                },
                {
                    "index": 225,
                    "belong_page": 1,
                    "question_id": 352273,
                    "question_title": "<p>&nbsp;需求管理是一个对系统需求变更、了解和控制的过程，以下活动中，&nbsp;（27） 不属于需求管理的主要活动。</p>",
                    "question_type": 1,
                    "answer_type": 1,
                    "show_type_name": "单选题",
                    "new_parent_id": 352273,
                    "score_rule": "",
                    "material_text": "",
                    "sort_son": "0",
                    "analyze": "<p>需求管理活动包括变更控制、版本控制、需求跟踪、需求状态跟踪。</p>",
                    "like": 0,
                    "answer": [
                        "A"
                    ],
                    "option": [
                        " 需求收集 ",
                        " 版本控制 ",
                        " 需求跟踪 ",
                        " 变更控制 "
                    ]
                },
                {
                    "index": 226,
                    "belong_page": 1,
                    "question_id": 352275,
                    "question_title": "<p>&nbsp;基于 RUP 的软件过程是一个迭代过程， 一个开发周期包括初始、细化、构建和移交4 个阶段。每次通过这 4 个阶段就会产生一代软件，其中定义最终业务模型是&nbsp;（28） 阶段的任务。采用迭代式开发，&nbsp;（29） 。</p>",
                    "question_type": 9,
                    "answer_type": 1,
                    "show_type_name": "单选题",
                    "new_parent_id": 352274,
                    "score_rule": "",
                    "material_text": null,
                    "sort_son": "1",
                    "analyze": "<p>RUP 中的软件过程在时间上被分解为 4 个顺序的阶段，分别是初始阶段、细化阶段、构 建阶段和移交阶段。</p><p>初始阶段的任务是为系统建立业务模型并确定项目的边界；细化阶段的任务是分析问题 领域，建立完善的架构，淘汰项目中最高风险的元素；在构建阶段，要开发所有剩余的构件和应用程序功能，把这些构件集成为产品；移交阶段的重点是确保软件对最终用户是可用的。</p><p>基于 RUP 的软件过程是一个迭代过程，通过初始、细化、构建和移交 4 个阶段构成一个开发周期。每一个阶段都由一个或多个连续的选代（iteration）组成。迭代并不是重复地做相同的事，而是针对不同用例的细化和实现。每一个迭代都是一个完整的开发过程，它需要项目经理根据当前迭代所处的阶段以及上次迭代的结果，适当地对核心工作流中的行为进行裁剪。</p>",
                    "like": 0,
                    "answer": [
                        "A"
                    ],
                    "option": [
                        " 初始 ",
                        " 细化 ",
                        " 构建 ",
                        " 移交 "
                    ]
                },
                {
                    "index": 227,
                    "belong_page": 1,
                    "question_id": 352276,
                    "question_title": "<p>&nbsp;基于 RUP 的软件过程是一个迭代过程， 一个开发周期包括初始、细化、构建和移交4 个阶段。每次通过这 4 个阶段就会产生一代软件，其中定义最终业务模型是&nbsp;（28） 阶段的任务。采用迭代式开发，&nbsp;（29） 。</p>",
                    "question_type": 9,
                    "answer_type": 1,
                    "show_type_name": "单选题",
                    "new_parent_id": 352274,
                    "score_rule": "",
                    "material_text": null,
                    "sort_son": "2",
                    "analyze": "<p>RUP 中的软件过程在时间上被分解为 4 个顺序的阶段，分别是初始阶段、细化阶段、构 建阶段和移交阶段。</p><p>初始阶段的任务是为系统建立业务模型并确定项目的边界；细化阶段的任务是分析问题 领域，建立完善的架构，淘汰项目中最高风险的元素；在构建阶段，要开发所有剩余的构件和应用程序功能，把这些构件集成为产品；移交阶段的重点是确保软件对最终用户是可用的。</p><p>基于 RUP 的软件过程是一个迭代过程，通过初始、细化、构建和移交 4 个阶段构成一个开发周期。每一个阶段都由一个或多个连续的选代（iteration）组成。迭代并不是重复地做相同的事，而是针对不同用例的细化和实现。每一个迭代都是一个完整的开发过程，它需要项目经理根据当前迭代所处的阶段以及上次迭代的结果，适当地对核心工作流中的行为进行裁剪。</p>",
                    "like": 0,
                    "answer": [
                        "A"
                    ],
                    "option": [
                        " 每一个迭代都是一个完整的开发过程 ",
                        " 每一轮迭代的重点是对特定的用例进行部分实现 ",
                        " 在后续迭代中强调用户的主动参与 ",
                        " 通常以功能分解为基础 "
                    ]
                },
                {
                    "index": 228,
                    "belong_page": 1,
                    "question_id": 352277,
                    "question_title": "<p>&nbsp;以下关于敏捷方法的叙述中，&nbsp;（30） 是不正确的。</p>",
                    "question_type": 1,
                    "answer_type": 1,
                    "show_type_name": "单选题",
                    "new_parent_id": 352277,
                    "score_rule": "",
                    "material_text": "",
                    "sort_son": "0",
                    "analyze": "<p>敏捷开发以用户的需求进化为核心，采用迭代、循序渐进的方法进行软件开发。在敏捷 开发中，软件项目在构建初期被切分成多个子项目，各个子项目的成果都经过测试，具备可视、可集成和可运行使用的特征。换言之，就是把一个大项目分为多个相互联系， 但也可独立运行的小项目，并分别完成，在此过程中软件一直处于可使用状态。</p><p>敏捷型方法认为最根本的文档应该是源码，而不是繁琐的文档。</p>",
                    "like": 0,
                    "answer": [
                        "A"
                    ],
                    "option": [
                        " 敏捷型方法的思考角度是“面向文档”的 ",
                        " 极限编程是著名的敏捷开发方法 ",
                        " 敏捷型方法是“适应性”而非“预设性” ",
                        " 敏捷开发方法是迭代增量式的开发方法 "
                    ]
                },
                {
                    "index": 229,
                    "belong_page": 1,
                    "question_id": 352324,
                    "question_title": "<p>&nbsp;下图用白盒测试方法进行测试，图中有&nbsp;（67） 条路径，采用McCabe度量计算该程序图的环路复杂性为&nbsp;（68） 。</p><p></p><img style=\"max-width:100%;height:auto\"  src=\"https://s2.51cto.com/images/20220923/1663932395971027.png\" title=\"1663932395971027.png\" alt=\"image.png\"/>",
                    "question_type": 9,
                    "answer_type": 1,
                    "show_type_name": "单选题",
                    "new_parent_id": 352323,
                    "score_rule": "",
                    "material_text": null,
                    "sort_son": "1",
                    "analyze": "<p>路径覆盖是指选取足够的测试用例，使得程序的每条可能执行到的路径都至少经过一次（如果程序中有环路，则要求每条环路路径至少经过一次）。图中有4条路径。本题的环路复杂性为图中闭环的个数+1，结果是4。</p>",
                    "like": 0,
                    "answer": [
                        "B"
                    ],
                    "option": [
                        "&nbsp;3",
                        "&nbsp;4",
                        "&nbsp;5",
                        "&nbsp;6"
                    ]
                },
                {
                    "index": 230,
                    "belong_page": 1,
                    "question_id": 352325,
                    "question_title": "<p>&nbsp;下图用白盒测试方法进行测试，图中有&nbsp;（67） 条路径，采用McCabe度量计算该程序图的环路复杂性为&nbsp;（68） 。</p><p></p><img style=\"max-width:100%;height:auto\"  src=\"https://s2.51cto.com/images/20220923/1663932395971027.png\" title=\"1663932395971027.png\" alt=\"image.png\"/>",
                    "question_type": 9,
                    "answer_type": 1,
                    "show_type_name": "单选题",
                    "new_parent_id": 352323,
                    "score_rule": "",
                    "material_text": null,
                    "sort_son": "2",
                    "analyze": "<p>&nbsp;路径覆盖是指选取足够的测试用例，使得程序的每条可能执行到的路径都至少经过一次（如果程序中有环路，则要求每条环路路径至少经过一次）。 图中有4条路径。本题的环路复杂性为图中闭环的个数+1，所以结果是4。</p>",
                    "like": 0,
                    "answer": [
                        "B"
                    ],
                    "option": [
                        "3&nbsp;",
                        "4&nbsp;",
                        "5&nbsp;",
                        "6&nbsp;"
                    ]
                },
                {
                    "index": 231,
                    "belong_page": 1,
                    "question_id": 352327,
                    "question_title": "<p>&nbsp;项目经理为某政府网站改造项目制作了如下双代号网络图（单位：天），该项目的总工期为&nbsp;（69） 天。在项目实施的过程中，活动②—⑦比计划提前了2天，活动⑧—⑩实际工期是3天，活动⑥—⑦的工期增加了3天，判断对项目总工期的影响&nbsp;（70） 。</p><img style=\"max-width:100%;height:auto\"  src=\"https://s2.51cto.com/images/20220923/1663932489912514.png\" title=\"1663932489912514.png\" alt=\"image.png\"/>",
                    "question_type": 9,
                    "answer_type": 1,
                    "show_type_name": "单选题",
                    "new_parent_id": 352326,
                    "score_rule": "",
                    "material_text": null,
                    "sort_son": "1",
                    "analyze": "<p>找出关键路径为S-3-6-7-5-8-10-E，长度为37。</p><p>因为2-7为非关键路径，活动2-7比计划提前了2天对工期没有影响。</p><p>活动8-10在关键路径上，活动8-10实际工期是3天，比计划提前1天，总工期缩短1天。</p><p>活动6-7也在关键路径上，活动6-7的工期增加了3天，总工期增加3天。</p><p>综合来看，对项目总工期的影响是增加了2天。</p>",
                    "like": 0,
                    "answer": [
                        "B"
                    ],
                    "option": [
                        " 40 ",
                        " 37 ",
                        " 34 ",
                        " 32 "
                    ]
                },
                {
                    "index": 232,
                    "belong_page": 1,
                    "question_id": 352328,
                    "question_title": "<p>&nbsp;项目经理为某政府网站改造项目制作了如下双代号网络图（单位：天），该项目的总工期为&nbsp;（69） 天。在项目实施的过程中，活动②—⑦比计划提前了2天，活动⑧—⑩实际工期是3天，活动⑥—⑦的工期增加了3天，判断对项目总工期的影响&nbsp;（70） 。</p><img style=\"max-width:100%;height:auto\"  src=\"https://s2.51cto.com/images/20220923/1663932489912514.png\" title=\"1663932489912514.png\" alt=\"image.png\"/>",
                    "question_type": 9,
                    "answer_type": 1,
                    "show_type_name": "单选题",
                    "new_parent_id": 352326,
                    "score_rule": "",
                    "material_text": null,
                    "sort_son": "2",
                    "analyze": "<p>找出关键路径为S-3-6-7-5-8-10-E，长度为37。</p><p>因为2-7为非关键路径，活动2-7比计划提前了2天对工期没有影响。</p><p>活动8-10在关键路径上，活动8-10实际工期是3天，比计划提前1天，总工期缩短1天。</p><p>活动6-7也在关键路径上，活动6-7的工期增加了3天，总工期增加3天。</p><p>综合来看，对项目总工期的影响是增加了2天。</p>",
                    "like": 0,
                    "answer": [
                        "B"
                    ],
                    "option": [
                        " 没有影响 ",
                        " 加了2天 ",
                        " 增加了3天 ",
                        " 增加了4天 "
                    ]
                },
                {
                    "index": 233,
                    "belong_page": 1,
                    "question_id": 352365,
                    "question_title": "<p>项目时间管理中的过程包括（ &nbsp;）。</p>",
                    "question_type": 1,
                    "answer_type": 1,
                    "show_type_name": "单选题",
                    "new_parent_id": 352365,
                    "score_rule": "",
                    "material_text": "",
                    "sort_son": "0",
                    "analyze": "<p>时间管理的过程包括：</p><p>⑦活动定义</p><p>⑧活动排序</p><p>⑨活动的资源估算</p><p>⑩活动历时估算</p><p>⑪制定计划</p><p>⑫进度控制</p>",
                    "like": 0,
                    "answer": [
                        "B"
                    ],
                    "option": [
                        " 活动定义、活动排序、活动的资源估算和工作进度分解 ",
                        " 活动定义、活动排序、活动的资源估算、活动历时估算、制定计划和进度控制 ",
                        " 项目章程、项目范围管理计划、组织过程资产和批准的变更申请 ",
                        " 生产项目计划、项目可交付物说明、信息系统要求说明和项目度量标准 "
                    ]
                },
                {
                    "index": 234,
                    "belong_page": 1,
                    "question_id": 352391,
                    "question_title": "<p>对于开发模型来说，（）复用好、开发过程无间隙、节省时间。（）是瀑布与原型（演化）模型结合体，适用于复杂项目。（）需要用户参与，模块化要求高，不适用新技术。（）是用例驱动、架构为中心、迭代、增量。</p>",
                    "question_type": 9,
                    "answer_type": 1,
                    "show_type_name": "单选题",
                    "new_parent_id": 352390,
                    "score_rule": "",
                    "material_text": null,
                    "sort_son": "1",
                    "analyze": "<p>开发模型的特点如下：</p><img style=\"max-width:100%;height:auto\"  src=\"https://s2.51cto.com/images/20220923/1663935138807096.png\" title=\"1663935138807096.png\" alt=\"image.png\"/><br/>",
                    "like": 0,
                    "answer": [
                        "D"
                    ],
                    "option": [
                        " RAD模型&nbsp; ",
                        " 螺旋模型&nbsp; ",
                        " RUP模型&nbsp; ",
                        " 喷泉模型&nbsp; "
                    ]
                },
                {
                    "index": 235,
                    "belong_page": 1,
                    "question_id": 352392,
                    "question_title": "<p>对于开发模型来说，（）复用好、开发过程无间隙、节省时间。（）是瀑布与原型（演化）模型结合体，适用于复杂项目。（）需要用户参与，模块化要求高，不适用新技术。（）是用例驱动、架构为中心、迭代、增量。</p>",
                    "question_type": 9,
                    "answer_type": 1,
                    "show_type_name": "单选题",
                    "new_parent_id": 352390,
                    "score_rule": "",
                    "material_text": null,
                    "sort_son": "2",
                    "analyze": "<p>开发模型的特点如下：</p><img style=\"max-width:100%;height:auto\"  src=\"https://s2.51cto.com/images/20220923/1663935138807096.png\" title=\"1663935138807096.png\" alt=\"image.png\"/>",
                    "like": 0,
                    "answer": [
                        "B"
                    ],
                    "option": [
                        "&nbsp; RAD模型 ",
                        "&nbsp; 螺旋模型 ",
                        "&nbsp; RUP模型 ",
                        "&nbsp; 喷泉模型 "
                    ]
                },
                {
                    "index": 236,
                    "belong_page": 1,
                    "question_id": 352393,
                    "question_title": "<p>对于开发模型来说，（）复用好、开发过程无间隙、节省时间。（）是瀑布与原型（演化）模型结合体，适用于复杂项目。（）需要用户参与，模块化要求高，不适用新技术。（）是用例驱动、架构为中心、迭代、增量。</p>",
                    "question_type": 9,
                    "answer_type": 1,
                    "show_type_name": "单选题",
                    "new_parent_id": 352390,
                    "score_rule": "",
                    "material_text": null,
                    "sort_son": "3",
                    "analyze": "<p>开发模型的特点如下：</p><img style=\"max-width:100%;height:auto\"  src=\"https://s2.51cto.com/images/20220923/1663935138807096.png\" title=\"1663935138807096.png\" alt=\"image.png\"/>",
                    "like": 0,
                    "answer": [
                        "A"
                    ],
                    "option": [
                        " RAD模型&nbsp; &nbsp; ",
                        " 螺旋模型&nbsp;&nbsp; ",
                        " RUP模型&nbsp;&nbsp; ",
                        " 喷泉模型&nbsp; "
                    ]
                },
                {
                    "index": 237,
                    "belong_page": 1,
                    "question_id": 352394,
                    "question_title": "<p>对于开发模型来说，（）复用好、开发过程无间隙、节省时间。（）是瀑布与原型（演化）模型结合体，适用于复杂项目。（）需要用户参与，模块化要求高，不适用新技术。（）是用例驱动、架构为中心、迭代、增量。</p>",
                    "question_type": 9,
                    "answer_type": 1,
                    "show_type_name": "单选题",
                    "new_parent_id": 352390,
                    "score_rule": "",
                    "material_text": null,
                    "sort_son": "4",
                    "analyze": "<p>开发模型的特点如下：</p><img style=\"max-width:100%;height:auto\"  src=\"https://s2.51cto.com/images/20220923/1663935138807096.png\" title=\"1663935138807096.png\" alt=\"image.png\"/>",
                    "like": 0,
                    "answer": [
                        "C"
                    ],
                    "option": [
                        " RAD模型&nbsp; ",
                        " 螺旋模型 ",
                        " RUP模型 ",
                        " 喷泉模型 "
                    ]
                },
                {
                    "index": 238,
                    "belong_page": 1,
                    "question_id": 356204,
                    "question_title": "<p>数据资产的特征包括（18）</p><p>①可增值②可测试③可共享④可维护⑤可控制⑥可量化</p>",
                    "question_type": 1,
                    "answer_type": 1,
                    "show_type_name": "单选题",
                    "new_parent_id": 356204,
                    "score_rule": "",
                    "material_text": "",
                    "sort_son": "0",
                    "analyze": "<p>数据资产的特性包括：</p><p>可控制，可量化，可变现</p><p>虚拟性、共享性、时效性、安全性、交换性和规模性</p>",
                    "like": 0,
                    "answer": [
                        "D"
                    ],
                    "option": [
                        " ①②③④ ",
                        " ①②③⑤&nbsp;&nbsp; ",
                        " ①②④⑤&nbsp;&nbsp; ",
                        " ①③⑤⑥ "
                    ]
                },
                {
                    "index": 239,
                    "belong_page": 1,
                    "question_id": 356205,
                    "question_title": "<p>数据管理能力成熟度评估模型（DCMM）是我国首个数据管理领域的国家标准，DCMM提出了符合我国企业的数据管理框架，该框架将组织数据管理能力划分为8个能力域，分别为:数据战略、数据治理、数据架构、数据标准，数据质量、数据安全、（19）。</p>",
                    "question_type": 1,
                    "answer_type": 1,
                    "show_type_name": "单选题",
                    "new_parent_id": 356205,
                    "score_rule": "",
                    "material_text": "",
                    "sort_son": "0",
                    "analyze": "<p>DCMM评估内容包括数据战略、数据治理、数据架构、数据应用、数据安全、数据质量、数据标准和数据生存周期。</p>",
                    "like": 0,
                    "answer": [
                        "A"
                    ],
                    "option": [
                        " 数据应用和数据生存周期 ",
                        " 数据应用和数据测试 ",
                        " 数据维护和数据生存周期 ",
                        " 数据维护和数据测试&nbsp;&nbsp; "
                    ]
                },
                {
                    "index": 240,
                    "belong_page": 1,
                    "question_id": 356209,
                    "question_title": "<p>与瀑布模型相比，（22）降低了实现需求变更的成本，更容易得到客户对于已完成开发工作的反馈意见，并且客户可以更早地使用软件并从中获得价值。</p>",
                    "question_type": 1,
                    "answer_type": 1,
                    "show_type_name": "单选题",
                    "new_parent_id": 356209,
                    "score_rule": "",
                    "material_text": "",
                    "sort_son": "0",
                    "analyze": "<p>增量式开发相比于瀑布模型的一些重要优点：</p><p>降低了适应用户需求变更的成本。重新分析和修改文档的工作量较之瀑布模型要少很多。</p><p>在开发过程中更容易得到用户对于已做的开发工作的反馈意见。用户可以评价软件的现实版本，并可以看到已经实现了多少。这比让用户从软件设计文档中判断工程进度要好很多。</p><p>使更快地交付和部署有用的软件到客户方变成了可能，虽然不是所有的功能都已经包含在内。相比于瀑布模型，用户可以更早地使用软件并创造商业价值。</p>",
                    "like": 0,
                    "answer": [
                        "C"
                    ],
                    "option": [
                        " 快速原型模型 ",
                        " 敏捷开发 ",
                        " 增量式开发 ",
                        " 智能模型 "
                    ]
                },
                {
                    "index": 241,
                    "belong_page": 1,
                    "question_id": 356210,
                    "question_title": "<p>CMMI是软件企业进行多方面能力评价的、集成的成熟度模型，软件企业在实施过程中，为了达到本地化，应组织体系编写组，建立基于CMMI的软件质量管理体系文件，体系文件的层次结构一般分为四层，包括:①顶层方针②模板类文件③过程文件④规程文件按照自顶向下的塔型排列，以下顺序正确的是（23）。</p>",
                    "question_type": 1,
                    "answer_type": 1,
                    "show_type_name": "单选题",
                    "new_parent_id": 356210,
                    "score_rule": "",
                    "material_text": "",
                    "sort_son": "0",
                    "analyze": "<p>软件过程构架结构由四个层次组成：方针、过程、规程和第四层的标准、规范、指南、模板、Checklist等组成。</p><p>1、方针为第一层文件，它是组织标准软件的高层次的抽象描述，它反映在公司的过程改进总体方针、政策中，由公司主管副总裁批准执行。</p><p>2、过程为第二层文件，主要规定在项目开发中执行该过程时应当执行的各项活动及适用标准。过程定义文件及其相关文件制定必须符合方针的要求。</p><p>3、规程为第三层文件，是对过程某些复杂活动的具体描述。</p><p>4、标准、规范、指南、模板、Checklist、范例库等是对上级过程或规程提供细致的步骤、活动及说明的支持性文档，第四层的文件从属于上级过程。</p>",
                    "like": 0,
                    "answer": [
                        "D"
                    ],
                    "option": [
                        " ①④③② ",
                        " ①④②③&nbsp; ",
                        " ①②③④ ",
                        " ①③④② "
                    ]
                },
                {
                    "index": 242,
                    "belong_page": 1,
                    "question_id": 356216,
                    "question_title": "<p>（29）的常见功能包括版本控制、变更管理、配置状态管理、访问控制和安全控制等。</p>",
                    "question_type": 1,
                    "answer_type": 1,
                    "show_type_name": "单选题",
                    "new_parent_id": 356216,
                    "score_rule": "",
                    "material_text": "",
                    "sort_son": "0",
                    "analyze": "<p>软件配置管理工具是指支持完成配置项标识、版本控制、变化控制、审计和状态统计等任务的工具，主要有下述功能：</p><p>(1)配置支持。配置是一组有共同目的的中间软件产品，其中每一个中间软件产品称为一个配置项。软件配置管理支持用户建立配置项之间的各种关系，并对这些关系加以维护，维护这些关系有助于完成某些特定任务(例如Build)和标识某一变化对整个系统开发的影响。&nbsp;[1]&nbsp;</p><p>(2)版本控制。版本控制是软件配置管理的基本要求，它可以保证在任何时刻恢复任何一个版本、版本控制还记录每个配置项的发展历史，这样就保证了版本之间的可追踪性，也为查找错误提供了帮助，版本控制也是支持并行开发的基础。</p><p>(3)变更控制。变更控制是指在整个软件生存周期中对软件变更的控制。变更控制系统记录每次变更的相关信息(变更的原因、变更的实施者以及变更的内容等)。这些信息有助于追踪出现的各种问题。</p><p>(4)构造支持。软件系统往往由许多配置项构成，建立整个系统是个复杂和费时的过程，软件配置管理工具可以记录和追踪每个配置项信息，帮助用户自动和快速地建立系统，和版本控制结合在一起，可以有效地支持同时开发系统的多个版本。</p><p>(5)过程支持。过程详细描述了各种人员在整个软件生存周期中如何使用整个系统，过程控制可以保证每一步都按照正确的顺序由合适的人员实施。过程控制本来是软件开发环境中一个独立的部分，软件配置管理也开始提供这部分功能。软件配置管理工具对过程的支持还很不够，而且支持方式差别也很大，许多管理只是提供一个预先定义好的生存周期模型，并保证开发的每一步都按照这个模型规定进行。</p><p>(6)团队支持。团队支持是指多个开发人员同时开发一个软件系统。大多数软件系统都需要多个开发人员参与，有效的团队支持对开发人员是很有用的。团队支持主要包括工作区管理、并行开发管理和远程开发管理(某些软件配置管理工具还包括对开发人员支持)。</p>",
                    "like": 0,
                    "answer": [
                        "D"
                    ],
                    "option": [
                        " 软件测试工具 ",
                        " 版本控制工具 ",
                        " 软件维护工具 ",
                        " 软件配置管理工具 "
                    ]
                },
                {
                    "index": 243,
                    "belong_page": 1,
                    "question_id": 356265,
                    "question_title": "<p>某项目包括A、B、C、D四道工序，各道工序之间的衔接关系、正常进度下各工序所需的时间和直接费用、赶工进度下所需的时间和直接费用如下表所示。该项目每天需要的间接费用为4.5万元。根据此表，以最低成本完成该项目需要（70）天。</p><img style=\"max-width:100%;height:auto\"  src=\"https://s2.51cto.com/images/20221122/1669108956506875.png\" title=\"1669108956506875.png\" alt=\"image.png\"/>",
                    "question_type": 1,
                    "answer_type": 1,
                    "show_type_name": "单选题",
                    "new_parent_id": 356265,
                    "score_rule": "",
                    "material_text": "",
                    "sort_son": "0",
                    "analyze": "<p>本题考查项目管理中的成本优化。从题目分析可得以下表格：</p><img style=\"max-width:100%;height:auto\"  src=\"https://s2.51cto.com/images/20221122/1669108986261834.png\" title=\"1669108986261834.png\" alt=\"image.png\"/><br/><p>1.绘制正常进度计划网络图如下：</p><img style=\"max-width:100%;height:auto\"  src=\"https://s2.51cto.com/images/20221122/1669109006454395.png\" title=\"1669109006454395.png\" alt=\"image.png\"/><br/><p>由上图可知，正常进度的关键路径为A-C-D，总工期为3+4+5＝l2天，总费用为10+15+12+8+12*4.5=99。</p><p>2.全部赶工后的工期，关键路径是A-C-D，总工期为1+2+2=5天，总费用为18+19+20+14+5*4.5=93.5。因为压缩过度，这个费用没有达到理想状态。</p><img style=\"max-width:100%;height:auto\"  src=\"https://s2.51cto.com/images/20221122/1669109020733690.png\" title=\"1669109020733690.png\" alt=\"image.png\"/><br/><p>要想合理压缩成本，关键是在缩短总工期、减少间接费用的同时不引起直接费用显著增加，因此必须先缩短关键路径上的作业时间，详细操作如下：</p><p>3. 因为D是关键路径上的活动，而且压缩单位费用最低（2万/天），对D先压缩2天，总工期减为10天。本步骤增加直接费用2*2=4万元，节省间接费用2*4.5=9万元，节省费用9-4=5万元。此时总费用为99-5=94万元，关键路径有两条：A-B和A-C-D。如下图。</p><img style=\"max-width:100%;height:auto\"  src=\"https://s2.51cto.com/images/20221122/1669109036441346.png\" title=\"1669109036441346.png\" alt=\"image.png\"/><br/><p>4. 把两条关键路径上的B和D同时压缩1天，总工期减为9天，本步骤增加直接费用2+1=3万元，节省间接费用4.5万元，节省费用4.5-3=1.5万元。此时总费用为94-1.5=92.5万元，关键路径仍为A-B和A-C-D。如下图。</p><img style=\"max-width:100%;height:auto\"  src=\"https://s2.51cto.com/images/20221122/1669109049313711.png\" title=\"1669109049313711.png\" alt=\"image.png\"/><br/><p>5.最后把两条路径公共的工序A压缩2天，总工期减为7天，本步骤增加直接费用2*4=8万元，节省间接费用2*4.5=9万元，节省费用9-8=1万元。此时总费用为92.5-1=91.5万元，关键路径仍为A-B和A-C-D。如下图。</p><img style=\"max-width:100%;height:auto\"  src=\"https://s2.51cto.com/images/20221122/1669109067673656.png\" title=\"1669109067673656.png\" alt=\"image.png\"/><br/><p>至此，A、B、C、D均已赶工到最大限度，总工期为7天，总费用为91.5万元，为最低成本。</p>",
                    "like": 0,
                    "answer": [
                        "A"
                    ],
                    "option": [
                        "7",
                        "9",
                        "10",
                        "5"
                    ]
                },
                {
                    "index": 244,
                    "belong_page": 1,
                    "question_id": 54269,
                    "question_title": "<p>阅读以下关于软件架构设计的叙述，在答题纸上回答问题1至问题3<br/>某公司要在现场开发一个网站应用系统，该系统的特点是：规模不大；工期短；用户需求不明确；没有大的技术风险；系统中的一些模块可以外包给其他的公司开发。在选择开发过程时，项目组内产生了分歧。<br/>王工提出采用XP（eXtreme Programming，极限编程），理由是XP方法简洁，能减轻开发人员的负担、快速适应市场、缩短投资回收期。<br/>李工认为采用XP在项目开发中存在一些问题，建议考虑原型开发方法。<br/>双方就上述的问题展开了激烈的争论。项目组最后决定采用XP，但同时针对李工提出的XP中存在的问题采取了相应的措施。<br/>【问题1】（8分）<br/>小规模发布（small release）是XP的基本元素之一。请用200字以内文字分别阐明：<br/>（1）原型系统和XP小规模发布的系统的主要差别？<br/>（2）为什么该项目组没有采用原型开发方法？<br/>【问题2】（8分）<br/>请用200字以内文字，简要说明采用XP方法可能会存在哪些问题。<br/>【问题3】（9分）<br/>在项目组的后续讨论中，李工提出，如果项目规模扩大，XP将不再适用。王工对此表示赞同，但同时提出可以将XP方法和传统软件开发过程相结合。请用200字以内的文字简要地说明如何将XP方法和传统软件开发过程相结合。</p>",
                    "question_type": 5,
                    "answer_type": 5,
                    "show_type_name": null,
                    "new_parent_id": 54269,
                    "score_rule": "",
                    "material_text": null,
                    "sort_son": "0",
                    "analyze": "<p>无</p>",
                    "like": 0,
                    "answer": [
                        "<p>【问题1】<br/>（1）原型系统和XP小型发布的系统的主要差别是功能。采用原型系统主要是让用户确认需求，或者用来测试关键的技术，但是它展示的功能并不是实际系统的功能，不能用来评价实际的系统；XP小型发布的系统考试时不包括足够的功能，但是每个功能和可发布的产品的定义是一样的。在完整性上，它配备了一系列实用的功能集；在质量上，它可以健壮地运行。<br/>（2）在该项目中，不需要开发原型系统。<br/>由于项目没有大的技术风险，所以不需要用原型系统来测试关键技术。<br/>网站系统的开发和原型系统的开发在工作量上是相当的，在时间要求短的情况下，直接开发系统可以节省时间。<br/>对于用户需求经常发生变化的情况，可以采用XP开发方法的代码重构、持续集成和小型发布等技术。<br/>【问题2】<br/>（1）开发团队、管理层，以及客户的不理解，阻碍XP方法论实施。<br/>（2）导致开发团队忽视文档，以XP为借口拒绝编写甚至是必须的文档。<br/>（3）XP是针对单一团队设计的，外包方的参与将会为有效的组织带来很大的困难。<br/>（4）缺乏客户的参与，导致用户故事编写、优先级确认等工作遇到困难。<br/>（5）项目规模扩大后，XP方法论将不适应。<br/>（6）对客户、开发人员和管理者的素质要求较高。<br/>【问题3】<br/>（1）可以将XP和传统软件开发过程中的增量式开发过程相结合。<br/>（2）将大规模项目划分为若干个具有共同目标的小规模项目，用XP方法论组织小项目开发，用传统软件过程方法论监控全局。<br/>（3）在此基础上，建立面向目标的项目管理。</p>"
                    ],
                    "option": "[]"
                },
                {
                    "index": 245,
                    "belong_page": 1,
                    "question_id": 347292,
                    "question_title": "<p>1、按照传统的软件生命周期方法学，可以把软件生命周期划分为哪三个阶段？</p><p><br/></p><p>2、哪种开发方法是从具体的部件开始，凭借设计者的技巧进行相互连接、修改和扩大的？</p><p><br/></p><p>3、敏捷开发的哪种方法是不同项目，采用不同策略？</p><p><br/></p><p>4、基于uml的面向对象需求分析过程中用什么图表示目标软件系统的总体框架结构？</p><p><br/></p><p>5、在面向对象设计过程中需要进行持久化存储的是什么类？</p><p><br/></p>",
                    "question_type": 5,
                    "answer_type": 5,
                    "show_type_name": "问答题",
                    "new_parent_id": 347292,
                    "score_rule": "",
                    "material_text": "",
                    "sort_son": "0",
                    "analyze": "<p>详见答案</p>",
                    "like": 0,
                    "answer": [
                        "<p>1、按照传统的软件生命周期方法学，可以把软件生命周期划分为哪三个阶段？</p><p>答：软件定义、软件开发、软件运行与维护三个阶段。</p><p>2、哪种开发方法是从具体的部件开始，凭借设计者的技巧进行相互连接、修改和扩大的？</p><p>答：自底向上。</p><p>3、敏捷开发的哪种方法是不同项目，采用不同策略？</p><p>答：水晶方法。</p><p>4、基于uml的面向对象需求分析过程中用什么图表示目标软件系统的总体框架结构？</p><p>答：包图及类图。</p><p>5、在面向对象设计过程中需要进行持久化存储的是什么类？</p><p>答：实体类</p>"
                    ],
                    "option": "[]"
                }
            ],
            "total_question": 245,
            "summary": {
                "radio": {
                    "total_question": 243,
                    "total_score": 0
                },
                "multiple": {
                    "total_question": 0,
                    "total_score": 0
                },
                "fill": {
                    "total_question": 0,
                    "total_score": 0
                },
                "program": {
                    "total_question": 0,
                    "total_score": 0
                },
                "qanda": {
                    "total_question": 2,
                    "total_score": 0
                },
                "cloze": {
                    "total_question": 0,
                    "total_score": 0
                },
                "budingxiang": {
                    "total_question": 0,
                    "total_score": 0
                },
                "material": {
                    "total_question": 0,
                    "total_score": 0
                }
            },
            "title": "软件开发与管理"
        },
        "pagination": {
            "curPage": 1,
            "pageSize": 1000,
            "total": 245,
            "hasNextPage": false
        },
        "totalOrder": [
            {
                "index": 1,
                "question_type": "1",
                "belong_page": 1,
                "question_id": "43257",
                "answer_type": 1
            },
            {
                "index": 2,
                "question_type": "1",
                "belong_page": 1,
                "question_id": "43300",
                "answer_type": 1
            },
            {
                "index": 3,
                "question_type": "1",
                "belong_page": 1,
                "question_id": "43301",
                "answer_type": 1
            },
            {
                "index": 4,
                "question_type": "1",
                "belong_page": 1,
                "question_id": "43303",
                "answer_type": 1
            },
            {
                "index": 5,
                "question_type": "1",
                "belong_page": 1,
                "question_id": "43305",
                "answer_type": 1
            },
            {
                "index": 6,
                "question_type": "1",
                "belong_page": 1,
                "question_id": "43306",
                "answer_type": 1
            },
            {
                "index": 7,
                "question_type": "1",
                "belong_page": 1,
                "question_id": "43310",
                "answer_type": 1
            },
            {
                "index": 8,
                "question_type": "1",
                "belong_page": 1,
                "question_id": "43311",
                "answer_type": 1
            },
            {
                "index": 9,
                "question_type": "1",
                "belong_page": 1,
                "question_id": "43315",
                "answer_type": 1
            },
            {
                "index": 10,
                "question_type": "1",
                "belong_page": 1,
                "question_id": "43317",
                "answer_type": 1
            },
            {
                "index": 11,
                "question_type": "1",
                "belong_page": 1,
                "question_id": "43320",
                "answer_type": 1
            },
            {
                "index": 12,
                "question_type": "1",
                "belong_page": 1,
                "question_id": "43327",
                "answer_type": 1
            },
            {
                "index": 13,
                "question_type": "1",
                "belong_page": 1,
                "question_id": "43331",
                "answer_type": 1
            },
            {
                "index": 14,
                "question_type": "1",
                "belong_page": 1,
                "question_id": "43760",
                "answer_type": 1
            },
            {
                "index": 15,
                "question_type": "1",
                "belong_page": 1,
                "question_id": "43761",
                "answer_type": 1
            },
            {
                "index": 16,
                "question_type": "1",
                "belong_page": 1,
                "question_id": "43764",
                "answer_type": 1
            },
            {
                "index": 17,
                "question_type": "1",
                "belong_page": 1,
                "question_id": "43765",
                "answer_type": 1
            },
            {
                "index": 18,
                "question_type": "1",
                "belong_page": 1,
                "question_id": "43769",
                "answer_type": 1
            },
            {
                "index": 19,
                "question_type": "1",
                "belong_page": 1,
                "question_id": "43772",
                "answer_type": 1
            },
            {
                "index": 20,
                "question_type": "1",
                "belong_page": 1,
                "question_id": "43868",
                "answer_type": 1
            },
            {
                "index": 21,
                "question_type": "1",
                "belong_page": 1,
                "question_id": "43869",
                "answer_type": 1
            },
            {
                "index": 22,
                "question_type": "1",
                "belong_page": 1,
                "question_id": "43870",
                "answer_type": 1
            },
            {
                "index": 23,
                "question_type": "1",
                "belong_page": 1,
                "question_id": "43871",
                "answer_type": 1
            },
            {
                "index": 24,
                "question_type": "1",
                "belong_page": 1,
                "question_id": "43891",
                "answer_type": 1
            },
            {
                "index": 25,
                "question_type": "1",
                "belong_page": 1,
                "question_id": "43892",
                "answer_type": 1
            },
            {
                "index": 26,
                "question_type": "1",
                "belong_page": 1,
                "question_id": "43893",
                "answer_type": 1
            },
            {
                "index": 27,
                "question_type": "1",
                "belong_page": 1,
                "question_id": "43894",
                "answer_type": 1
            },
            {
                "index": 28,
                "question_type": "1",
                "belong_page": 1,
                "question_id": "43895",
                "answer_type": 1
            },
            {
                "index": 29,
                "question_type": "1",
                "belong_page": 1,
                "question_id": "43896",
                "answer_type": 1
            },
            {
                "index": 30,
                "question_type": "1",
                "belong_page": 1,
                "question_id": "43897",
                "answer_type": 1
            },
            {
                "index": 31,
                "question_type": "1",
                "belong_page": 1,
                "question_id": "43898",
                "answer_type": 1
            },
            {
                "index": 32,
                "question_type": "1",
                "belong_page": 1,
                "question_id": "43899",
                "answer_type": 1
            },
            {
                "index": 33,
                "question_type": "1",
                "belong_page": 1,
                "question_id": "43900",
                "answer_type": 1
            },
            {
                "index": 34,
                "question_type": "1",
                "belong_page": 1,
                "question_id": "45327",
                "answer_type": 1
            },
            {
                "index": 35,
                "question_type": "1",
                "belong_page": 1,
                "question_id": "45328",
                "answer_type": 1
            },
            {
                "index": 36,
                "question_type": "1",
                "belong_page": 1,
                "question_id": "45332",
                "answer_type": 1
            },
            {
                "index": 37,
                "question_type": "1",
                "belong_page": 1,
                "question_id": "45333",
                "answer_type": 1
            },
            {
                "index": 38,
                "question_type": "1",
                "belong_page": 1,
                "question_id": "45334",
                "answer_type": 1
            },
            {
                "index": 39,
                "question_type": "1",
                "belong_page": 1,
                "question_id": "45336",
                "answer_type": 1
            },
            {
                "index": 40,
                "question_type": "1",
                "belong_page": 1,
                "question_id": "45337",
                "answer_type": 1
            },
            {
                "index": 41,
                "question_type": "1",
                "belong_page": 1,
                "question_id": "45338",
                "answer_type": 1
            },
            {
                "index": 42,
                "question_type": "1",
                "belong_page": 1,
                "question_id": "46872",
                "answer_type": 1
            },
            {
                "index": 43,
                "question_type": "1",
                "belong_page": 1,
                "question_id": "46892",
                "answer_type": 1
            },
            {
                "index": 44,
                "question_type": "1",
                "belong_page": 1,
                "question_id": "46896",
                "answer_type": 1
            },
            {
                "index": 45,
                "question_type": "1",
                "belong_page": 1,
                "question_id": "46906",
                "answer_type": 1
            },
            {
                "index": 46,
                "question_type": "1",
                "belong_page": 1,
                "question_id": "46909",
                "answer_type": 1
            },
            {
                "index": 47,
                "question_type": "1",
                "belong_page": 1,
                "question_id": "46916",
                "answer_type": 1
            },
            {
                "index": 48,
                "question_type": "1",
                "belong_page": 1,
                "question_id": "46917",
                "answer_type": 1
            },
            {
                "index": 49,
                "question_type": "1",
                "belong_page": 1,
                "question_id": "46920",
                "answer_type": 1
            },
            {
                "index": 50,
                "question_type": "1",
                "belong_page": 1,
                "question_id": "46930",
                "answer_type": 1
            },
            {
                "index": 51,
                "question_type": "1",
                "belong_page": 1,
                "question_id": "46932",
                "answer_type": 1
            },
            {
                "index": 52,
                "question_type": "1",
                "belong_page": 1,
                "question_id": "46935",
                "answer_type": 1
            },
            {
                "index": 53,
                "question_type": "1",
                "belong_page": 1,
                "question_id": "46944",
                "answer_type": 1
            },
            {
                "index": 54,
                "question_type": "1",
                "belong_page": 1,
                "question_id": "46946",
                "answer_type": 1
            },
            {
                "index": 55,
                "question_type": "1",
                "belong_page": 1,
                "question_id": "46948",
                "answer_type": 1
            },
            {
                "index": 56,
                "question_type": "1",
                "belong_page": 1,
                "question_id": "46992",
                "answer_type": 1
            },
            {
                "index": 57,
                "question_type": "1",
                "belong_page": 1,
                "question_id": "49845",
                "answer_type": 1
            },
            {
                "index": 58,
                "question_type": "1",
                "belong_page": 1,
                "question_id": "49846",
                "answer_type": 1
            },
            {
                "index": 59,
                "question_type": "1",
                "belong_page": 1,
                "question_id": "49848",
                "answer_type": 1
            },
            {
                "index": 60,
                "question_type": "1",
                "belong_page": 1,
                "question_id": "49849",
                "answer_type": 1
            },
            {
                "index": 61,
                "question_type": "1",
                "belong_page": 1,
                "question_id": "49850",
                "answer_type": 1
            },
            {
                "index": 62,
                "question_type": "1",
                "belong_page": 1,
                "question_id": "49851",
                "answer_type": 1
            },
            {
                "index": 63,
                "question_type": "1",
                "belong_page": 1,
                "question_id": "49852",
                "answer_type": 1
            },
            {
                "index": 64,
                "question_type": "1",
                "belong_page": 1,
                "question_id": "49853",
                "answer_type": 1
            },
            {
                "index": 65,
                "question_type": "1",
                "belong_page": 1,
                "question_id": "49854",
                "answer_type": 1
            },
            {
                "index": 66,
                "question_type": "1",
                "belong_page": 1,
                "question_id": "49860",
                "answer_type": 1
            },
            {
                "index": 67,
                "question_type": "1",
                "belong_page": 1,
                "question_id": "49862",
                "answer_type": 1
            },
            {
                "index": 68,
                "question_type": "1",
                "belong_page": 1,
                "question_id": "49863",
                "answer_type": 1
            },
            {
                "index": 69,
                "question_type": "1",
                "belong_page": 1,
                "question_id": "49892",
                "answer_type": 1
            },
            {
                "index": 70,
                "question_type": "1",
                "belong_page": 1,
                "question_id": "49893",
                "answer_type": 1
            },
            {
                "index": 71,
                "question_type": "1",
                "belong_page": 1,
                "question_id": "49920",
                "answer_type": 1
            },
            {
                "index": 72,
                "question_type": "1",
                "belong_page": 1,
                "question_id": "49922",
                "answer_type": 1
            },
            {
                "index": 73,
                "question_type": "1",
                "belong_page": 1,
                "question_id": "49923",
                "answer_type": 1
            },
            {
                "index": 74,
                "question_type": "1",
                "belong_page": 1,
                "question_id": "49924",
                "answer_type": 1
            },
            {
                "index": 75,
                "question_type": "1",
                "belong_page": 1,
                "question_id": "49925",
                "answer_type": 1
            },
            {
                "index": 76,
                "question_type": "1",
                "belong_page": 1,
                "question_id": "49926",
                "answer_type": 1
            },
            {
                "index": 77,
                "question_type": "1",
                "belong_page": 1,
                "question_id": "49927",
                "answer_type": 1
            },
            {
                "index": 78,
                "question_type": "1",
                "belong_page": 1,
                "question_id": "49928",
                "answer_type": 1
            },
            {
                "index": 79,
                "question_type": "1",
                "belong_page": 1,
                "question_id": "49932",
                "answer_type": 1
            },
            {
                "index": 80,
                "question_type": "1",
                "belong_page": 1,
                "question_id": "49933",
                "answer_type": 1
            },
            {
                "index": 81,
                "question_type": "1",
                "belong_page": 1,
                "question_id": "49943",
                "answer_type": 1
            },
            {
                "index": 82,
                "question_type": "1",
                "belong_page": 1,
                "question_id": "50897",
                "answer_type": 1
            },
            {
                "index": 83,
                "question_type": "1",
                "belong_page": 1,
                "question_id": "54206",
                "answer_type": 1
            },
            {
                "index": 84,
                "question_type": "1",
                "belong_page": 1,
                "question_id": "54207",
                "answer_type": 1
            },
            {
                "index": 85,
                "question_type": "1",
                "belong_page": 1,
                "question_id": "54208",
                "answer_type": 1
            },
            {
                "index": 86,
                "question_type": "1",
                "belong_page": 1,
                "question_id": "54209",
                "answer_type": 1
            },
            {
                "index": 87,
                "question_type": "1",
                "belong_page": 1,
                "question_id": "54210",
                "answer_type": 1
            },
            {
                "index": 88,
                "question_type": "1",
                "belong_page": 1,
                "question_id": "54222",
                "answer_type": 1
            },
            {
                "index": 89,
                "question_type": "1",
                "belong_page": 1,
                "question_id": "54225",
                "answer_type": 1
            },
            {
                "index": 90,
                "question_type": "1",
                "belong_page": 1,
                "question_id": "54230",
                "answer_type": 1
            },
            {
                "index": 91,
                "question_type": "1",
                "belong_page": 1,
                "question_id": "54231",
                "answer_type": 1
            },
            {
                "index": 92,
                "question_type": "1",
                "belong_page": 1,
                "question_id": "54232",
                "answer_type": 1
            },
            {
                "index": 93,
                "question_type": "1",
                "belong_page": 1,
                "question_id": "54256",
                "answer_type": 1
            },
            {
                "index": 94,
                "question_type": "1",
                "belong_page": 1,
                "question_id": "54257",
                "answer_type": 1
            },
            {
                "index": 95,
                "question_type": "1",
                "belong_page": 1,
                "question_id": "54299",
                "answer_type": 1
            },
            {
                "index": 96,
                "question_type": "1",
                "belong_page": 1,
                "question_id": "54300",
                "answer_type": 1
            },
            {
                "index": 97,
                "question_type": "1",
                "belong_page": 1,
                "question_id": "54301",
                "answer_type": 1
            },
            {
                "index": 98,
                "question_type": "1",
                "belong_page": 1,
                "question_id": "54303",
                "answer_type": 1
            },
            {
                "index": 99,
                "question_type": "1",
                "belong_page": 1,
                "question_id": "54304",
                "answer_type": 1
            },
            {
                "index": 100,
                "question_type": "1",
                "belong_page": 1,
                "question_id": "54305",
                "answer_type": 1
            },
            {
                "index": 101,
                "question_type": "1",
                "belong_page": 1,
                "question_id": "54313",
                "answer_type": 1
            },
            {
                "index": 102,
                "question_type": "1",
                "belong_page": 1,
                "question_id": "54315",
                "answer_type": 1
            },
            {
                "index": 103,
                "question_type": "1",
                "belong_page": 1,
                "question_id": "62501",
                "answer_type": 1
            },
            {
                "index": 104,
                "question_type": "1",
                "belong_page": 1,
                "question_id": "63612",
                "answer_type": 1
            },
            {
                "index": 105,
                "question_type": "1",
                "belong_page": 1,
                "question_id": "63614",
                "answer_type": 1
            },
            {
                "index": 106,
                "question_type": "1",
                "belong_page": 1,
                "question_id": "63616",
                "answer_type": 1
            },
            {
                "index": 107,
                "question_type": "1",
                "belong_page": 1,
                "question_id": "63618",
                "answer_type": 1
            },
            {
                "index": 108,
                "question_type": "1",
                "belong_page": 1,
                "question_id": "63619",
                "answer_type": 1
            },
            {
                "index": 109,
                "question_type": "1",
                "belong_page": 1,
                "question_id": "63622",
                "answer_type": 1
            },
            {
                "index": 110,
                "question_type": "1",
                "belong_page": 1,
                "question_id": "63626",
                "answer_type": 1
            },
            {
                "index": 111,
                "question_type": "1",
                "belong_page": 1,
                "question_id": "63628",
                "answer_type": 1
            },
            {
                "index": 112,
                "question_type": "1",
                "belong_page": 1,
                "question_id": "63630",
                "answer_type": 1
            },
            {
                "index": 113,
                "question_type": "1",
                "belong_page": 1,
                "question_id": "63631",
                "answer_type": 1
            },
            {
                "index": 114,
                "question_type": "1",
                "belong_page": 1,
                "question_id": "63640",
                "answer_type": 1
            },
            {
                "index": 115,
                "question_type": "1",
                "belong_page": 1,
                "question_id": "63689",
                "answer_type": 1
            },
            {
                "index": 116,
                "question_type": "1",
                "belong_page": 1,
                "question_id": "86607",
                "answer_type": 1
            },
            {
                "index": 117,
                "question_type": "1",
                "belong_page": 1,
                "question_id": "88858",
                "answer_type": 1
            },
            {
                "index": 118,
                "question_type": "1",
                "belong_page": 1,
                "question_id": "88859",
                "answer_type": 1
            },
            {
                "index": 119,
                "question_type": "1",
                "belong_page": 1,
                "question_id": "88860",
                "answer_type": 1
            },
            {
                "index": 120,
                "question_type": "1",
                "belong_page": 1,
                "question_id": "88861",
                "answer_type": 1
            },
            {
                "index": 121,
                "question_type": "1",
                "belong_page": 1,
                "question_id": "151192",
                "answer_type": 1
            },
            {
                "index": 122,
                "question_type": "1",
                "belong_page": 1,
                "question_id": "208418",
                "answer_type": 1
            },
            {
                "index": 123,
                "question_type": "1",
                "belong_page": 1,
                "question_id": "208419",
                "answer_type": 1
            },
            {
                "index": 124,
                "question_type": "1",
                "belong_page": 1,
                "question_id": "208422",
                "answer_type": 1
            },
            {
                "index": 125,
                "question_type": "1",
                "belong_page": 1,
                "question_id": "208423",
                "answer_type": 1
            },
            {
                "index": 126,
                "question_type": "1",
                "belong_page": 1,
                "question_id": "208424",
                "answer_type": 1
            },
            {
                "index": 127,
                "question_type": "1",
                "belong_page": 1,
                "question_id": "208425",
                "answer_type": 1
            },
            {
                "index": 128,
                "question_type": "1",
                "belong_page": 1,
                "question_id": "208426",
                "answer_type": 1
            },
            {
                "index": 129,
                "question_type": "1",
                "belong_page": 1,
                "question_id": "208427",
                "answer_type": 1
            },
            {
                "index": 130,
                "question_type": "1",
                "belong_page": 1,
                "question_id": "208493",
                "answer_type": 1
            },
            {
                "index": 131,
                "question_type": "1",
                "belong_page": 1,
                "question_id": "208494",
                "answer_type": 1
            },
            {
                "index": 132,
                "question_type": "1",
                "belong_page": 1,
                "question_id": "208495",
                "answer_type": 1
            },
            {
                "index": 133,
                "question_type": "1",
                "belong_page": 1,
                "question_id": "208501",
                "answer_type": 1
            },
            {
                "index": 134,
                "question_type": "1",
                "belong_page": 1,
                "question_id": "208502",
                "answer_type": 1
            },
            {
                "index": 135,
                "question_type": "1",
                "belong_page": 1,
                "question_id": "208505",
                "answer_type": 1
            },
            {
                "index": 136,
                "question_type": "9",
                "belong_page": 1,
                "question_id": "281198",
                "answer_type": 1
            },
            {
                "index": 137,
                "question_type": "9",
                "belong_page": 1,
                "question_id": "281199",
                "answer_type": 1
            },
            {
                "index": 138,
                "question_type": "9",
                "belong_page": 1,
                "question_id": "281200",
                "answer_type": 1
            },
            {
                "index": 139,
                "question_type": "1",
                "belong_page": 1,
                "question_id": "281201",
                "answer_type": 1
            },
            {
                "index": 140,
                "question_type": "1",
                "belong_page": 1,
                "question_id": "281327",
                "answer_type": 1
            },
            {
                "index": 141,
                "question_type": "1",
                "belong_page": 1,
                "question_id": "281329",
                "answer_type": 1
            },
            {
                "index": 142,
                "question_type": "1",
                "belong_page": 1,
                "question_id": "281345",
                "answer_type": 1
            },
            {
                "index": 143,
                "question_type": "1",
                "belong_page": 1,
                "question_id": "281354",
                "answer_type": 1
            },
            {
                "index": 144,
                "question_type": "1",
                "belong_page": 1,
                "question_id": "284648",
                "answer_type": 1
            },
            {
                "index": 145,
                "question_type": "1",
                "belong_page": 1,
                "question_id": "284680",
                "answer_type": 1
            },
            {
                "index": 146,
                "question_type": "1",
                "belong_page": 1,
                "question_id": "284681",
                "answer_type": 1
            },
            {
                "index": 147,
                "question_type": "1",
                "belong_page": 1,
                "question_id": "284699",
                "answer_type": 1
            },
            {
                "index": 148,
                "question_type": "9",
                "belong_page": 1,
                "question_id": "284701",
                "answer_type": 1
            },
            {
                "index": 149,
                "question_type": "9",
                "belong_page": 1,
                "question_id": "284702",
                "answer_type": 1
            },
            {
                "index": 150,
                "question_type": "9",
                "belong_page": 1,
                "question_id": "284706",
                "answer_type": 1
            },
            {
                "index": 151,
                "question_type": "9",
                "belong_page": 1,
                "question_id": "284707",
                "answer_type": 1
            },
            {
                "index": 152,
                "question_type": "1",
                "belong_page": 1,
                "question_id": "284709",
                "answer_type": 1
            },
            {
                "index": 153,
                "question_type": "9",
                "belong_page": 1,
                "question_id": "303645",
                "answer_type": 1
            },
            {
                "index": 154,
                "question_type": "9",
                "belong_page": 1,
                "question_id": "303646",
                "answer_type": 1
            },
            {
                "index": 155,
                "question_type": "9",
                "belong_page": 1,
                "question_id": "303648",
                "answer_type": 1
            },
            {
                "index": 156,
                "question_type": "9",
                "belong_page": 1,
                "question_id": "303649",
                "answer_type": 1
            },
            {
                "index": 157,
                "question_type": "9",
                "belong_page": 1,
                "question_id": "303651",
                "answer_type": 1
            },
            {
                "index": 158,
                "question_type": "9",
                "belong_page": 1,
                "question_id": "303652",
                "answer_type": 1
            },
            {
                "index": 159,
                "question_type": "9",
                "belong_page": 1,
                "question_id": "303657",
                "answer_type": 1
            },
            {
                "index": 160,
                "question_type": "9",
                "belong_page": 1,
                "question_id": "303658",
                "answer_type": 1
            },
            {
                "index": 161,
                "question_type": "9",
                "belong_page": 1,
                "question_id": "303659",
                "answer_type": 1
            },
            {
                "index": 162,
                "question_type": "9",
                "belong_page": 1,
                "question_id": "303661",
                "answer_type": 1
            },
            {
                "index": 163,
                "question_type": "9",
                "belong_page": 1,
                "question_id": "303662",
                "answer_type": 1
            },
            {
                "index": 164,
                "question_type": "9",
                "belong_page": 1,
                "question_id": "303664",
                "answer_type": 1
            },
            {
                "index": 165,
                "question_type": "9",
                "belong_page": 1,
                "question_id": "303665",
                "answer_type": 1
            },
            {
                "index": 166,
                "question_type": "9",
                "belong_page": 1,
                "question_id": "303669",
                "answer_type": 1
            },
            {
                "index": 167,
                "question_type": "9",
                "belong_page": 1,
                "question_id": "303670",
                "answer_type": 1
            },
            {
                "index": 168,
                "question_type": "9",
                "belong_page": 1,
                "question_id": "303671",
                "answer_type": 1
            },
            {
                "index": 169,
                "question_type": "1",
                "belong_page": 1,
                "question_id": "303672",
                "answer_type": 1
            },
            {
                "index": 170,
                "question_type": "9",
                "belong_page": 1,
                "question_id": "303674",
                "answer_type": 1
            },
            {
                "index": 171,
                "question_type": "9",
                "belong_page": 1,
                "question_id": "303675",
                "answer_type": 1
            },
            {
                "index": 172,
                "question_type": "1",
                "belong_page": 1,
                "question_id": "303676",
                "answer_type": 1
            },
            {
                "index": 173,
                "question_type": "9",
                "belong_page": 1,
                "question_id": "303678",
                "answer_type": 1
            },
            {
                "index": 174,
                "question_type": "9",
                "belong_page": 1,
                "question_id": "303679",
                "answer_type": 1
            },
            {
                "index": 175,
                "question_type": "1",
                "belong_page": 1,
                "question_id": "303712",
                "answer_type": 1
            },
            {
                "index": 176,
                "question_type": "1",
                "belong_page": 1,
                "question_id": "307122",
                "answer_type": 1
            },
            {
                "index": 177,
                "question_type": "1",
                "belong_page": 1,
                "question_id": "307123",
                "answer_type": 1
            },
            {
                "index": 178,
                "question_type": "1",
                "belong_page": 1,
                "question_id": "307124",
                "answer_type": 1
            },
            {
                "index": 179,
                "question_type": "1",
                "belong_page": 1,
                "question_id": "307125",
                "answer_type": 1
            },
            {
                "index": 180,
                "question_type": "1",
                "belong_page": 1,
                "question_id": "307126",
                "answer_type": 1
            },
            {
                "index": 181,
                "question_type": "1",
                "belong_page": 1,
                "question_id": "310848",
                "answer_type": 1
            },
            {
                "index": 182,
                "question_type": "9",
                "belong_page": 1,
                "question_id": "310850",
                "answer_type": 1
            },
            {
                "index": 183,
                "question_type": "9",
                "belong_page": 1,
                "question_id": "310851",
                "answer_type": 1
            },
            {
                "index": 184,
                "question_type": "9",
                "belong_page": 1,
                "question_id": "310852",
                "answer_type": 1
            },
            {
                "index": 185,
                "question_type": "9",
                "belong_page": 1,
                "question_id": "310854",
                "answer_type": 1
            },
            {
                "index": 186,
                "question_type": "9",
                "belong_page": 1,
                "question_id": "310855",
                "answer_type": 1
            },
            {
                "index": 187,
                "question_type": "1",
                "belong_page": 1,
                "question_id": "310859",
                "answer_type": 1
            },
            {
                "index": 188,
                "question_type": "1",
                "belong_page": 1,
                "question_id": "310878",
                "answer_type": 1
            },
            {
                "index": 189,
                "question_type": "9",
                "belong_page": 1,
                "question_id": "310889",
                "answer_type": 1
            },
            {
                "index": 190,
                "question_type": "9",
                "belong_page": 1,
                "question_id": "310890",
                "answer_type": 1
            },
            {
                "index": 191,
                "question_type": "9",
                "belong_page": 1,
                "question_id": "310891",
                "answer_type": 1
            },
            {
                "index": 192,
                "question_type": "1",
                "belong_page": 1,
                "question_id": "312914",
                "answer_type": 1
            },
            {
                "index": 193,
                "question_type": "9",
                "belong_page": 1,
                "question_id": "312953",
                "answer_type": 1
            },
            {
                "index": 194,
                "question_type": "9",
                "belong_page": 1,
                "question_id": "312954",
                "answer_type": 1
            },
            {
                "index": 195,
                "question_type": "1",
                "belong_page": 1,
                "question_id": "312976",
                "answer_type": 1
            },
            {
                "index": 196,
                "question_type": "1",
                "belong_page": 1,
                "question_id": "312977",
                "answer_type": 1
            },
            {
                "index": 197,
                "question_type": "9",
                "belong_page": 1,
                "question_id": "312982",
                "answer_type": 1
            },
            {
                "index": 198,
                "question_type": "9",
                "belong_page": 1,
                "question_id": "312983",
                "answer_type": 1
            },
            {
                "index": 199,
                "question_type": "1",
                "belong_page": 1,
                "question_id": "312995",
                "answer_type": 1
            },
            {
                "index": 200,
                "question_type": "1",
                "belong_page": 1,
                "question_id": "315924",
                "answer_type": 1
            },
            {
                "index": 201,
                "question_type": "1",
                "belong_page": 1,
                "question_id": "315925",
                "answer_type": 1
            },
            {
                "index": 202,
                "question_type": "1",
                "belong_page": 1,
                "question_id": "315926",
                "answer_type": 1
            },
            {
                "index": 203,
                "question_type": "1",
                "belong_page": 1,
                "question_id": "315927",
                "answer_type": 1
            },
            {
                "index": 204,
                "question_type": "1",
                "belong_page": 1,
                "question_id": "315928",
                "answer_type": 1
            },
            {
                "index": 205,
                "question_type": "1",
                "belong_page": 1,
                "question_id": "315929",
                "answer_type": 1
            },
            {
                "index": 206,
                "question_type": "1",
                "belong_page": 1,
                "question_id": "315930",
                "answer_type": 1
            },
            {
                "index": 207,
                "question_type": "1",
                "belong_page": 1,
                "question_id": "315987",
                "answer_type": 1
            },
            {
                "index": 208,
                "question_type": "9",
                "belong_page": 1,
                "question_id": "350302",
                "answer_type": 1
            },
            {
                "index": 209,
                "question_type": "9",
                "belong_page": 1,
                "question_id": "350303",
                "answer_type": 1
            },
            {
                "index": 210,
                "question_type": "1",
                "belong_page": 1,
                "question_id": "350308",
                "answer_type": 1
            },
            {
                "index": 211,
                "question_type": "1",
                "belong_page": 1,
                "question_id": "350309",
                "answer_type": 1
            },
            {
                "index": 212,
                "question_type": "9",
                "belong_page": 1,
                "question_id": "350311",
                "answer_type": 1
            },
            {
                "index": 213,
                "question_type": "9",
                "belong_page": 1,
                "question_id": "350312",
                "answer_type": 1
            },
            {
                "index": 214,
                "question_type": "9",
                "belong_page": 1,
                "question_id": "350314",
                "answer_type": 1
            },
            {
                "index": 215,
                "question_type": "9",
                "belong_page": 1,
                "question_id": "350315",
                "answer_type": 1
            },
            {
                "index": 216,
                "question_type": "9",
                "belong_page": 1,
                "question_id": "350317",
                "answer_type": 1
            },
            {
                "index": 217,
                "question_type": "9",
                "belong_page": 1,
                "question_id": "350318",
                "answer_type": 1
            },
            {
                "index": 218,
                "question_type": "1",
                "belong_page": 1,
                "question_id": "350364",
                "answer_type": 1
            },
            {
                "index": 219,
                "question_type": "1",
                "belong_page": 1,
                "question_id": "350367",
                "answer_type": 1
            },
            {
                "index": 220,
                "question_type": "9",
                "belong_page": 1,
                "question_id": "352265",
                "answer_type": 1
            },
            {
                "index": 221,
                "question_type": "9",
                "belong_page": 1,
                "question_id": "352266",
                "answer_type": 1
            },
            {
                "index": 222,
                "question_type": "1",
                "belong_page": 1,
                "question_id": "352270",
                "answer_type": 1
            },
            {
                "index": 223,
                "question_type": "1",
                "belong_page": 1,
                "question_id": "352271",
                "answer_type": 1
            },
            {
                "index": 224,
                "question_type": "1",
                "belong_page": 1,
                "question_id": "352272",
                "answer_type": 1
            },
            {
                "index": 225,
                "question_type": "1",
                "belong_page": 1,
                "question_id": "352273",
                "answer_type": 1
            },
            {
                "index": 226,
                "question_type": "9",
                "belong_page": 1,
                "question_id": "352275",
                "answer_type": 1
            },
            {
                "index": 227,
                "question_type": "9",
                "belong_page": 1,
                "question_id": "352276",
                "answer_type": 1
            },
            {
                "index": 228,
                "question_type": "1",
                "belong_page": 1,
                "question_id": "352277",
                "answer_type": 1
            },
            {
                "index": 229,
                "question_type": "9",
                "belong_page": 1,
                "question_id": "352324",
                "answer_type": 1
            },
            {
                "index": 230,
                "question_type": "9",
                "belong_page": 1,
                "question_id": "352325",
                "answer_type": 1
            },
            {
                "index": 231,
                "question_type": "9",
                "belong_page": 1,
                "question_id": "352327",
                "answer_type": 1
            },
            {
                "index": 232,
                "question_type": "9",
                "belong_page": 1,
                "question_id": "352328",
                "answer_type": 1
            },
            {
                "index": 233,
                "question_type": "1",
                "belong_page": 1,
                "question_id": "352365",
                "answer_type": 1
            },
            {
                "index": 234,
                "question_type": "9",
                "belong_page": 1,
                "question_id": "352391",
                "answer_type": 1
            },
            {
                "index": 235,
                "question_type": "9",
                "belong_page": 1,
                "question_id": "352392",
                "answer_type": 1
            },
            {
                "index": 236,
                "question_type": "9",
                "belong_page": 1,
                "question_id": "352393",
                "answer_type": 1
            },
            {
                "index": 237,
                "question_type": "9",
                "belong_page": 1,
                "question_id": "352394",
                "answer_type": 1
            },
            {
                "index": 238,
                "question_type": "1",
                "belong_page": 1,
                "question_id": "356204",
                "answer_type": 1
            },
            {
                "index": 239,
                "question_type": "1",
                "belong_page": 1,
                "question_id": "356205",
                "answer_type": 1
            },
            {
                "index": 240,
                "question_type": "1",
                "belong_page": 1,
                "question_id": "356209",
                "answer_type": 1
            },
            {
                "index": 241,
                "question_type": "1",
                "belong_page": 1,
                "question_id": "356210",
                "answer_type": 1
            },
            {
                "index": 242,
                "question_type": "1",
                "belong_page": 1,
                "question_id": "356216",
                "answer_type": 1
            },
            {
                "index": 243,
                "question_type": "1",
                "belong_page": 1,
                "question_id": "356265",
                "answer_type": 1
            },
            {
                "index": 244,
                "question_type": "5",
                "belong_page": 1,
                "question_id": "54269",
                "answer_type": 5
            },
            {
                "index": 245,
                "question_type": "5",
                "belong_page": 1,
                "question_id": "347292",
                "answer_type": 5
            }
        ],
        "progress": []
    }
}
