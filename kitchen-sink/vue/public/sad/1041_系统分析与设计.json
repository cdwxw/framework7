{
    "msg": "成功",
    "status": 0,
    "data": {
        "data": {
            "question": [
                {
                    "index": 1,
                    "belong_page": 1,
                    "question_id": 43219,
                    "question_title": "<p>用例(use case)用来描述系统对事件做出响应时所采取的行动。用例之间是具有相关性的。在一个会员管理系统中，会员注册时可以采用电话和邮件两种方式。用例“会员注册”和“电话注册”、“邮件注册”之间是（ ）关系。</p>",
                    "question_type": 1,
                    "answer_type": 1,
                    "show_type_name": null,
                    "new_parent_id": 43219,
                    "score_rule": "",
                    "material_text": null,
                    "sort_son": "0",
                    "analyze": "<p>用例之间的关系主要有包含、扩展和泛化。</p><p><br/></p>",
                    "like": 0,
                    "answer": [
                        "C"
                    ],
                    "option": [
                        " 包含(include) ",
                        " 扩展(extend) ",
                        " 泛化(generalize) ",
                        " 依赖(depends&nbsp;on) "
                    ]
                },
                {
                    "index": 2,
                    "belong_page": 1,
                    "question_id": 43220,
                    "question_title": "<p>在UML提供的系统视图中，（请作答此空）是逻辑视图的一次执行实例，描述了并发与同步结构；（ ）是最基本的需求分析模型。</p>",
                    "question_type": 1,
                    "answer_type": 1,
                    "show_type_name": null,
                    "new_parent_id": 43220,
                    "score_rule": "",
                    "material_text": null,
                    "sort_son": "0",
                    "analyze": "<p>UML对系统架构的定义是系统的组织结构，包括系统分解的组成部分，以及它们的关联性、交互机制和指导原则等提供系统设计的信息。具体来说，就是指以下5个系统视图：</p><p>①逻辑视图。逻辑视图也称为设计视图，它表示了设计模型中在架构方面具有重要意义的部分，即类、子系统、包和用例实现的子集。</p><p>②进程视图。进程视图是可执行线程和进程作为活动类的建模，它是逻辑视图的一次执行实例，描述了并发与同步结构。</p><p>③实现视图。实现视图对组成基于系统的物理代码的文件和构件进行建模。</p><p>④部署视图。部署视图把构件部署到一组物理节点上，表示软件到硬件的映射和分布结构。</p><p>⑤用例视图。用例视图是最基本的需求分析模型。</p>",
                    "like": 0,
                    "answer": [
                        "A"
                    ],
                    "option": [
                        " 进程视图&nbsp; ",
                        " 实现视图 ",
                        " 部署视图 ",
                        " 用例视图 "
                    ]
                },
                {
                    "index": 3,
                    "belong_page": 1,
                    "question_id": 43221,
                    "question_title": "<p><br/></p><p style=\"margin: 0px;\"><span style=\"margin: 0px; font-family: 华文楷体; font-size: 11pt;\"><span style=\"font-family:华文楷体\">在</span>UML提供的系统视图中，(</span><span style=\"margin: 0px; font-family: 华文楷体; font-size: 11pt;\">2</span><span style=\"margin: 0px; font-family: 华文楷体; font-size: 11pt;\">)是逻辑视图的一次执行实例，描述了并发与同步结构；（</span><span style=\"margin: 0px; font-family: 华文楷体; font-size: 11pt;\">3</span><span style=\"margin: 0px; font-family: 华文楷体; font-size: 11pt;\"><span style=\"font-family:华文楷体\">）是最基本的需求分析模型。【回答括号3】</span></span></p><p><br/></p>",
                    "question_type": 1,
                    "answer_type": 1,
                    "show_type_name": null,
                    "new_parent_id": 43221,
                    "score_rule": "",
                    "material_text": null,
                    "sort_son": "0",
                    "analyze": "<p><br/></p><p style=\"margin: 0px; line-height: 150%; layout-grid-mode: char;\"><span style=\"margin: 0px; font-family: 华文楷体; font-size: 11pt;\">UML对系统架构的定义是系统的组织结构，包括系统分解的组成部分，以及它们的关联性、交互机制和指导原则等提供系统设计的信息。具体来说，就是指以下5个系统视图：</span><span style=\"margin: 0px; font-family: 华文楷体; font-size: 11pt;\"></span></p><p style=\"margin: 0px; line-height: 150%; layout-grid-mode: char;\"><span style=\"margin: 0px; font-family: 华文楷体; font-size: 11pt;\">①逻辑视图。逻辑视图也称为设计视图，它表示了设计模型中在架构方面具有重要意义的部分，即类、子系统、包和用例实现的子集。</span><span style=\"margin: 0px; font-family: 华文楷体; font-size: 11pt;\"></span></p><p style=\"margin: 0px; line-height: 150%; layout-grid-mode: char;\"><span style=\"margin: 0px; font-family: 华文楷体; font-size: 11pt;\">②进程视图。进程视图是可执行线程和进程作为活动类的建模，它是逻辑视图的一次执行实例，描述了并发与同步结构。</span><span style=\"margin: 0px; font-family: 华文楷体; font-size: 11pt;\"></span></p><p style=\"margin: 0px; line-height: 150%; layout-grid-mode: char;\"><span style=\"margin: 0px; font-family: 华文楷体; font-size: 11pt;\">③实现视图。实现视图对组成基于系统的物理代码的文件和构件进行建模。</span><span style=\"margin: 0px; font-family: 华文楷体; font-size: 11pt;\"></span></p><p style=\"margin: 0px; line-height: 150%; layout-grid-mode: char;\"><span style=\"margin: 0px; font-family: 华文楷体; font-size: 11pt;\">④部署视图。部署视图把构件部署到一组物理节点上，表示软件到硬件的映射和分布结构。</span><span style=\"margin: 0px; font-family: 华文楷体; font-size: 11pt;\"></span></p><p style=\"margin: 0px; line-height: 150%; layout-grid-mode: char;\"><span style=\"margin: 0px; font-family: 华文楷体; font-size: 11pt;\">⑤用例视图。用例视图是最基本的需求分析模型。</span><span style=\"margin: 0px; font-family: 华文楷体; font-size: 11pt;\"></span></p><p><br/></p>",
                    "like": 0,
                    "answer": [
                        "D"
                    ],
                    "option": [
                        " 进程视图&nbsp; ",
                        " 实现视图 ",
                        " 部署视图 ",
                        " 用例视图 "
                    ]
                },
                {
                    "index": 4,
                    "belong_page": 1,
                    "question_id": 43223,
                    "question_title": "<p><br/></p><p style=\"margin: 0px;\"><span style=\"margin: 0px; font-family: 华文楷体; font-size: 11pt;\">“4+1”视图主要用于描述系统逻辑架构，最早由Philippe Kruchten于1995年提出。其中（</span><span style=\"margin: 0px; font-family: 华文楷体; font-size: 11pt;\">4</span><span style=\"margin: 0px; font-family: 华文楷体; font-size: 11pt;\"><span style=\"font-family:华文楷体\">）视图用于描述对象模型，并说明系统应该为用户提供哪些服务。当采用面向对象的设计方法描述对象模型时，通常使用（</span></span><span style=\"margin: 0px; font-family: 华文楷体; font-size: 11pt;\">5</span><span style=\"margin: 0px; font-family: 华文楷体; font-size: 11pt;\"><span style=\"font-family:华文楷体\">）表达类的内部属性和行为，以及类集合之间的交互关系；采用（</span></span><span style=\"margin: 0px; font-family: 华文楷体; font-size: 11pt;\">6</span><span style=\"margin: 0px; font-family: 华文楷体; font-size: 11pt;\"><span style=\"font-family:华文楷体\">）定义对象的内部行为。【回答括号5】</span></span></p><p><br/></p>",
                    "question_type": 1,
                    "answer_type": 1,
                    "show_type_name": null,
                    "new_parent_id": 43223,
                    "score_rule": "",
                    "material_text": null,
                    "sort_son": "0",
                    "analyze": "<p><br/></p><p style=\"margin: 0px; line-height: 150%; text-indent: 21pt; layout-grid-mode: char;\"><span style=\"margin: 0px; font-family: 华文楷体; font-size: 11pt;\">“4+1”视图是对逻辑架构进行描述，最早由Philippe Kruchten提出，他在1995年的IEEE Software上发表了题为The 4+1 View Model of Architecture的论文，引起了业界的极大关注，并最终被RUP采纳，现在已经成为架构设计的结构标准。“4+1”视图主要包括：</span><span style=\"margin: 0px; font-family: 华文楷体; font-size: 11pt;\"></span></p><p style=\"margin: 0px; line-height: 150%; layout-grid-mode: char;\"><span style=\"margin: 0px; font-family: 华文楷体; font-size: 11pt;\">①逻辑视图(Logical View)，设计的对象模型(使用面向对象的设计方法时)。</span><span style=\"margin: 0px; font-family: 华文楷体; font-size: 11pt;\"></span></p><p style=\"margin: 0px; line-height: 150%; layout-grid-mode: char;\"><span style=\"margin: 0px; font-family: 华文楷体; font-size: 11pt;\">②过程视图(Process View)，捕捉设计的并发和同步特征。</span><span style=\"margin: 0px; font-family: 华文楷体; font-size: 11pt;\"></span></p><p style=\"margin: 0px; line-height: 150%; layout-grid-mode: char;\"><span style=\"margin: 0px; font-family: 华文楷体; font-size: 11pt;\">③物理视图(Physical View)，描述了软件到硬件的映射，反映了分布式特性。</span><span style=\"margin: 0px; font-family: 华文楷体; font-size: 11pt;\"></span></p><p style=\"margin: 0px; line-height: 150%; layout-grid-mode: char;\"><span style=\"margin: 0px; font-family: 华文楷体; font-size: 11pt;\">④开发视图(Development View)，描述了在开发环境中软件的静态组织结构。</span><span style=\"margin: 0px; font-family: 华文楷体; font-size: 11pt;\"></span></p><p style=\"margin: 0px; line-height: 150%; layout-grid-mode: char;\"><span style=\"margin: 0px; font-family: 华文楷体; font-size: 11pt;\">⑤架构的描述，即所做的各种决定，可以围绕着这四个视图来组织，然后由一些用例(Use Cases)或场景(Scenarios)来说明，从而形成了第五个视图。</span><span style=\"margin: 0px; font-family: 华文楷体; font-size: 11pt;\"></span></p><p style=\"margin: 0px; line-height: 150%; layout-grid-mode: char;\"><span style=\"margin: 0px; font-family: 华文楷体; font-size: 11pt;\"><span style=\"font-family:华文楷体\">当采用面向对象的设计方法描述对象模型时，通常使用类图表达类的内部属性和行为，以及类集合之间的交互关系；采用状态图定义对象的内部行为。</span></span><span style=\"margin: 0px; font-family: 华文楷体; font-size: 11pt;\"></span></p><p><br/></p>",
                    "like": 0,
                    "answer": [
                        "D"
                    ],
                    "option": [
                        " 对象图&nbsp; ",
                        " 活动图&nbsp; ",
                        " 状态图 ",
                        " 类图 "
                    ]
                },
                {
                    "index": 5,
                    "belong_page": 1,
                    "question_id": 43225,
                    "question_title": "<p><br/></p><p style=\"margin: 0px;\"><span style=\"margin: 0px; font-family: 华文楷体; font-size: 11pt;\"><span style=\"font-family:华文楷体\">在面向对象设计中，（</span></span><span style=\"margin: 0px; font-family: 华文楷体; font-size: 11pt;\">7</span><span style=\"margin: 0px; font-family: 华文楷体; font-size: 11pt;\"><span style=\"font-family:华文楷体\">）可以实现界面控制、外部接口和环境隔离。（</span></span><span style=\"margin: 0px; font-family: 华文楷体; font-size: 11pt;\">8</span><span style=\"margin: 0px; font-family: 华文楷体; font-size: 11pt;\"><span style=\"font-family:华文楷体\">）作为完成用例业务的责任承担者，协调、控制其他类共同完成用例规定的功能或行为。【回答括号7】</span></span></p><p><br/></p>",
                    "question_type": 1,
                    "answer_type": 1,
                    "show_type_name": null,
                    "new_parent_id": 43225,
                    "score_rule": "",
                    "material_text": null,
                    "sort_son": "0",
                    "analyze": "<p><br/></p><p style=\"margin: 0px; line-height: 150%; text-indent: 0pt; layout-grid-mode: char;\"><span style=\"margin: 0px; font-family: 华文楷体; font-size: 11pt;\"><span style=\"font-family:华文楷体\">类封装了信息和行为，是面向对象的重要组成部分。在面向对象设计中，类可以分为三种类型：实体类、边界类和控制类。</span></span><span style=\"margin: 0px; font-family: 华文楷体; font-size: 11pt;\"></span></p><p style=\"margin: 0px; line-height: 150%; layout-grid-mode: char;\"><span style=\"margin: 0px; font-family: 华文楷体; font-size: 11pt;\">①实体类映射需求中的每个实体，实体类保存需要存储在永久存储体中的信息。实体类是对用户来说最有意义的类，通常采用业务领域术语命名，一般来说是一个名词，在用例模型向领域模型转化中，一个参与者一般对应于实体类。</span><span style=\"margin: 0px; font-family: 华文楷体; font-size: 11pt;\"></span></p><p style=\"margin: 0px; line-height: 150%; layout-grid-mode: char;\"><span style=\"margin: 0px; font-family: 华文楷体; font-size: 11pt;\">②控制类是用于控制用例工作的类，一般是由动宾结构的短语(“动词+名词”或“名词+动词”)转化来的名词。控制类用于对一个或几个用例所特有的控制行为进行建模，控制对象通常控制其他对象，因此它们的行为具有协调性。</span><span style=\"margin: 0px; font-family: 华文楷体; font-size: 11pt;\"></span></p><p style=\"margin: 0px;\"><span style=\"margin: 0px; font-family: 华文楷体; font-size: 11pt;\">③边界类用于封装在用例内、外流动的信息或数据流。边界类是一种用于对系统外部环境与其内部运作之间的交互进行建模的类。边界对象将系统与其外部环境的变更隔离开，使这些变更不会对系统其他部分造成影响。</span></p><p><br/></p>",
                    "like": 0,
                    "answer": [
                        "C"
                    ],
                    "option": [
                        " 实体类 ",
                        " 控制类 ",
                        " 边界类 ",
                        " 交互类 "
                    ]
                },
                {
                    "index": 6,
                    "belong_page": 1,
                    "question_id": 43226,
                    "question_title": "<p><br/></p><p style=\"margin: 0px;\"><span style=\"margin: 0px; font-family: 华文楷体; font-size: 11pt;\"><span style=\"font-family:华文楷体\">在面向对象设计中，（</span></span><span style=\"margin: 0px; font-family: 华文楷体; font-size: 11pt;\">7</span><span style=\"margin: 0px; font-family: 华文楷体; font-size: 11pt;\"><span style=\"font-family:华文楷体\">）可以实现界面控制、外部接口和环境隔离。（</span></span><span style=\"margin: 0px; font-family: 华文楷体; font-size: 11pt;\">8</span><span style=\"margin: 0px; font-family: 华文楷体; font-size: 11pt;\"><span style=\"font-family:华文楷体\">）作为完成用例业务的责任承担者，协调、控制其他类共同完成用例规定的功能或行为。【回答括号8】</span></span></p><p><br/></p>",
                    "question_type": 1,
                    "answer_type": 1,
                    "show_type_name": null,
                    "new_parent_id": 43226,
                    "score_rule": "",
                    "material_text": null,
                    "sort_son": "0",
                    "analyze": "<p><br/></p><p style=\"margin: 0px; line-height: 150%; text-indent: 0pt; layout-grid-mode: char;\"><span style=\"margin: 0px; font-family: 华文楷体; font-size: 11pt;\"><span style=\"font-family:华文楷体\">类封装了信息和行为，是面向对象的重要组成部分。在面向对象设计中，类可以分为三种类型：实体类、边界类和控制类。</span></span><span style=\"margin: 0px; font-family: 华文楷体; font-size: 11pt;\"></span></p><p style=\"margin: 0px; line-height: 150%; layout-grid-mode: char;\"><span style=\"margin: 0px; font-family: 华文楷体; font-size: 11pt;\">①实体类映射需求中的每个实体，实体类保存需要存储在永久存储体中的信息。实体类是对用户来说最有意义的类，通常采用业务领域术语命名，一般来说是一个名词，在用例模型向领域模型转化中，一个参与者一般对应于实体类。</span><span style=\"margin: 0px; font-family: 华文楷体; font-size: 11pt;\"></span></p><p style=\"margin: 0px; line-height: 150%; layout-grid-mode: char;\"><span style=\"margin: 0px; font-family: 华文楷体; font-size: 11pt;\">②控制类是用于控制用例工作的类，一般是由动宾结构的短语(“动词+名词”或“名词+动词”)转化来的名词。控制类用于对一个或几个用例所特有的控制行为进行建模，控制对象通常控制其他对象，因此它们的行为具有协调性。</span><span style=\"margin: 0px; font-family: 华文楷体; font-size: 11pt;\"></span></p><p style=\"margin: 0px; line-height: 150%; layout-grid-mode: char;\"><span style=\"margin: 0px; font-family: 华文楷体; font-size: 11pt;\">③边界类用于封装在用例内、外流动的信息或数据流。边界类是一种用于对系统外部环境与其内部运作之间的交互进行建模的类。边界对象将系统与其外部环境的变更隔离开，使这些变更不会对系统其他部分造成影响。</span><span style=\"margin: 0px; font-family: 华文楷体; font-size: 11pt;\"></span></p><p><br/></p>",
                    "like": 0,
                    "answer": [
                        "B"
                    ],
                    "option": [
                        " 实体类 ",
                        " 控制类 ",
                        " 边界类 ",
                        " 交互类 "
                    ]
                },
                {
                    "index": 7,
                    "belong_page": 1,
                    "question_id": 43227,
                    "question_title": "<p>在结构化分析方法中，用（请作答此空）表示功能模型，用（ ）表示行为模型。</p>",
                    "question_type": 1,
                    "answer_type": 1,
                    "show_type_name": null,
                    "new_parent_id": 43227,
                    "score_rule": "",
                    "material_text": null,
                    "sort_son": "0",
                    "analyze": "<p>结构化分析方法的基本思想是自顶向下，逐层分解，把一个大问题分解成若干个小问题，每个小问题再分解成若干个更小的问题。经过逐层分解，每个最低层的问题都是足够简单、容易解决的。结构化方法分析模型的核心是数据字典，围绕这个核心，有三个层次的模型，分别是数据模型、功能模型和行为模型（也称为状态模型）。在实际工作中，一般使用E-R图表示数据模型，用DFD表示功能模型，用状态转换图表示行为模型。这三个模型有着密切的关系，它们的建立不具有严格的时序性，而是一个迭代的过程。</p>",
                    "like": 0,
                    "answer": [
                        "C"
                    ],
                    "option": [
                        " ER图&nbsp; ",
                        " 用例图 ",
                        " DFD&nbsp; ",
                        " 对象图 "
                    ]
                },
                {
                    "index": 8,
                    "belong_page": 1,
                    "question_id": 43228,
                    "question_title": "<p><br/></p><p style=\"margin: 0px;\"><span style=\"margin: 0px; font-family: 华文楷体; font-size: 11pt;\"><span style=\"font-family:华文楷体\">在结构化分析方法中，用</span>(</span><span style=\"margin: 0px; font-family: 华文楷体; font-size: 11pt;\">9</span><span style=\"margin: 0px; font-family: 华文楷体; font-size: 11pt;\">)表示功能模型，用（</span><span style=\"margin: 0px; font-family: 华文楷体; font-size: 11pt;\">10</span><span style=\"margin: 0px; font-family: 华文楷体; font-size: 11pt;\"><span style=\"font-family:华文楷体\">）表示行为模型。【回答括号10】</span></span></p><p><br/></p>",
                    "question_type": 1,
                    "answer_type": 1,
                    "show_type_name": null,
                    "new_parent_id": 43228,
                    "score_rule": "",
                    "material_text": null,
                    "sort_son": "0",
                    "analyze": "<p>结构化分析方法的基本思想是自顶向下，逐层分解，把一个大问题分解成若干个小问题，每个小问题再分解成若干个更小的问题。经过逐层分解，每个最低层的问题都是足够简单、容易解决的。结构化方法分析模型的核心是数据字典，围绕这个核心，有三个层次的模型，分别是数据模型、功能模型和行为模型(也称为状态模型)。在实际工作中，一般使用E-R图表示数据模型，用DFD表示功能模型，用状态转换图表示行为模型。这三个模型有着密切的关系，它们的建立不具有严格的时序性，而是一个迭代的过程。</p><p><br/></p><p><br/></p>",
                    "like": 0,
                    "answer": [
                        "D"
                    ],
                    "option": [
                        " 通信图 ",
                        " 顺序图 ",
                        " 活动图&nbsp; ",
                        " 状态转换图 "
                    ]
                },
                {
                    "index": 9,
                    "belong_page": 1,
                    "question_id": 43232,
                    "question_title": "<p><br/></p><p style=\"margin: 0px;\"><span style=\"margin: 0px; font-family: 华文楷体; font-size: 11pt;\"><span style=\"font-family:华文楷体\">面向对象的分析模型主要由顶层架构图、用例与用例图和（</span></span><span style=\"margin: 0px; font-family: 华文楷体; font-size: 11pt;\">13</span><span style=\"margin: 0px; font-family: 华文楷体; font-size: 11pt;\"><span style=\"font-family:华文楷体\">）构成：设计模型则包含以（</span></span><span style=\"margin: 0px; font-family: 华文楷体; font-size: 11pt;\">14</span><span style=\"margin: 0px; font-family: 华文楷体; font-size: 11pt;\"><span style=\"font-family:华文楷体\">）表示的软件体系机构图、以交互图表示的用例实现图、完整精确的类图、描述复杂对象的（</span></span><span style=\"margin: 0px; font-family: 华文楷体; font-size: 11pt;\">15</span><span style=\"margin: 0px; font-family: 华文楷体; font-size: 11pt;\"><span style=\"font-family:华文楷体\">）和用以描述流程化处理过程的活动图等。【回答括号13】</span></span></p><p><br/></p>",
                    "question_type": 1,
                    "answer_type": 1,
                    "show_type_name": null,
                    "new_parent_id": 43232,
                    "score_rule": "",
                    "material_text": null,
                    "sort_son": "0",
                    "analyze": "<p><br/></p><p style=\"margin: 0px; line-height: 150%; text-indent: 21pt; layout-grid-mode: char;\"><span style=\"margin: 0px; font-family: 华文楷体; font-size: 11pt;\"><span style=\"font-family:华文楷体\">面向对象的分析模型主要由顶层架构图、用例与用例图和领域概念模型构成；</span></span><span style=\"margin: 0px; font-family: 华文楷体; font-size: 11pt;\"></span></p><p style=\"margin: 0px; line-height: 150%; text-indent: 21pt; layout-grid-mode: char;\"><span style=\"margin: 0px; font-family: 华文楷体; font-size: 11pt;\"><span style=\"font-family:华文楷体\">设计模型则包含以包图表示的软件体系机构图、以交互图表示的用例实现图、完整精确的类图、描述复杂对象的状态图和用以描述流程化处理过程的活动图等。</span></span><span style=\"margin: 0px; font-family: 华文楷体; font-size: 11pt;\"></span></p><p><br/></p>",
                    "like": 0,
                    "answer": [
                        "B"
                    ],
                    "option": [
                        " 数据流模型 ",
                        " 领域概念模型 ",
                        " 功能分解图&nbsp; ",
                        " 功能需求模型 "
                    ]
                },
                {
                    "index": 10,
                    "belong_page": 1,
                    "question_id": 43234,
                    "question_title": "<p><br/></p><p style=\"margin: 0px; line-height: 150%; text-indent: 21pt; layout-grid-mode: char;\"><span style=\"margin: 0px; font-family: 华文楷体; font-size: 11pt;\"><span style=\"font-family:华文楷体\">面向对象的分析模型主要由顶层架构图、用例与用例图和（</span></span><span style=\"margin: 0px; font-family: 华文楷体; font-size: 11pt;\">13</span><span style=\"margin: 0px; font-family: 华文楷体; font-size: 11pt;\"><span style=\"font-family:华文楷体\">）构成：设计模型则包含以（</span></span><span style=\"margin: 0px; font-family: 华文楷体; font-size: 11pt;\">14</span><span style=\"margin: 0px; font-family: 华文楷体; font-size: 11pt;\"><span style=\"font-family:华文楷体\">）表示的软件体系机构图、以交互图表示的用例实现图、完整精确的类图、描述复杂对象的（</span></span><span style=\"margin: 0px; font-family: 华文楷体; font-size: 11pt;\">15</span><span style=\"margin: 0px; font-family: 华文楷体; font-size: 11pt;\"><span style=\"font-family:华文楷体\">）和用以描述流程化处理过程的活动图等。【回答括号14】</span></span><span style=\"margin: 0px; font-family: 华文楷体; font-size: 11pt;\"></span></p><p><br/></p>",
                    "question_type": 1,
                    "answer_type": 1,
                    "show_type_name": null,
                    "new_parent_id": 43234,
                    "score_rule": "",
                    "material_text": null,
                    "sort_son": "0",
                    "analyze": "<p><br/></p><p style=\"margin: 0px; line-height: 150%; text-indent: 21pt; layout-grid-mode: char;\"><span style=\"margin: 0px; font-family: 华文楷体; font-size: 11pt;\"><span style=\"font-family:华文楷体\">面向对象的分析模型主要由顶层架构图、用例与用例图和领域概念模型构成；</span></span><span style=\"margin: 0px; font-family: 华文楷体; font-size: 11pt;\"></span></p><p style=\"margin: 0px; line-height: 150%; text-indent: 21pt; layout-grid-mode: char;\"><span style=\"margin: 0px; font-family: 华文楷体; font-size: 11pt;\"><span style=\"font-family:华文楷体\">设计模型则包含以包图表示的软件体系机构图、以交互图表示的用例实现图、完整精确的类图、描述复杂对象的状态图和用以描述流程化处理过程的活动图等。</span></span><span style=\"margin: 0px; font-family: 华文楷体; font-size: 11pt;\"></span></p><p><br/></p>",
                    "like": 0,
                    "answer": [
                        "C"
                    ],
                    "option": [
                        " 模型试图控制器 ",
                        " 组件图 ",
                        " 包图 ",
                        " 2&nbsp;层、3&nbsp;层或&nbsp;N&nbsp;层 "
                    ]
                },
                {
                    "index": 11,
                    "belong_page": 1,
                    "question_id": 43235,
                    "question_title": "<p><br/></p><p style=\"margin: 0px;\"><span style=\"margin: 0px; font-family: 华文楷体; font-size: 11pt;\"><span style=\"font-family:华文楷体\">面向对象的分析模型主要由顶层架构图、用例与用例图和（</span></span><span style=\"margin: 0px; font-family: 华文楷体; font-size: 11pt;\">13</span><span style=\"margin: 0px; font-family: 华文楷体; font-size: 11pt;\"><span style=\"font-family:华文楷体\">）构成：设计模型则包含以（</span></span><span style=\"margin: 0px; font-family: 华文楷体; font-size: 11pt;\">14</span><span style=\"margin: 0px; font-family: 华文楷体; font-size: 11pt;\"><span style=\"font-family:华文楷体\">）表示的软件体系机构图、以交互图表示的用例实现图、完整精确的类图、描述复杂对象的（</span></span><span style=\"margin: 0px; font-family: 华文楷体; font-size: 11pt;\">15</span><span style=\"margin: 0px; font-family: 华文楷体; font-size: 11pt;\"><span style=\"font-family:华文楷体\">）和用以描述流程化处理过程的活动图等。【回答括号15】</span></span></p><p><br/></p>",
                    "question_type": 1,
                    "answer_type": 1,
                    "show_type_name": null,
                    "new_parent_id": 43235,
                    "score_rule": "",
                    "material_text": null,
                    "sort_son": "0",
                    "analyze": "<p><br/></p><p style=\"margin: 0px; line-height: 150%; text-indent: 21pt; layout-grid-mode: char;\"><span style=\"margin: 0px; font-family: 华文楷体; font-size: 11pt;\"><span style=\"font-family:华文楷体\">面向对象的分析模型主要由顶层架构图、用例与用例图和领域概念模型构成；</span></span><span style=\"margin: 0px; font-family: 华文楷体; font-size: 11pt;\"></span></p><p style=\"margin: 0px; line-height: 150%; text-indent: 21pt; layout-grid-mode: char;\"><span style=\"margin: 0px; font-family: 华文楷体; font-size: 11pt;\"><span style=\"font-family:华文楷体\">设计模型则包含以包图表示的软件体系机构图、以交互图表示的用例实现图、完整精确的类图、描述复杂对象的状态图和用以描述流程化处理过程的活动图等。</span></span><span style=\"margin: 0px; font-family: 华文楷体; font-size: 11pt;\"></span></p><p><br/></p>",
                    "like": 0,
                    "answer": [
                        "D"
                    ],
                    "option": [
                        " 序列图&nbsp; ",
                        " 协作图&nbsp;&nbsp; ",
                        " 流程图&nbsp;&nbsp;&nbsp;&nbsp; ",
                        " 状态图 "
                    ]
                },
                {
                    "index": 12,
                    "belong_page": 1,
                    "question_id": 43243,
                    "question_title": "某系统中的文本显示类 (Text View) 和图片显示类 (Picture View) 都继承了组件类 (Component)，分别显示文本和图片内容，现需要构造带有滚动条或者带有黑色边框，或者既有滚动条又有黑色边框的文本显示控件和图片显示控件，但希望最多只增加3个类。那么采用设计模式（请作答此空）可实现该需求，其优点是（ ）。",
                    "question_type": 1,
                    "answer_type": 1,
                    "show_type_name": null,
                    "new_parent_id": 43243,
                    "score_rule": "",
                    "material_text": null,
                    "sort_son": "0",
                    "analyze": "装饰 (Decorator) 模式可以再不修改对象外观和功能的情况下添加或者删除对象功能。它可以使用一种对客户端来说是透明的方法来修改对象的功能，也就是使用初始类的子类实例对初始对象进行授权。装饰模式还为对象动态地添加了额外的重任，这样就在不使用静态继承的情况下，为修改对象功能提供了灵活的选择。<p><br/>在以下情况中，应该使用装饰模式：<br/></p><p>• 想要在单个对象中动态并且透明地添加责任，而这样并不会影响其他对象；<br/></p><p>• 想要在以后可能要修改的对象中添加责任；<br/></p><p>• 当无法通过静态子类化实现扩展时。</p><p></p>",
                    "like": 0,
                    "answer": [
                        "C"
                    ],
                    "option": [
                        " 外观 ",
                        " 单体 ",
                        " 装饰 ",
                        " 模板方法 "
                    ]
                },
                {
                    "index": 13,
                    "belong_page": 1,
                    "question_id": 43245,
                    "question_title": "<p><br/></p><p style=\"margin: 0px; line-height: 150%; text-indent: 21pt; layout-grid-mode: char;\"><span style=\"margin: 0px; font-family: 华文楷体; font-size: 11pt;\"><span style=\"font-family:华文楷体\">某系统中的文本显示类</span>(Text View)和图片显示类(Picture View)都继承了组件类(Component)，分别显示文本和图片内容，现需要构造带有滚动条或者带有黑色边框，或者既有滚动条又有黑色边框的文本显示控件和图片显示控件，但希望最多只增加3个类。那么采用设计模式（</span><span style=\"margin: 0px; font-family: 华文楷体; font-size: 11pt;\">1</span><span style=\"margin: 0px; font-family: 华文楷体; font-size: 11pt;\"><span style=\"font-family:华文楷体\">）可实现该需求，其优点是（</span></span><span style=\"margin: 0px; font-family: 华文楷体; font-size: 11pt;\">2</span><span style=\"margin: 0px; font-family: 华文楷体; font-size: 11pt;\"><span style=\"font-family:华文楷体\">）。【回答括号2】</span></span><span style=\"margin: 0px; font-family: 华文楷体; font-size: 11pt;\"></span></p><p><br/></p>",
                    "question_type": 1,
                    "answer_type": 1,
                    "show_type_name": null,
                    "new_parent_id": 43245,
                    "score_rule": "",
                    "material_text": null,
                    "sort_son": "0",
                    "analyze": "<p><br/></p><p style=\"margin: 0px; line-height: 150%; text-indent: 21pt; layout-grid-mode: char;\"><span style=\"margin: 0px; font-family: 华文楷体; font-size: 11pt;\"><span style=\"font-family:华文楷体\">装饰</span>(Decorator)模式可以再不修改对象外观和功能的情况下添加或者删除对象功能。它可以使用一种对客户端来说是透明的方法来修改对象的功能，也就是使用初始类的子类实例对初始对象进行授权。装饰模式还为对象动态地添加了额外的重任，这样就在不使用静态继承的情况下，为修改对象功能提供了灵活的选择。</span><span style=\"margin: 0px; font-family: 华文楷体; font-size: 11pt;\"></span></p><p style=\"margin: 0px; line-height: 150%; layout-grid-mode: char;\"><span style=\"margin: 0px; font-family: 华文楷体; font-size: 11pt;\"><span style=\"font-family:华文楷体\">在以下情况中，应该使用装饰模式：</span></span><span style=\"margin: 0px; font-family: 华文楷体; font-size: 11pt;\"></span></p><p style=\"margin: 0px; line-height: 150%; layout-grid-mode: char;\"><span style=\"margin: 0px; font-family: 华文楷体; font-size: 11pt;\">•想要在单个对象中动态并且透明地添加责任，而这样并不会影响其他对象；</span><span style=\"margin: 0px; font-family: 华文楷体; font-size: 11pt;\"></span></p><p style=\"margin: 0px; line-height: 150%; layout-grid-mode: char;\"><span style=\"margin: 0px; font-family: 华文楷体; font-size: 11pt;\">•想要在以后可能要修改的对象中添加责任；</span><span style=\"margin: 0px; font-family: 华文楷体; font-size: 11pt;\"></span></p><p style=\"margin: 0px; line-height: 150%; layout-grid-mode: char;\"><span style=\"margin: 0px; font-family: 华文楷体; font-size: 11pt;\">•当无法通过静态子类化实现扩展时。</span><span style=\"margin: 0px; font-family: 华文楷体; font-size: 11pt;\"></span></p><p><br/></p>",
                    "like": 0,
                    "answer": [
                        "A"
                    ],
                    "option": [
                        " 比静态继承具有更大的灵活性&nbsp; ",
                        " 提高已有功能的重复使用性 ",
                        " 可以将接口与实现相分离&nbsp;&nbsp; ",
                        " 为复杂系统提供了简单接口 "
                    ]
                },
                {
                    "index": 14,
                    "belong_page": 1,
                    "question_id": 43247,
                    "question_title": "<p><br/></p><p style=\"margin: 0px;\"><span style=\"margin: 0px; font-family: 华文楷体; font-size: 11pt;\"><span style=\"font-family:华文楷体\">一组对象以定义良好但是复杂的方式进行通信，产生的相互依赖关系结构混乱且难以理解。采用</span>( &nbsp; </span><span style=\"margin: 0px; font-family: 华文楷体; font-size: 11pt;\">)模式，用一个特定对象来封装一系列的对象交互，从而使各对象不需要显式地相互引用，使其耦合松散，而且可以独立地改变它们之间的交互。</span></p><p><br/></p>",
                    "question_type": 1,
                    "answer_type": 1,
                    "show_type_name": null,
                    "new_parent_id": 43247,
                    "score_rule": "",
                    "material_text": null,
                    "sort_son": "0",
                    "analyze": "<p><br/></p><p style=\"margin: 0px; line-height: 150%; text-indent: 21pt; layout-grid-mode: char;\"><span style=\"margin: 0px; font-family: 华文楷体; font-size: 11pt;\"><span style=\"font-family:华文楷体\">解释器模式属于类的行为模式，描述了如何为语言定义一个文法，如何在该语言中表示一个句子，以及如何解释这些句子，这里的</span>“语言”是使用规定格式和语法的代码。</span><span style=\"margin: 0px; font-family: 华文楷体; font-size: 11pt;\"></span></p><p style=\"margin: 0px; line-height: 150%; text-indent: 21pt; layout-grid-mode: char;\"><span style=\"margin: 0px; font-family: 华文楷体; font-size: 11pt;\"><span style=\"font-family:华文楷体\">策略模式是一种对象的行为型模式，定义一系列算法，并将每个算法封装起来，并让它们可以相互替换。策略模式让算法独立于使用它的客户而变化，其目的是将行为和环境分隔，当出现新的行为时，只需要实现新的策略类。</span></span><span style=\"margin: 0px; font-family: 华文楷体; font-size: 11pt;\"></span></p><p style=\"margin: 0px; line-height: 150%; text-indent: 21pt; layout-grid-mode: char;\"><span style=\"margin: 0px; font-family: 华文楷体; font-size: 11pt;\"><span style=\"font-family:华文楷体\">中介者模式是一种对象的行为行模式，通过一个中介对象来封装一系列的对象交互。中介者使得各对象不需要现实地相互引用，从而使其耦合松散，而且可以独立地改变它们之间的交互。中介者对象的存在保证了对象结构上的稳定，也就说说系统的结构不会因为新对象的引入带来大量的修改工作。</span></span><span style=\"margin: 0px; font-family: 华文楷体; font-size: 11pt;\"></span></p><p style=\"margin: 0px; line-height: 150%; text-indent: 21pt; layout-grid-mode: char;\"><span style=\"margin: 0px; font-family: 华文楷体; font-size: 11pt;\"><span style=\"font-family:华文楷体\">迭代器模式是一种对象的行为型模式，提供了一种方法来访问聚合对象，而不用暴露这个对象的内部表示。迭代器模式支持以不同的方式遍历一个聚合对象。</span></span><span style=\"margin: 0px; font-family: 华文楷体; font-size: 11pt;\"></span></p><p><br/></p>",
                    "like": 0,
                    "answer": [
                        "C"
                    ],
                    "option": [
                        " 解释器(Interpreter) ",
                        " 策略(Strategy) ",
                        " 中介者(Mediator) ",
                        " 迭代器(Iterator) "
                    ]
                },
                {
                    "index": 15,
                    "belong_page": 1,
                    "question_id": 43249,
                    "question_title": "<p><br/></p><p style=\"margin: 0px; line-height: 150%; layout-grid-mode: char;\"><span style=\"margin: 0px; font-family: 华文楷体; font-size: 11pt;\"><span style=\"font-family:华文楷体\">某广告公司的宣传产品有宣传册、文章、传单等多种形式，宣传产品的出版方式包括纸质方式、</span>CD、DVD、在线发布等。现要求为该广告公司设计一个管理这些宣传产品的应用，采用（</span><span style=\"margin: 0px; font-family: 华文楷体; font-size: 11pt;\">4</span><span style=\"margin: 0px; font-family: 华文楷体; font-size: 11pt;\"><span style=\"font-family:华文楷体\">）设计模式较为合适，该模式（</span></span><span style=\"margin: 0px; font-family: 华文楷体; font-size: 11pt;\">5</span><span style=\"margin: 0px; font-family: 华文楷体; font-size: 11pt;\"><span style=\"font-family:华文楷体\">）。【回答括号4】</span></span><span style=\"margin: 0px; font-family: 华文楷体; font-size: 11pt;\"></span></p><p><br/></p>",
                    "question_type": 1,
                    "answer_type": 1,
                    "show_type_name": null,
                    "new_parent_id": 43249,
                    "score_rule": "",
                    "material_text": null,
                    "sort_son": "0",
                    "analyze": "<p><br/></p><p style=\"margin: 0px; line-height: 150%; text-indent: 21pt; layout-grid-mode: char;\"><span style=\"margin: 0px; font-family: 华文楷体; font-size: 11pt;\"><span style=\"font-family:华文楷体\">题目所给出的应用中，不希望在不同的宣传产品与具体所采用的出版方式之间建立一个固定的绑定关系，以避免这两者之间的紧耦合关系。这种情形适合于采用</span>Bridge(桥接)模式。桥接模式属于结构型设计模式的一种。结构型模式描述如何将类或对象合在一起形成更大的结构。桥接模式将抽象部分与它的实现部分分离，使它们都可以独立地变化。</span><span style=\"margin: 0px; font-family: 华文楷体; font-size: 11pt;\"></span></p><p style=\"margin: 0px;\"><span style=\"margin: 0px; font-family: 华文楷体; font-size: 11pt;\"><span style=\"font-family:华文楷体\">在以下情况可以使用</span>Bridge模式：&nbsp;①不希望在抽象以及抽象的实现部分之间有一个固定的绑定关系。例如这种情况可能是因为，在程序运行时刻可以选择或切换实现部分；②类的抽象以及它的实现都应该可以通过生成子类的方法加以扩充，使用Bridge模式可以对不同的抽象接口和实现部分进行组合，并分别对它们进行扩充。③对一个抽象的实现部分的修改应该对用户不产生影响，即客户的代码不必重新编译。</span></p><p><br/></p>",
                    "like": 0,
                    "answer": [
                        "C"
                    ],
                    "option": [
                        " Decorator ",
                        " Adapter ",
                        " Bridge&nbsp;&nbsp;&nbsp;&nbsp; ",
                        " Facade "
                    ]
                },
                {
                    "index": 16,
                    "belong_page": 1,
                    "question_id": 43251,
                    "question_title": "<p><br/></p><p style=\"margin: 0px; line-height: 150%; layout-grid-mode: char;\"><span style=\"margin: 0px; font-family: 华文楷体; font-size: 11pt;\"><span style=\"font-family:华文楷体\">某广告公司的宣传产品有宣传册、文章、传单等多种形式，宣传产品的出版方式包括纸质方式、</span>CD、DVD、在线发布等。现要求为该广告公司设计一个管理这些宣传产品的应用，采用（</span><span style=\"margin: 0px; font-family: 华文楷体; font-size: 11pt;\">4</span><span style=\"margin: 0px; font-family: 华文楷体; font-size: 11pt;\"><span style=\"font-family:华文楷体\">）设计模式较为合适，该模式（</span></span><span style=\"margin: 0px; font-family: 华文楷体; font-size: 11pt;\">5</span><span style=\"margin: 0px; font-family: 华文楷体; font-size: 11pt;\"><span style=\"font-family:华文楷体\">）。【回答括号5】</span></span><span style=\"margin: 0px; font-family: 华文楷体; font-size: 11pt;\"></span></p><p><br/></p>",
                    "question_type": 1,
                    "answer_type": 1,
                    "show_type_name": null,
                    "new_parent_id": 43251,
                    "score_rule": "",
                    "material_text": null,
                    "sort_son": "0",
                    "analyze": "<p><br/></p><p style=\"margin: 0px; line-height: 150%; text-indent: 21pt; layout-grid-mode: char;\"><span style=\"margin: 0px; font-family: 华文楷体; font-size: 11pt;\"><span style=\"font-family:华文楷体\">题目所给出的应用中，不希望在不同的宣传产品与具体所采用的出版方式之间建立一个固定的绑定关系，以避免这两者之间的紧耦合关系。这种情形适合于采用</span>Bridge(桥接)模式。桥接模式属于结构型设计模式的一种。结构型模式描述如何将类或对象合在一起形成更大的结构。桥接模式将抽象部分与它的实现部分分离，使它们都可以独立地变化。</span><span style=\"margin: 0px; font-family: 华文楷体; font-size: 11pt;\"></span></p><p style=\"margin: 0px; line-height: 150%; text-indent: 21pt; layout-grid-mode: char;\"><span style=\"margin: 0px; font-family: 华文楷体; font-size: 11pt;\"><span style=\"font-family:华文楷体\">在以下情况可以使用</span>Bridge模式：&nbsp;①不希望在抽象以及抽象的实现部分之间有一个固定的绑定关系。例如这种情况可能是因为，在程序运行时刻可以选择或切换实现部分；②类的抽象以及它的实现都应该可以通过生成子类的方法加以扩充，使用Bridge模式可以对不同的抽象接口和实现部分进行组合，并分别对它们进行扩充。③对一个抽象的实现部分的修改应该对用户不产生影响，即客户的代码不必重新编译。</span><span style=\"margin: 0px; font-family: 华文楷体; font-size: 11pt;\"></span></p><p><br/></p>",
                    "like": 0,
                    "answer": [
                        "B"
                    ],
                    "option": [
                        " 将一系列复杂的类包装成一个简单的封闭接口 ",
                        " 将抽象部分与它的实现部分分离，使它们都可以独立地变化 ",
                        " 可在不影响其他对象的情况下，以动态、透明的方式给单个对象添加职责 ",
                        " 将一个接口转换为客户希望的另一个接口 "
                    ]
                },
                {
                    "index": 17,
                    "belong_page": 1,
                    "question_id": 43255,
                    "question_title": "<p>某软件公司欲开发一个绘图软件，要求使用不同的绘图程序绘制不同的图形。在明确用户需求后，该公司的架构师决定采用Bridge模式实现该软件，并设计UML类图如下图所示。图中与Bridge模式中的“Abstraction”角色相对应的类是（请作答此空），与“Implementor”角色相对应的类是（ ）。<br/><img style=\"max-width:100%;height:auto\"  src=\"https://s2.51cto.com/images/20211202/1638434226414799.png\" title=\"1638434226414799.png\" alt=\"屏幕截图 2021-12-02.png\"/></p>",
                    "question_type": 1,
                    "answer_type": 1,
                    "show_type_name": null,
                    "new_parent_id": 43255,
                    "score_rule": "",
                    "material_text": null,
                    "sort_son": "0",
                    "analyze": "<p>桥接模式将抽象部分与它的实现部分分离，使它们都可以独立地变化。它是一种对象结构型模式，又称为柄体(Handle and Body)模式或接口(Interface)模式。桥接模式类似于多重继承方案，但是多重继承方案往往违背了类的单一职责原则，其复用性比较差，桥接模式是比多重继承方案更好的解决方法。</p><p>·Abstraction定义抽象类的接口；维护一个指向Implementor类型对象的指针。</p><p>·RefinedAbstraction扩充由Abstraction定义的接口。</p><p>·Implementor定义实现类的接口，该接口不一定要与Abstraction的接口完全一致；事实上这两个接口可以完全不同。一般来说，Implementor接口仅提供基本操作，而Abstraction则定义了基于这些基本操作的较高层次的操作。</p><p>·ConcreteImplementor实现Implementor接口并定义它的具体实现。</p><p>图中与Bridge模式中的“Abstraction”角色相对应的类是Shape，与“Implementor”角色相对应的类是Drawing。</p><p><br/></p>",
                    "like": 0,
                    "answer": [
                        "A"
                    ],
                    "option": [
                        " Shape ",
                        " Drawing&nbsp; ",
                        " Rectangle&nbsp; ",
                        " V2Drawing "
                    ]
                },
                {
                    "index": 18,
                    "belong_page": 1,
                    "question_id": 43256,
                    "question_title": "<p>某软件公司欲开发一个绘图软件，要求使用不同的绘图程序绘制不同的图形。在明确用户需求后，该公司的架构师决定采用Bridge模式实现该软件，并设计UML类图如下图所示。图中与Bridge模式中的“Abstraction”角色相对应的类是（ ），与“Implementor”角色相对应的类是（请作答此空）。<br/><img style=\"max-width:100%;height:auto\"  src=\"https://s2.51cto.com/images/20211202/1638434347909527.png\" title=\"1638434347909527.png\" alt=\"屏幕截图 2021-12-02.png\"/></p>",
                    "question_type": 1,
                    "answer_type": 1,
                    "show_type_name": null,
                    "new_parent_id": 43256,
                    "score_rule": "",
                    "material_text": null,
                    "sort_son": "0",
                    "analyze": "<p>桥接模式将抽象部分与它的实现部分分离，使它们都可以独立地变化。它是一种对象结构型模式，又称为柄体(Handle and Body)模式或接口(Interface)模式。桥接模式类似于多重继承方案，但是多重继承方案往往违背了类的单一职责原则，其复用性比较差，桥接模式是比多重继承方案更好的解决方法。</p><p>·Abstraction定义抽象类的接口；维护一个指向Implementor类型对象的指针。</p><p>·RefinedAbstraction扩充由Abstraction定义的接口。</p><p>·Implementor定义实现类的接口，该接口不一定要与Abstraction的接口完全一致；事实上这两个接口可以完全不同。一般来说，Implementor接口仅提供基本操作，而Abstraction则定义了基于这些基本操作的较高层次的操作。</p><p>·ConcreteImplementor实现Implementor接口并定义它的具体实现。</p><p>图中与Bridge模式中的“Abstraction”角色相对应的类是Shape，与“Implementor”角色相对应的类是Drawing。</p><p><br/></p>",
                    "like": 0,
                    "answer": [
                        "B"
                    ],
                    "option": [
                        " Shape&nbsp; ",
                        " Drawing ",
                        " Rectangle ",
                        " V2Drawing "
                    ]
                },
                {
                    "index": 19,
                    "belong_page": 1,
                    "question_id": 43259,
                    "question_title": "<p><br/></p><p style=\"margin: 0px; line-height: 150%; text-indent: 21pt; layout-grid-mode: char;\"><span style=\"margin: 0px; font-family: 华文楷体; font-size: 11pt;\"><span style=\"font-family:华文楷体\">按照设计模式的目的进行划分，现有的设计模式可以分为三类。其中创建型模式通过采用抽象类所定义的接口，封装了系统中对象如何创建、组合等信息，其代表有</span>(</span><span style=\"margin: 0px; font-family: 华文楷体; font-size: 11pt;\">9</span><span style=\"margin: 0px; font-family: 华文楷体; font-size: 11pt;\">)模式等;(</span><span style=\"margin: 0px; font-family: 华文楷体; font-size: 11pt;\">10</span><span style=\"margin: 0px; font-family: 华文楷体; font-size: 11pt;\">)模式主要用于如何组合己有的类和对象以获得更大的结构，其代表有 Adapter 模式等;(</span><span style=\"margin: 0px; font-family: 华文楷体; font-size: 11pt;\">11</span><span style=\"margin: 0px; font-family: 华文楷体; font-size: 11pt;\">)模式主要用于对象之间的职责及其提供服务的分配方式，其代表有(</span><span style=\"margin: 0px; font-family: 华文楷体; font-size: 11pt;\">12</span><span style=\"margin: 0px; font-family: 华文楷体; font-size: 11pt;\">)模式等。【回答括号9】</span><span style=\"margin: 0px; font-family: 华文楷体; font-size: 11pt;\"></span></p><p><br/></p>",
                    "question_type": 1,
                    "answer_type": 1,
                    "show_type_name": null,
                    "new_parent_id": 43259,
                    "score_rule": "",
                    "material_text": null,
                    "sort_son": "0",
                    "analyze": "<p><br/></p><p style=\"margin: 0px; line-height: 150%; text-indent: 21pt; layout-grid-mode: char;\"><span style=\"margin: 0px; font-family: 华文楷体; font-size: 11pt;\"><span style=\"font-family:华文楷体\">按照设计模式的目的进行划分，现有的设计模式可以分为三类。</span></span><span style=\"margin: 0px; font-family: 华文楷体; font-size: 11pt;\"></span></p><p style=\"margin: 0px; line-height: 150%; text-indent: 21pt; layout-grid-mode: char;\"><span style=\"margin: 0px; font-family: 华文楷体; font-size: 11pt;\"><span style=\"font-family:华文楷体\">创建型模式通过采用抽象类所定义的接口，封装了系统中对象如何创建、组合等信息，其代表有</span>Singleton模式等; </span><span style=\"margin: 0px; font-family: 华文楷体; font-size: 11pt;\"></span></p><p style=\"margin: 0px; line-height: 150%; text-indent: 21pt; layout-grid-mode: char;\"><span style=\"margin: 0px; font-family: 华文楷体; font-size: 11pt;\"><span style=\"font-family:华文楷体\">结构型模式主要用于如何组合己有的类和对象以获得更大的结构，其代表有</span> Adapter 模式等; </span><span style=\"margin: 0px; font-family: 华文楷体; font-size: 11pt;\"></span></p><p style=\"margin: 0px; line-height: 150%; text-indent: 21pt; layout-grid-mode: char;\"><span style=\"margin: 0px; font-family: 华文楷体; font-size: 11pt;\"><span style=\"font-family:华文楷体\">行为型模式主要用于对象之间的职责及其提供服务的分配方式，其代表有</span>Visitor模式等。</span><span style=\"margin: 0px; font-family: 华文楷体; font-size: 11pt;\"></span></p><p><br/></p>",
                    "like": 0,
                    "answer": [
                        "D"
                    ],
                    "option": [
                        " Decorator ",
                        " Fly&nbsp;weight ",
                        " &nbsp;Command ",
                        " Singleton "
                    ]
                },
                {
                    "index": 20,
                    "belong_page": 1,
                    "question_id": 43260,
                    "question_title": "<p><br/></p><p style=\"margin: 0px; line-height: 150%; text-indent: 21pt; layout-grid-mode: char;\"><span style=\"margin: 0px; font-family: 华文楷体; font-size: 11pt;\"><span style=\"font-family:华文楷体\">按照设计模式的目的进行划分，现有的设计模式可以分为三类。其中创建型模式通过采用抽象类所定义的接口，封装了系统中对象如何创建、组合等信息，其代表有</span>(</span><span style=\"margin: 0px; font-family: 华文楷体; font-size: 11pt;\">9</span><span style=\"margin: 0px; font-family: 华文楷体; font-size: 11pt;\">)模式等;(</span><span style=\"margin: 0px; font-family: 华文楷体; font-size: 11pt;\">10</span><span style=\"margin: 0px; font-family: 华文楷体; font-size: 11pt;\">)模式主要用于如何组合己有的类和对象以获得更大的结构，其代表有 Adapter 模式等;(</span><span style=\"margin: 0px; font-family: 华文楷体; font-size: 11pt;\">11</span><span style=\"margin: 0px; font-family: 华文楷体; font-size: 11pt;\">)模式主要用于对象之间的职责及其提供服务的分配方式，其代表有(</span><span style=\"margin: 0px; font-family: 华文楷体; font-size: 11pt;\">12</span><span style=\"margin: 0px; font-family: 华文楷体; font-size: 11pt;\">)模式等。【回答括号10】</span></p><p><br/></p>",
                    "question_type": 1,
                    "answer_type": 1,
                    "show_type_name": null,
                    "new_parent_id": 43260,
                    "score_rule": "",
                    "material_text": null,
                    "sort_son": "0",
                    "analyze": "<p><br/></p><p style=\"margin: 0px; line-height: 150%; text-indent: 21pt; layout-grid-mode: char;\"><span style=\"margin: 0px; font-family: 华文楷体; font-size: 11pt;\"><span style=\"font-family:华文楷体\">按照设计模式的目的进行划分，现有的设计模式可以分为三类。</span></span><span style=\"margin: 0px; font-family: 华文楷体; font-size: 11pt;\"></span></p><p style=\"margin: 0px; line-height: 150%; text-indent: 21pt; layout-grid-mode: char;\"><span style=\"margin: 0px; font-family: 华文楷体; font-size: 11pt;\"><span style=\"font-family:华文楷体\">创建型模式通过采用抽象类所定义的接口，封装了系统中对象如何创建、组合等信息，其代表有</span>Singleton模式等; </span><span style=\"margin: 0px; font-family: 华文楷体; font-size: 11pt;\"></span></p><p style=\"margin: 0px; line-height: 150%; text-indent: 21pt; layout-grid-mode: char;\"><span style=\"margin: 0px; font-family: 华文楷体; font-size: 11pt;\"><span style=\"font-family:华文楷体\">结构型模式主要用于如何组合己有的类和对象以获得更大的结构，其代表有</span> Adapter 模式等; </span><span style=\"margin: 0px; font-family: 华文楷体; font-size: 11pt;\"></span></p><p style=\"margin: 0px; line-height: 150%; text-indent: 21pt; layout-grid-mode: char;\"><span style=\"margin: 0px; font-family: 华文楷体; font-size: 11pt;\"><span style=\"font-family:华文楷体\">行为型模式主要用于对象之间的职责及其提供服务的分配方式，其代表有</span>Visitor模式等。</span><span style=\"margin: 0px; font-family: 华文楷体; font-size: 11pt;\"></span></p><p><br/></p>",
                    "like": 0,
                    "answer": [
                        "C"
                    ],
                    "option": [
                        " 合成型 ",
                        " 组合型 ",
                        " 结构型 ",
                        " 聚合型 "
                    ]
                },
                {
                    "index": 21,
                    "belong_page": 1,
                    "question_id": 43261,
                    "question_title": "<p><br/></p><p style=\"margin: 0px; line-height: 150%; text-indent: 21pt; layout-grid-mode: char;\"><span style=\"margin: 0px; font-family: 华文楷体; font-size: 11pt;\"><span style=\"font-family:华文楷体\">按照设计模式的目的进行划分，现有的设计模式可以分为三类。其中创建型模式通过采用抽象类所定义的接口，封装了系统中对象如何创建、组合等信息，其代表有</span>(</span><span style=\"margin: 0px; font-family: 华文楷体; font-size: 11pt;\">9</span><span style=\"margin: 0px; font-family: 华文楷体; font-size: 11pt;\">)模式等;(</span><span style=\"margin: 0px; font-family: 华文楷体; font-size: 11pt;\">10</span><span style=\"margin: 0px; font-family: 华文楷体; font-size: 11pt;\">)模式主要用于如何组合己有的类和对象以获得更大的结构，其代表有 Adapter 模式等;(</span><span style=\"margin: 0px; font-family: 华文楷体; font-size: 11pt;\">11</span><span style=\"margin: 0px; font-family: 华文楷体; font-size: 11pt;\">)模式主要用于对象之间的职责及其提供服务的分配方式，其代表有(</span><span style=\"margin: 0px; font-family: 华文楷体; font-size: 11pt;\">12</span><span style=\"margin: 0px; font-family: 华文楷体; font-size: 11pt;\">)模式等。【回答括号11】</span><span style=\"margin: 0px; font-family: 华文楷体; font-size: 11pt;\"></span></p><p><br/></p>",
                    "question_type": 1,
                    "answer_type": 1,
                    "show_type_name": null,
                    "new_parent_id": 43261,
                    "score_rule": "",
                    "material_text": null,
                    "sort_son": "0",
                    "analyze": "<p><br/></p><p style=\"margin: 0px; line-height: 150%; text-indent: 21pt; layout-grid-mode: char;\"><span style=\"margin: 0px; font-family: 华文楷体; font-size: 11pt;\"><span style=\"font-family:华文楷体\">按照设计模式的目的进行划分，现有的设计模式可以分为三类。</span></span><span style=\"margin: 0px; font-family: 华文楷体; font-size: 11pt;\"></span></p><p style=\"margin: 0px; line-height: 150%; text-indent: 21pt; layout-grid-mode: char;\"><span style=\"margin: 0px; font-family: 华文楷体; font-size: 11pt;\"><span style=\"font-family:华文楷体\">创建型模式通过采用抽象类所定义的接口，封装了系统中对象如何创建、组合等信息，其代表有</span>Singleton模式等; </span><span style=\"margin: 0px; font-family: 华文楷体; font-size: 11pt;\"></span></p><p style=\"margin: 0px; line-height: 150%; text-indent: 21pt; layout-grid-mode: char;\"><span style=\"margin: 0px; font-family: 华文楷体; font-size: 11pt;\"><span style=\"font-family:华文楷体\">结构型模式主要用于如何组合己有的类和对象以获得更大的结构，其代表有</span> Adapter 模式等; </span><span style=\"margin: 0px; font-family: 华文楷体; font-size: 11pt;\"></span></p><p style=\"margin: 0px; line-height: 150%; text-indent: 21pt; layout-grid-mode: char;\"><span style=\"margin: 0px; font-family: 华文楷体; font-size: 11pt;\"><span style=\"font-family:华文楷体\">行为型模式主要用于对象之间的职责及其提供服务的分配方式，其代表有</span>Visitor模式等。</span><span style=\"margin: 0px; font-family: 华文楷体; font-size: 11pt;\"></span></p><p><br/></p>",
                    "like": 0,
                    "answer": [
                        "A"
                    ],
                    "option": [
                        " 行为型 ",
                        " 交互型 ",
                        " 耦合性 ",
                        " 关联型 "
                    ]
                },
                {
                    "index": 22,
                    "belong_page": 1,
                    "question_id": 43262,
                    "question_title": "<p><br/></p><p style=\"margin: 0px;\"><span style=\"margin: 0px; font-family: 华文楷体; font-size: 11pt;\"><span style=\"font-family:华文楷体\">按照设计模式的目的进行划分，现有的设计模式可以分为三类。其中创建型模式通过采用抽象类所定义的接口，封装了系统中对象如何创建、组合等信息，其代表有</span>(</span><span style=\"margin: 0px; font-family: 华文楷体; font-size: 11pt;\">9</span><span style=\"margin: 0px; font-family: 华文楷体; font-size: 11pt;\">)模式等;(</span><span style=\"margin: 0px; font-family: 华文楷体; font-size: 11pt;\">10</span><span style=\"margin: 0px; font-family: 华文楷体; font-size: 11pt;\">)模式主要用于如何组合己有的类和对象以获得更大的结构，其代表有 Adapter 模式等;(</span><span style=\"margin: 0px; font-family: 华文楷体; font-size: 11pt;\">11</span><span style=\"margin: 0px; font-family: 华文楷体; font-size: 11pt;\">)模式主要用于对象之间的职责及其提供服务的分配方式，其代表有(</span><span style=\"margin: 0px; font-family: 华文楷体; font-size: 11pt;\">12</span><span style=\"margin: 0px; font-family: 华文楷体; font-size: 11pt;\">)模式等。【回答括号12】</span></p><p><br/></p>",
                    "question_type": 1,
                    "answer_type": 1,
                    "show_type_name": null,
                    "new_parent_id": 43262,
                    "score_rule": "",
                    "material_text": null,
                    "sort_son": "0",
                    "analyze": "<p><br/></p><p style=\"margin: 0px; line-height: 150%; text-indent: 21pt; layout-grid-mode: char;\"><span style=\"margin: 0px; font-family: 华文楷体; font-size: 11pt;\"><span style=\"font-family:华文楷体\">按照设计模式的目的进行划分，现有的设计模式可以分为三类。</span></span><span style=\"margin: 0px; font-family: 华文楷体; font-size: 11pt;\"></span></p><p style=\"margin: 0px; line-height: 150%; text-indent: 21pt; layout-grid-mode: char;\"><span style=\"margin: 0px; font-family: 华文楷体; font-size: 11pt;\"><span style=\"font-family:华文楷体\">创建型模式通过采用抽象类所定义的接口，封装了系统中对象如何创建、组合等信息，其代表有</span>Singleton模式等; </span><span style=\"margin: 0px; font-family: 华文楷体; font-size: 11pt;\"></span></p><p style=\"margin: 0px; line-height: 150%; text-indent: 21pt; layout-grid-mode: char;\"><span style=\"margin: 0px; font-family: 华文楷体; font-size: 11pt;\"><span style=\"font-family:华文楷体\">结构型模式主要用于如何组合己有的类和对象以获得更大的结构，其代表有</span> Adapter 模式等; </span><span style=\"margin: 0px; font-family: 华文楷体; font-size: 11pt;\"></span></p><p style=\"margin: 0px; line-height: 150%; text-indent: 21pt; layout-grid-mode: char;\"><span style=\"margin: 0px; font-family: 华文楷体; font-size: 11pt;\"><span style=\"font-family:华文楷体\">行为型模式主要用于对象之间的职责及其提供服务的分配方式，其代表有</span>Visitor模式等。</span><span style=\"margin: 0px; font-family: 华文楷体; font-size: 11pt;\"></span></p><p><br/></p>",
                    "like": 0,
                    "answer": [
                        "D"
                    ],
                    "option": [
                        " Prototype ",
                        " Facade ",
                        " &nbsp;Proxy&nbsp; ",
                        " Visitor "
                    ]
                },
                {
                    "index": 23,
                    "belong_page": 1,
                    "question_id": 43263,
                    "question_title": "<p><br/></p><p style=\"margin: 0px;\"><span style=\"margin: 0px; font-family: 宋体; font-size: 10.5pt;\"><span style=\"font-family:宋体\">自动售货机根据库存、存放货币量、找零能力、所选项目等不同，在货币存入并进行选择时具有如下行为：交付产品不找零</span> <span style=\"font-family:宋体\">：交付产品找零：存入货币不足而不提供任何产品；库存不足而不提供任何产品。这一业务需求适合采用</span></span><span style=\"text-decoration:underline;\"><span style=\"margin: 0px; font-family: &quot;Times New Roman&quot;; font-size: 10.5pt; text-decoration: underline;\">&nbsp;</span></span><span style=\"text-decoration:underline;\"><span style=\"margin: 0px; font-family: 宋体; font-size: 10.5pt; text-decoration: underline;\"><span style=\"font-family:宋体\">（</span></span></span><span style=\"text-decoration:underline;\"><span style=\"margin: 0px; font-family: 宋体; font-size: 10.5pt; text-decoration: underline;\">13</span></span><span style=\"text-decoration:underline;\"><span style=\"margin: 0px; font-family: 宋体; font-size: 10.5pt; text-decoration: underline;\"><span style=\"font-family:宋体\">）</span></span></span><span style=\"text-decoration:underline;\"><span style=\"margin: 0px; font-family: &quot;Times New Roman&quot;; font-size: 10.5pt; text-decoration: underline;\">&nbsp;</span></span><span style=\"margin: 0px; font-family: 宋体; font-size: 10.5pt;\"><span style=\"font-family:宋体\">模式设计实现，其类图如下图所示，其中</span></span><span style=\"text-decoration:underline;\"><span style=\"margin: 0px; font-family: &quot;Times New Roman&quot;; font-size: 10.5pt; text-decoration: underline;\">&nbsp;</span></span><span style=\"text-decoration:underline;\"><span style=\"margin: 0px; font-family: 宋体; font-size: 10.5pt; text-decoration: underline;\"><span style=\"font-family:宋体\">（</span></span></span><span style=\"text-decoration:underline;\"><span style=\"margin: 0px; font-family: 宋体; font-size: 10.5pt; text-decoration: underline;\">14</span></span><span style=\"text-decoration:underline;\"><span style=\"margin: 0px; font-family: 宋体; font-size: 10.5pt; text-decoration: underline;\"><span style=\"font-family:宋体\">）</span></span></span><span style=\"text-decoration:underline;\"><span style=\"margin: 0px; font-family: &quot;Times New Roman&quot;; font-size: 10.5pt; text-decoration: underline;\">&nbsp;</span></span><span style=\"margin: 0px; font-family: 宋体; font-size: 10.5pt;\"><span style=\"font-family:宋体\">是客户程序使用的主要接口，可用状态来对其进行配置。此模式为</span></span><span style=\"text-decoration:underline;\"><span style=\"margin: 0px; font-family: &quot;Times New Roman&quot;; font-size: 10.5pt; text-decoration: underline;\">&nbsp;</span></span><span style=\"text-decoration:underline;\"><span style=\"margin: 0px; font-family: 宋体; font-size: 10.5pt; text-decoration: underline;\"><span style=\"font-family:宋体\">（</span></span></span><span style=\"text-decoration:underline;\"><span style=\"margin: 0px; font-family: 宋体; font-size: 10.5pt; text-decoration: underline;\">15</span></span><span style=\"text-decoration:underline;\"><span style=\"margin: 0px; font-family: 宋体; font-size: 10.5pt; text-decoration: underline;\"><span style=\"font-family:宋体\">）</span></span></span><span style=\"text-decoration:underline;\"><span style=\"margin: 0px; font-family: &quot;Times New Roman&quot;; font-size: 10.5pt; text-decoration: underline;\">&nbsp;</span></span><span style=\"margin: 0px; font-family: 宋体; font-size: 10.5pt;\"><span style=\"font-family:宋体\">，体现的最主要的意图是</span></span><span style=\"text-decoration:underline;\"><span style=\"margin: 0px; font-family: &quot;Times New Roman&quot;; font-size: 10.5pt; text-decoration: underline;\">&nbsp;</span></span><span style=\"text-decoration:underline;\"><span style=\"margin: 0px; font-family: 宋体; font-size: 10.5pt; text-decoration: underline;\"><span style=\"font-family:宋体\">（</span></span></span><span style=\"text-decoration:underline;\"><span style=\"margin: 0px; font-family: 宋体; font-size: 10.5pt; text-decoration: underline;\">16</span></span><span style=\"text-decoration:underline;\"><span style=\"margin: 0px; font-family: 宋体; font-size: 10.5pt; text-decoration: underline;\"><span style=\"font-family:宋体\">）</span></span></span><span style=\"text-decoration:underline;\"><span style=\"margin: 0px; font-family: &quot;Times New Roman&quot;; font-size: 10.5pt; text-decoration: underline;\">&nbsp;</span></span><span style=\"margin: 0px; font-family: 宋体; font-size: 10.5pt;\"><span style=\"font-family:宋体\">。【回答括号13】</span></span></p><p><img style=\"max-width:100%;height:auto\"  src=\"https://s2.51cto.com/images/201807/b5b48e7941ee202242f5312b3bf137be26b67d.png\"/></p>",
                    "question_type": 1,
                    "answer_type": 1,
                    "show_type_name": null,
                    "new_parent_id": 43263,
                    "score_rule": "",
                    "material_text": null,
                    "sort_son": "0",
                    "analyze": "<p><br/></p><p style=\"margin: 0px; text-indent: 20.7pt;\"><span style=\"margin: 0px; font-family: 宋体;\"><span style=\"font-family:宋体\">状态型模式的特点是对于对象内部的状态，允许其在不同的状态下，拥有不同的行为，对状态单独封装成类。题干中根据投入货币的情况，售货机分别有交付产品不找零和交付产品找零以及不提供货物等行为判断该模式是属于状态模式。</span>Vending Machine State<span style=\"font-family:宋体\">是客户程序使用的主要接口。</span></span><span style=\"margin: 0px; font-family: &quot;Times New Roman&quot;;\"></span></p><p style=\"margin: 0px; text-indent: 20.7pt;\"><span style=\"margin: 0px; font-family: 宋体;\"><span style=\"font-family:宋体\">设计模式的类型如下所示：</span></span><span style=\"margin: 0px; font-family: &quot;Times New Roman&quot;;\"></span></p><p><img style=\"max-width:100%;height:auto\"  src=\"https://s2.51cto.com/images/201807/49a34111235aba9eb137943cda054688b2eb95.png\"/></p><p style=\"margin: 0px; text-indent: 20.7pt;\"><span style=\"margin: 0px; font-family: 宋体;\"><span style=\"font-family:宋体\">观察者模式（</span>Observer Pattern<span style=\"font-family:宋体\">）：观察者模式定义了对象间的一种一对多依赖关系，使得每当一个对象改变状态，则所有依赖于它的对象都会得到通知并被自动更新。</span></span><span style=\"margin: 0px; font-family: &quot;Times New Roman&quot;;\"></span></p><p style=\"margin: 0px; text-indent: 20.7pt;\"><span style=\"margin: 0px; font-family: 宋体;\"><span style=\"font-family:宋体\">访问者模式（</span>Visitor Pattern<span style=\"font-family:宋体\">）：表示一个作用于某对象结构中的各元素的操作。它使你可以在不改变各元素的类的前提下定义作用与这些元素的新操作。即对于某个对象或者一组对象，不同的访问者，产生的结果不同，执行操作也不同。</span></span><span style=\"margin: 0px; font-family: &quot;Times New Roman&quot;;\"></span></p><p style=\"margin: 0px; text-indent: 20.7pt;\"><span style=\"margin: 0px; font-family: 宋体;\"><span style=\"font-family:宋体\">备忘录模式（</span>Memento Pattern<span style=\"font-family:宋体\">）：在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态。这样就可以将该对象恢复到原先保存的状态。</span></span><span style=\"margin: 0px; font-family: &quot;Times New Roman&quot;;\"></span></p><p style=\"margin: 0px; text-indent: 20.7pt;\"><span style=\"margin: 0px; font-family: 宋体;\"><span style=\"font-family:宋体\">策略模式（</span>Strategy Pattern<span style=\"font-family:宋体\">）：策略模式定义了一系列的算法，并将每一个算法封装起来，而且使它们还可以相互替换。策略模式让算法独立于使用它的客户而独立变化。 </span></span><span style=\"margin: 0px; font-family: &quot;Times New Roman&quot;;\"></span></p><p style=\"margin: 0px; text-indent: 20.7pt;\"><span style=\"margin: 0px; font-family: 宋体;\"><span style=\"font-family:宋体\">命令模式（</span>Command Pattern<span style=\"font-family:宋体\">）：将一个请求封装成一个对象，从而使得用不同的请求对客户进行参数化；对请求排队或记录请求日志，以及支持可撤销的操作。</span></span><span style=\"margin: 0px; font-family: &quot;Times New Roman&quot;;\"></span></p><p><br/></p>",
                    "like": 0,
                    "answer": [
                        "B"
                    ],
                    "option": [
                        " 观察者（Obeserver） ",
                        " 状态（State） ",
                        " 策略（Stratehy） ",
                        " 访问者（Visitor） "
                    ]
                },
                {
                    "index": 24,
                    "belong_page": 1,
                    "question_id": 43264,
                    "question_title": "<p><br/></p><p style=\"margin: 16px 0px; text-indent: 23.7pt;\"><span style=\"margin: 0px; color: #000000; font-family: 楷体_GB2312;\"><span style=\"font-family:楷体_GB2312\">自动售货机根据库存、存放货币量、找零能力、所选项目等不同，在货币存入并进行选择时具有如下行为：交付产品不找零</span> <span style=\"font-family:楷体_GB2312\">：交付产品找零：存入货币不足而不提供任何产品；库存不足而不提供任何产品。这一业务需求适合采用</span></span><span style=\"text-decoration:underline;\"><span style=\"margin: 0px; color: #000000; font-family: &quot;Times New Roman&quot;; text-decoration: underline;\">&nbsp;</span></span><span style=\"text-decoration:underline;\"><span style=\"margin: 0px; color: #000000; font-family: 楷体_GB2312; text-decoration: underline;\"><span style=\"font-family:楷体_GB2312\">（</span></span></span><span style=\"text-decoration:underline;\"><span style=\"margin: 0px; color: #000000; font-family: 楷体_GB2312; text-decoration: underline;\">13</span></span><span style=\"text-decoration:underline;\"><span style=\"margin: 0px; color: #000000; font-family: 楷体_GB2312; text-decoration: underline;\"><span style=\"font-family:楷体_GB2312\">）</span></span></span><span style=\"text-decoration:underline;\"><span style=\"margin: 0px; color: #000000; font-family: &quot;Times New Roman&quot;; text-decoration: underline;\">&nbsp;</span></span><span style=\"margin: 0px; color: #000000; font-family: 楷体_GB2312;\"><span style=\"font-family:楷体_GB2312\">模式设计实现，其类图如下图所示，其中</span></span><span style=\"text-decoration:underline;\"><span style=\"margin: 0px; color: #000000; font-family: &quot;Times New Roman&quot;; text-decoration: underline;\">&nbsp;</span></span><span style=\"text-decoration:underline;\"><span style=\"margin: 0px; color: #000000; font-family: 楷体_GB2312; text-decoration: underline;\"><span style=\"font-family:楷体_GB2312\">（</span></span></span><span style=\"text-decoration:underline;\"><span style=\"margin: 0px; color: #000000; font-family: 楷体_GB2312; text-decoration: underline;\">14</span></span><span style=\"text-decoration:underline;\"><span style=\"margin: 0px; color: #000000; font-family: 楷体_GB2312; text-decoration: underline;\"><span style=\"font-family:楷体_GB2312\">）</span></span></span><span style=\"text-decoration:underline;\"><span style=\"margin: 0px; color: #000000; font-family: &quot;Times New Roman&quot;; text-decoration: underline;\">&nbsp;</span></span><span style=\"margin: 0px; color: #000000; font-family: 楷体_GB2312;\"><span style=\"font-family:楷体_GB2312\">是客户程序使用的主要接口，可用状态来对其进行配置。此模式为</span></span><span style=\"text-decoration:underline;\"><span style=\"margin: 0px; color: #000000; font-family: &quot;Times New Roman&quot;; text-decoration: underline;\">&nbsp;</span></span><span style=\"text-decoration:underline;\"><span style=\"margin: 0px; color: #000000; font-family: 楷体_GB2312; text-decoration: underline;\"><span style=\"font-family:楷体_GB2312\">（</span></span></span><span style=\"text-decoration:underline;\"><span style=\"margin: 0px; color: #000000; font-family: 楷体_GB2312; text-decoration: underline;\">15</span></span><span style=\"text-decoration:underline;\"><span style=\"margin: 0px; color: #000000; font-family: 楷体_GB2312; text-decoration: underline;\"><span style=\"font-family:楷体_GB2312\">）</span></span></span><span style=\"text-decoration:underline;\"><span style=\"margin: 0px; color: #000000; font-family: &quot;Times New Roman&quot;; text-decoration: underline;\">&nbsp;</span></span><span style=\"margin: 0px; color: #000000; font-family: 楷体_GB2312;\"><span style=\"font-family:楷体_GB2312\">，体现的最主要的意图是</span></span><span style=\"text-decoration:underline;\"><span style=\"margin: 0px; color: #000000; font-family: &quot;Times New Roman&quot;; text-decoration: underline;\">&nbsp;</span></span><span style=\"text-decoration:underline;\"><span style=\"margin: 0px; color: #000000; font-family: 楷体_GB2312; text-decoration: underline;\"><span style=\"font-family:楷体_GB2312\">（</span></span></span><span style=\"text-decoration:underline;\"><span style=\"margin: 0px; color: #000000; font-family: 楷体_GB2312; text-decoration: underline;\">16</span></span><span style=\"text-decoration:underline;\"><span style=\"margin: 0px; color: #000000; font-family: 楷体_GB2312; text-decoration: underline;\"><span style=\"font-family:楷体_GB2312\">）</span></span></span><span style=\"text-decoration:underline;\"><span style=\"margin: 0px; color: #000000; font-family: &quot;Times New Roman&quot;; text-decoration: underline;\">&nbsp;</span></span><span style=\"margin: 0px; color: #000000; font-family: 楷体_GB2312;\"><span style=\"font-family:楷体_GB2312\">。【回答括号14】<img style=\"max-width:100%;height:auto\"  src=\"https://s2.51cto.com/images/201807/0280f2e985c2982461a3525962b3571216b4f5.png\"/></span></span><span style=\"margin: 0px; color: #000000; font-family: &quot;Times New Roman&quot;;\"></span></p><p><br/></p>",
                    "question_type": 1,
                    "answer_type": 1,
                    "show_type_name": null,
                    "new_parent_id": 43264,
                    "score_rule": "",
                    "material_text": null,
                    "sort_son": "0",
                    "analyze": "<p><br/></p><p style=\"margin: 0px; text-indent: 20.7pt;\"><span style=\"margin: 0px; font-family: 宋体;\"><span style=\"font-family:宋体\">状态型模式的特点是对于对象内部的状态，允许其在不同的状态下，拥有不同的行为，对状态单独封装成类。题干中根据投入货币的情况，售货机分别有交付产品不找零和交付产品找零以及不提供货物等行为判断该模式是属于状态模式。</span>Vending Machine State<span style=\"font-family:宋体\">是客户程序使用的主要接口。</span></span><span style=\"margin: 0px; font-family: &quot;Times New Roman&quot;;\"></span></p><p style=\"margin: 0px; text-indent: 20.7pt;\"><span style=\"margin: 0px; font-family: 宋体;\"><span style=\"font-family:宋体\">设计模式的类型如下所示：</span></span><span style=\"margin: 0px; font-family: &quot;Times New Roman&quot;;\"></span></p><p style=\"margin: 0px; text-indent: 20.7pt;\"><span style=\"margin: 0px; font-family: &quot;Times New Roman&quot;;\">&nbsp;</span></p><p><img style=\"max-width:100%;height:auto\"  src=\"https://s2.51cto.com/images/201807/e73af5560ed5670ef8d9081798dc5166b9dd41.png\"/></p><p style=\"margin: 0px; text-indent: 20.7pt;\"><span style=\"margin: 0px; font-family: 宋体;\"><span style=\"font-family:宋体\">观察者模式（</span>Observer Pattern<span style=\"font-family:宋体\">）：观察者模式定义了对象间的一种一对多依赖关系，使得每当一个对象改变状态，则所有依赖于它的对象都会得到通知并被自动更新。</span></span><span style=\"margin: 0px; font-family: &quot;Times New Roman&quot;;\"></span></p><p style=\"margin: 0px; text-indent: 20.7pt;\"><span style=\"margin: 0px; font-family: 宋体;\"><span style=\"font-family:宋体\">访问者模式（</span>Visitor Pattern<span style=\"font-family:宋体\">）：表示一个作用于某对象结构中的各元素的操作。它使你可以在不改变各元素的类的前提下定义作用与这些元素的新操作。即对于某个对象或者一组对象，不同的访问者，产生的结果不同，执行操作也不同。</span></span><span style=\"margin: 0px; font-family: &quot;Times New Roman&quot;;\"></span></p><p style=\"margin: 0px; text-indent: 20.7pt;\"><span style=\"margin: 0px; font-family: 宋体;\"><span style=\"font-family:宋体\">备忘录模式（</span>Memento Pattern<span style=\"font-family:宋体\">）：在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态。这样就可以将该对象恢复到原先保存的状态。</span></span><span style=\"margin: 0px; font-family: &quot;Times New Roman&quot;;\"></span></p><p style=\"margin: 0px; text-indent: 20.7pt;\"><span style=\"margin: 0px; font-family: 宋体;\"><span style=\"font-family:宋体\">策略模式（</span>Strategy Pattern<span style=\"font-family:宋体\">）：策略模式定义了一系列的算法，并将每一个算法封装起来，而且使它们还可以相互替换。策略模式让算法独立于使用它的客户而独立变化。 </span></span><span style=\"margin: 0px; font-family: &quot;Times New Roman&quot;;\"></span></p><p style=\"margin: 0px; text-indent: 20.7pt;\"><span style=\"margin: 0px; font-family: 宋体;\"><span style=\"font-family:宋体\">命令模式（</span>Command Pattern<span style=\"font-family:宋体\">）：将一个请求封装成一个对象，从而使得用不同的请求对客户进行参数化；对请求排队或记录请求日志，以及支持可撤销的操作。</span></span><span style=\"margin: 0px; font-family: &quot;Times New Roman&quot;;\"></span></p><p><br/></p>",
                    "like": 0,
                    "answer": [
                        "A"
                    ],
                    "option": [
                        " Vending&nbsp;MachineState ",
                        " Buy ",
                        " Vending&nbsp;DepositState ",
                        " Vending&nbsp;Stock&nbsp;State "
                    ]
                },
                {
                    "index": 25,
                    "belong_page": 1,
                    "question_id": 43265,
                    "question_title": "<p><br/></p><p style=\"margin: 16px 0px; text-indent: 23.7pt;\"><span style=\"margin: 0px; color: #000000; font-family: 楷体_GB2312;\"><span style=\"font-family:楷体_GB2312\">自动售货机根据库存、存放货币量、找零能力、所选项目等不同，在货币存入并进行选择时具有如下行为：交付产品不找零</span> <span style=\"font-family:楷体_GB2312\">：交付产品找零：存入货币不足而不提供任何产品；库存不足而不提供任何产品。这一业务需求适合采用</span></span><span style=\"text-decoration:underline;\"><span style=\"margin: 0px; color: #000000; font-family: &quot;Times New Roman&quot;; text-decoration: underline;\">&nbsp;</span></span><span style=\"text-decoration:underline;\"><span style=\"margin: 0px; color: #000000; font-family: 楷体_GB2312; text-decoration: underline;\"><span style=\"font-family:楷体_GB2312\">（</span></span></span><span style=\"text-decoration:underline;\"><span style=\"margin: 0px; color: #000000; font-family: 楷体_GB2312; text-decoration: underline;\">13</span></span><span style=\"text-decoration:underline;\"><span style=\"margin: 0px; color: #000000; font-family: 楷体_GB2312; text-decoration: underline;\"><span style=\"font-family:楷体_GB2312\">）</span></span></span><span style=\"text-decoration:underline;\"><span style=\"margin: 0px; color: #000000; font-family: &quot;Times New Roman&quot;; text-decoration: underline;\">&nbsp;</span></span><span style=\"margin: 0px; color: #000000; font-family: 楷体_GB2312;\"><span style=\"font-family:楷体_GB2312\">模式设计实现，其类图如下图所示，其中</span></span><span style=\"text-decoration:underline;\"><span style=\"margin: 0px; color: #000000; font-family: &quot;Times New Roman&quot;; text-decoration: underline;\">&nbsp;</span></span><span style=\"text-decoration:underline;\"><span style=\"margin: 0px; color: #000000; font-family: 楷体_GB2312; text-decoration: underline;\"><span style=\"font-family:楷体_GB2312\">（</span></span></span><span style=\"text-decoration:underline;\"><span style=\"margin: 0px; color: #000000; font-family: 楷体_GB2312; text-decoration: underline;\">14</span></span><span style=\"text-decoration:underline;\"><span style=\"margin: 0px; color: #000000; font-family: 楷体_GB2312; text-decoration: underline;\"><span style=\"font-family:楷体_GB2312\">）</span></span></span><span style=\"text-decoration:underline;\"><span style=\"margin: 0px; color: #000000; font-family: &quot;Times New Roman&quot;; text-decoration: underline;\">&nbsp;</span></span><span style=\"margin: 0px; color: #000000; font-family: 楷体_GB2312;\"><span style=\"font-family:楷体_GB2312\">是客户程序使用的主要接口，可用状态来对其进行配置。此模式为</span></span><span style=\"text-decoration:underline;\"><span style=\"margin: 0px; color: #000000; font-family: &quot;Times New Roman&quot;; text-decoration: underline;\">&nbsp;</span></span><span style=\"text-decoration:underline;\"><span style=\"margin: 0px; color: #000000; font-family: 楷体_GB2312; text-decoration: underline;\"><span style=\"font-family:楷体_GB2312\">（</span></span></span><span style=\"text-decoration:underline;\"><span style=\"margin: 0px; color: #000000; font-family: 楷体_GB2312; text-decoration: underline;\">15</span></span><span style=\"text-decoration:underline;\"><span style=\"margin: 0px; color: #000000; font-family: 楷体_GB2312; text-decoration: underline;\"><span style=\"font-family:楷体_GB2312\">）</span></span></span><span style=\"text-decoration:underline;\"><span style=\"margin: 0px; color: #000000; font-family: &quot;Times New Roman&quot;; text-decoration: underline;\">&nbsp;</span></span><span style=\"margin: 0px; color: #000000; font-family: 楷体_GB2312;\"><span style=\"font-family:楷体_GB2312\">，体现的最主要的意图是</span></span><span style=\"text-decoration:underline;\"><span style=\"margin: 0px; color: #000000; font-family: &quot;Times New Roman&quot;; text-decoration: underline;\">&nbsp;</span></span><span style=\"text-decoration:underline;\"><span style=\"margin: 0px; color: #000000; font-family: 楷体_GB2312; text-decoration: underline;\"><span style=\"font-family:楷体_GB2312\">（</span></span></span><span style=\"text-decoration:underline;\"><span style=\"margin: 0px; color: #000000; font-family: 楷体_GB2312; text-decoration: underline;\">16</span></span><span style=\"text-decoration:underline;\"><span style=\"margin: 0px; color: #000000; font-family: 楷体_GB2312; text-decoration: underline;\"><span style=\"font-family:楷体_GB2312\">）</span></span></span><span style=\"text-decoration:underline;\"><span style=\"margin: 0px; color: #000000; font-family: &quot;Times New Roman&quot;; text-decoration: underline;\">&nbsp;</span></span><span style=\"margin: 0px; color: #000000; font-family: 楷体_GB2312;\"><span style=\"font-family:楷体_GB2312\">。【回答括号15】<img style=\"max-width:100%;height:auto\"  src=\"https://s2.51cto.com/images/201807/1745c6986f0b093ff5d502facecf25bc4abbeb.png\"/></span></span><span style=\"margin: 0px; color: #000000; font-family: &quot;Times New Roman&quot;;\"></span></p><p><br/></p>",
                    "question_type": 1,
                    "answer_type": 1,
                    "show_type_name": null,
                    "new_parent_id": 43265,
                    "score_rule": "",
                    "material_text": null,
                    "sort_son": "0",
                    "analyze": "<p><br/></p><p style=\"margin: 0px; text-indent: 20.7pt;\"><span style=\"margin: 0px; font-family: 宋体;\"><span style=\"font-family:宋体\">状态型模式的特点是对于对象内部的状态，允许其在不同的状态下，拥有不同的行为，对状态单独封装成类。题干中根据投入货币的情况，售货机分别有交付产品不找零和交付产品找零以及不提供货物等行为判断该模式是属于状态模式。</span>Vending Machine State<span style=\"font-family:宋体\">是客户程序使用的主要接口。</span></span><span style=\"margin: 0px; font-family: &quot;Times New Roman&quot;;\"></span></p><p style=\"margin: 0px; text-indent: 20.7pt;\"><span style=\"margin: 0px; font-family: 宋体;\"><span style=\"font-family:宋体\">设计模式的类型如下所示：</span></span><span style=\"margin: 0px; font-family: &quot;Times New Roman&quot;;\"></span></p><p><img style=\"max-width:100%;height:auto\"  src=\"https://s2.51cto.com/images/201807/3528fea8455b7f450b2963805ef774032aae5c.png\"/></p><p style=\"margin: 0px; text-indent: 20.7pt;\"><span style=\"margin: 0px; font-family: 宋体;\"><span style=\"font-family:宋体\">观察者模式（</span>Observer Pattern<span style=\"font-family:宋体\">）：观察者模式定义了对象间的一种一对多依赖关系，使得每当一个对象改变状态，则所有依赖于它的对象都会得到通知并被自动更新。</span></span><span style=\"margin: 0px; font-family: &quot;Times New Roman&quot;;\"></span></p><p style=\"margin: 0px; text-indent: 20.7pt;\"><span style=\"margin: 0px; font-family: 宋体;\"><span style=\"font-family:宋体\">访问者模式（</span>Visitor Pattern<span style=\"font-family:宋体\">）：表示一个作用于某对象结构中的各元素的操作。它使你可以在不改变各元素的类的前提下定义作用与这些元素的新操作。即对于某个对象或者一组对象，不同的访问者，产生的结果不同，执行操作也不同。</span></span><span style=\"margin: 0px; font-family: &quot;Times New Roman&quot;;\"></span></p><p style=\"margin: 0px; text-indent: 20.7pt;\"><span style=\"margin: 0px; font-family: 宋体;\"><span style=\"font-family:宋体\">备忘录模式（</span>Memento Pattern<span style=\"font-family:宋体\">）：在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态。这样就可以将该对象恢复到原先保存的状态。</span></span><span style=\"margin: 0px; font-family: &quot;Times New Roman&quot;;\"></span></p><p style=\"margin: 0px; text-indent: 20.7pt;\"><span style=\"margin: 0px; font-family: 宋体;\"><span style=\"font-family:宋体\">策略模式（</span>Strategy Pattern<span style=\"font-family:宋体\">）：策略模式定义了一系列的算法，并将每一个算法封装起来，而且使它们还可以相互替换。策略模式让算法独立于使用它的客户而独立变化。 </span></span><span style=\"margin: 0px; font-family: &quot;Times New Roman&quot;;\"></span></p><p style=\"margin: 0px; text-indent: 20.7pt;\"><span style=\"margin: 0px; font-family: 宋体;\"><span style=\"font-family:宋体\">命令模式（</span>Command Pattern<span style=\"font-family:宋体\">）：将一个请求封装成一个对象，从而使得用不同的请求对客户进行参数化；对请求排队或记录请求日志，以及支持可撤销的操作。</span></span><span style=\"margin: 0px; font-family: &quot;Times New Roman&quot;;\"></span></p><p><br/></p>",
                    "like": 0,
                    "answer": [
                        "D"
                    ],
                    "option": [
                        " 创建型对象模式 ",
                        " 结构型对象模式 ",
                        " 行为型类模式 ",
                        " 行为型对象模式 "
                    ]
                },
                {
                    "index": 26,
                    "belong_page": 1,
                    "question_id": 43266,
                    "question_title": "<p><br/></p><p style=\"margin: 16px 0px; text-indent: 23.7pt;\"><span style=\"margin: 0px; color: #000000; font-family: 楷体_GB2312;\"><span style=\"font-family:楷体_GB2312\">自动售货机根据库存、存放货币量、找零能力、所选项目等不同，在货币存入并进行选择时具有如下行为：交付产品不找零</span> <span style=\"font-family:楷体_GB2312\">：交付产品找零：存入货币不足而不提供任何产品；库存不足而不提供任何产品。这一业务需求适合采用</span></span><span style=\"text-decoration:underline;\"><span style=\"margin: 0px; color: #000000; font-family: &quot;Times New Roman&quot;; text-decoration: underline;\">&nbsp;</span></span><span style=\"text-decoration:underline;\"><span style=\"margin: 0px; color: #000000; font-family: 楷体_GB2312; text-decoration: underline;\"><span style=\"font-family:楷体_GB2312\">（</span></span></span><span style=\"text-decoration:underline;\"><span style=\"margin: 0px; color: #000000; font-family: 楷体_GB2312; text-decoration: underline;\">13</span></span><span style=\"text-decoration:underline;\"><span style=\"margin: 0px; color: #000000; font-family: 楷体_GB2312; text-decoration: underline;\"><span style=\"font-family:楷体_GB2312\">）</span></span></span><span style=\"text-decoration:underline;\"><span style=\"margin: 0px; color: #000000; font-family: &quot;Times New Roman&quot;; text-decoration: underline;\">&nbsp;</span></span><span style=\"margin: 0px; color: #000000; font-family: 楷体_GB2312;\"><span style=\"font-family:楷体_GB2312\">模式设计实现，其类图如下图所示，其中</span></span><span style=\"text-decoration:underline;\"><span style=\"margin: 0px; color: #000000; font-family: &quot;Times New Roman&quot;; text-decoration: underline;\">&nbsp;</span></span><span style=\"text-decoration:underline;\"><span style=\"margin: 0px; color: #000000; font-family: 楷体_GB2312; text-decoration: underline;\"><span style=\"font-family:楷体_GB2312\">（</span></span></span><span style=\"text-decoration:underline;\"><span style=\"margin: 0px; color: #000000; font-family: 楷体_GB2312; text-decoration: underline;\">14</span></span><span style=\"text-decoration:underline;\"><span style=\"margin: 0px; color: #000000; font-family: 楷体_GB2312; text-decoration: underline;\"><span style=\"font-family:楷体_GB2312\">）</span></span></span><span style=\"text-decoration:underline;\"><span style=\"margin: 0px; color: #000000; font-family: &quot;Times New Roman&quot;; text-decoration: underline;\">&nbsp;</span></span><span style=\"margin: 0px; color: #000000; font-family: 楷体_GB2312;\"><span style=\"font-family:楷体_GB2312\">是客户程序使用的主要接口，可用状态来对其进行配置。此模式为</span></span><span style=\"text-decoration:underline;\"><span style=\"margin: 0px; color: #000000; font-family: &quot;Times New Roman&quot;; text-decoration: underline;\">&nbsp;</span></span><span style=\"text-decoration:underline;\"><span style=\"margin: 0px; color: #000000; font-family: 楷体_GB2312; text-decoration: underline;\"><span style=\"font-family:楷体_GB2312\">（</span></span></span><span style=\"text-decoration:underline;\"><span style=\"margin: 0px; color: #000000; font-family: 楷体_GB2312; text-decoration: underline;\">15</span></span><span style=\"text-decoration:underline;\"><span style=\"margin: 0px; color: #000000; font-family: 楷体_GB2312; text-decoration: underline;\"><span style=\"font-family:楷体_GB2312\">）</span></span></span><span style=\"text-decoration:underline;\"><span style=\"margin: 0px; color: #000000; font-family: &quot;Times New Roman&quot;; text-decoration: underline;\">&nbsp;</span></span><span style=\"margin: 0px; color: #000000; font-family: 楷体_GB2312;\"><span style=\"font-family:楷体_GB2312\">，体现的最主要的意图是</span></span><span style=\"text-decoration:underline;\"><span style=\"margin: 0px; color: #000000; font-family: &quot;Times New Roman&quot;; text-decoration: underline;\">&nbsp;</span></span><span style=\"text-decoration:underline;\"><span style=\"margin: 0px; color: #000000; font-family: 楷体_GB2312; text-decoration: underline;\"><span style=\"font-family:楷体_GB2312\">（</span></span></span><span style=\"text-decoration:underline;\"><span style=\"margin: 0px; color: #000000; font-family: 楷体_GB2312; text-decoration: underline;\">16</span></span><span style=\"text-decoration:underline;\"><span style=\"margin: 0px; color: #000000; font-family: 楷体_GB2312; text-decoration: underline;\"><span style=\"font-family:楷体_GB2312\">）</span></span></span><span style=\"text-decoration:underline;\"><span style=\"margin: 0px; color: #000000; font-family: &quot;Times New Roman&quot;; text-decoration: underline;\">&nbsp;</span></span><span style=\"margin: 0px; color: #000000; font-family: 楷体_GB2312;\"><span style=\"font-family:楷体_GB2312\">。【回答括号16】<img style=\"max-width:100%;height:auto\"  src=\"https://s2.51cto.com/images/201807/6472eea86cc59067d2947080b09830098d7f68.png\"/></span></span><span style=\"margin: 0px; color: #000000; font-family: &quot;Times New Roman&quot;;\"></span></p><p><br/></p>",
                    "question_type": 1,
                    "answer_type": 1,
                    "show_type_name": null,
                    "new_parent_id": 43266,
                    "score_rule": "",
                    "material_text": null,
                    "sort_son": "0",
                    "analyze": "<p><br/></p><p style=\"margin: 0px; text-indent: 20.7pt;\"><span style=\"margin: 0px; font-family: 宋体;\"><span style=\"font-family:宋体\">状态型模式的特点是对于对象内部的状态，允许其在不同的状态下，拥有不同的行为，对状态单独封装成类。题干中根据投入货币的情况，售货机分别有交付产品不找零和交付产品找零以及不提供货物等行为判断该模式是属于状态模式。</span>Vending Machine State<span style=\"font-family:宋体\">是客户程序使用的主要接口。</span></span><span style=\"margin: 0px; font-family: &quot;Times New Roman&quot;;\"></span></p><p style=\"margin: 0px; text-indent: 20.7pt;\"><span style=\"margin: 0px; font-family: 宋体;\"><span style=\"font-family:宋体\">设计模式的类型如下所示：</span></span><span style=\"margin: 0px; font-family: &quot;Times New Roman&quot;;\"></span></p><p style=\"margin: 0px; text-indent: 20.7pt;\"><span style=\"margin: 0px; font-family: &quot;Times New Roman&quot;;\">&nbsp;</span></p><p><img style=\"max-width:100%;height:auto\"  src=\"https://s2.51cto.com/images/201807/e3b056a68ff75108dae427b0d5552daa264a37.png\"/></p><p style=\"margin: 0px; text-indent: 20.7pt;\"><span style=\"margin: 0px; font-family: 宋体;\"><span style=\"font-family:宋体\">观察者模式（</span>Observer Pattern<span style=\"font-family:宋体\">）：观察者模式定义了对象间的一种一对多依赖关系，使得每当一个对象改变状态，则所有依赖于它的对象都会得到通知并被自动更新。</span></span><span style=\"margin: 0px; font-family: &quot;Times New Roman&quot;;\"></span></p><p style=\"margin: 0px; text-indent: 20.7pt;\"><span style=\"margin: 0px; font-family: 宋体;\"><span style=\"font-family:宋体\">访问者模式（</span>Visitor Pattern<span style=\"font-family:宋体\">）：表示一个作用于某对象结构中的各元素的操作。它使你可以在不改变各元素的类的前提下定义作用与这些元素的新操作。即对于某个对象或者一组对象，不同的访问者，产生的结果不同，执行操作也不同。</span></span><span style=\"margin: 0px; font-family: &quot;Times New Roman&quot;;\"></span></p><p style=\"margin: 0px; text-indent: 20.7pt;\"><span style=\"margin: 0px; font-family: 宋体;\"><span style=\"font-family:宋体\">备忘录模式（</span>Memento Pattern<span style=\"font-family:宋体\">）：在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态。这样就可以将该对象恢复到原先保存的状态。</span></span><span style=\"margin: 0px; font-family: &quot;Times New Roman&quot;;\"></span></p><p style=\"margin: 0px; text-indent: 20.7pt;\"><span style=\"margin: 0px; font-family: 宋体;\"><span style=\"font-family:宋体\">策略模式（</span>Strategy Pattern<span style=\"font-family:宋体\">）：策略模式定义了一系列的算法，并将每一个算法封装起来，而且使它们还可以相互替换。策略模式让算法独立于使用它的客户而独立变化。 </span></span><span style=\"margin: 0px; font-family: &quot;Times New Roman&quot;;\"></span></p><p style=\"margin: 0px; text-indent: 20.7pt;\"><span style=\"margin: 0px; font-family: 宋体;\"><span style=\"font-family:宋体\">命令模式（</span>Command Pattern<span style=\"font-family:宋体\">）：将一个请求封装成一个对象，从而使得用不同的请求对客户进行参数化；对请求排队或记录请求日志，以及支持可撤销的操作。</span></span><span style=\"margin: 0px; font-family: &quot;Times New Roman&quot;;\"></span></p><p><br/></p>",
                    "like": 0,
                    "answer": [
                        "C"
                    ],
                    "option": [
                        " 当一个对象状态改变时所有依赖它的对象得到通知并自动更新 ",
                        " 在不破坏封装性的前提下，捕获对象的内部状态并在对象之外保存 ",
                        " 一个对象在其内部状态改变时改变其行为 ",
                        " 将请求封装为对象从而可以使用不同的请求对客户进行参数化 "
                    ]
                },
                {
                    "index": 27,
                    "belong_page": 1,
                    "question_id": 43314,
                    "question_title": "<p><br/></p><p style=\"margin: 0px;\"><span style=\"margin: 0px; font-family: &quot;Kaiti SC&quot;; font-size: 11pt;\"><span style=\"font-family:Kaiti SC\">概要设计文档的内容不包括（</span> &nbsp;<span style=\"font-family:Kaiti SC\">）</span></span></p><p><br/></p>",
                    "question_type": 1,
                    "answer_type": 1,
                    "show_type_name": null,
                    "new_parent_id": 43314,
                    "score_rule": "",
                    "material_text": null,
                    "sort_son": "0",
                    "analyze": "<p><br/></p><p style=\"margin: 0px; line-height: 150%; text-indent: 20.15pt; layout-grid-mode: char;\"><span style=\"margin: 0px; line-height: 150%; font-family: &quot;Kaiti SC&quot;; font-size: 11pt;\"><span style=\"font-family:Kaiti SC\">一般来讲，概要设计的内容可以包含系统构架、模块划分、系统接口、数据设计</span>4个主要方面的内容，不包括模块内算法设计。</span><span style=\"margin: 0px; line-height: 150%; font-family: &quot;Kaiti SC&quot;; font-size: 11pt;\"></span></p><p style=\"margin: 0px; line-height: 150%; text-indent: 20.15pt; layout-grid-mode: char;\"><span style=\"margin: 0px; line-height: 150%; font-family: &quot;Kaiti SC&quot;; font-size: 11pt;\">&nbsp;</span></p><p><br/></p>",
                    "like": 0,
                    "answer": [
                        "C"
                    ],
                    "option": [
                        " 体系结构设计 ",
                        " 数据库设计 ",
                        " 模块内算法设计 ",
                        " 逻辑数据结构设计 "
                    ]
                },
                {
                    "index": 28,
                    "belong_page": 1,
                    "question_id": 43340,
                    "question_title": "<p style=\"margin: 0px;\"><span style=\"margin: 0px; font-family: 宋体;\"><span face=\"宋体\">某异地开发的信息系统集成项目以程序流程图、数据流程图等为主要分析设计工具。由于用户身处异地，现场参与系统开发成本较高，因此项目组采用了先开发一个简化系统，待用户认可后再开发最终系统的策略。该信息系统集成项目的开发方法属于</span> <span face=\"宋体\">（</span> <span face=\"宋体\">）</span> <span face=\"宋体\">。</span></span></p><p><br/></p>",
                    "question_type": 1,
                    "answer_type": 1,
                    "show_type_name": null,
                    "new_parent_id": 43340,
                    "score_rule": "",
                    "material_text": null,
                    "sort_son": "0",
                    "analyze": "<p></p><p style=\"margin: 0px;\"><span style=\"margin: 0px; font-family: 宋体;\"><span face=\"宋体\">结构化方法使用的主要分析设计工具是</span>“程序流程图、数据流程图等”，“先开发一个简化系统，待用户认可后再开发最终系统”是原型法的特点。所以，该信息系统集成项目的开发方法属于“<span face=\"Times New Roman\">A </span><span face=\"宋体\">结构化方法与原型法的组合应用”。</span></span></p><p><br/></p>",
                    "like": 0,
                    "answer": [
                        "A"
                    ],
                    "option": [
                        " 结构化方法与原型法的组合应用 ",
                        " 结构化方法与面向对象方法的组合应用 ",
                        " 原型法与面向对象方法的组合应用 ",
                        " 原型法与形式化方法的组合应用 "
                    ]
                },
                {
                    "index": 29,
                    "belong_page": 1,
                    "question_id": 43762,
                    "question_title": "<p><br/></p><p class=\"MsoNormal\" style=\"text-indent:20.7000pt;text-align:left;\"><span style=\"mso-spacerun:&#39;yes&#39;;font-family:宋体;font-size:10.5000pt;mso-font-kerning:1.0000pt;\"><span style=\"font-family:宋体\">下列叙述中，不满足好的需求陈述要求的是</span></span><span style=\"text-decoration:underline;\"><span style=\"mso-spacerun:&#39;yes&#39;;font-family:宋体;text-decoration:underline;text-underline:single;font-size:10.5000pt;mso-font-kerning:1.0000pt;\"><span style=\"font-family:宋体\">（</span></span></span><span style=\"text-decoration:underline;\"><span style=\"mso-spacerun:&#39;yes&#39;;font-family:宋体;text-decoration:underline;text-underline:single;font-size:10.5000pt;mso-font-kerning:1.0000pt;\">27</span></span><span style=\"text-decoration:underline;\"><span style=\"mso-spacerun:&#39;yes&#39;;font-family:宋体;text-decoration:underline;text-underline:single;font-size:10.5000pt;mso-font-kerning:1.0000pt;\"><span style=\"font-family:宋体\">）</span></span></span><span style=\"mso-spacerun:&#39;yes&#39;;font-family:宋体;font-size:10.5000pt;mso-font-kerning:1.0000pt;\"><span style=\"font-family:宋体\">。</span></span><span style=\"mso-spacerun:&#39;yes&#39;;font-family:宋体;mso-hansi-font-family:&#39;Times New Roman&#39;;font-size:10.5000pt;mso-font-kerning:1.0000pt;\"></span></p><p><br/></p>",
                    "question_type": 1,
                    "answer_type": 1,
                    "show_type_name": null,
                    "new_parent_id": 43762,
                    "score_rule": "",
                    "material_text": null,
                    "sort_son": "0",
                    "analyze": "<p>略</p>",
                    "like": 0,
                    "answer": [
                        "D"
                    ],
                    "option": [
                        " 每一项需求都必须完整、准确地描述即将要开发的功能 ",
                        " 需求必须能够在系统及其运行环境的能力和约束条件内实现 ",
                        " 每一项需求记录的功能都必须是用户的真正的需要 ",
                        " 所有需求都应被视为同等重要 "
                    ]
                },
                {
                    "index": 30,
                    "belong_page": 1,
                    "question_id": 43791,
                    "question_title": "<p>某公司欲开发一个网上商城系统，在架构设计阶段，公司的架构师识别出3个核心质量属性场景。其中“系统主站断电后，能够在2分钟内自动切换到备用站点，并恢复正常运行”主要与（请作答此空）质量属性相关，通常可采用（ ）架构策略实现该属性；“在并发用户数不超过1000人时，用户的交易请求应该在0.5s内完成”主要与（ ）质量属性相关，通常可采用（ ）架构策略实现该属性；“系统应该能够抵挡恶意用户的入侵行为，并进行报警和记录”主要与（ ）质量属性相关，通常可采用（ ）架构策略实现该属性。</p>",
                    "question_type": 1,
                    "answer_type": 1,
                    "show_type_name": null,
                    "new_parent_id": 43791,
                    "score_rule": "",
                    "material_text": null,
                    "sort_son": "0",
                    "analyze": "<p>“系统主站断电后，能够在2分钟内自动切换到备用站点，并恢复正常运行”主要与可用性质量属性相关，通常可采用心跳、Ping/Echo、主动冗余、被动冗余、选举等架构策略实现该属性；“在并发用户数不超过1000人时，用户的交易请求应该在0.5s内完成”，主要与性能这一质量属性相关，实现该属性的常见架构策略包括：增加计算资源、减少计算开销、引入并发机制、采用资源调度等。“系统应该能够抵挡恶意用户的入侵行为，并进行报警和记录”主要与安全性质量属性相关。通常采用抵御攻击、攻击检测、用户认证、用户授权、追踪审计等架构策略实现该属性。</p>",
                    "like": 0,
                    "answer": [
                        "B"
                    ],
                    "option": [
                        " 性能&nbsp; ",
                        " 可用性&nbsp; ",
                        " 易用性&nbsp; ",
                        " 可修改性 "
                    ]
                },
                {
                    "index": 31,
                    "belong_page": 1,
                    "question_id": 43874,
                    "question_title": "<p><br/></p><p><br/></p><p class=\"MsoNormal\" style=\"text-align:justify;text-justify:inter-ideograph;\"><span style=\"mso-spacerun:&#39;yes&#39;;font-family:宋体;font-size:10.5000pt;mso-font-kerning:1.0000pt;\"><span style=\"font-family:宋体\">需求分析的验证性含义表述不正确的是（</span> <span style=\"font-family:宋体\">）</span></span><span style=\"mso-spacerun:&#39;yes&#39;;font-family:宋体;font-size:10.5000pt;mso-font-kerning:1.0000pt;\"></span></p><p><br/></p>",
                    "question_type": 1,
                    "answer_type": 1,
                    "show_type_name": null,
                    "new_parent_id": 43874,
                    "score_rule": "",
                    "material_text": null,
                    "sort_son": "0",
                    "analyze": "<p>略<br/></p>",
                    "like": 0,
                    "answer": [
                        "D"
                    ],
                    "option": [
                        " 验证性要保持和用户要求的同步 ",
                        " 验证性要保持需求分析各侧面的一致性. ",
                        " 保持需求和设计的同步 ",
                        " 要实现所有用户的任何需求 "
                    ]
                },
                {
                    "index": 32,
                    "belong_page": 1,
                    "question_id": 43888,
                    "question_title": "<p><br/></p><p><br/></p><p class=\"MsoNormal\" style=\"text-align:left;\"><span style=\"mso-spacerun:&#39;yes&#39;;font-family:宋体;mso-ascii-font-family:Calibri;mso-hansi-font-family:Calibri;mso-bidi-font-family:&#39;Times New Roman&#39;;font-size:10.5000pt;mso-font-kerning:1.0000pt;\"><span style=\"font-family:宋体\">面向消息中间件</span>MOM<span style=\"font-family:宋体\">的主要特点不包括（ ）</span></span><span style=\"mso-spacerun:&#39;yes&#39;;font-family:宋体;mso-ascii-font-family:Calibri;mso-hansi-font-family:Calibri;mso-bidi-font-family:&#39;Times New Roman&#39;;font-size:10.5000pt;mso-font-kerning:1.0000pt;\"></span></p><p><br/></p>",
                    "question_type": 1,
                    "answer_type": 1,
                    "show_type_name": null,
                    "new_parent_id": 43888,
                    "score_rule": "",
                    "material_text": null,
                    "sort_son": "0",
                    "analyze": "<p>略<br/></p>",
                    "like": 0,
                    "answer": [
                        "C"
                    ],
                    "option": [
                        " 通信程序可在不同的时间运行 ",
                        " 程序与网络复杂性相隔离 ",
                        " 程序与网络不隔离 ",
                        " 对应用程序的结构没有约束 "
                    ]
                },
                {
                    "index": 33,
                    "belong_page": 1,
                    "question_id": 46899,
                    "question_title": "<p>组织信息化需求通常包含三个层次，其中（）需求的目标是提升组织的竞争能力，为组织的可持续发展提供支持环境。</p>",
                    "question_type": 1,
                    "answer_type": 1,
                    "show_type_name": null,
                    "new_parent_id": 46899,
                    "score_rule": "",
                    "material_text": null,
                    "sort_son": "0",
                    "analyze": "<p>一般说来，信息化需求包含3个层次，即战略需求、运作需求和技术需求。</p><p>战略需求。组织信息化的目标是提升组织的竞争能力、为组织的可持续发展提供一个支持环境。从某种意义上来说，信息化对组织不仅仅是服务的手段和实现现有战略的辅助工具；信息化可以把组织战略提升到一个新的水平，为组织带来新的发展契机。特别是对于企业，信息化战略是企业竞争的基础。</p><p><br/></p>",
                    "like": 0,
                    "answer": [
                        "A"
                    ],
                    "option": [
                        " 战略 ",
                        " 发展 ",
                        " 人事 ",
                        " 财务 "
                    ]
                },
                {
                    "index": 34,
                    "belong_page": 1,
                    "question_id": 46914,
                    "question_title": "<p>以下关于需求陈述的描述中,（) 是不正确的。</p>",
                    "question_type": 1,
                    "answer_type": 1,
                    "show_type_name": null,
                    "new_parent_id": 46914,
                    "score_rule": "",
                    "material_text": null,
                    "sort_son": "0",
                    "analyze": "<p>需求应按照重要程度进行区别对待，因此D不正确。</p>",
                    "like": 0,
                    "answer": [
                        "D"
                    ],
                    "option": [
                        " 每一项需求都必须完整、准确地描述即将要开发的功能 ",
                        " 需求必须能够在系统及其运行环境的能力和约束条件内实现 ",
                        " 每一项需求记录的功能都必须是用户的真正的需要 ",
                        " 在良好的需求陈述中，所有需求都应被视为同等重要 "
                    ]
                },
                {
                    "index": 35,
                    "belong_page": 1,
                    "question_id": 46936,
                    "question_title": "<p>面向对象的分析模型主要由顶层架构图、用例与用例图和（）构成。</p>",
                    "question_type": 1,
                    "answer_type": 1,
                    "show_type_name": null,
                    "new_parent_id": 46936,
                    "score_rule": "",
                    "material_text": null,
                    "sort_son": "0",
                    "analyze": "<p>面向对象的分析模型主要由顶层架构图、用例与用例图和领域概念模型构成。</p>",
                    "like": 0,
                    "answer": [
                        "B"
                    ],
                    "option": [
                        " 数据流模型 ",
                        " 领域概念模型 ",
                        " 功能分解图 ",
                        " 功能需求模型 "
                    ]
                },
                {
                    "index": 36,
                    "belong_page": 1,
                    "question_id": 46937,
                    "question_title": "<p>面向对象的分析模型设计模型则包含以（）表示的软件体系机构图、以交互图表示的用例实现图、完整精确的类图、描述复杂对象的状态图和用以描述流程化处理过程的活动图等。</p>",
                    "question_type": 1,
                    "answer_type": 1,
                    "show_type_name": null,
                    "new_parent_id": 46937,
                    "score_rule": "",
                    "material_text": null,
                    "sort_son": "0",
                    "analyze": "<p>设计模型则包含以包图表示的软件体系机构图、以交互图表示的用例实现图、完整精确的类图、描述复杂对象的状态图和用以描述流程化处理过程的活动图等。</p>",
                    "like": 0,
                    "answer": [
                        "C"
                    ],
                    "option": [
                        " 模型试图控制器 ",
                        " 组件图 ",
                        " 包图 ",
                        " 2 层、3 层或 N 层 "
                    ]
                },
                {
                    "index": 37,
                    "belong_page": 1,
                    "question_id": 46938,
                    "question_title": "<p>面向对象的分析模型设计模型则包含以包图表示的软件体系机构图、以交互图表示的用例实现图、完整精确的类图、描述复杂对象的（）和用以描述流程化处理过程的活动图等。</p>",
                    "question_type": 1,
                    "answer_type": 1,
                    "show_type_name": null,
                    "new_parent_id": 46938,
                    "score_rule": "",
                    "material_text": null,
                    "sort_son": "0",
                    "analyze": "<p>设计模型则包含以包图表示的软件体系机构图、以交互图表示的用例实现图、完整精确的类图、描述复杂对象的状态图和用以描述流程化处理过程的活动图等。</p>",
                    "like": 0,
                    "answer": [
                        "D"
                    ],
                    "option": [
                        " 序列图 ",
                        " 协作图 ",
                        " 流程图 ",
                        " 状态图 "
                    ]
                },
                {
                    "index": 38,
                    "belong_page": 1,
                    "question_id": 46956,
                    "question_title": "<p>在基于体系结构的软件设计方法中，采用（）来描述功能需求。</p>",
                    "question_type": 1,
                    "answer_type": 1,
                    "show_type_name": null,
                    "new_parent_id": 46956,
                    "score_rule": "",
                    "material_text": null,
                    "sort_son": "0",
                    "analyze": "<p>根据基于软件架构的设计的定义，基于软件架构的设计（Architecture Based Software Development，ABSD）强调由商业、质量和功能需求的组合驱动软件架构设计。它强调采用视角和视图来描述软件架构，采用用例和质量属性场景来描述需求。</p>",
                    "like": 0,
                    "answer": [
                        "C"
                    ],
                    "option": [
                        " 类图 ",
                        " 视角 ",
                        " 用例 ",
                        " 质量场景 "
                    ]
                },
                {
                    "index": 39,
                    "belong_page": 1,
                    "question_id": 46957,
                    "question_title": "<p>在基于体系结构的软件设计方法中，采用（5）来描述质量需求。</p>",
                    "question_type": 1,
                    "answer_type": 1,
                    "show_type_name": null,
                    "new_parent_id": 46957,
                    "score_rule": "",
                    "material_text": null,
                    "sort_son": "0",
                    "analyze": "<p>根据基于软件架构的设计的定义，基于软件架构的设计（Architecture Based Software Development，ABSD）强调由商业、质量和功能需求的组合驱动软件架构设计。它强调采用视角和视图来描述软件架构，采用用例和质量属性场景来描述需求。进一步来说，用例描述的是功能需求，质量属性场景描述的是质量需求（或侧重于非功能需求）。</p>",
                    "like": 0,
                    "answer": [
                        "C"
                    ],
                    "option": [
                        " 连接件 ",
                        " 用例 ",
                        " 质量场景 ",
                        " 视角 "
                    ]
                },
                {
                    "index": 40,
                    "belong_page": 1,
                    "question_id": 46965,
                    "question_title": "<p>按照设计模式的目的进行划分，现有的设计模式可以分为三类。其中创建型模式通过采用抽象类所定义的接口，封装了系统中对象如何创建、组合等信息，其代表有()模式等；</p>",
                    "question_type": 1,
                    "answer_type": 1,
                    "show_type_name": null,
                    "new_parent_id": 46965,
                    "score_rule": "",
                    "material_text": null,
                    "sort_son": "0",
                    "analyze": "<p>创建型模式通过采用抽象类所定义的接口，封装了系统中对象如何创建、组合等信息，其代表有Singleton模式。</p>",
                    "like": 0,
                    "answer": [
                        "D"
                    ],
                    "option": [
                        " Decorator ",
                        " Fly weight ",
                        " Command ",
                        " Singleton "
                    ]
                },
                {
                    "index": 41,
                    "belong_page": 1,
                    "question_id": 46966,
                    "question_title": "<p>按照设计模式的目的进行划分，现有的设计模式可以分为三类。()模式主要用于如何组合己有的类和对象以获得更大的结构，其代表有 Adapter 模式等；</p>",
                    "question_type": 1,
                    "answer_type": 1,
                    "show_type_name": null,
                    "new_parent_id": 46966,
                    "score_rule": "",
                    "material_text": null,
                    "sort_son": "0",
                    "analyze": "<p>结构型模式主要用于如何组合己有的类和对象以获得更大的结构，其代表有 Adapter 模式等;</p>",
                    "like": 0,
                    "answer": [
                        "C"
                    ],
                    "option": [
                        " 合成型 ",
                        " 组合型 ",
                        " 结构型 ",
                        " 聚合型 "
                    ]
                },
                {
                    "index": 42,
                    "belong_page": 1,
                    "question_id": 46967,
                    "question_title": "<p>照设计模式的目的进行划分，现有的设计模式可以分为三类。(15)模式主要用于对象之间的职责及其提供服务的分配方式；</p>",
                    "question_type": 1,
                    "answer_type": 1,
                    "show_type_name": null,
                    "new_parent_id": 46967,
                    "score_rule": "",
                    "material_text": null,
                    "sort_son": "0",
                    "analyze": "<p>行为型模式主要用于对象之间的职责及其提供服务的分配方式，其代表有Visitor模式等。</p>",
                    "like": 0,
                    "answer": [
                        "A"
                    ],
                    "option": [
                        " 行为型 ",
                        " 交互型 ",
                        " 耦合型 ",
                        " 关联型 "
                    ]
                },
                {
                    "index": 43,
                    "belong_page": 1,
                    "question_id": 46968,
                    "question_title": "<p>按照设计模式的目的进行划分，现有的设计模式可以分为三类。行为型模式主要用于对象之间的职责及其提供服务的分配方式，其代表有()模式等。</p>",
                    "question_type": 1,
                    "answer_type": 1,
                    "show_type_name": null,
                    "new_parent_id": 46968,
                    "score_rule": "",
                    "material_text": null,
                    "sort_son": "0",
                    "analyze": "<p>行为型模式主要用于对象之间的职责及其提供服务的分配方式，其代表有Visitor模式等。</p>",
                    "like": 0,
                    "answer": [
                        "D"
                    ],
                    "option": [
                        " Prototype ",
                        " Facade ",
                        " Proxy ",
                        " Visitor "
                    ]
                },
                {
                    "index": 44,
                    "belong_page": 1,
                    "question_id": 49839,
                    "question_title": "<p>对计算机评价的主要性能指标有时钟频率、( 请作答此空)、运算精度和内存容量等。对数据库管理系统评价的主要性能指标有（）、数据库所允许的索引数量和最大并发实物处理能力等。</p>",
                    "question_type": 1,
                    "answer_type": 1,
                    "show_type_name": null,
                    "new_parent_id": 49839,
                    "score_rule": "",
                    "material_text": null,
                    "sort_son": "0",
                    "analyze": "<p>性能指标，是软、硬件的性能指标的集成。在硬件中，包括计算机、各种通信交换设备、各类网络设备等；在软件中，包括：操作系统、协议以及应用程序等。</p><p>对计算机评价的主要性能指标有：时钟频率（主频）；运算速度；运算精度；内存的存储容量；存储器的存取周期；数据处理速率PDR（processing data rate）；吞吐率；各种响应时间；各种利用率；RASIS特性（即：可靠性Reliability、可用性Availability、可维护性、完整性和安全性；平均故障响应时间；兼容性；可扩充性；性能价格比。</p><p>衡量数据库管理系统的主要性能指标包括数据库本身和管理系统两部分，有：数据库的大小、数据库中表的数量、单个表的大小、表中允许的记录（行）数量、单个记录（行）的大小、表上所允许的索引数量、数据库所允许的索引数量、最大并发事务处理能力、负载均衡能力、最大连接数等等。</p>",
                    "like": 0,
                    "answer": [
                        "D"
                    ],
                    "option": [
                        " 丢包率 ",
                        " 端口吞吐量 ",
                        " 可移植性 ",
                        " 数据处理速率 "
                    ]
                },
                {
                    "index": 45,
                    "belong_page": 1,
                    "question_id": 49843,
                    "question_title": "<p>组织信息化需求通常包含三个层次，其中（请作答此空）需求的目标是提升组织的竞争能力，为组织的可持续发展提供支持环境。（ ）需求包含实现信息化战略目标的需求、运营策略的需求和人才培养的需求三个方面。技术需求主要强调在信息层技术层面上对系统的完善、升级、集成和整合提出的需求。</p>",
                    "question_type": 1,
                    "answer_type": 1,
                    "show_type_name": null,
                    "new_parent_id": 49843,
                    "score_rule": "",
                    "material_text": null,
                    "sort_son": "0",
                    "analyze": "<p>一般说来，信息化需求包含3个层次，即战略需求、运作需求和技术需求。</p><p>一是战略需求。组织信息化的目标是提升组织的竞争能力、为组织的可持续发展提供一个支持环境。从某种意义上来说，信息化对组织不仅仅是服务的手段和实现现有战略的辅助工具；信息化可以把组织战略提升到一个新的水平，为组织带来新的发展契机。特别是对于企业，信息化战略是企业竞争的基础。</p><p>二是运作需求。组织信息化的运作需求是组织信息化需求非常重要且关键的一环，它包含三方面的内容：一是实现信息化战略目标的需要；二是运作策略的需要。三是人才培养的需要。</p><p>三是技术需求。由于系统开发时间过长等问题在信息技术层面上对系统的完善、升级、集成和整合提出了需求。也有的组织，原来基本上没有大型的信息系统项目，有的也只是一些单机应用，这样的组织的信息化需求，一般是从头开发新的系统。</p>",
                    "like": 0,
                    "answer": [
                        "A"
                    ],
                    "option": [
                        " 战略 ",
                        " 发展 ",
                        " 人事 ",
                        " 财务 "
                    ]
                },
                {
                    "index": 46,
                    "belong_page": 1,
                    "question_id": 49844,
                    "question_title": "<p>组织信息化需求通常包含三个层次，其中（）需求的目标是提升组织的竞争能力，为组织的可持续发展提供支持环境。(请作答此空 )需求包含实现信息化战略目标的需求、运营策略的需求和人才培养的需求三个方面。技术需求主要强调在信息层技术层面上对系统的完善、升级、集成和整合提出的需求。</p>",
                    "question_type": 1,
                    "answer_type": 1,
                    "show_type_name": null,
                    "new_parent_id": 49844,
                    "score_rule": "",
                    "material_text": null,
                    "sort_son": "0",
                    "analyze": "<p>一般说来，信息化需求包含3个层次，即战略需求、运作需求和技术需求。</p><p>一是战略需求。组织信息化的目标是提升组织的竞争能力、为组织的可持续发展提供一个支持环境。从某种意义上来说，信息化对组织不仅仅是服务的手段和实现现有战略的辅助工具；信息化可以把组织战略提升到一个新的水平，为组织带来新的发展契机。特别是对于企业，信息化战略是企业竞争的基础。&lt;</p><p>二是运作需求。组织信息化的运作需求是组织信息化需求非常重要且关键的一环，它包含三方面的内容：一是实现信息化战略目标的需要；二是运作策略的需要。三是人才培养的需要。</p><p>三是技术需求。由于系统开发时间过长等问题在信息技术层面上对系统的完善、升级、集成和整合提出了需求。也有的组织，原来基本上没有大型的信息系统项目，有的也只是一些单机应用，这样的组织的信息化需求，一般是从头开发新的系统。</p>",
                    "like": 0,
                    "answer": [
                        "B"
                    ],
                    "option": [
                        " 规划 ",
                        " 运作 ",
                        " 营销 ",
                        " 管理 "
                    ]
                },
                {
                    "index": 47,
                    "belong_page": 1,
                    "question_id": 49847,
                    "question_title": "<p>以下关于需 求 陈 述 的描述中,（ ) 是 不 正 确的。</p>",
                    "question_type": 1,
                    "answer_type": 1,
                    "show_type_name": null,
                    "new_parent_id": 49847,
                    "score_rule": "",
                    "material_text": null,
                    "sort_son": "0",
                    "analyze": "<p>需求应按照重要程度进行区别对待，因此D不正确。</p>",
                    "like": 0,
                    "answer": [
                        "D"
                    ],
                    "option": [
                        " 每一项需求都必须完整、准确地描述即将要开发的功能 ",
                        " 需求必须能够在系统及其运行环境的能力和约束条件内实现 ",
                        " 每一项需求记录的功能都必须是用户的真正的需要 ",
                        " 在良好的需求陈述中，所有需求都应被视为同等重要 "
                    ]
                },
                {
                    "index": 48,
                    "belong_page": 1,
                    "question_id": 49855,
                    "question_title": "<p>面向对象的分析模型主要由顶层架构图、用例与用例图和（ 请作答此空）构成：设计模型则包含以（）表示的软件体系机构图、以交互图表示的用例实现图、完整精确的类图、描述复杂对象的（）和用以描述流程化处理过程的活动图等。</p>",
                    "question_type": 1,
                    "answer_type": 1,
                    "show_type_name": null,
                    "new_parent_id": 49855,
                    "score_rule": "",
                    "material_text": null,
                    "sort_son": "0",
                    "analyze": "<p>面向对象的分析模型主要由顶层架构图、用例与用例图和领域概念模型构成；</p><p>设计模型则包含以包图表示的软件体系机构图、以交互图表示的用例实现图、完整精确的类图、描述复杂对象的状态图和用以描述流程化处理过程的活动图等。</p>",
                    "like": 0,
                    "answer": [
                        "B"
                    ],
                    "option": [
                        " 数据流模型 ",
                        " 领域概念模型 ",
                        " 功能分解图 ",
                        " 功能需求模型 "
                    ]
                },
                {
                    "index": 49,
                    "belong_page": 1,
                    "question_id": 49856,
                    "question_title": "<p>面向对象的分析模型主要由顶层架构图、用例与用例图和（）构成：设计模型则包含以（请作答此空）表示的软件体系机构图、以交互图表示的用例实现图、完整精确的类图、描述复杂对象的（）和用以描述流程化处理过程的活动图等。</p>",
                    "question_type": 1,
                    "answer_type": 1,
                    "show_type_name": null,
                    "new_parent_id": 49856,
                    "score_rule": "",
                    "material_text": null,
                    "sort_son": "0",
                    "analyze": "<p>面向对象的分析模型主要由顶层架构图、用例与用例图和领域概念模型构成；</p><p>设计模型则包含以包图表示的软件体系机构图、以交互图表示的用例实现图、完整精确的类图、描述复杂对象的状态图和用以描述流程化处理过程的活动图等。</p>",
                    "like": 0,
                    "answer": [
                        "C"
                    ],
                    "option": [
                        " 模型试图控制器 ",
                        " 组件图 ",
                        " 包图 ",
                        " 2 层、3 层或 N 层 "
                    ]
                },
                {
                    "index": 50,
                    "belong_page": 1,
                    "question_id": 49857,
                    "question_title": "<p>面向对象的分析模型主要由顶层架构图、用例与用例图和（）构成：设计模型则包含以（）表示的软件体系机构图、以交互图表示的用例实现图、完整精确的类图、描述复杂对象的（请作答此空 ）和用以描述流程化处理过程的活动图等。</p>",
                    "question_type": 1,
                    "answer_type": 1,
                    "show_type_name": null,
                    "new_parent_id": 49857,
                    "score_rule": "",
                    "material_text": null,
                    "sort_son": "0",
                    "analyze": "<p>面向对象的分析模型主要由顶层架构图、用例与用例图和领域概念模型构成；</p><p>设计模型则包含以包图表示的软件体系机构图、以交互图表示的用例实现图、完整精确的类图、描述复杂对象的状态图和用以描述流程化处理过程的活动图等。</p>",
                    "like": 0,
                    "answer": [
                        "D"
                    ],
                    "option": [
                        " 序列图 ",
                        " 协作图 ",
                        " 流程图 ",
                        " 状态图 "
                    ]
                },
                {
                    "index": 51,
                    "belong_page": 1,
                    "question_id": 49858,
                    "question_title": "<p>软件构件是一个独立可部署的软件单元，与程序设计中的对象不同，构件（ ）。</p>",
                    "question_type": 1,
                    "answer_type": 1,
                    "show_type_name": null,
                    "new_parent_id": 49858,
                    "score_rule": "",
                    "material_text": null,
                    "sort_son": "0",
                    "analyze": "<p>构件的特性是:</p><p>（1）独立部署单元；</p><p>（2）作为第三方的组装单元；</p><p>（3）没有（外部的）可见状态。<br/>构件创建的对象（对这些对象的引用）可以与对象分离开来，并对构件的客户可见。<br/></p><p>一个构件可以包含多个类元素，但是一个类元素只能属于一个构件。将一个类拆分进行部署通常没什么意义。</p><p>对象的特性是：</p><p>（1）一个实例单元，具有唯一的标志。</p><p>（2）可能具有状态，此状态外部可见。</p><p>（3）封装了自己的状态和行为。</p>",
                    "like": 0,
                    "answer": [
                        "B"
                    ],
                    "option": [
                        " 是一个实例单元，具有唯一的标志 ",
                        " 可以利用容器管理自身对外的可见状态 ",
                        " 利用工厂方法（如构造函数）来创建自己的实例 ",
                        " 之间可以共享一个类元素 "
                    ]
                },
                {
                    "index": 52,
                    "belong_page": 1,
                    "question_id": 49859,
                    "question_title": "<p>为了使一个接口的规范和实现该接口的构件得到广泛应用，需要实现接口的标准化。接口标准他是对（ ）的标准化。</p>",
                    "question_type": 1,
                    "answer_type": 1,
                    "show_type_name": null,
                    "new_parent_id": 49859,
                    "score_rule": "",
                    "material_text": null,
                    "sort_son": "0",
                    "analyze": "<p>接口标准是对.接口中消息模式、格式和协的标准化</p>",
                    "like": 0,
                    "answer": [
                        "B"
                    ],
                    "option": [
                        " 保证接口唯一性的命名方案 ",
                        " 接口中消息模式、格式和协议 ",
                        " 接口中所接收的数据格式 ",
                        " 接口消息适用语境 "
                    ]
                },
                {
                    "index": 53,
                    "belong_page": 1,
                    "question_id": 49877,
                    "question_title": "<p>按照设计模式的目的进行划分，现有的设计模式可以分为三类。其中创建型模式通过采用抽象类所定义的接口，封装了系统中对象如何创建、组合等信息，其代表有(请作答此空 )模式等;(&nbsp; &nbsp;)模式主要用于如何组合己有的类和对象以获得更大的结构，其代表有 Adapter 模式等;(&nbsp; &nbsp;)模式主要用于对象之间的职责及其提供服务的分配方式，其代表有(&nbsp; &nbsp; &nbsp; )模式等。</p>",
                    "question_type": 1,
                    "answer_type": 1,
                    "show_type_name": null,
                    "new_parent_id": 49877,
                    "score_rule": "",
                    "material_text": null,
                    "sort_son": "0",
                    "analyze": "<p>按照设计模式的目的进行划分，现有的设计模式可以分为三类。</p><p>创建型模式通过采用抽象类所定义的接口，封装了系统中对象如何创建、组合等信息，其代表有Singleton模式等;</p><p>结构型模式主要用于如何组合己有的类和对象以获得更大的结构，其代表有 Adapter 模式等;</p><p>行为型模式主要用于对象之间的职责及其提供服务的分配方式，其代表有Visitor模式等。</p>",
                    "like": 0,
                    "answer": [
                        "D"
                    ],
                    "option": [
                        " Decorator ",
                        " Fly weight ",
                        " Command ",
                        " Singleton "
                    ]
                },
                {
                    "index": 54,
                    "belong_page": 1,
                    "question_id": 49878,
                    "question_title": "<p>按照设计模式的目的进行划分，现有的设计模式可以分为三类。其中创建型模式通过采用抽象类所定义的接口，封装了系统中对象如何创建、组合等信息，其代表有(&nbsp; &nbsp;)模式等;( 请作答此空)模式主要用于如何组合己有的类和对象以获得更大的结构，其代表有 Adapter 模式等;(&nbsp; &nbsp; )模式主要用于对象之间的职责及其提供服务的分配方式，其代表有(&nbsp; &nbsp; &nbsp; )模式等。</p>",
                    "question_type": 1,
                    "answer_type": 1,
                    "show_type_name": null,
                    "new_parent_id": 49878,
                    "score_rule": "",
                    "material_text": null,
                    "sort_son": "0",
                    "analyze": "<p>按照设计模式的目的进行划分，现有的设计模式可以分为三类。</p><p>创建型模式通过采用抽象类所定义的接口，封装了系统中对象如何创建、组合等信息，其代表有Singleton模式等;</p><p>结构型模式主要用于如何组合己有的类和对象以获得更大的结构，其代表有 Adapter 模式等;</p><p>行为型模式主要用于对象之间的职责及其提供服务的分配方式，其代表有Visitor模式等。</p>",
                    "like": 0,
                    "answer": [
                        "C"
                    ],
                    "option": [
                        " 合成型 ",
                        " 组合型 ",
                        " 结构型 ",
                        " 聚合型 "
                    ]
                },
                {
                    "index": 55,
                    "belong_page": 1,
                    "question_id": 49879,
                    "question_title": "<p>按照设计模式的目的进行划分，现有的设计模式可以分为三类。其中创建型模式通过采用抽象类所定义的接口，封装了系统中对象如何创建、组合等信息，其代表有(&nbsp; )模式等;(&nbsp; )模式主要用于如何组合己有的类和对象以获得更大的结构，其代表有 Adapter 模式等;(请作答此空 )模式主要用于对象之间的职责及其提供服务的分配方式，其代表有(&nbsp; )模式等。</p>",
                    "question_type": 1,
                    "answer_type": 1,
                    "show_type_name": null,
                    "new_parent_id": 49879,
                    "score_rule": "",
                    "material_text": null,
                    "sort_son": "0",
                    "analyze": "<p>按照设计模式的目的进行划分，现有的设计模式可以分为三类。</p><p>创建型模式通过采用抽象类所定义的接口，封装了系统中对象如何创建、组合等信息，其代表有Singleton模式等;</p><p>结构型模式主要用于如何组合己有的类和对象以获得更大的结构，其代表有 Adapter 模式等;</p><p>行为型模式主要用于对象之间的职责及其提供服务的分配方式，其代表有Visitor模式等。</p>",
                    "like": 0,
                    "answer": [
                        "A"
                    ],
                    "option": [
                        " 行为型 ",
                        " 交互型 ",
                        " 耦合性 ",
                        " 关联型 "
                    ]
                },
                {
                    "index": 56,
                    "belong_page": 1,
                    "question_id": 49881,
                    "question_title": "<p>某公司欲开发一个在线交易网站，在架构设计阶段，公司的架构师识别出 3 个核心质量属性场景。其中&quot;网站正常运行时，用户发起的交易请求应该在 3 秒内完成&quot; 主要与（请作答此空 ）质量属性相关，通常可采用（ ）架构策略实现该属性; &quot;在线交易主站宕机后，能够在 3 秒内自动切换至备用站点并恢复正常运行&quot;主要与（&nbsp; ）质量属 性相关，通常可采用（&nbsp; ）架构策略实现该属性; &quot;系统应该具备一定的安全保护措施， 从而能够抵挡恶意的入侵破坏行为，并对所有针对网站的攻击行为进行报警和记录&quot;主要与（）质量属性相关，通常可采用（&nbsp; ）架构策略实现该属性。</p>",
                    "question_type": 1,
                    "answer_type": 1,
                    "show_type_name": null,
                    "new_parent_id": 49881,
                    "score_rule": "",
                    "material_text": null,
                    "sort_son": "0",
                    "analyze": "<p>对于题干描述：&quot;用户的交易请求需要在3秒内得到响应&quot;，主要与性能这一质量属性相关，实现该属性的常见架构策略包括：增加计算资源、减少计算开销、引入并发机制、采用资源调度等。</p><p>&quot;在线交易主站宕机后，需要在3秒内恢复正常运行&quot;主要与可用性质量属性相关，通常可采用心跳、Ping/Echo、主动冗余、被动冗余、选举等架构策略实现该属性。</p><p>&quot;系统应该具备一定的安全保护措施， 从而能够抵挡恶意的入侵破坏行为，并对所有针对网站的攻击行为进行报警和记录&quot;主要与安全性质量属性相关，通常可采用入侵检测、用户认证、用户授权、追踪审计等架构策略实现该属性。</p>",
                    "like": 0,
                    "answer": [
                        "B"
                    ],
                    "option": [
                        " 可用性 ",
                        " 性能 ",
                        " 易用性 ",
                        " 可修改性 "
                    ]
                },
                {
                    "index": 57,
                    "belong_page": 1,
                    "question_id": 49882,
                    "question_title": "<p>某公司欲开发一个在线交易网站，在架构设计阶段，公司的架构师识别出 3 个核心质量属性场景。其中&quot;网站正常运行时，用户发起的交易请求应该在 3 秒内完成&quot; 主要与（）质量属性相关，通常可采用（请作答此空 ）架构策略实现该属性; &quot;在线交易主站宕机后，能够在 3 秒内自动切换至备用站点并恢复正常运行&quot;主要与（）质量属 性相关，通常可采用（）架构策略实现该属性; &quot;系统应该具备一定的安全保护措施， 从而能够抵挡恶意的入侵破坏行为，并对所有针对网站的攻击行为进行报警和记录&quot;主要与（）质量属性相关，通常可采用（）架构策略实现该属性。</p>",
                    "question_type": 1,
                    "answer_type": 1,
                    "show_type_name": null,
                    "new_parent_id": 49882,
                    "score_rule": "",
                    "material_text": null,
                    "sort_son": "0",
                    "analyze": "<p>对于题干描述：&quot;用户的交易请求需要在3秒内得到响应&quot;，主要与性能这一质量属性相关，实现该属性的常见架构策略包括：增加计算资源、减少计算开销、引入并发机制、采用资源调度等。</p><p>&quot;在线交易主站宕机后，需要在3秒内恢复正常运行&quot;主要与可用性质量属性相关，通常可采用心跳、Ping/Echo、主动冗余、被动冗余、选举等架构策略实现该属性。</p><p>&quot;系统应该具备一定的安全保护措施， 从而能够抵挡恶意的入侵破坏行为，并对所有针对网站的攻击行为进行报警和记录&quot;主要与安全性质量属性相关，通常可采用入侵检测、用户认证、用户授权、追踪审计等架构策略实现该属性。</p>",
                    "like": 0,
                    "answer": [
                        "D"
                    ],
                    "option": [
                        " 抽象接口 ",
                        " 信息隐藏 ",
                        " 主动冗余 ",
                        " 资源调度 "
                    ]
                },
                {
                    "index": 58,
                    "belong_page": 1,
                    "question_id": 49885,
                    "question_title": "<p>某公司欲开发一个在线交易网站，在架构设计阶段，公司的架构师识别出 3 个核心质量属性场景。其中&quot;网站正常运行时，用户发起的交易请求应该在 3 秒内完成&quot; 主要与（）质量属性相关，通常可采用（）架构策略实现该属性; &quot;在线交易主站宕机后，能够在 3 秒内自动切换至备用站点并恢复正常运行&quot;主要与（）质量属 性相关，通常可采用（）架构策略实现该属性; &quot;系统应该具备一定的安全保护措施， 从而能够抵挡恶意的入侵破坏行为，并对所有针对网站的攻击行为进行报警和记录&quot;主要与（请作答此空）质量属性相关，通常可采用（）架构策略实现该属性。</p>",
                    "question_type": 1,
                    "answer_type": 1,
                    "show_type_name": null,
                    "new_parent_id": 49885,
                    "score_rule": "",
                    "material_text": null,
                    "sort_son": "0",
                    "analyze": "<p>对于题干描述：&quot;用户的交易请求需要在3秒内得到响应&quot;，主要与性能这一质量属性相关，实现该属性的常见架构策略包括：增加计算资源、减少计算开销、引入并发机制、采用资源调度等。</p><p>&quot;在线交易主站宕机后，需要在3秒内恢复正常运行&quot;主要与可用性质量属性相关，通常可采用心跳、Ping/Echo、主动冗余、被动冗余、选举等架构策略实现该属性。</p><p>&quot;系统应该具备一定的安全保护措施， 从而能够抵挡恶意的入侵破坏行为，并对所有针对网站的攻击行为进行报警和记录&quot;主要与安全性质量属性相关，通常可采用入侵检测、用户认证、用户授权、追踪审计等架构策略实现该属性。</p>",
                    "like": 0,
                    "answer": [
                        "B"
                    ],
                    "option": [
                        " 可用性 ",
                        " 安全性 ",
                        " 可测试性 ",
                        " 可修改性 "
                    ]
                },
                {
                    "index": 59,
                    "belong_page": 1,
                    "question_id": 49886,
                    "question_title": "<p>某公司欲开发一个在线交易网站，在架构设计阶段，公司的架构师识别出 3 个核心质量属性场景。其中&quot;网站正常运行时，用户发起的交易请求应该在 3 秒内完成&quot; 主要与（）质量属性相关，通常可采用（）架构策略实现该属性; &quot;在线交易主站宕机后，能够在 3 秒内自动切换至备用站点并恢复正常运行&quot;主要与（）质量属 性相关，通常可采用（）架构策略实现该属性; &quot;系统应该具备一定的安全保护措施， 从而能够抵挡恶意的入侵破坏行为，并对所有针对网站的攻击行为进行报警和记录&quot;主要与（）质量属性相关，通常可采用（请作答此空 ）架构策略实现该属性。</p>",
                    "question_type": 1,
                    "answer_type": 1,
                    "show_type_name": null,
                    "new_parent_id": 49886,
                    "score_rule": "",
                    "material_text": null,
                    "sort_son": "0",
                    "analyze": "<p>对于题干描述：&quot;用户的交易请求需要在3秒内得到响应&quot;，主要与性能这一质量属性相关，实现该属性的常见架构策略包括：增加计算资源、减少计算开销、引入并发机制、采用资源调度等。</p><p>&quot;在线交易主站宕机后，需要在3秒内恢复正常运行&quot;主要与可用性质量属性相关，通常可采用心跳、Ping/Echo、主动冗余、被动冗余、选举等架构策略实现该属性。</p><p>&quot;系统应该具备一定的安全保护措施， 从而能够抵挡恶意的入侵破坏行为，并对所有针对网站的攻击行为进行报警和记录&quot;主要与安全性质量属性相关，通常可采用入侵检测、用户认证、用户授权、追踪审计等架构策略实现该属性。</p>",
                    "like": 0,
                    "answer": [
                        "A"
                    ],
                    "option": [
                        " 追踪审计 ",
                        " Ping/Echo ",
                        " 选举 ",
                        " 维护现有接口 "
                    ]
                },
                {
                    "index": 60,
                    "belong_page": 1,
                    "question_id": 49897,
                    "question_title": "<p>The architecture design specifies the overall architecture and the placement of software and hardware that will be used. Architecture design is a very complex process that is often left to experienced architecture designers and consultants. The first step is to refine the () into more detailed requirements that are then employed to help select the architecture to be used and the software components to be placed on each device. In a (), one also has to decide whether to use a two-tier, three-tier, or n-tier architecture. Then the requirements and the architecture</p><p>design are used to develop the hardware and software specification. There are four primary types of nonfunctional requirements that can be important in designing the architecture. () &nbsp;specify &nbsp;the operating environment(s) in which the system must perform and how those may change over time. ( 请作答此空) &nbsp;focus &nbsp;on the nonfunctional requirements issues such as response time, capacity, and reliability. () are the abilities to protect the information system from disruption and data loss, whether caused by an intentional act. Cultural and political requirements are specific to the countries in which the system will be used.</p>",
                    "question_type": 1,
                    "answer_type": 1,
                    "show_type_name": null,
                    "new_parent_id": 49897,
                    "score_rule": "",
                    "material_text": null,
                    "sort_son": "0",
                    "analyze": "<p>体系结构设计指定了将使用的总体架构和软件和硬件的位置。架构设计是一个非常复杂的过程，通常留给经验丰富的架构设计师和顾问。第一步是将非功能需求细化为更详细的需求，然后使用这些需求来帮助选择要使用的体系结构和将要放置在每个设备上的软件组件。在客户端-服务器体系结构，也决定是否使用双层、三层或多层结构。然后，需求和体系结构设计用于开发硬件和软件规范。有四种主要类型的非功能需求在设计架构中是很重要的。操作要求指定操作环境，系统必须执行和那些可能会随时间而改变。性能要求关注非功能性需求的问题，如响应时间、容量和可靠性。安全要求的能力来保护信息系统的中断和数据丢失，无论是通过故意行为造成。文化和政治要求是具体的国家将使用该系统。</p>",
                    "like": 0,
                    "answer": [
                        "C"
                    ],
                    "option": [
                        " Environment requirements<br/>环境要求 ",
                        " Maintainability requirements<br/>可维修性要求 ",
                        " Performance requirements<br/>性能要求 ",
                        " Virus control requirements<br/>病毒控制要求 "
                    ]
                },
                {
                    "index": 61,
                    "belong_page": 1,
                    "question_id": 49898,
                    "question_title": "<p>The architecture design specifies the overall architecture and the placement of software and hardware that will be used. Architecture design is a very complex process that is often left to experienced architecture designers and consultants. The first step is to refine the ( ) into more detailed requirements that are then employed to help select the architecture to be used and the software components to be placed on each device. In a ( ), one also has to decide whether to use a two-tier, three-tier, or n-tier architecture. Then the requirements and the architecture</p><p>design are used to develop the hardware and software specification. There are four primary types of nonfunctional requirements that can be important in designing the architecture. ( ) specify &nbsp;the operating environment(s) in which the system must perform and how those may change over time. ( ) focus &nbsp;on the nonfunctional requirements issues such as response time, capacity, and reliability. (请作答此空) are the abilities to protect the information system from disruption and data loss, whether caused by an intentional act. Cultural and political requirements are specific to the countries in which the system will be used.</p>",
                    "question_type": 1,
                    "answer_type": 1,
                    "show_type_name": null,
                    "new_parent_id": 49898,
                    "score_rule": "",
                    "material_text": null,
                    "sort_son": "0",
                    "analyze": "<p>体系结构设计指定了将使用的总体架构和软件和硬件的位置。架构设计是一个非常复杂的过程，通常留给经验丰富的架构设计师和顾问。第一步是将非功能需求细化为更详细的需求，然后使用这些需求来帮助选择要使用的体系结构和将要放置在每个设备上的软件组件。在客户端-服务器体系结构，也决定是否使用双层、三层或多层结构。然后，需求和体系结构设计用于开发硬件和软件规范。有四种主要类型的非功能需求在设计架构中是很重要的。操作要求指定操作环境，系统必须执行和那些可能会随时间而改变。性能要求关注非功能性需求的问题，如响应时间、容量和可靠性。安全要求的能力来保护信息系统的中断和数据丢失，无论是通过故意行为造成。文化和政治要求是具体的国家将使用该系统。</p>",
                    "like": 0,
                    "answer": [
                        "B"
                    ],
                    "option": [
                        " Safety requirements<br/>安全要求 ",
                        " Security requirements<br/>安全要求 ",
                        " Data management requirements<br/>数据管理要求 ",
                        " System requirements<br/>系统要求 "
                    ]
                },
                {
                    "index": 62,
                    "belong_page": 1,
                    "question_id": 49917,
                    "question_title": "<p>国家和地方人口信息的采集、处理和利用，属于（）的电子政务活动。</p>",
                    "question_type": 1,
                    "answer_type": 1,
                    "show_type_name": null,
                    "new_parent_id": 49917,
                    "score_rule": "",
                    "material_text": null,
                    "sort_son": "0",
                    "analyze": "<p>电子政务是对现有的政府形态的一种改造，利用信息技术和其他相关技术，将其管理和服务职能进行集成，在网络上实现政府组织结构和工作流程优化重组。与电子政务相关的行为主体有三个，即政府、企（事）业单位及居民。国家和地方人口信息的采集、处理和利用，属于政府对政府的电子政务活动。</p>",
                    "like": 0,
                    "answer": [
                        "A"
                    ],
                    "option": [
                        " 政府对政府 ",
                        " 政府对居民 ",
                        " 居民对居民 ",
                        " 居民对政府 "
                    ]
                },
                {
                    "index": 63,
                    "belong_page": 1,
                    "question_id": 49918,
                    "question_title": "<p>ERP（Enterprise Resource Planning）是建立在信息技术的基础上，利用现代企业的先进管理思想，对企业的物流、资金流和（ &nbsp;）流进行全面集成管理的管理信息系统，为企业提供决策、计划、控制与经营业绩评估的全方位和系统化的管理平台。</p>",
                    "question_type": 1,
                    "answer_type": 1,
                    "show_type_name": null,
                    "new_parent_id": 49918,
                    "score_rule": "",
                    "material_text": null,
                    "sort_son": "0",
                    "analyze": "<p>ERP（Enterprise Resource Planning）是建立在信息技术的基础上，利用现代企业的先进管理思想，对企业的物流、资金流和信息流进行全面集成管理的管理信息系统，为企业提供决策、计划、控制与经营业绩评估的全方位和系统化的管理平台。</p><p>ERP系统主要包括：生产预测、销售管理（计划）、经营计划（生产计划大纲）、主生产计划、物料需求计划、能力需求计划、车间作业计划、采购与库存管理、质量与设备管理、财务管理、ERP有关扩展应用模块等内容。显然对企业物料的进、出、存进行管理的模块是库存管理模块。</p>",
                    "like": 0,
                    "answer": [
                        "C"
                    ],
                    "option": [
                        " 产品 ",
                        " 人力资源 ",
                        " 信息 ",
                        " 加工 "
                    ]
                },
                {
                    "index": 64,
                    "belong_page": 1,
                    "question_id": 49919,
                    "question_title": "<p>在ERP系统中，（ ）管理模块主要是对企业物料的进、出、存进行管理。</p>",
                    "question_type": 1,
                    "answer_type": 1,
                    "show_type_name": null,
                    "new_parent_id": 49919,
                    "score_rule": "",
                    "material_text": null,
                    "sort_son": "0",
                    "analyze": "<p>ERP（Enterprise Resource Planning）是建立在信息技术的基础上，利用现代企业的先进管理思想，对企业的物流、资金流和信息流进行全面集成管理的管理信息系统，为企业提供决策、计划、控制与经营业绩评估的全方位和系统化的管理平台。</p><p>ERP系统主要包括：生产预测、销售管理（计划）、经营计划（生产计划大纲）、主生产计划、物料需求计划、能力需求计划、车间作业计划、采购与库存管理、质量与设备管理、财务管理、ERP有关扩展应用模块等内容。显然对企业物料的进、出、存进行管理的模块是库存管理模块。</p>",
                    "like": 0,
                    "answer": [
                        "A"
                    ],
                    "option": [
                        " 库存 ",
                        " 物料 ",
                        " 采购 ",
                        " 销售 "
                    ]
                },
                {
                    "index": 65,
                    "belong_page": 1,
                    "question_id": 49929,
                    "question_title": "<p>面向对象的分析模型主要由（请作答此空 ）、用例与用例图、领域概念模型构成；设计模型则包含以包图表示的软件体系结构图、以交互图表示的（）、完整精确的类图、针对复杂对象的状态图和描述流程化处理过程的（）等。</p>",
                    "question_type": 1,
                    "answer_type": 1,
                    "show_type_name": null,
                    "new_parent_id": 49929,
                    "score_rule": "",
                    "material_text": null,
                    "sort_son": "0",
                    "analyze": "<p>面向对象的分析模型主要由顶层架构图、用例与用例图、领域概念模型构成；设计模型则包含以包图表示的软件体系结构图、以交互图表示的用例实现图、完整精确的类图、针对复杂对象的状态图和用以描述流程化处理过程的活动图等。</p>",
                    "like": 0,
                    "answer": [
                        "B"
                    ],
                    "option": [
                        " 业务活动图 ",
                        " 顶层架构图 ",
                        " 数据流模型 ",
                        " 实体联系图 "
                    ]
                },
                {
                    "index": 66,
                    "belong_page": 1,
                    "question_id": 49930,
                    "question_title": "<p>面向对象的分析模型主要由（）、用例与用例图、领域概念模型构成；设计模型则包含以包图表示的软件体系结构图、以交互图表示的（请作答此空 ）、完整精确的类图、针对复杂对象的状态图和描述流程化处理过程的（）等。</p>",
                    "question_type": 1,
                    "answer_type": 1,
                    "show_type_name": null,
                    "new_parent_id": 49930,
                    "score_rule": "",
                    "material_text": null,
                    "sort_son": "0",
                    "analyze": "<p>面向对象的分析模型主要由顶层架构图、用例与用例图、领域概念模型构成；设计模型则包含以包图表示的软件体系结构图、以交互图表示的用例实现图、完整精确的类图、针对复杂对象的状态图和用以描述流程化处理过程的活动图等。</p>",
                    "like": 0,
                    "answer": [
                        "C"
                    ],
                    "option": [
                        " 功能分解图 ",
                        " 时序关系图 ",
                        " 用例实现图 ",
                        " 软件部署图 "
                    ]
                },
                {
                    "index": 67,
                    "belong_page": 1,
                    "question_id": 49931,
                    "question_title": "<p>面向对象的分析模型主要由（）、用例与用例图、领域概念模型构成；设计模型则包含以包图表示的软件体系结构图、以交互图表示的（）、完整精确的类图、针对复杂对象的状态图和描述流程化处理过程的（ 请作答此空）等。</p>",
                    "question_type": 1,
                    "answer_type": 1,
                    "show_type_name": null,
                    "new_parent_id": 49931,
                    "score_rule": "",
                    "material_text": null,
                    "sort_son": "0",
                    "analyze": "<p>面向对象的分析模型主要由顶层架构图、用例与用例图、领域概念模型构成；设计模型则包含以包图表示的软件体系结构图、以交互图表示的用例实现图、完整精确的类图、针对复杂对象的状态图和用以描述流程化处理过程的活动图等。</p>",
                    "like": 0,
                    "answer": [
                        "D"
                    ],
                    "option": [
                        " 序列图 ",
                        " 协作图 ",
                        " 流程图 ",
                        " 活动图 "
                    ]
                },
                {
                    "index": 68,
                    "belong_page": 1,
                    "question_id": 49952,
                    "question_title": "<p>设计模式基于面向对象技术，是人们在长期的开发实践中良好经验的结晶，提供了一个简单、统一的描述方法，使得人们可以复用这些软件设计办法、过程管理经验。按照设计模式的目的进行划分，现有的设计模式可以分为创建型、（请作答此空 &nbsp;）和行为型三种类型。其中（）属于创建型模式，（）属于行为型模式。（）模式可以将一个复杂的组件分成功能性抽象和内部实现两个独立的但又相关的继承层次结构，从而可以实现接口与实现分离。</p>",
                    "question_type": 1,
                    "answer_type": 1,
                    "show_type_name": null,
                    "new_parent_id": 49952,
                    "score_rule": "",
                    "material_text": null,
                    "sort_son": "0",
                    "analyze": "<p>设计模式包括：创建型、结构型、行为型。</p><p>Singleton是单例模式，属于创建型设计模式。</p><p>Memento是备忘录模式，属于行为型设计模式。</p><p>Bridge是桥接模式，它的特点是实现接口与实现分离。</p>",
                    "like": 0,
                    "answer": [
                        "C"
                    ],
                    "option": [
                        " 合成型 ",
                        " 组合型 ",
                        " 结构型 ",
                        " 聚合型 "
                    ]
                },
                {
                    "index": 69,
                    "belong_page": 1,
                    "question_id": 49953,
                    "question_title": "<p>&nbsp;设计模式基于面向对象技术，是人们在长期的开发实践中良好经验的结晶，提供了一个简单、统一的描述方法，使得人们可以复用这些软件设计办法、过程管理经验。按照设计模式的目的进行划分，现有的设计模式可以分为创建型、（）和行为型三种类型。其中（请作答此空 ）属于创建型模式，（）属于行为型模式。（）模式可以将一个复杂的组件分成功能性抽象和内部实现两个独立的但又相关的继承层次结构，从而可以实现接口与实现分离。</p>",
                    "question_type": 1,
                    "answer_type": 1,
                    "show_type_name": null,
                    "new_parent_id": 49953,
                    "score_rule": "",
                    "material_text": null,
                    "sort_son": "0",
                    "analyze": "<p>设计模式包括：创建型、结构型、行为型。</p><p>Singleton是单例模式，属于创建型设计模式。</p><p>Memento是备忘录模式，属于行为型设计模式。</p><p>Bridge是桥接模式，它的特点是实现接口与实现分离。</p>",
                    "like": 0,
                    "answer": [
                        "D"
                    ],
                    "option": [
                        " Adaptor ",
                        " Facade ",
                        " Command ",
                        " Singleton "
                    ]
                },
                {
                    "index": 70,
                    "belong_page": 1,
                    "question_id": 49955,
                    "question_title": "<p>设计模式基于面向对象技术，是人们在长期的开发实践中良好经验的结晶，提供了一个简单、统一的描述方法，使得人们可以复用这些软件设计办法、过程管理经验。按照设计模式的目的进行划分，现有的设计模式可以分为创建型、（）和行为型三种类型。其中（）属于创建型模式，（）属于行为型模式。（请作答此空 ）模式可以将一个复杂的组件分成功能性抽象和内部实现两个独立的但又相关的继承层次结构，从而可以实现接口与实现分离。</p>",
                    "question_type": 1,
                    "answer_type": 1,
                    "show_type_name": null,
                    "new_parent_id": 49955,
                    "score_rule": "",
                    "material_text": null,
                    "sort_son": "0",
                    "analyze": "<p>设计模式包括：创建型、结构型、行为型。</p><p>Singleton是单例模式，属于创建型设计模式。</p><p>Memento是备忘录模式，属于行为型设计模式。</p><p>Bridge是桥接模式，它的特点是实现接口与实现分离。</p>",
                    "like": 0,
                    "answer": [
                        "D"
                    ],
                    "option": [
                        " Prototype ",
                        " Flyweight ",
                        " Adapter ",
                        " Bridge "
                    ]
                },
                {
                    "index": 71,
                    "belong_page": 1,
                    "question_id": 49961,
                    "question_title": "<p>某公司欲开发一个智能机器人系统，在架构设计阶段，公司的架构师识别出3个核心质量属性场景。其中&quot;机器人系统主电源断电后，能够在10秒内自动启动备用电源并进行切换，恢复正常运行&quot;主要与（）质量属性相关，通常可采用（）架构策略实现该属性；&quot;机器人在正常运动过程中如果发现前方2米内有人或者障碍物，应在1秒内停止并在2秒内选择一条新的运行路径&quot;主要与（）质量属性相关，通常可采用（）架构策略实现该属性；&quot;对机器人的远程控制命令应该进行加密，从而能够抵挡恶意的入侵破坏行为，并对攻击进行报警和记录&quot;主要与（）质量属性相关，通常可采用（请作答此空 ）架构策略实现该属性。</p>",
                    "question_type": 1,
                    "answer_type": 1,
                    "show_type_name": null,
                    "new_parent_id": 49961,
                    "score_rule": "",
                    "material_text": null,
                    "sort_son": "0",
                    "analyze": "<p>&quot;机器人系统主电源断电后，能够在10秒内自动启动备用电源并进行切换，恢复正常运行&quot;属于可用性，因为场景描述的是故障恢复问题。主动冗余是可用性的常见策略。</p><p>&quot;机器人在正常运动过程中如果发现前方2米内有人或者障碍物，应在1秒内停止并在2秒内选择一条新的运行路径&quot;属于性能，资源调度是其常见策略。</p><p>&quot;对机器人的远程控制命令应该进行加密，从而能够抵挡恶意的入侵破坏行为，并对攻击进行报警和记录&quot;属于安全性，常见的策略是追踪审计。</p>",
                    "like": 0,
                    "answer": [
                        "B"
                    ],
                    "option": [
                        " 内置监控器 ",
                        " 追踪审计 ",
                        " 记录/回放 ",
                        " 维护现有接口 "
                    ]
                },
                {
                    "index": 72,
                    "belong_page": 1,
                    "question_id": 49968,
                    "question_title": "<p>以下关于数学建模的叙述中，不正确的是（ &nbsp;）。</p>",
                    "question_type": 1,
                    "answer_type": 1,
                    "show_type_name": null,
                    "new_parent_id": 49968,
                    "score_rule": "",
                    "material_text": null,
                    "sort_son": "0",
                    "analyze": "<p>数学建模是利用数学方法解决实际问题的一种实践。即通过抽象、简化、假设、引进变量等处理过程后，将实际问题用数学方式表达，建立起数学模型，然后运用先进的数学方法及计算机技术进行求解。数学模型是对于现实世界的一个特定对象，一个特定目的，根据特有的内在规律，做出一些必要的假设，运用适当的数学工具，得到一个数学结构。数学建模应该有一个统一的评价机制，但是没有反馈机制。</p>",
                    "like": 0,
                    "answer": [
                        "D"
                    ],
                    "option": [
                        " 数学模型是对现实世界的一种简化的抽象描述 ",
                        " 数学建模时需要在简单性和准确性之间求得平衡 ",
                        " 数学模型应该用统一的、普适的标准对其进行评价 ",
                        " 数学建模需要从失败和用户的反馈中学习和改进 "
                    ]
                },
                {
                    "index": 73,
                    "belong_page": 1,
                    "question_id": 50901,
                    "question_title": "<p>某广告公司的宣传产品有宣传册、文章、传单等多种形式，宣传产品的出版方式包括纸质方式、CD、DVD、在线发布等。现要求为该广告公司设计一个管理这些宣传产品的应用，采用（作答此空）设计模式较为合适，该模式（）。</p>",
                    "question_type": 1,
                    "answer_type": 1,
                    "show_type_name": null,
                    "new_parent_id": 50901,
                    "score_rule": "",
                    "material_text": null,
                    "sort_son": "0",
                    "analyze": "<p>题目所给出的应用中，不希望在不同的宣传产品与具体所采用的出版方式之间建立一个固定的绑定关系，以避免这两者之间的紧耦合关系。这种情形适合于采用Bridge(桥接)模式。桥接模式属于结构型设计模式的一种。结构型模式描述如何将类或对象合在一起形成更大的结构。桥接模式将抽象部分与它的实现部分分离，使它们都可以独立地变化。在以下情况可以使用Bridge模式：&nbsp;①不希望在抽象以及抽象的实现部分之间有一个固定的绑定关系。例如这种情况可能是因为，在程序运行时刻可以选择或切换实现部分；②类的抽象以及它的实现都应该可以通过生成子类的方法加以扩充，使用Bridge模式可以对不同的抽象接口和实现部分进行组合，并分别对它们进行扩充。③对一个抽象的实现部分的修改应该对用户不产生影响，即客户的代码不必重新编译。</p>",
                    "like": 0,
                    "answer": [
                        "C"
                    ],
                    "option": [
                        " Decorator ",
                        " Adapter ",
                        " Bridge ",
                        " Facade "
                    ]
                },
                {
                    "index": 74,
                    "belong_page": 1,
                    "question_id": 50912,
                    "question_title": "<p>“4+1”视图主要用于描述系统逻辑架构，最早由Philippe Kruchten于1995年提出。其中（作答此空）视图用于描述对象模型，并说明系统应该为用户提供哪些服务。当采用面向对象的设计方法描述对象模型时，通常使用（）表达类的内部属性和行为，以及类集合之间的交互关系；采用（）定义对象的内部行为。</p>",
                    "question_type": 1,
                    "answer_type": 1,
                    "show_type_name": null,
                    "new_parent_id": 50912,
                    "score_rule": "",
                    "material_text": null,
                    "sort_son": "0",
                    "analyze": "<p>“4+1”视图是对逻辑架构进行描述，最早由Philippe Kruchten提出，他在1995年的IEEE Software上发表了题为The 4+1 View Model of Architecture的论文，引起了业界的极大关注，并最终被RUP采纳，现在已经成为架构设计的结构标准。“4+1”视图主要包括：①逻辑视图(Logical View)，设计的对象模型(使用面向对象的设计方法时)。②过程视图(Process View)，捕捉设计的并发和同步特征。③物理视图(Physical View)，描述了软件到硬件的映射，反映了分布式特性。④开发视图(Development View)，描述了在开发环境中软件的静态组织结构。⑤架构的描述，即所做的各种决定，可以围绕着这四个视图来组织，然后由一些用例(Use Cases)或场景(Scenarios)来说明，从而形成了第五个视图。当采用面向对象的设计方法描述对象模型时，通常使用类图表达类的内部属性和行为，以及类集合之间的交互关系；采用状态图定义对象的内部行为。</p>",
                    "like": 0,
                    "answer": [
                        "A"
                    ],
                    "option": [
                        " 逻辑 ",
                        " 过程 ",
                        " 开发 ",
                        " 物理 "
                    ]
                },
                {
                    "index": 75,
                    "belong_page": 1,
                    "question_id": 50913,
                    "question_title": "<p>“4+1”视图主要用于描述系统逻辑架构，最早由Philippe Kruchten于1995年提出。其中（）视图用于描述对象模型，并说明系统应该为用户提供哪些服务。当采用面向对象的设计方法描述对象模型时，通常使用（作答此空）表达类的内部属性和行为，以及类集合之间的交互关系；采用（）定义对象的内部行为。</p>",
                    "question_type": 1,
                    "answer_type": 1,
                    "show_type_name": null,
                    "new_parent_id": 50913,
                    "score_rule": "",
                    "material_text": null,
                    "sort_son": "0",
                    "analyze": "<p>“4+1”视图是对逻辑架构进行描述，最早由Philippe Kruchten提出，他在1995年的IEEE Software上发表了题为The 4+1 View Model of Architecture的论文，引起了业界的极大关注，并最终被RUP采纳，现在已经成为架构设计的结构标准。“4+1”视图主要包括：①逻辑视图(Logical View)，设计的对象模型(使用面向对象的设计方法时)。②过程视图(Process View)，捕捉设计的并发和同步特征。③物理视图(Physical View)，描述了软件到硬件的映射，反映了分布式特性。④开发视图(Development View)，描述了在开发环境中软件的静态组织结构。⑤架构的描述，即所做的各种决定，可以围绕着这四个视图来组织，然后由一些用例(Use Cases)或场景(Scenarios)来说明，从而形成了第五个视图。当采用面向对象的设计方法描述对象模型时，通常使用类图表达类的内部属性和行为，以及类集合之间的交互关系；采用状态图定义对象的内部行为。</p>",
                    "like": 0,
                    "answer": [
                        "D"
                    ],
                    "option": [
                        " 对象图 ",
                        " 活动图 ",
                        " 状态图 ",
                        " 类图 "
                    ]
                },
                {
                    "index": 76,
                    "belong_page": 1,
                    "question_id": 50914,
                    "question_title": "<p>“4+1”视图主要用于描述系统逻辑架构，最早由Philippe Kruchten于1995年提出。其中（）视图用于描述对象模型，并说明系统应该为用户提供哪些服务。当采用面向对象的设计方法描述对象模型时，通常使用（）表达类的内部属性和行为，以及类集合之间的交互关系；采用（作答此空）定义对象的内部行为。</p>",
                    "question_type": 1,
                    "answer_type": 1,
                    "show_type_name": null,
                    "new_parent_id": 50914,
                    "score_rule": "",
                    "material_text": null,
                    "sort_son": "0",
                    "analyze": "<p>“4+1”视图是对逻辑架构进行描述，最早由Philippe Kruchten提出，他在1995年的IEEE Software上发表了题为The 4+1 View Model of Architecture的论文，引起了业界的极大关注，并最终被RUP采纳，现在已经成为架构设计的结构标准。“4+1”视图主要包括：①逻辑视图(Logical View)，设计的对象模型(使用面向对象的设计方法时)。②过程视图(Process View)，捕捉设计的并发和同步特征。③物理视图(Physical View)，描述了软件到硬件的映射，反映了分布式特性。④开发视图(Development View)，描述了在开发环境中软件的静态组织结构。⑤架构的描述，即所做的各种决定，可以围绕着这四个视图来组织，然后由一些用例(Use Cases)或场景(Scenarios)来说明，从而形成了第五个视图。当采用面向对象的设计方法描述对象模型时，通常使用类图表达类的内部属性和行为，以及类集合之间的交互关系；采用状态图定义对象的内部行为。</p>",
                    "like": 0,
                    "answer": [
                        "C"
                    ],
                    "option": [
                        " 对象图 ",
                        " 活动图 ",
                        " 状态图 ",
                        " 类图 "
                    ]
                },
                {
                    "index": 77,
                    "belong_page": 1,
                    "question_id": 50926,
                    "question_title": "<p>某公司欲开发一个在线交易系统，在架构设计阶段，公司的架构师识别出3个核心质量属性场景。其中“当系统面临断电故障后，需要在1小时内切换至备份站点并恢复正常运行”主要与()质量属性相关，通常可采用（）架构策略实现该属性；“在并发用户数量为1000人时，用户的交易请求需要在0.5秒内得到响应”主要与（）质量属性相关，通常可采用（）架构策略实现该属性；“对系统的消息中间件进行替换时，替换工作需要在5人/月内完成”主要与（请作答此空）质量属性相关，通常可采用（）架构策略实现该属性。</p>",
                    "question_type": 1,
                    "answer_type": 1,
                    "show_type_name": null,
                    "new_parent_id": 50926,
                    "score_rule": "",
                    "material_text": null,
                    "sort_son": "0",
                    "analyze": "<p>“当系统面临断电故障后，需要在1小时内切换至备份站点并恢复正常运行”主要与可用性质量属性相关，通常可采用心跳、Ping/Echo、主动冗余、被动冗余、选举等架构策略实现该属性；“在并发用户数量为1000人时，用户的交易请求需要在0.5秒内得到响应”，主要与性能这一质量属性相关，实现该属性的常见架构策略包括：增加计算资源、减少计算开销、引入并发机制、采用资源调度等。“对系统的消息中间件进行替换时，替换工作需要在5人/月内完成”主要与可修改性质量属性相关，通常可采用接口-实现分类、抽象、信息隐藏等架构策略实现该属性。</p>",
                    "like": 0,
                    "answer": [
                        "D"
                    ],
                    "option": [
                        " 可用性 ",
                        " 安全性 ",
                        " 可测试性 ",
                        " 可修改性 "
                    ]
                },
                {
                    "index": 78,
                    "belong_page": 1,
                    "question_id": 50927,
                    "question_title": "<p>某公司欲开发一个在线交易系统，在架构设计阶段，公司的架构师识别出3个核心质量属性场景。其中“当系统面临断电故障后，需要在1小时内切换至备份站点并恢复正常运行”主要与()质量属性相关，通常可采用（）架构策略实现该属性；“在并发用户数量为1000人时，用户的交易请求需要在0.5秒内得到响应”主要与（）质量属性相关，通常可采用（）架构策略实现该属性；“对系统的消息中间件进行替换时，替换工作需要在5人/月内完成”主要与（）质量属性相关，通常可采用（作答此空）架构策略实现该属性。</p>",
                    "question_type": 1,
                    "answer_type": 1,
                    "show_type_name": null,
                    "new_parent_id": 50927,
                    "score_rule": "",
                    "material_text": null,
                    "sort_son": "0",
                    "analyze": "<p>“当系统面临断电故障后，需要在1小时内切换至备份站点并恢复正常运行”主要与可用性质量属性相关，通常可采用心跳、Ping/Echo、主动冗余、被动冗余、选举等架构策略实现该属性；“在并发用户数量为1000人时，用户的交易请求需要在0.5秒内得到响应”，主要与性能这一质量属性相关，实现该属性的常见架构策略包括：增加计算资源、减少计算开销、引入并发机制、采用资源调度等。“对系统的消息中间件进行替换时，替换工作需要在5人/月内完成”主要与可修改性质量属性相关，通常可采用接口-实现分类、抽象、信息隐藏等架构策略实现该属性。</p>",
                    "like": 0,
                    "answer": [
                        "A"
                    ],
                    "option": [
                        " 接口-实现分离 ",
                        " 记录/回放 ",
                        " 内置监控器 ",
                        " 追踪审计 "
                    ]
                },
                {
                    "index": 79,
                    "belong_page": 1,
                    "question_id": 54188,
                    "question_title": "<p>UML用系统视图描述系统的组织结构。其中，（ &nbsp;）采用类、子系统、包和用例对系统架构进行设计建模。</p>",
                    "question_type": 1,
                    "answer_type": 1,
                    "show_type_name": null,
                    "new_parent_id": 54188,
                    "score_rule": "",
                    "material_text": null,
                    "sort_son": "0",
                    "analyze": "<p>本题考查UML的基本概念。<br/>UML利用5个系统视图描述系统的组织结构，包括系统分解的组成部分，以及它们的关联性、交互机制和指导原则等提供系统设计的信息。用例视图是最基本的需求分析模型。逻辑视图表示了设计模型中在架构方面具有重要意义的部分，即类、子系统、包和用例实现的子集。进程视图是可执行线程和进程作为活动类的建模。实现视图对组成基于系统的物理代码的文件和组件进行建模。部署视图把组件部署到一组物理节点上，表示软件到硬件的映射和分布结构。</p>",
                    "like": 0,
                    "answer": [
                        "B"
                    ],
                    "option": [
                        " 用例视图 ",
                        " 逻辑视图 ",
                        " 实现视图 ",
                        " 部署视图 "
                    ]
                },
                {
                    "index": 80,
                    "belong_page": 1,
                    "question_id": 54189,
                    "question_title": "<p>面向对象系统分析与设计中，结构图用于描述事物之间的关系，包括（请作答此空）；行为图用于描述参与者与用例之间的交互及参与者如何使用系统，包括（ &nbsp;）。</p>",
                    "question_type": 1,
                    "answer_type": 1,
                    "show_type_name": null,
                    "new_parent_id": 54189,
                    "score_rule": "",
                    "material_text": null,
                    "sort_son": "0",
                    "analyze": "<p>本题考查面向对象分析与设计的基本概念。 在UML中，有两种类型的图：结构图和行为图。结构图用来描述事物之间的关系；包括类图、对象图、组件图和部署图。行为图用来描述参与者和用例之间的交互，或者描述参与者如何使用系统；行为图包括用例图、顺序图、活动图、状态图和通信图。</p>",
                    "like": 0,
                    "answer": [
                        "C"
                    ],
                    "option": [
                        " 用例图、类图、对象图和通信图 ",
                        " 用例图、类图、对象图和部署图 ",
                        " 类图、对象图、组件图和部署图 ",
                        " 类图、对象图、组件图和通信图 "
                    ]
                },
                {
                    "index": 81,
                    "belong_page": 1,
                    "question_id": 54190,
                    "question_title": "<p>面向对象系统分析与设计中，结构图用于描述事物之间的关系，包括（ ）；行为图用于描述参与者与用例之间的交互及参与者如何使用系统，包括（请作答此空）。</p>",
                    "question_type": 1,
                    "answer_type": 1,
                    "show_type_name": null,
                    "new_parent_id": 54190,
                    "score_rule": "",
                    "material_text": null,
                    "sort_son": "0",
                    "analyze": "<p>本题考查面向对象分析与设计的基本概念。 在UML中，有两种类型的图：结构图和行为图。结构图用来描述事物之间的关系；包括类图、对象图、组件图和部署图。行为图用来描述参与者和用例之间的交互，或者描述参与者如何使用系统；行为图包括用例图、顺序图、活动图、状态图和通信图。</p>",
                    "like": 0,
                    "answer": [
                        "D"
                    ],
                    "option": [
                        " 用例图、顺序图、活动图和部署图 ",
                        " 用例图、顺序图、活动图和组件图 ",
                        " 顺序图、活动图、状态图和部署图 ",
                        " 顺序图、活动图、状态图和通信图 "
                    ]
                },
                {
                    "index": 82,
                    "belong_page": 1,
                    "question_id": 54226,
                    "question_title": "<p>&quot;置于用户控制之下&quot;是用户界面设计的&quot;黄金三原则&quot;之一。下列叙述中，不满足该原则的情形是（ &nbsp;）。</p>",
                    "question_type": 1,
                    "answer_type": 1,
                    "show_type_name": null,
                    "new_parent_id": 54226,
                    "score_rule": "",
                    "material_text": null,
                    "sort_son": "0",
                    "analyze": "<p>置于用户控制之下、减轻用户的记忆负担以及保持界面的一致性是著名用户界面设计专家Theo Mandel博士所创造，通常称之为人机交互的&quot;黄金三原则&quot;。 &quot;置于用户控制之下&quot;原则包含的内容是：在定义人机交互方式时，不强迫用户采用不是必须的或者不情愿的方式来进行操作，允许交互的中断和撤销。当用户操作技能等级提高时，可以实现流水化的交互方式，允许用户定制交互方式，以便使用户界面与内部技术细节隔离，允许用户和出现在屏幕上的对象直接进行交互。</p>",
                    "like": 0,
                    "answer": [
                        "A"
                    ],
                    "option": [
                        " 不能中断或撤销正在进行的人机交互操作 ",
                        " 不强迫用户采用不情愿的方式来进行操作 ",
                        " 用户可以定制交互方式 ",
                        " 用户可以和出现在屏幕上的对象直接进行交互 "
                    ]
                },
                {
                    "index": 83,
                    "belong_page": 1,
                    "question_id": 54227,
                    "question_title": "<p>如下UML类图表示的是（请作答此空）设计模式。以下关于该设计模式的叙述中，错误是（ &nbsp;）。<br/><img style=\"max-width:100%;height:auto\"  src=\"http://s2.51cto.com/images/20181012/1539329410547753.jpg\" title=\"1539329410547753.jpg\" alt=\"1.jpg\"/></p>",
                    "question_type": 1,
                    "answer_type": 1,
                    "show_type_name": null,
                    "new_parent_id": 54227,
                    "score_rule": "",
                    "material_text": null,
                    "sort_son": "0",
                    "analyze": "<p>本题考查面向对象方法中的设计模式知识。<br/>题中的类图是抽象工厂设计模式，该设计模式的意图是提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类。使用抽象工厂设计模式的常见情形是：一个系统要独立于其产品的创建、组合和表示时；一个系统要由多个产品系列中的一个来配置时；当需要强调一系列相关的产品对象的设计以便进行联合使用时；当提供一个产品类库，而只想显示它们的接口不是实现时。对于希望使用已经存在的类，但其接口不符合需求的情形，应当考虑适配器设计模式。</p>",
                    "like": 0,
                    "answer": [
                        "C"
                    ],
                    "option": [
                        " 工厂方法 ",
                        " 策略 ",
                        " 抽象工厂 ",
                        " 观察者 "
                    ]
                },
                {
                    "index": 84,
                    "belong_page": 1,
                    "question_id": 54228,
                    "question_title": "<p>如下UML类图表示的是（ ）设计模式。以下关于该设计模式的叙述中，错误是（请作答此空）。<br/><img style=\"max-width:100%;height:auto\"  src=\"http://s2.51cto.com/images/20181012/1539329450927674.jpg\" title=\"1539329450927674.jpg\" alt=\"1.jpg\"/></p>",
                    "question_type": 1,
                    "answer_type": 1,
                    "show_type_name": null,
                    "new_parent_id": 54228,
                    "score_rule": "",
                    "material_text": null,
                    "sort_son": "0",
                    "analyze": "<p>本题考查面向对象方法中的设计模式知识。<br/>题中的类图是抽象工厂设计模式，该设计模式的意图是提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类。使用抽象工厂设计模式的常见情形是：一个系统要独立于其产品的创建、组合和表示时；一个系统要由多个产品系列中的一个来配置时；当需要强调一系列相关的产品对象的设计以便进行联合使用时；当提供一个产品类库，而只想显示它们的接口不是实现时。对于希望使用已经存在的类，但其接口不符合需求的情形，应当考虑适配器设计模式。</p>",
                    "like": 0,
                    "answer": [
                        "D"
                    ],
                    "option": [
                        " 提供创建一系列相关或相互依赖的对象的接口，而无需指定这些对象所属的具体类 ",
                        " 可应用于一个系统要由多个产品系列中的一个来配置的时候 ",
                        " 可应用于强调一系列相关产品对象的设计以便进行联合使用的时候 ",
                        " 可应用于希望使用已经存在的类，但其接口不符合需求的时候 "
                    ]
                },
                {
                    "index": 85,
                    "belong_page": 1,
                    "question_id": 54233,
                    "question_title": "<p>系统输入设计中应尽可能考虑人的因素，以下关于输入设计的一般原理中，错误的是（ &nbsp;）。</p>",
                    "question_type": 1,
                    "answer_type": 1,
                    "show_type_name": null,
                    "new_parent_id": 54233,
                    "score_rule": "",
                    "material_text": null,
                    "sort_son": "0",
                    "analyze": "<p>本题考查应用系统输入设计的基本知识。<br/>人的因素在系统输入设计中扮演了很重要的角色。输入应该尽可能地简单，以降低错误发生的可能性，如对于范围可控的数据，使用选择的方式替代用户输入；只输入变化的数据等。输入应该尽可能使用已有含义明确的设计，需要采用模仿的方式而非创新。为了避免用户理解的二义性，应该对表格中输入的数据给出提示信息。</p>",
                    "like": 0,
                    "answer": [
                        "B"
                    ],
                    "option": [
                        " 只让用户输入变化的数据 ",
                        " 使用创新的模式吸引用户的眼球 ",
                        " 表格中各个数据项应有提示信息 ",
                        " 尽可能使用选择而不是键盘输入的方式获取数据 "
                    ]
                },
                {
                    "index": 86,
                    "belong_page": 1,
                    "question_id": 54275,
                    "question_title": "<p>UML中，序列图的基本元素包括（ &nbsp;）。</p>",
                    "question_type": 1,
                    "answer_type": 1,
                    "show_type_name": null,
                    "new_parent_id": 54275,
                    "score_rule": "",
                    "material_text": null,
                    "sort_son": "0",
                    "analyze": "<p>时序图（Sequence Diagram），亦称为序列图或循序图，是一种UML行为图。它通过描述对象之间发送消息的时间顺序显示多个对象之间的动态协作。它可以表示用例的行为顺序，当执行一个用例行为时，时序图中的每条消息对应了一个类操作或状态机中引起转换的触发事件。<br/>时序图中包括如下元素：角色，对象，生命线，激活期和消息。<br/>1、角色（Actor）<br/>系统角色，可以是人或者其他系统，子系统。<br/>2、对象（Object）<br/>对象代表时序图中的对象在交互中所扮演的角色，位于时序图顶部。<br/>对象一般包含以下三种命名方式：<br/>第一种方式包含对象名和类名。<br/>第二种方式只显示类名不显示对象名，即为一个匿名对象。<br/>第三种方式只显示对象名不显示类名。<br/>3、生命线（Lifeline）<br/>生命线代表时序图中的对象在一段时期内的存在。时序图中每个对象和底部中心都有一条垂直的虚线，这就是对象的生命线，对象间 的消息存在于两条虚线间。<br/>4、激活期（Activation）<br/>激活期代表时序图中的对象执行一项操作的时期，在时序图中每条生命线上的窄的矩形代表活动期。它可以被理解成C语言语义中一对花括号&quot;{}&quot;中的内容。<br/>5、消息（Message）<br/>消息是定义交互和协作中交换信息的类，用于对实体间的通信内容建模，信息用于在实体间传递信息。允许实体请求其他的服务，类角色通过发送和接受信息进行通信。</p>",
                    "like": 0,
                    "answer": [
                        "C"
                    ],
                    "option": [
                        " 对象、生命线和泳道 ",
                        " 对象、泳道和消息 ",
                        " 对象、生命线和消息 ",
                        " 生命线、泳道和消息 "
                    ]
                },
                {
                    "index": 87,
                    "belong_page": 1,
                    "question_id": 54276,
                    "question_title": "<p>在面向对象方法中，信息流是通过向参与者或内部对象发送消息形成的。（ &nbsp;）用于描述进出系统的信息流。</p>",
                    "question_type": 1,
                    "answer_type": 1,
                    "show_type_name": null,
                    "new_parent_id": 54276,
                    "score_rule": "",
                    "material_text": null,
                    "sort_son": "0",
                    "analyze": "<p>状态图描述了一个对象在其生命周期中可能的状态组合；顺序图用来描述对象按照时间顺序的消息流来建模用例；数据流图是一种描述数据通过系统的流程以及系统实施的工作或处理过程的过程模型；流程图以图形化的方式展示应用程序从数据输入开始到获得输出为止的逻辑过程。</p>",
                    "like": 0,
                    "answer": [
                        "B"
                    ],
                    "option": [
                        " 状态图 ",
                        " 顺序图 ",
                        " 数据流图 ",
                        " 流程图 "
                    ]
                },
                {
                    "index": 88,
                    "belong_page": 1,
                    "question_id": 54286,
                    "question_title": "<p>确定系统边界应在数据库设计的（请作答此空）阶段进行；关系规范化是在数据库设计的（ &nbsp;）阶段进行。</p>",
                    "question_type": 1,
                    "answer_type": 1,
                    "show_type_name": null,
                    "new_parent_id": 54286,
                    "score_rule": "",
                    "material_text": null,
                    "sort_son": "0",
                    "analyze": "<p>需求分析阶段的任务是：对现实世界要处理的对象（组织、部门、企业等）进行详细调查，在了解现行系统的概况，确定新系统功能的过程中，确定系统边界、收集支持系统目标的基础数据及其处理方法。<br/>逻辑设计阶段的任务之一是对关系模式进一步地规范化处理。因为生成的初始关系模式并不能完全符合要求，还会有数据冗余、更新异常存在，这就需要根据规范化理论对关系模式分解之后，消除冗余和更新异常。不过有时根据处理要求，可能还需要增加部分冗余以满足处理要求。逻辑设计阶段的任务就需要作部分关系模式的处理，分解、合并或增加冗余属性，提高存储效率和处理效率。</p>",
                    "like": 0,
                    "answer": [
                        "A"
                    ],
                    "option": [
                        " 需求分析 ",
                        " 概念设计 ",
                        " 逻辑设计 ",
                        " 物理设计 "
                    ]
                },
                {
                    "index": 89,
                    "belong_page": 1,
                    "question_id": 54287,
                    "question_title": "<p>确定系统边界应在数据库设计的（ ）阶段进行；关系规范化是在数据库设计的（请作答此空）阶段进行。</p>",
                    "question_type": 1,
                    "answer_type": 1,
                    "show_type_name": null,
                    "new_parent_id": 54287,
                    "score_rule": "",
                    "material_text": null,
                    "sort_son": "0",
                    "analyze": "<p>需求分析阶段的任务是：对现实世界要处理的对象（组织、部门、企业等）进行详细调查，在了解现行系统的概况，确定新系统功能的过程中，确定系统边界、收集支持系统目标的基础数据及其处理方法。<br/>逻辑设计阶段的任务之一是对关系模式进一步地规范化处理。因为生成的初始关系模式并不能完全符合要求，还会有数据冗余、更新异常存在，这就需要根据规范化理论对关系模式分解之后，消除冗余和更新异常。不过有时根据处理要求，可能还需要增加部分冗余以满足处理要求。逻辑设计阶段的任务就需要作部分关系模式的处理，分解、合并或增加冗余属性，提高存储效率和处理效率。</p>",
                    "like": 0,
                    "answer": [
                        "C"
                    ],
                    "option": [
                        " 需求分析 ",
                        " 概念设计 ",
                        " 逻辑设计 ",
                        " 物理设计 "
                    ]
                },
                {
                    "index": 90,
                    "belong_page": 1,
                    "question_id": 54307,
                    "question_title": "<p>某服务器软件系统对可用性（Availability）和性能（Performance）要求较高，（请作答此空）设计策略能提高该系统的可用性，（ &nbsp;）设计策略能够提高该系统的性能。</p>",
                    "question_type": 1,
                    "answer_type": 1,
                    "show_type_name": null,
                    "new_parent_id": 54307,
                    "score_rule": "",
                    "material_text": null,
                    "sort_son": "0",
                    "analyze": "<p>软件质量属性描述了软件的非功能性属性。可用性质量属性描述了可用性是系统能够正常运行的时间比例，实现可用性策略的主要方法有错误检测、错误恢复和错误防御。主动冗余就是一种错误恢复的策略。性能是指系统的响应能力，即要经过多长时间才能对某个事件做出响应，或者在某段时间内系统所能处理事件的个数。队列调度是一种提升系统性能的常用方法。</p>",
                    "like": 0,
                    "answer": [
                        "C"
                    ],
                    "option": [
                        " 限制访问 ",
                        " 内置监控器 ",
                        " 主动冗余 ",
                        " 队列调度 "
                    ]
                },
                {
                    "index": 91,
                    "belong_page": 1,
                    "question_id": 54310,
                    "question_title": "<p>某软件公司正在承担开发一个字处理器的任务。在需求分析阶段，公司的相关人员整理出一些相关的系统需求，其中，&quot;找出文档中的拼写错误并提供一个替换项列表来供选择替换拼错的词&quot;属于（请作答此空）；&quot;显示提供替换词的对话框以及实现整个文档范围的替换&quot;属于（ &nbsp;）；&quot;用户能有效地纠正文档中的拼写错误&quot;属于（ &nbsp;）。</p>",
                    "question_type": 1,
                    "answer_type": 1,
                    "show_type_name": null,
                    "new_parent_id": 54310,
                    "score_rule": "",
                    "material_text": null,
                    "sort_son": "0",
                    "analyze": "<p>本题主要考查需求分析及分类知识。软件需求包括三个不同的层次：业务需求、用户需求和功能需求。业务需求反映了组织机构或客户对系统、产品高层次的目标要求，它们在项目视图与范围文档中予以说明。用户需求描述了用户使用产品必须要完成的任务，这在用例文档或方案脚本说明中予以说明。功能需求定义了开发人员必须实现的软件功能，使得用户能完成他们的任务，从而满足了业务需求。<br/>以题干中字处理程序为例，&quot;用户能有效地纠正文档中的拼写错误&quot;是业务需求，因为该产品的包装盒封面上可能会标明这是个满足业务需求的拼写检查器。而对应的用户需求则是&quot;找出文档中的拼写错误并通过一个提供的替换项列表来供选择替换拼错的词&quot;。同时，该拼写检查器还有许多功能需求，如找到并高亮度提示错词的操作；显示提供替换词的对话框以及实现整个文档范围的替换。</p>",
                    "like": 0,
                    "answer": [
                        "B"
                    ],
                    "option": [
                        " 业务需求 ",
                        " 用户需求 ",
                        " 功能需求 ",
                        " 性能需求 "
                    ]
                },
                {
                    "index": 92,
                    "belong_page": 1,
                    "question_id": 54311,
                    "question_title": "<p>某软件公司正在承担开发一个字处理器的任务。在需求分析阶段，公司的相关人员整理出一些相关的系统需求，其中，&quot;找出文档中的拼写错误并提供一个替换项列表来供选择替换拼错的词&quot;属于（ ）；&quot;显示提供替换词的对话框以及实现整个文档范围的替换&quot;属于（请作答此空）；&quot;用户能有效地纠正文档中的拼写错误&quot;属于（ &nbsp;）。</p>",
                    "question_type": 1,
                    "answer_type": 1,
                    "show_type_name": null,
                    "new_parent_id": 54311,
                    "score_rule": "",
                    "material_text": null,
                    "sort_son": "0",
                    "analyze": "<p>本题主要考查需求分析及分类知识。软件需求包括三个不同的层次：业务需求、用户需求和功能需求。业务需求反映了组织机构或客户对系统、产品高层次的目标要求，它们在项目视图与范围文档中予以说明。用户需求描述了用户使用产品必须要完成的任务，这在用例文档或方案脚本说明中予以说明。功能需求定义了开发人员必须实现的软件功能，使得用户能完成他们的任务，从而满足了业务需求。<br/>以题干中字处理程序为例，&quot;用户能有效地纠正文档中的拼写错误&quot;是业务需求，因为该产品的包装盒封面上可能会标明这是个满足业务需求的拼写检查器。而对应的用户需求则是&quot;找出文档中的拼写错误并通过一个提供的替换项列表来供选择替换拼错的词&quot;。同时，该拼写检查器还有许多功能需求，如找到并高亮度提示错词的操作；显示提供替换词的对话框以及实现整个文档范围的替换。</p>",
                    "like": 0,
                    "answer": [
                        "C"
                    ],
                    "option": [
                        " 业务需求 ",
                        " 用户需求 ",
                        " 功能需求 ",
                        " 性能需求 "
                    ]
                },
                {
                    "index": 93,
                    "belong_page": 1,
                    "question_id": 54312,
                    "question_title": "<p>某软件公司正在承担开发一个字处理器的任务。在需求分析阶段，公司的相关人员整理出一些相关的系统需求，其中，&quot;找出文档中的拼写错误并提供一个替换项列表来供选择替换拼错的词&quot;属于（ ）；&quot;显示提供替换词的对话框以及实现整个文档范围的替换&quot;属于（ ）；&quot;用户能有效地纠正文档中的拼写错误&quot;属于（请作答此空）。</p>",
                    "question_type": 1,
                    "answer_type": 1,
                    "show_type_name": null,
                    "new_parent_id": 54312,
                    "score_rule": "",
                    "material_text": null,
                    "sort_son": "0",
                    "analyze": "<p>本题主要考查需求分析及分类知识。软件需求包括三个不同的层次：业务需求、用户需求和功能需求。业务需求反映了组织机构或客户对系统、产品高层次的目标要求，它们在项目视图与范围文档中予以说明。用户需求描述了用户使用产品必须要完成的任务，这在用例文档或方案脚本说明中予以说明。功能需求定义了开发人员必须实现的软件功能，使得用户能完成他们的任务，从而满足了业务需求。<br/>以题干中字处理程序为例，&quot;用户能有效地纠正文档中的拼写错误&quot;是业务需求，因为该产品的包装盒封面上可能会标明这是个满足业务需求的拼写检查器。而对应的用户需求则是&quot;找出文档中的拼写错误并通过一个提供的替换项列表来供选择替换拼错的词&quot;。同时，该拼写检查器还有许多功能需求，如找到并高亮度提示错词的操作；显示提供替换词的对话框以及实现整个文档范围的替换。</p>",
                    "like": 0,
                    "answer": [
                        "A"
                    ],
                    "option": [
                        " 业务需求 ",
                        " 用户需求 ",
                        " 功能需求 ",
                        " 性能需求 "
                    ]
                },
                {
                    "index": 94,
                    "belong_page": 1,
                    "question_id": 54323,
                    "question_title": "<p>软件需求可以分为几个类型，诸如处理速度、存储容量、信号速度等方面的需求属于（ ）。</p>",
                    "question_type": 1,
                    "answer_type": 1,
                    "show_type_name": null,
                    "new_parent_id": 54323,
                    "score_rule": "",
                    "material_text": null,
                    "sort_son": "0",
                    "analyze": "<p>软件需求指系统必须完成的事，以及必须具备的品质。主要包括如下3种：<br/>功能需求：系统必须完成的那些事，即为了向它的用户提供有用的功能，产品必须执行的动作；<br/>非功能需求：产品必须具备的属性或品质，如可靠性、性能、响应时间、容错性、扩展性等；<br/>设计约束：指限制条件和补充规定。</p>",
                    "like": 0,
                    "answer": [
                        "B"
                    ],
                    "option": [
                        " 功能需求 ",
                        " 性能需求 ",
                        " 外部接口需求 ",
                        " 设计约束 "
                    ]
                },
                {
                    "index": 95,
                    "belong_page": 1,
                    "question_id": 54324,
                    "question_title": "<p>Philippe kruchten提出的4+1视图模型从（ ）几个方面来描述软件需求。<br/>①逻辑视图 &nbsp;②进程视图 &nbsp;③物理视图 &nbsp;④开发视图 &nbsp;⑤数据流视图 &nbsp;⑥场景视图</p>",
                    "question_type": 1,
                    "answer_type": 1,
                    "show_type_name": null,
                    "new_parent_id": 54324,
                    "score_rule": "",
                    "material_text": null,
                    "sort_son": "0",
                    "analyze": "<p>4+1视图模型从五个不同的视角来描述软件体系结构，每个视角只关心系统的一个侧面，五个视角结合在一起才能反映软件体系结构的全部内容。这五个视角分别为：<br/>1. 逻辑视图：主要支持系统的功能需求，它直接面向最终用户；<br/>2. 开发视图：主要支持软件模块的组织和管理，它直接面向编程人员；<br/>3. 进程视图：主要关注一些非功能性的需求，如系统的性能和可用性等，它直接面向系统集成人员；<br/>4. 物理视图：主要关注如何把软件映射到硬件上，通常要解决系统的拓扑结构、系统安装、通信等问题，它直接而向系统工程人员；<br/>5. 场景视图：是重要系统活动的抽象描述，可以使上述四个视图有机联系起来，可认为是最重要的需求抽象。<br/>其中，逻辑视图、开发视图描述系统的静态结构，进程视图和物理视图描述系统的动态结构。</p>",
                    "like": 0,
                    "answer": [
                        "C"
                    ],
                    "option": [
                        " ③④⑤⑥ ",
                        " ①②③④ ",
                        " ①②③④⑥ ",
                        " ①③④⑤⑥ "
                    ]
                },
                {
                    "index": 96,
                    "belong_page": 1,
                    "question_id": 54335,
                    "question_title": "<p>（请作答此空）的选择是开发一个软件系统时的基本设计决策；（ &nbsp;）是最低层的模式，关注软件系统的设计与实现，描述了如何实现构件及构件之间的关系。引用一计数是C++管理动态资源时常用的一种（ &nbsp;）。</p>",
                    "question_type": 1,
                    "answer_type": 1,
                    "show_type_name": null,
                    "new_parent_id": 54335,
                    "score_rule": "",
                    "material_text": null,
                    "sort_son": "0",
                    "analyze": "<p>本题考查软件设计中使用的架构模式、设计模式和惯用法的基本概念。<br/>架构模式是软件设计中的高层决策，例如C/S结构就属于架构模式，架构模式反映了开发软件系统过程中所作的基本设计决策；设计模式主要关注软件系统的设计，与具体的实现语言无关：惯用法则是实现时通过某种特定的程序设计语言来描述构件与构件之间的关系，例如引用-计数就是C++语言中的一种惯用法。</p>",
                    "like": 0,
                    "answer": [
                        "A"
                    ],
                    "option": [
                        " 架构模式 ",
                        " 惯用法 ",
                        " 设计模式 ",
                        " 分析模式 "
                    ]
                },
                {
                    "index": 97,
                    "belong_page": 1,
                    "question_id": 54337,
                    "question_title": "<p>（ ）的选择是开发一个软件系统时的基本设计决策；（ ）是最低层的模式，关注软件系统的设计与实现，描述了如何实现构件及构件之间的关系。引用一计数是C++管理动态资源时常用的一种（请作答此空）。</p>",
                    "question_type": 1,
                    "answer_type": 1,
                    "show_type_name": null,
                    "new_parent_id": 54337,
                    "score_rule": "",
                    "material_text": null,
                    "sort_son": "0",
                    "analyze": "<p>本题考查软件设计中使用的架构模式、设计模式和惯用法的基本概念。<br/>架构模式是软件设计中的高层决策，例如C/S结构就属于架构模式，架构模式反映了开发软件系统过程中所作的基本设计决策；设计模式主要关注软件系统的设计，与具体的实现语言无关：惯用法则是实现时通过某种特定的程序设计语言来描述构件与构件之间的关系，例如引用-计数就是C++语言中的一种惯用法。</p>",
                    "like": 0,
                    "answer": [
                        "B"
                    ],
                    "option": [
                        " 架构模式 ",
                        " 惯用法 ",
                        " 设计模式 ",
                        " 分析模式 "
                    ]
                },
                {
                    "index": 98,
                    "belong_page": 1,
                    "question_id": 54349,
                    "question_title": "<p>System analysis is traditionally done top-down using structured analysis based on （请作答此空）. Object-oriented analysis focuses on creation of models. The three types of theanalysis model are（ &nbsp;）. There are two substages of object-oriented analysis.（ &nbsp;）focuses on real-world things whose semantics the application captures. The object constructedin the requirement analysis shows the（ &nbsp;）of the real-world system and organizes it intoworkable pieces.（ &nbsp;）addresses the computer aspects of the application that are visible tousers. The objects are those which can be expected to vary from time to time quite rapidly.</p>",
                    "question_type": 1,
                    "answer_type": 1,
                    "show_type_name": null,
                    "new_parent_id": 54349,
                    "score_rule": "",
                    "material_text": null,
                    "sort_son": "0",
                    "analyze": "<p>传统的系统分析以功能分解为基础，利用结构化分析自顶向下完成。面向对象分析关注于模型的创建。该分析模型有三种类型：类模型、交互模型和状态模型。面向对象分析有两个子阶段。领域分析侧重于现实世界中那些语义被应用程序获取的事物。在需求分析中所构造的对象说明了现实世界系统的静态结构并将其组织为可用的片段。应用分析处理应用系统中用户可见的计算机问题。所分析的对象可能会被预计时不时地发生较快的变化。</p>",
                    "like": 0,
                    "answer": [
                        "A"
                    ],
                    "option": [
                        " functional decomposition ",
                        " object abstraction ",
                        " data inheritance ",
                        " information generalization "
                    ]
                },
                {
                    "index": 99,
                    "belong_page": 1,
                    "question_id": 54350,
                    "question_title": "<p>System analysis is traditionally done top-down using structured analysis based on（ ）. Object-oriented analysis focuses on creation of models. The three types of theanalysis model are（请作答此空）. There are two substages of object-oriented analysis.（ ）focuses on real-world things whose semantics the application captures. The object constructedin the requirement analysis shows the（ &nbsp;）of the real-world system and organizes it intoworkable pieces.（ &nbsp;）addresses the computer aspects of the application that are visible tousers. The objects are those which can be expected to vary from time to time quite rapidly.</p>",
                    "question_type": 1,
                    "answer_type": 1,
                    "show_type_name": null,
                    "new_parent_id": 54350,
                    "score_rule": "",
                    "material_text": null,
                    "sort_son": "0",
                    "analyze": "<p>传统的系统分析以功能分解为基础，利用结构化分析自顶向下完成。面向对象分析关注于模型的创建。该分析模型有三种类型：类模型、交互模型和状态模型。面向对象分析有两个子阶段。领域分析侧重于现实世界中那些语义被应用程序获取的事物。在需求分析中所构造的对象说明了现实世界系统的静态结构并将其组织为可用的片段。应用分析处理应用系统中用户可见的计算机问题。所分析的对象可能会被预计时不时地发生较快的变化。</p>",
                    "like": 0,
                    "answer": [
                        "B"
                    ],
                    "option": [
                        " function model，class model and state model ",
                        " class model，interaction model and state model ",
                        " class model，interaction model and sequence model ",
                        " function model，interaction model and state model "
                    ]
                },
                {
                    "index": 100,
                    "belong_page": 1,
                    "question_id": 54351,
                    "question_title": "<p>System analysis is traditionally done top-down using structured analysis based on（ ）. Object-oriented analysis focuses on creation of models. The three types of theanalysis model are（ &nbsp;）. There are two substages of object-oriented analysis.（请作答此空） focuses on real-world things whose semantics the application captures. The object constructedin the requirement analysis shows the（ &nbsp;）of the real-world system and organizes it intoworkable pieces.（ &nbsp;）addresses the computer aspects of the application that are visible tousers. The objects are those which can be expected to vary from time to time quite rapidly.</p>",
                    "question_type": 1,
                    "answer_type": 1,
                    "show_type_name": null,
                    "new_parent_id": 54351,
                    "score_rule": "",
                    "material_text": null,
                    "sort_son": "0",
                    "analyze": "<p>传统的系统分析以功能分解为基础，利用结构化分析自顶向下完成。面向对象分析关注于模型的创建。该分析模型有三种类型：类模型、交互模型和状态模型。面向对象分析有两个子阶段。领域分析侧重于现实世界中那些语义被应用程序获取的事物。在需求分析中所构造的对象说明了现实世界系统的静态结构并将其组织为可用的片段。应用分析处理应用系统中用户可见的计算机问题。所分析的对象可能会被预计时不时地发生较快的变化。</p>",
                    "like": 0,
                    "answer": [
                        "D"
                    ],
                    "option": [
                        " Static analysis ",
                        " Semantic analysis ",
                        " Scope analysis ",
                        " Domain analysis "
                    ]
                },
                {
                    "index": 101,
                    "belong_page": 1,
                    "question_id": 54352,
                    "question_title": "<p>System analysis is traditionally done top-down using structured analysis based on（ ）. Object-oriented analysis focuses on creation of models. The three types of theanalysis model are（ &nbsp;）. There are two substages of object-oriented analysis.（ ） focuses on real-world things whose semantics the application captures. The object constructedin the requirement analysis shows the（请作答此空）of the real-world system and organizes it intoworkable pieces.（ &nbsp;）addresses the computer aspects of the application that are visible tousers. The objects are those which can be expected to vary from time to time quite rapidly.</p>",
                    "question_type": 1,
                    "answer_type": 1,
                    "show_type_name": null,
                    "new_parent_id": 54352,
                    "score_rule": "",
                    "material_text": null,
                    "sort_son": "0",
                    "analyze": "<p>传统的系统分析以功能分解为基础，利用结构化分析自顶向下完成。面向对象分析关注于模型的创建。该分析模型有三种类型：类模型、交互模型和状态模型。面向对象分析有两个子阶段。领域分析侧重于现实世界中那些语义被应用程序获取的事物。在需求分析中所构造的对象说明了现实世界系统的静态结构并将其组织为可用的片段。应用分析处理应用系统中用户可见的计算机问题。所分析的对象可能会被预计时不时地发生较快的变化。</p>",
                    "like": 0,
                    "answer": [
                        "A"
                    ],
                    "option": [
                        " static structure ",
                        " system components ",
                        " data flows ",
                        " program procedures "
                    ]
                },
                {
                    "index": 102,
                    "belong_page": 1,
                    "question_id": 54353,
                    "question_title": "<p>System analysis is traditionally done top-down using structured analysis based on（ ）. Object-oriented analysis focuses on creation of models. The three types of theanalysis model are（ &nbsp;）. There are two substages of object-oriented analysis.（ ） focuses on real-world things whose semantics the application captures. The object constructedin the requirement analysis shows the（ ）of the real-world system and organizes it intoworkable pieces.（请作答此空）addresses the computer aspects of the application that are visible tousers. The objects are those which can be expected to vary from time to time quite rapidly.</p>",
                    "question_type": 1,
                    "answer_type": 1,
                    "show_type_name": null,
                    "new_parent_id": 54353,
                    "score_rule": "",
                    "material_text": null,
                    "sort_son": "0",
                    "analyze": "<p>传统的系统分析以功能分解为基础，利用结构化分析自顶向下完成。面向对象分析关注于模型的创建。该分析模型有三种类型：类模型、交互模型和状态模型。面向对象分析有两个子阶段。领域分析侧重于现实世界中那些语义被应用程序获取的事物。在需求分析中所构造的对象说明了现实世界系统的静态结构并将其组织为可用的片段。应用分析处理应用系统中用户可见的计算机问题。所分析的对象可能会被预计时不时地发生较快的变化。</p>",
                    "like": 0,
                    "answer": [
                        "C"
                    ],
                    "option": [
                        " Program analysis ",
                        " Function requirement ",
                        " Application analysis ",
                        " Physical model "
                    ]
                },
                {
                    "index": 103,
                    "belong_page": 1,
                    "question_id": 63636,
                    "question_title": "<p>软件概要设计包括设计软件的结构、确定系统功能模块及其相互关系，主要采用（　）描述程序的结构。</p>",
                    "question_type": 1,
                    "answer_type": 1,
                    "show_type_name": null,
                    "new_parent_id": 63636,
                    "score_rule": "",
                    "material_text": null,
                    "sort_son": "0",
                    "analyze": "<p>题目选项所列举的图与开发阶段的对应关系为：</p><p>1、需求分析阶段：数据流图。</p><p>2、概要设计阶段：模块结构图、层次图和HIPO图。</p><p>3、详细设计阶段：程序流程图、伪代码、盒图。</p>",
                    "like": 0,
                    "answer": [
                        "C"
                    ],
                    "option": [
                        " 程序流程图、PAD图和伪代码 ",
                        " 模块结构图、数据流图和盒图 ",
                        " 模块结构图、层次图和HIPO图 ",
                        " 程序流程图、 数据流图和层次图 "
                    ]
                },
                {
                    "index": 104,
                    "belong_page": 1,
                    "question_id": 63667,
                    "question_title": "<p>某公司欲开发一个大型多人即时战略游戏，游戏设计的目标之一是能够支持玩家自行创建战役地图，定义游戏对象的行为和对象之间的关系。针对该需求，公司应该采用（　）架构风格最为合适。在架构设计阶段，公司的架构师识别出2个核心质量属性场景。其中，“在并发用户数量为10000人时，用户的请求需要在1秒内得到响应”主要与（请作答此空）质量属性相关；“对游戏系统进行二次开发的时间不超过3个月”主要与（　）质量属性相关。</p>",
                    "question_type": 1,
                    "answer_type": 1,
                    "show_type_name": null,
                    "new_parent_id": 63667,
                    "score_rule": "",
                    "material_text": null,
                    "sort_son": "0",
                    "analyze": "<p>本题是极为经典的考题。题目中提及“支持玩家自行创建战役地图”这说明系统要能应对“自定义”内容的解析，这需要用到解释器风格。“并发用户数量10000人时用户请求要在1秒内得到响应”属于典型的性能属性，“对游戏系统进行二次开发的时间不超过3个月”属于可修改性属性。</p>",
                    "like": 0,
                    "answer": [
                        "A"
                    ],
                    "option": [
                        " 性能 ",
                        " 吞吐量 ",
                        " 可靠性 ",
                        " 可修改性 "
                    ]
                },
                {
                    "index": 105,
                    "belong_page": 1,
                    "question_id": 63669,
                    "question_title": "<p>设计模式描述了一个出现在特定设计语境中的设计再现问题，并为它的解决方案提供了一个经过充分验证的通用方案，不同的设计模式关注解决不同的问题。例如，抽象工厂模式提供一个接口，可以创建一系列相关或相互依赖的对象， 而无需指定它们具体的类，它是一种（请作答此空）模式；（　）模式将类的抽象部分和它的实现部分分离出来，使它们可以独立变化，它属于（　）模式；（　）模式将一个请求封装为一个对象，从而可用不同的请求对客户进行参数化，将请求排队或记录请求日志，支持可撤销的操作。</p>",
                    "question_type": 1,
                    "answer_type": 1,
                    "show_type_name": null,
                    "new_parent_id": 63669,
                    "score_rule": "",
                    "material_text": null,
                    "sort_son": "0",
                    "analyze": "<p>设计模式包括：创建型、结构型、行为型三大类别。</p><p>抽象工厂模式属于创建型设计模式。</p><p>桥接模式属于结构型设计模式。</p>",
                    "like": 0,
                    "answer": [
                        "D"
                    ],
                    "option": [
                        " 组合型 ",
                        " 结构型 ",
                        " 行为型 ",
                        " 创建型 "
                    ]
                },
                {
                    "index": 106,
                    "belong_page": 1,
                    "question_id": 63671,
                    "question_title": "<p>设计模式描述了一个出现在特定设计语境中的设计再现问题，并为它的解决方案提供了一个经过充分验证的通用方案，不同的设计模式关注解决不同的问题。例如，抽象工厂模式提供一个接口，可以创建一系列相关或相互依赖的对象， 而无需指定它们具体的类，它是一种（　）模式；（请作答此空）模式将类的抽象部分和它的实现部分分离出来，使它们可以独立变化，它属于（　）模式；（　）模式将一个请求封装为一个对象，从而可用不同的请求对客户进行参数化，将请求排队或记录请求日志，支持可撤销的操作。</p>",
                    "question_type": 1,
                    "answer_type": 1,
                    "show_type_name": null,
                    "new_parent_id": 63671,
                    "score_rule": "",
                    "material_text": null,
                    "sort_son": "0",
                    "analyze": "<p>设计模式包括：创建型、结构型、行为型三大类别。</p><p>抽象工厂模式属于创建型设计模式。</p><p>桥接模式属于结构型设计模式。</p>",
                    "like": 0,
                    "answer": [
                        "A"
                    ],
                    "option": [
                        " Bridge ",
                        " Proxy ",
                        " Prototype ",
                        " Adapter "
                    ]
                },
                {
                    "index": 107,
                    "belong_page": 1,
                    "question_id": 63673,
                    "question_title": "<p>设计模式描述了一个出现在特定设计语境中的设计再现问题，并为它的解决方案提供了一个经过充分验证的通用方案，不同的设计模式关注解决不同的问题。例如，抽象工厂模式提供一个接口，可以创建一系列相关或相互依赖的对象， 而无需指定它们具体的类，它是一种（　）模式；（　）模式将类的抽象部分和它的实现部分分离出来，使它们可以独立变化，它属于（请作答此空）模式；（　）模式将一个请求封装为一个对象，从而可用不同的请求对客户进行参数化，将请求排队或记录请求日志，支持可撤销的操作。</p>",
                    "question_type": 1,
                    "answer_type": 1,
                    "show_type_name": null,
                    "new_parent_id": 63673,
                    "score_rule": "",
                    "material_text": null,
                    "sort_son": "0",
                    "analyze": "<p>设计模式包括：创建型、结构型、行为型三大类别。</p><p>抽象工厂模式属于创建型设计模式。</p><p>桥接模式属于结构型设计模式。</p>",
                    "like": 0,
                    "answer": [
                        "B"
                    ],
                    "option": [
                        " 组合型 ",
                        " 结构型 ",
                        " 行为型 ",
                        " 创建型 "
                    ]
                },
                {
                    "index": 108,
                    "belong_page": 1,
                    "question_id": 63674,
                    "question_title": "<p>设计模式描述了一个出现在特定设计语境中的设计再现问题，并为它的解决方案提供了一个经过充分验证的通用方案，不同的设计模式关注解决不同的问题。例如，抽象工厂模式提供一个接口，可以创建一系列相关或相互依赖的对象， 而无需指定它们具体的类，它是一种（　）模式；（　）模式将类的抽象部分和它的实现部分分离出来，使它们可以独立变化，它属于（　）模式；（请作答此空）模式将一个请求封装为一个对象，从而可用不同的请求对客户进行参数化，将请求排队或记录请求日志，支持可撤销的操作。</p>",
                    "question_type": 1,
                    "answer_type": 1,
                    "show_type_name": null,
                    "new_parent_id": 63674,
                    "score_rule": "",
                    "material_text": null,
                    "sort_son": "0",
                    "analyze": "<p>设计模式包括：创建型、结构型、行为型三大类别。</p><p>抽象工厂模式属于创建型设计模式。</p><p>桥接模式属于结构型设计模式。</p>",
                    "like": 0,
                    "answer": [
                        "A"
                    ],
                    "option": [
                        " Command ",
                        " Facade ",
                        " Memento ",
                        " Visitor "
                    ]
                },
                {
                    "index": 109,
                    "belong_page": 1,
                    "question_id": 103112,
                    "question_title": "面向对象分析中，一个事物发生变化会影响另一个事物，两个事物之间属于（ ）",
                    "question_type": 1,
                    "answer_type": 1,
                    "show_type_name": null,
                    "new_parent_id": 103112,
                    "score_rule": "",
                    "material_text": null,
                    "sort_son": "0",
                    "analyze": "<p>此题考查面向对象类之间的关系，类之间的主要关系有关联、依赖、泛化、聚合、组合和实现等。</p><p>（1）关联关系。关联提供了不同类的对象之问的结构关系，它在一段时间内将多个类的实例连接在一起。</p><p>（2）依赖关系。两个类A和B，如果B的变化可能会引起A的变化，则称类A依赖于类B。</p><p>（3）泛化关系。泛化关系描述了一般事物与该事物中的特殊种类之间的关系，也就是父类与子类之间的关系。继承关系是泛化关系的反关系，也就是说，子类继承了父类，而父类则是子类的泛化。</p><p>（4）共享聚集。共享聚集关系通常简称为聚合关系，它表示类之间的整体与部分的关系，其含义是“部分”可能同时属于多个“整体”，“部分”与“整体”的生命周期可以不相同。例如，汽车和车轮就是聚合关系，车子坏了，车轮还可以用；车轮坏了，可以再换一个。</p><p>（5）组合聚集。组合聚集关系通常简称为组合关系，它也是表示类之间的整体与部分的关系。与聚合关系的区别在于，组合关系中的“部分”只能属于一个“整体”，“部分”与“整体”的生命周期相同，“部分”随着“整体”的创建而创建，也随着“整体”的消亡而消亡。例如，一个公司包含多个部门，它们之间的关系就是组合关系。公司一旦倒闭，也就无所谓部门了。</p><p>（6）实现关系。实现关系将说明和实现联系起来。接口是对行为而非实现的说明，而类中则包含了实现的结构。一个或多个类可以实现一个接口，而每个类分别实现接口中的操作。</p>",
                    "like": 0,
                    "answer": [
                        "B"
                    ],
                    "option": [
                        " 关联关系 ",
                        " 依赖关系 ",
                        " 实现关系 ",
                        " 泛化关系 "
                    ]
                },
                {
                    "index": 110,
                    "belong_page": 1,
                    "question_id": 103113,
                    "question_title": "在线学习系统中，课程学习和课程考试都需要先检查学员的权限，“课程学习”与“检查权限”两个用例之间属于(请作答此空)课程学习过程中，如果所缴纳学费不够，就需要补缴学费，“课程学习”与“缴纳学费”两个用例之间属于( &nbsp;);课程学习前需要课程注册，可以采用电话注册或网络注册，“课程注册”与“网络注册”两个用例之间属于( &nbsp;)。",
                    "question_type": 1,
                    "answer_type": 1,
                    "show_type_name": null,
                    "new_parent_id": 103113,
                    "score_rule": "",
                    "material_text": null,
                    "sort_son": "0",
                    "analyze": "<p>此题考查用例之间的关系，题目几乎完全与教程上的例子雷同。</p><p>用例之间的关系主要有包含、扩展和泛化三类。</p><p>（1）包含关系。当可以从两个或两个以上的用例中提取公共行为时，应该使用包含关系来表示它们。“课程学习”与“检查权限”是包含关系。</p><p>（2）扩展关系。如果一个用例明显地混合了两种或两种以上的不同场景，即根据情况可能发生多种分支，则可以将这个用例分为一个基本用例和一个或多个扩展用例，这样使描述可能更加清晰。“课程学习”与“缴纳学费”是扩展关系。</p><p>（3）泛化关系。当多个用例共同拥有一种类似的结构和行为的时候，可以将它们的共性抽象成为父用例，其他的用例作为泛化关系中的子用例。“课程注册”与“网络注册”是泛化关系。</p>",
                    "like": 0,
                    "answer": [
                        "A"
                    ],
                    "option": [
                        " 包含关系 ",
                        " 扩展关系 ",
                        " 泛化关系 ",
                        " 关联关系 "
                    ]
                },
                {
                    "index": 111,
                    "belong_page": 1,
                    "question_id": 103114,
                    "question_title": "<p>在线学习系统中，课程学习和课程考试都需要先检查学员的权限，“课程学习”与“检查权限”两个用例之间属于( )课程学习过程中，如果所缴纳学费不够，就需要补缴学费，“课程学习”与“缴纳学费”两个用例之间属于（请作答此空）；课程学习前需要课程注册，可以采用电话注册或网络注册，“课程注册”与“网络注册”两个用例之间属于( &nbsp;)。</p>",
                    "question_type": 1,
                    "answer_type": 1,
                    "show_type_name": null,
                    "new_parent_id": 103114,
                    "score_rule": "",
                    "material_text": null,
                    "sort_son": "0",
                    "analyze": "<p>此题考查用例之间的关系，题目几乎完全与教程上的例子雷同。</p><p>用例之间的关系主要有包含、扩展和泛化三类。</p><p>（1）包含关系。当可以从两个或两个以上的用例中提取公共行为时，应该使用包含关系来表示它们。“课程学习”与“检查权限”是包含关系。</p><p>（2）扩展关系。如果一个用例明显地混合了两种或两种以上的不同场景，即根据情况可能发生多种分支，则可以将这个用例分为一个基本用例和一个或多个扩展用例，这样使描述可能更加清晰。“课程学习”与“缴纳学费”是扩展关系。</p><p>（3）泛化关系。当多个用例共同拥有一种类似的结构和行为的时候，可以将它们的共性抽象成为父用例，其他的用例作为泛化关系中的子用例。“课程注册”与“网络注册”是泛化关系。</p>",
                    "like": 0,
                    "answer": [
                        "B"
                    ],
                    "option": [
                        " 包含关系 ",
                        " 扩展关系 ",
                        " 泛化关系 ",
                        " 关联关系 "
                    ]
                },
                {
                    "index": 112,
                    "belong_page": 1,
                    "question_id": 103115,
                    "question_title": "在线学习系统中，课程学习和课程考试都需要先检查学员的权限，“课程学习”与“检查权限”两个用例之间属于( )课程学习过程中，如果所缴纳学费不够，就需要补缴学费，“课程学习”与“缴纳学费”两个用例之间属于( );课程学习前需要课程注册，可以采用电话注册或网络注册，“课程注册”与“网络注册”两个用例之间属于(请作答此空)。",
                    "question_type": 1,
                    "answer_type": 1,
                    "show_type_name": null,
                    "new_parent_id": 103115,
                    "score_rule": "",
                    "material_text": null,
                    "sort_son": "0",
                    "analyze": "<p>此题考查用例之间的关系，题目几乎完全与教程上的例子雷同。</p><p>用例之间的关系主要有包含、扩展和泛化三类。</p><p>（1）包含关系。当可以从两个或两个以上的用例中提取公共行为时，应该使用包含关系来表示它们。“课程学习”与“检查权限”是包含关系。</p><p>（2）扩展关系。如果一个用例明显地混合了两种或两种以上的不同场景，即根据情况可能发生多种分支，则可以将这个用例分为一个基本用例和一个或多个扩展用例，这样使描述可能更加清晰。“课程学习”与“缴纳学费”是扩展关系。</p><p>（3）泛化关系。当多个用例共同拥有一种类似的结构和行为的时候，可以将它们的共性抽象成为父用例，其他的用例作为泛化关系中的子用例。“课程注册”与“网络注册”是泛化关系。</p>",
                    "like": 0,
                    "answer": [
                        "C"
                    ],
                    "option": [
                        " 包含关系 ",
                        " 扩展关系 ",
                        " 泛化关系 ",
                        " 关联关系 "
                    ]
                },
                {
                    "index": 113,
                    "belong_page": 1,
                    "question_id": 103116,
                    "question_title": "以下设计模式中，（请作答此空）模式使多个对象都有机会处理请求。将这些对象连成一条链。并沿着这条链传递该请求。直到有一个对象处理为止。从而避免请求的发送者和接收者之间的耦合关系。（）模式提供一种方法顺序访问一个聚合对象中的各个元素。且不需要暴露该对象的内部表示。这两种模式均为（）",
                    "question_type": 1,
                    "answer_type": 1,
                    "show_type_name": null,
                    "new_parent_id": 103116,
                    "score_rule": "",
                    "material_text": null,
                    "sort_son": "0",
                    "analyze": "<p>责任链模式：通过给多个对象处理请求的机会，减少请求的发送者与接受者之间的耦合。将接收对象链接起来，在链中传递请求，直到有一个对象处理这个请求。</p><p>迭代器模式：提供一种方法来顺序访问一个聚合对象中的各个元素，而不需要暴露该对象的内部表示</p><p>命令模式：将一个请求封装为一个对象，从而可用不同的请求对客户进行参数化，将请求排队或记录请求日志，支持可撤销的操作</p><p>解释器模式：给定一种语言，定义它的文法表示，并定义一个解释器，该解释器用来根据文法表示来解释语言中的句子</p><p>责任链模式和迭代器模式都是行为型对象模式</p>",
                    "like": 0,
                    "answer": [
                        "A"
                    ],
                    "option": [
                        " 责任链。（Chain of Responsibility） ",
                        " 解释器。（Interpreter） ",
                        " 命令。（Command） ",
                        " 迭代器。（Iterator） "
                    ]
                },
                {
                    "index": 114,
                    "belong_page": 1,
                    "question_id": 103117,
                    "question_title": "以下设计模式中，（ ）模式使多个对象都有机会处理请求。将这些对象连成一条链。并沿着这条链传递该请求。直到有一个对象处理为止。从而避免请求的发送者和接收者之间的耦合关系。（请作答此空）模式提供一种方法顺序访问一个聚合对象中的各个元素。且不需要暴露该对象的内部表示。这两种模式均为（）",
                    "question_type": 1,
                    "answer_type": 1,
                    "show_type_name": null,
                    "new_parent_id": 103117,
                    "score_rule": "",
                    "material_text": null,
                    "sort_son": "0",
                    "analyze": "<p>责任链模式：通过给多个对象处理请求的机会，减少请求的发送者与接受者之间的耦合。将接收对象链接起来，在链中传递请求，直到有一个对象处理这个请求。</p><p>迭代器模式：提供一种方法来顺序访问一个聚合对象中的各个元素，而不需要暴露该对象的内部表示</p><p>命令模式：将一个请求封装为一个对象，从而可用不同的请求对客户进行参数化，将请求排队或记录请求日志，支持可撤销的操作</p><p>解释器模式：给定一种语言，定义它的文法表示，并定义一个解释器，该解释器用来根据文法表示来解释语言中的句子</p><p>责任链模式和迭代器模式都是行为型对象模式</p>",
                    "like": 0,
                    "answer": [
                        "D"
                    ],
                    "option": [
                        " 责任链。（Chain of Responsibility） ",
                        " 解释器。（Interpreter） ",
                        " 命令。（Command） ",
                        " 迭代器。（Iterator） "
                    ]
                },
                {
                    "index": 115,
                    "belong_page": 1,
                    "question_id": 103118,
                    "question_title": "以下设计模式中，（ ）模式使多个对象都有机会处理请求。将这些对象连成一条链。并沿着这条链传递该请求。直到有一个对象处理为止。从而避免请求的发送者和接收者之间的耦合关系。（）模式提供一种方法顺序访问一个聚合对象中的各个元素。且不需要暴露该对象的内部表示。这两种模式均为（请作答此空）",
                    "question_type": 1,
                    "answer_type": 1,
                    "show_type_name": null,
                    "new_parent_id": 103118,
                    "score_rule": "",
                    "material_text": null,
                    "sort_son": "0",
                    "analyze": "<p>责任链模式：通过给多个对象处理请求的机会，减少请求的发送者与接受者之间的耦合。将接收对象链接起来，在链中传递请求，直到有一个对象处理这个请求。</p><p>迭代器模式：提供一种方法来顺序访问一个聚合对象中的各个元素，而不需要暴露该对象的内部表示</p><p>命令模式：将一个请求封装为一个对象，从而可用不同的请求对客户进行参数化，将请求排队或记录请求日志，支持可撤销的操作</p><p>解释器模式：给定一种语言，定义它的文法表示，并定义一个解释器，该解释器用来根据文法表示来解释语言中的句子</p><p>责任链模式和迭代器模式都是行为型对象模式</p>",
                    "like": 0,
                    "answer": [
                        "C"
                    ],
                    "option": [
                        " 创建型对象模式。 ",
                        " 结构型对象模式。 ",
                        " 行为型对象模式。 ",
                        " 行为型类模式。 "
                    ]
                },
                {
                    "index": 116,
                    "belong_page": 1,
                    "question_id": 103125,
                    "question_title": "<p>以下关于软件系统模块结构设计的叙述中，正确的是（） 。</p>",
                    "question_type": 1,
                    "answer_type": 1,
                    "show_type_name": null,
                    "new_parent_id": 103125,
                    "score_rule": "",
                    "material_text": null,
                    "sort_son": "0",
                    "analyze": "<p>一个模块的扇出是指该模块直接调用的下级模块的个数，扇出大表示模块的复杂度高，需要控制和协调过多的下级模块。扇出过大一般是因为缺乏中间层次，应当适当增加中间层次的控制模块：扇出过小时可以把下级模块进一步分解成若干个子功能模块，或者合并到它的上级模块中去。一个模块的扇入是指直接调用该模块的上级模块的个数；扇入大表示模块的复用程度高。设计良好的软件结构通常顶层扇出比较大，中间扇出比较小，底层模块则有大扇入。</p>",
                    "like": 0,
                    "answer": [
                        "D"
                    ],
                    "option": [
                        " 当模块扇出过大时，应把下级模块进一步分解为若干个子模块 ",
                        " 当模块扇出过小时，应适当增加中间的控制模块 ",
                        " 模块的扇入大，表示模块的复杂度较高 ",
                        " 模块的扇入大，表示模块的复用程度高 "
                    ]
                },
                {
                    "index": 117,
                    "belong_page": 1,
                    "question_id": 151187,
                    "question_title": "以下关于软件中间件的叙述，错误的是（）。",
                    "question_type": 1,
                    "answer_type": 1,
                    "show_type_name": null,
                    "new_parent_id": 151187,
                    "score_rule": "",
                    "material_text": null,
                    "sort_son": "0",
                    "analyze": "<p>中间件是一种独立的系统软件或服务程序，分布式应用软件借助这种软件在不同的技术之间共享资源，中间件位于客户机服务器的操作系统之上，应用程序之下。管理计算资源和网络通信。</p>",
                    "like": 0,
                    "answer": [
                        "D"
                    ],
                    "option": [
                        " 中间件通过标准接口实现与应用程序的关联，提供特定功能的服务 ",
                        " 使用中间件可以提高应用软件可移植性 ",
                        " 使用中间件有助于提高开发效率 ",
                        " 中间件位于客户机服务器的操作系统之下，应用程序之上。管理计算资源和网络通信。 "
                    ]
                },
                {
                    "index": 118,
                    "belong_page": 1,
                    "question_id": 151213,
                    "question_title": "对于开发模型来说，（请作答此空）复用好、开发过程无间隙、节省时间。（）是瀑布与原型（演化）模型结合体，适用于复杂项目。（）需要用户参与，模块化要求高，不适用新技术。（）是用例驱动、架构为中心、迭代、增量。",
                    "question_type": 1,
                    "answer_type": 1,
                    "show_type_name": null,
                    "new_parent_id": 151213,
                    "score_rule": "",
                    "material_text": null,
                    "sort_son": "0",
                    "analyze": "<p>开发模型的特点如下：</p><p><img style=\"max-width:100%;height:auto\"  src=\"https://s2.51cto.com/images/20190925/1569396523928379.jpg\" title=\"1569396523928379.jpg\" alt=\"1.jpg\"/></p><br/>",
                    "like": 0,
                    "answer": [
                        "D"
                    ],
                    "option": [
                        " RAD模型 ",
                        " 螺旋模型 ",
                        " RUP模型 ",
                        " 喷泉模型 "
                    ]
                },
                {
                    "index": 119,
                    "belong_page": 1,
                    "question_id": 151214,
                    "question_title": "对于开发模型来说，（ ）复用好、开发过程无间隙、节省时间。（请作答此空）是瀑布与原型（演化）模型结合体，适用于复杂项目。（）需要用户参与，模块化要求高，不适用新技术。（）是用例驱动、架构为中心、迭代、增量。",
                    "question_type": 1,
                    "answer_type": 1,
                    "show_type_name": null,
                    "new_parent_id": 151214,
                    "score_rule": "",
                    "material_text": null,
                    "sort_son": "0",
                    "analyze": "<p>开发模型的特点如下：</p><p><img style=\"max-width:100%;height:auto\"  src=\"https://s2.51cto.com/images/20190925/1569396582417625.jpg\" title=\"1569396582417625.jpg\" alt=\"1.jpg\"/></p><br/>",
                    "like": 0,
                    "answer": [
                        "B"
                    ],
                    "option": [
                        " RAD模型 ",
                        " 螺旋模型 ",
                        " RUP模型 ",
                        " 喷泉模型 "
                    ]
                },
                {
                    "index": 120,
                    "belong_page": 1,
                    "question_id": 151215,
                    "question_title": "对于开发模型来说，（ ）复用好、开发过程无间隙、节省时间。（ ）是瀑布与原型（演化）模型结合体，适用于复杂项目。（请作答此空）需要用户参与，模块化要求高，不适用新技术。（）是用例驱动、架构为中心、迭代、增量。",
                    "question_type": 1,
                    "answer_type": 1,
                    "show_type_name": null,
                    "new_parent_id": 151215,
                    "score_rule": "",
                    "material_text": null,
                    "sort_son": "0",
                    "analyze": "<p>开发模型的特点如下：</p><p><img style=\"max-width:100%;height:auto\"  src=\"https://s2.51cto.com/images/20190925/1569396637510592.jpg\" title=\"1569396637510592.jpg\" alt=\"1.jpg\"/></p><br/>",
                    "like": 0,
                    "answer": [
                        "A"
                    ],
                    "option": [
                        " RAD模型 ",
                        " 螺旋模型 ",
                        " RUP模型 ",
                        " 喷泉模型 "
                    ]
                },
                {
                    "index": 121,
                    "belong_page": 1,
                    "question_id": 151217,
                    "question_title": "在面向对象分析中，利用（请作答此空）表示需求，并从中提炼出中（），以上两者形成（），之后再进行后续的开发工作。",
                    "question_type": 1,
                    "answer_type": 1,
                    "show_type_name": null,
                    "new_parent_id": 151217,
                    "score_rule": "",
                    "material_text": null,
                    "sort_son": "0",
                    "analyze": "在面向对象分析中，利用用例与用例图表示需求，从用例模型中提炼形成领域模型，用例的实现可以用交互图表示。从领域模型和用例图形成类图，用包图和类图形成体系结构图。之后再进行后续的开发工作。",
                    "like": 0,
                    "answer": [
                        "D"
                    ],
                    "option": [
                        " 类图 ",
                        " 数据流图 ",
                        " 包图 ",
                        " 用例与用例图 "
                    ]
                },
                {
                    "index": 122,
                    "belong_page": 1,
                    "question_id": 151218,
                    "question_title": "在面向对象分析中，利用（ ）表示需求，并从中提炼出中（请作答此空），以上两者形成（），之后再进行后续的开发工作。",
                    "question_type": 1,
                    "answer_type": 1,
                    "show_type_name": null,
                    "new_parent_id": 151218,
                    "score_rule": "",
                    "material_text": null,
                    "sort_son": "0",
                    "analyze": "在面向对象分析中，利用用例与用例图表示需求，从用例模型中提炼形成领域模型，用例的实现可以用交互图表示。从领域模型和用例图形成类图，用包图和类图形成体系结构图。之后再进行后续的开发工作。",
                    "like": 0,
                    "answer": [
                        "A"
                    ],
                    "option": [
                        " 领域模型 ",
                        " 架构模型 ",
                        " 体系结构图 ",
                        " 类图 "
                    ]
                },
                {
                    "index": 123,
                    "belong_page": 1,
                    "question_id": 159188,
                    "question_title": "某订单处理系统中，“创建新订单”和“更新订单”两个用例都需要检查客户的账号是否正确，为此定义一个通用的用例“核查客户账户”。用例“创建新订单”和“更新订单”与用例“核查客户账户”之间是（ ）。",
                    "question_type": 1,
                    "answer_type": 1,
                    "show_type_name": null,
                    "new_parent_id": 159188,
                    "score_rule": "",
                    "material_text": null,
                    "sort_son": "0",
                    "analyze": "<p>本题考查用例建模中用例之间的基本关系。</p><p>使用用例健模系统需求时,两个或多个用例可能执行同样的功能步骤。把这些公共步骤提取成独立的用例,称为抽象用例。抽象用例代表了某种程度的复用,是降低用例之间冗余的较好方式。抽象用例可以被另一个需要使用它的功能用例访问,抽象用例和使用它的用例之间的关系你为使用关系。</p>",
                    "like": 0,
                    "answer": [
                        "A"
                    ],
                    "option": [
                        " 包含关系 ",
                        " 聚合关系 ",
                        " 泛化关系 ",
                        " 关联关系 "
                    ]
                },
                {
                    "index": 124,
                    "belong_page": 1,
                    "question_id": 159189,
                    "question_title": "UML的事物是对模型中最具有代表性的成分的抽象，（请作答此空）是模型的静态部分，描述概念或物理元素；（ ）用来描述、说明和标注模型的任何元素。",
                    "question_type": 1,
                    "answer_type": 1,
                    "show_type_name": null,
                    "new_parent_id": 159189,
                    "score_rule": "",
                    "material_text": null,
                    "sort_son": "0",
                    "analyze": "<p>UML中有4种事物:</p><p>1、结构事物是UML模型中的名词。它们通常是模型的静态部分,描述概念或物理元素；</p><p>2、行为事物是UML模型的动态部分。它们是模型中的动词,描述了跨越时间和空间的行为；</p><p>3、分组事物是UML模型的组仅部分。它们是—些由模型分解成的盒子；</p><p>4、注释事物是UML模型的解释部分。这些注释事物用来描述、说明和标注模型的任何元素。</p>",
                    "like": 0,
                    "answer": [
                        "A"
                    ],
                    "option": [
                        " 结构事物 ",
                        " 分组事物 ",
                        " 行为事物 ",
                        " 注释事物 "
                    ]
                },
                {
                    "index": 125,
                    "belong_page": 1,
                    "question_id": 159190,
                    "question_title": "UML的事物是对模型中最具有代表性的成分的抽象，（ ）是模型的静态部分，描述概念或物理元素；（请作答此空）用来描述、说明和标注模型的任何元素。",
                    "question_type": 1,
                    "answer_type": 1,
                    "show_type_name": null,
                    "new_parent_id": 159190,
                    "score_rule": "",
                    "material_text": null,
                    "sort_son": "0",
                    "analyze": "<p>UML中有4种事物:</p><p>1、结构事物是UML模型中的名词。它们通常是模型的静态部分,描述概念或物理元素；</p><p>2、行为事物是UML模型的动态部分。它们是模型中的动词,描述了跨越时间和空间的行为；</p><p>3、分组事物是UML模型的组仅部分。它们是—些由模型分解成的盒子；</p><p>4、注释事物是UML模型的解释部分。这些注释事物用来描述、说明和标注模型的任何元素。</p>",
                    "like": 0,
                    "answer": [
                        "B"
                    ],
                    "option": [
                        " 分组事物 ",
                        " 注释事物 ",
                        " 结构事物 ",
                        " 行为事物 "
                    ]
                },
                {
                    "index": 126,
                    "belong_page": 1,
                    "question_id": 159191,
                    "question_title": "UML用关系把事物结合在一起，（请作答此空）描述一个事物发生变化会影响另一个事物的语义；（ &nbsp;）描述特殊元素的对象可替换一般元素的对象。",
                    "question_type": 1,
                    "answer_type": 1,
                    "show_type_name": null,
                    "new_parent_id": 159191,
                    "score_rule": "",
                    "material_text": null,
                    "sort_son": "0",
                    "analyze": "<p>UML中有4种关系:</p><p>1、依赖是两个事物间的语义关系,其中一个事物(独立事物)发生变化会影响另一个事物（依赖事物)的语义;</p><p>2、关联是一种结构关系,描述了一组链,链式对象之间的连接,聚集是一种特殊类型的关联，描述整体与部分间的结构关系;</p><p>3、泛化是一种特殊一般关系,特殊元素的对象可替代一般元素的对象；</p><p>4、实现是类元之间的语义关系,其中一个类元指定了由另一个类元保证执行的契约。</p>",
                    "like": 0,
                    "answer": [
                        "D"
                    ],
                    "option": [
                        " 聚合关系 ",
                        " 关联关系 ",
                        " 包含关系 ",
                        " 依赖关系 "
                    ]
                },
                {
                    "index": 127,
                    "belong_page": 1,
                    "question_id": 159192,
                    "question_title": "UML用关系把事物结合在一起，（ &nbsp;）描述一个事物发生变化会影响另一个事物的语义；（请作答此空）描述特殊元素的对象可替换一般元素的对象。",
                    "question_type": 1,
                    "answer_type": 1,
                    "show_type_name": null,
                    "new_parent_id": 159192,
                    "score_rule": "",
                    "material_text": null,
                    "sort_son": "0",
                    "analyze": "<p>UML中有4种关系:</p><p>1、依赖是两个事物间的语义关系,其中一个事物(独立事物)发生变化会影响另一个事物（依赖事物)的语义;</p><p>2、关联是一种结构关系,描述了一组链,链式对象之间的连接,聚集是一种特殊类型的关联，描述整体与部分间的结构关系;</p><p>3、泛化是一种特殊一般关系,特殊元素的对象可替代一般元素的对象；</p><p>4、实现是类元之间的语义关系,其中一个类元指定了由另一个类元保证执行的契约。</p>",
                    "like": 0,
                    "answer": [
                        "C"
                    ],
                    "option": [
                        " 实现关系 ",
                        " 聚合关系 ",
                        " 泛化关系 ",
                        " 关联关系 "
                    ]
                },
                {
                    "index": 128,
                    "belong_page": 1,
                    "question_id": 159206,
                    "question_title": "软件开发团队欲开发一套管理信息系统，在项目初期，用户提出了软件的一些基本功能，但是没有详细定义输入、处理和输出需求。在这种情况下，该团队在开发过程应采用（ ）。",
                    "question_type": 1,
                    "answer_type": 1,
                    "show_type_name": null,
                    "new_parent_id": 159206,
                    "score_rule": "",
                    "material_text": null,
                    "sort_son": "0",
                    "analyze": "在软件开发过程中,如果用户仅仅提出软件的—些基本功能,但是没有详细定义输入、处理和输出需求。在这种情况下,该软件开发团队应该采取原型开发方法最为合适。因此本题应该选C。",
                    "like": 0,
                    "answer": [
                        "C"
                    ],
                    "option": [
                        " 瀑布模型 ",
                        " 增量模型 ",
                        " 原型开发模型 ",
                        " 快速应用程序开发（RAD） "
                    ]
                },
                {
                    "index": 129,
                    "belong_page": 1,
                    "question_id": 159207,
                    "question_title": "<p>统一软件开发过程是一种基于面向对象技术的软件开发过程，其特点是“用例驱动，以架构为核心，迭代并增量”。统一软件开发过程定义了四种通用的开发阶段，它们按照过程顺序分别是：起始阶段、（请作答此空）、构建阶段和（ ），其中在构建阶段主要产生的文档有（ ）。</p>",
                    "question_type": 1,
                    "answer_type": 1,
                    "show_type_name": null,
                    "new_parent_id": 159207,
                    "score_rule": "",
                    "material_text": null,
                    "sort_son": "0",
                    "analyze": "<p>统一软件开发过程(UP)是一种基于面向对象技术的软件开发过程。其特点是“用例驱动，以架构为核心,迭代并增量”。统一软件过程定义了5种通用的框架活动,它们按照过程顺序分别是:起始阶段、细化阶段、构建阶段、交付阶段和生产价段.其中在构阶段主要产生的文档包括设计模型。因此本题应该选择B</p>",
                    "like": 0,
                    "answer": [
                        "B"
                    ],
                    "option": [
                        " 分析阶段 ",
                        " 细化阶段 ",
                        " 设计阶段 ",
                        " 交付阶段 "
                    ]
                },
                {
                    "index": 130,
                    "belong_page": 1,
                    "question_id": 159208,
                    "question_title": "统一软件开发过程是一种基于面向对象技术的软件开发过程，其特点是“用例驱动，以架构为核心，迭代并增量”。统一软件开发过程定义了四种通用的开发阶段，它们按照过程顺序分别是：起始阶段、（ ）、构建阶段和（请作答此空），其中在构建阶段主要产生的文档有（ ）。",
                    "question_type": 1,
                    "answer_type": 1,
                    "show_type_name": null,
                    "new_parent_id": 159208,
                    "score_rule": "",
                    "material_text": null,
                    "sort_son": "0",
                    "analyze": "统一软件开发过程(UP)是一种基于面向对象技术的软件开发过程。其特点是“用例驱动，以架构为核心,迭代并增量”。统一软件过程定义了5种通用的框架活动,它们按照过程顺序分别是:起始阶段、细化阶段、构建阶段、交付阶段和生产价段.其中在构阶段主要产生的文档包括设计模型。因此本题应该选择D",
                    "like": 0,
                    "answer": [
                        "D"
                    ],
                    "option": [
                        " 分析阶段 ",
                        " 细化阶段 ",
                        " 设计阶段 ",
                        " 交付阶段 "
                    ]
                },
                {
                    "index": 131,
                    "belong_page": 1,
                    "question_id": 159209,
                    "question_title": "统一软件开发过程是一种基于面向对象技术的软件开发过程，其特点是“用例驱动，以架构为核心，迭代并增量”。统一软件开发过程定义了四种通用的开发阶段，它们按照过程顺序分别是：起始阶段、（ ）、构建阶段和（ ），其中在构建阶段主要产生的文档有（请作答此空）。",
                    "question_type": 1,
                    "answer_type": 1,
                    "show_type_name": null,
                    "new_parent_id": 159209,
                    "score_rule": "",
                    "material_text": null,
                    "sort_son": "0",
                    "analyze": "统一软件开发过程(UP)是一种基于面向对象技术的软件开发过程。其特点是“用例驱动，以架构为核心,迭代并增量”。统一软件过程定义了5种通用的框架活动,它们按照过程顺序分别是:起始阶段、细化阶段、构建阶段、交付阶段和生产价段.其中在构阶段主要产生的文档包括设计模型。因此本题应该选择D",
                    "like": 0,
                    "answer": [
                        "D"
                    ],
                    "option": [
                        " 初始用户手册 ",
                        " 用例模型 ",
                        " 项目计划 ",
                        " 设计模型 "
                    ]
                },
                {
                    "index": 132,
                    "belong_page": 1,
                    "question_id": 159210,
                    "question_title": "某公司欲开发一个在线交易系统。为了能够精确表达用户与系统的复杂交互过程，应该采用UML的（ ）进行交互过程建模。",
                    "question_type": 1,
                    "answer_type": 1,
                    "show_type_name": null,
                    "new_parent_id": 159210,
                    "score_rule": "",
                    "material_text": null,
                    "sort_son": "0",
                    "analyze": "在采用UML进行软件建模时，当需要建模和描述复杂的交互过程时,通常会采用协作图或序列图,也会采用状态图加以辅助,因此本题选B。",
                    "like": 0,
                    "answer": [
                        "B"
                    ],
                    "option": [
                        " 类图 ",
                        " 序列图 ",
                        " 部署图 ",
                        " 对象图 "
                    ]
                },
                {
                    "index": 133,
                    "belong_page": 1,
                    "question_id": 159211,
                    "question_title": "敏捷软件过程强调：让客户满意和软件尽早增量发布；小而高度自主的项目团队；非正式的方法；最小化软件工程工作产品以及整体精简开发。（ ）不是采用这种软件开发过程的原因。",
                    "question_type": 1,
                    "answer_type": 1,
                    "show_type_name": null,
                    "new_parent_id": 159211,
                    "score_rule": "",
                    "material_text": null,
                    "sort_son": "0",
                    "analyze": "<p>敏捷软件过程强调让客户满意和软件尽早增量发布；小而高度自主的项目团队；非正式的方法；最小化软件工程工作产品以及整体精简开发。</p><p>产生这种情况的原因是：在绝大多数软件开发过程中，提前预测哪些需求是稳定的和哪些需求会变化非常困难；对于软件项目构建来说，设计和构建是交错的；从指定计划的角度来看，分析、设计、构建和测试并不容易预测；可执行原型和部分实现的可运行系统是了解用户需求和反馈的有效媒介。因此本题应该选择B.</p>",
                    "like": 0,
                    "answer": [
                        "B"
                    ],
                    "option": [
                        " 难以提前预测哪些需求是稳定的和哪些需求会变化 ",
                        " 对于软件项目开发来说，设计和实现可以做到基本分离 ",
                        " 从制定计划的角度来看，分析、设计、实现和测试并不容易预测 ",
                        " 可执行原型和部分实现的可运行系统是了解用户需求和反馈的有效媒介 "
                    ]
                },
                {
                    "index": 134,
                    "belong_page": 1,
                    "question_id": 159212,
                    "question_title": "软件的逆向工程是一个恢复设计的过程，从现有的程序中抽取数据、体系结构和过程的设计信息。逆向工程的完备性可以用在某一个抽象层次上提供信息的详细程度来描述，在大多数情况下，抽象层次越高，完备性就越低。下列可以通过逆向工程恢复的制品中，完备性最低的是（ ）。",
                    "question_type": 1,
                    "answer_type": 1,
                    "show_type_name": null,
                    "new_parent_id": 159212,
                    "score_rule": "",
                    "material_text": null,
                    "sort_son": "0",
                    "analyze": "软件的逆向工程是一个设计恢复的过程，从现有的程序中抽取数据、体系结构和过程的设计信息。逆向工程的完备性是指在某一个抽象层次上提供信息的详细程度，在大多数情况下，抽象层次越高，完备性就越低。逆向过程和实现该过程的工具的抽象层次是指可从源代码中抽取出来的设计信息的精密程度。理想情况下，抽象程度应该尽可能高。逆向工程过程应该能够导出过程的设计模型（一种底层的抽象）；程序和数据结构信息（稍高层次的抽象）；对象模型、数据和控制流模（相对高层的抽象）；UML图，状态及部署图（高层抽象）。随着抽象层次增高，完备性就会降低。因此本题应该选择D。",
                    "like": 0,
                    "answer": [
                        "D"
                    ],
                    "option": [
                        " 过程的设计模型 ",
                        " 程序和数据结构 ",
                        " 对象模型、数据和控制流 ",
                        " UML状态图和部署图 "
                    ]
                },
                {
                    "index": 135,
                    "belong_page": 1,
                    "question_id": 159213,
                    "question_title": "某公司要开发一个软件产品，产品的某些需求是明确的，而某些需求则需要进一步细化。由于市场竞争的压力，产品需要尽快上市，则开发该软件产品最不适合采用 （ &nbsp;） 模型。",
                    "question_type": 1,
                    "answer_type": 1,
                    "show_type_name": null,
                    "new_parent_id": 159213,
                    "score_rule": "",
                    "material_text": null,
                    "sort_son": "0",
                    "analyze": "瀑布模型将软件生命周期划分为需求分析、软件设计、程序编写、软件测试和运行维护等基本活动，并且规定了它们自上而下、相互衔接的固定次序，如同瀑布流水，逐级下落。瀑布模型要求待开发的系统需求是完整的、简明的、一致的，其突出的缺点是不适应用户需求的变化，开发模型是线性的，用户只有等到整个过程的末期才能见到开发成果。对于需求不确定的软件产品不适合采用瀑布模型。",
                    "like": 0,
                    "answer": [
                        "A"
                    ],
                    "option": [
                        " 瀑布 ",
                        " 原型 ",
                        " 增量 ",
                        " 螺旋 "
                    ]
                },
                {
                    "index": 136,
                    "belong_page": 1,
                    "question_id": 159214,
                    "question_title": "软件风险是指在软件开发过程中面临的一些不确定性和可能造成的损失。软件风险大致可以分为三类：项目风险、技术风险和商业风险。下列叙述中，（ ）属于商业风险。",
                    "question_type": 1,
                    "answer_type": 1,
                    "show_type_name": null,
                    "new_parent_id": 159214,
                    "score_rule": "",
                    "material_text": null,
                    "sort_son": "0",
                    "analyze": "软件风险是指在软件开发过程中面临的一些不确定性和可能造成的损失。软件风险大致可以分为三类:项目风险、技术风险和商业风险。商业风验主要包括5个方面;开发了一个没有人真正使用的优良产品或系统;开发的产品不在符合公司的整体策略;开发了一个销售部不知如何销售的软件;失去了高层管理人员的支持;没有得到预算或人员的保证,因此本题应该选D。",
                    "like": 0,
                    "answer": [
                        "D"
                    ],
                    "option": [
                        " 软件的开发时间可能会超出预期时间 ",
                        " 采用的开发技术过于先进，技术本身尚不稳定 ",
                        " 软件开发过程中需求一直未能稳定下来 ",
                        " 软件开发过程没有得到预算或人员上的保证 "
                    ]
                },
                {
                    "index": 137,
                    "belong_page": 1,
                    "question_id": 159226,
                    "question_title": "商业智能关注如何从业务数据中提取有用的信息，然后采用这些信息指导企业的业务开展。商业智能系统主要包括数据预处理、（ ）、数据分析和数据展现 4 个主要阶段。",
                    "question_type": 1,
                    "answer_type": 1,
                    "show_type_name": null,
                    "new_parent_id": 159226,
                    "score_rule": "",
                    "material_text": null,
                    "sort_son": "0",
                    "analyze": "BI系统主要包括数据预处理、建立数据仓库、数据分析和数据展现四个主要阶段。",
                    "like": 0,
                    "answer": [
                        "B"
                    ],
                    "option": [
                        " 数据索引 ",
                        " 数据仓库 ",
                        " 数据库 ",
                        " 数据字典 "
                    ]
                },
                {
                    "index": 138,
                    "belong_page": 1,
                    "question_id": 159243,
                    "question_title": "<p>对于如下所示的序列图所描述的场景，最适合于采用的设计模式是（请作答此空）；该模式适用的场合是（ ）。</p><img style=\"max-width:100%;height:auto\"  src=\"https://s2.51cto.com/images/20191019/1571472742158135.jpg\" title=\"1571472742158135.jpg\" alt=\"2.jpg\"/>",
                    "question_type": 1,
                    "answer_type": 1,
                    "show_type_name": null,
                    "new_parent_id": 159243,
                    "score_rule": "",
                    "material_text": null,
                    "sort_son": "0",
                    "analyze": "访问者（Visitor）模式是一种对象的行为模式，用于表示一个作用于某对象结构中的各元素的操作，它使得用户可以在不改变各元素的类的前提下，定义作用于这些元素的新操作。访问者模式使得新的操作变得很容易，但在一定程度上破坏了封装性。",
                    "like": 0,
                    "answer": [
                        "A"
                    ],
                    "option": [
                        " Visitor ",
                        " Strategy ",
                        " Observer ",
                        " State "
                    ]
                },
                {
                    "index": 139,
                    "belong_page": 1,
                    "question_id": 159244,
                    "question_title": "<p>对于如下所示的序列图所描述的场景，最适合于采用的设计模式是（）；该模式适用的场合是（请作答此空）。<br/><img style=\"max-width:100%;height:auto\"  src=\"https://s2.51cto.com/images/20191019/1571472801203279.jpg\" title=\"1571472801203279.jpg\" alt=\"2.jpg\"/></p>",
                    "question_type": 1,
                    "answer_type": 1,
                    "show_type_name": null,
                    "new_parent_id": 159244,
                    "score_rule": "",
                    "material_text": null,
                    "sort_son": "0",
                    "analyze": "<p>访问者（Visitor）模式是一种对象的行为模式，用于表示一个作用于某对象结构中的各元素的操作，它使得用户可以在不改变各元素的类的前提下，定义作用于这些元素的新操作。访问者模式使得新的操作变得很容易，但在一定程度上破坏了封装性。</p><p><br/></p>",
                    "like": 0,
                    "answer": [
                        "B"
                    ],
                    "option": [
                        " 对象的行为决定于它的状态，且必须在运行时刻根据状态改变它的行为 ",
                        " 定义对象结构的类很少改变，但经常需要在此结构上定义新的操作 ",
                        " 需要使用一个算法的不同变体 ",
                        " 一个对象必须通知其他对象，而它又不能假定其他对象是谁 "
                    ]
                },
                {
                    "index": 140,
                    "belong_page": 1,
                    "question_id": 159249,
                    "question_title": "遗产系统（Legacy System）的演化策略分为淘汰策略、继承策略、改造策略和集成策略。具有（请作答此空）特点的系统适合用继承策略演化。实施该策略时，应（ ）。",
                    "question_type": 1,
                    "answer_type": 1,
                    "show_type_name": null,
                    "new_parent_id": 159249,
                    "score_rule": "",
                    "material_text": null,
                    "sort_son": "0",
                    "analyze": "<p>如上图，把对遗留系统的评价结果分列在坐标的四个象限内。对处在不同象限的遗留系统采取不同的演化策略。</p><p>1. 淘汰策略</p><p>第三象限为低水平、低价值区，即遗留系统的技术含量较低，且具有较低的业务价值。对这种遗留系统的演化策略为淘汰，即全面重新开发新的系统以代替遗留系统。完全淘汰是一种极端性策略，一般是企业的业务产生了根本变化，遗留系统已经基本上不再适应企业运作的需要；或者是遗留系统的维护人员、维护文档资料都丢失了。经过评价，发现将遗留系统完全淘汰，开发全新的系统比改造旧系统从成本上更合算。</p><p>对遗留系统的完全淘汰是企业资源的根本浪费，系统分析师应该通过对遗留系统功能的理解和借鉴，可以帮助新系统的设计，降低新系统开发的风险。</p><p>2. 继承策略</p><p>第二象限为低水平、高价值区，即遗留系统的技术含量较低，已经满足企业运作的功能或性能要求，但具有较高的商业价值，目前企业的业务尚紧密依赖该系统。对这种遗留系统的演化策略为继承。在开发新系统时，需要完全兼容遗留系统的功能模型和数据模型。为了保证业务的连续性，新老系统必须并行运行一段时间，再逐渐切换到新系统上运行。</p><p>3. 改造策略</p><p>第一象限为高水平、高价值区，即遗留系统的技术含量较高，本身还有极大的生命力。系统具有较高的业务价值，基本上能够满足企业业务运作和决策支持的需要。这种系统可能建成的时间还很短，对这种遗留系统的演化策略为改造。改造包括系统功能的增强和数据模型的改造两个方面。系统功能的增强是指在原有系统的基础上增加新的应用要求，对遗留系统本身不做改变；数据模型的改造是指将遗留系统的旧的数据模型向新的数据模型的转化。</p><p>4. 集成策略</p><p>第四象限为高水平、低价值区，即遗留系统的技术含量较高，但其业务价值较低，可能只完成某个部门（或子公司）的业务管理。这种系统在各自的局部领域里工作良好，但对于整个企业来说，存在多个这样的系统，不同的系统基于不同的平台、不同的数据模型，形成了一个个信息孤岛，对这种遗留系统的演化策略为集成。</p>",
                    "like": 0,
                    "answer": [
                        "B"
                    ],
                    "option": [
                        " 技术含量低，具有较低的业务价值 ",
                        " 技术含量较低，具有较高的商业价值，目前企业的业务尚紧密依赖该系统 ",
                        " 技术含量较高，基本能够满足企业业务运作和决策支持的需要 ",
                        " 技术含量较高，业务价值低，可能只完成某个部门（或子公司）的业务 "
                    ]
                },
                {
                    "index": 141,
                    "belong_page": 1,
                    "question_id": 159250,
                    "question_title": "遗产系统（Legacy System）的演化策略分为淘汰策略、继承策略、改造策略和集成策略。具有（ ）特点的系统适合用继承策略演化。实施该策略时，应（请作答此空）。",
                    "question_type": 1,
                    "answer_type": 1,
                    "show_type_name": null,
                    "new_parent_id": 159250,
                    "score_rule": "",
                    "material_text": null,
                    "sort_son": "0",
                    "analyze": "<p>如上图，把对遗留系统的评价结果分列在坐标的四个象限内。对处在不同象限的遗留系统采取不同的演化策略。</p><p>1. 淘汰策略</p><p>第三象限为低水平、低价值区，即遗留系统的技术含量较低，且具有较低的业务价值。对这种遗留系统的演化策略为淘汰，即全面重新开发新的系统以代替遗留系统。完全淘汰是一种极端性策略，一般是企业的业务产生了根本变化，遗留系统已经基本上不再适应企业运作的需要；或者是遗留系统的维护人员、维护文档资料都丢失了。经过评价，发现将遗留系统完全淘汰，开发全新的系统比改造旧系统从成本上更合算。</p><p>对遗留系统的完全淘汰是企业资源的根本浪费，系统分析师应该通过对遗留系统功能的理解和借鉴，可以帮助新系统的设计，降低新系统开发的风险。</p><p>2. 继承策略</p><p>第二象限为低水平、高价值区，即遗留系统的技术含量较低，已经满足企业运作的功能或性能要求，但具有较高的商业价值，目前企业的业务尚紧密依赖该系统。对这种遗留系统的演化策略为继承。在开发新系统时，需要完全兼容遗留系统的功能模型和数据模型。为了保证业务的连续性，新老系统必须并行运行一段时间，再逐渐切换到新系统上运行。</p><p>3. 改造策略</p><p>第一象限为高水平、高价值区，即遗留系统的技术含量较高，本身还有极大的生命力。系统具有较高的业务价值，基本上能够满足企业业务运作和决策支持的需要。这种系统可能建成的时间还很短，对这种遗留系统的演化策略为改造。改造包括系统功能的增强和数据模型的改造两个方面。系统功能的增强是指在原有系统的基础上增加新的应用要求，对遗留系统本身不做改变；数据模型的改造是指将遗留系统的旧的数据模型向新的数据模型的转化。</p><p>4. 集成策略</p><p>第四象限为高水平、低价值区，即遗留系统的技术含量较高，但其业务价值较低，可能只完成某个部门（或子公司）的业务管理。这种系统在各自的局部领域里工作良好，但对于整个企业来说，存在多个这样的系统，不同的系统基于不同的平台、不同的数据模型，形成了一个个信息孤岛，对这种遗留系统的演化策略为集成。<span style=\"font-size: 16px;\"></span></p>",
                    "like": 0,
                    "answer": [
                        "C"
                    ],
                    "option": [
                        " 保持原有系统不变，只在其基础上增加新的应用功能 ",
                        " 保持原有系统功能不变，将旧的数据模型向新的数据模型的转化 ",
                        " 完全兼容遗产系统的功能模型和数据模型 ",
                        " 部分兼容遗产系统的功能模型和数据模型 "
                    ]
                },
                {
                    "index": 142,
                    "belong_page": 1,
                    "question_id": 159251,
                    "question_title": "数据流图中某个加工的一组动作依赖于多个逻辑条件的取值，则用 （ ） 能够清楚地表示复杂的条件组合与应做的动作之间的对应关系。",
                    "question_type": 1,
                    "answer_type": 1,
                    "show_type_name": null,
                    "new_parent_id": 159251,
                    "score_rule": "",
                    "material_text": null,
                    "sort_son": "0",
                    "analyze": "本题考查结构化分析方面的基础知识。在结构化分析中，用数据流图对软件功能建模，加工是数据流的一个重要要素，可以用多种方式描述，如流程图、NS盒图等，其中决策树和决策表适于用来表示加工中涉及多个逻辑条件的情况。",
                    "like": 0,
                    "answer": [
                        "D"
                    ],
                    "option": [
                        " 流程图 ",
                        " NS盒图 ",
                        " 形式语言 ",
                        " 决策树 "
                    ]
                },
                {
                    "index": 143,
                    "belong_page": 1,
                    "question_id": 208411,
                    "question_title": "ERP中的企业资源包括（ ）。",
                    "question_type": 1,
                    "answer_type": 1,
                    "show_type_name": "单选题",
                    "new_parent_id": 208411,
                    "score_rule": "",
                    "material_text": "",
                    "sort_son": "0",
                    "analyze": "ERP是针对物资资源管理（物流）、人力资源管理（人流）、财务资源管理（财流）、信息资源管理（信息流）集成一体化的企业管理软件。它将包含客户/服务架构，使用图形用户接口，应用开放系统制作。除了已有的标准功能，它还包括其它特性，如品质、过程运作管理、以及调整报告等。",
                    "like": 0,
                    "answer": [
                        "A"
                    ],
                    "option": [
                        " 物流、资金流和信息流 ",
                        " 物流、工作流和信息流 ",
                        " 物流、资金流和工作流 ",
                        " 资金流、工作流和信息流 "
                    ]
                },
                {
                    "index": 144,
                    "belong_page": 1,
                    "question_id": 208412,
                    "question_title": "CRM是一套先进的管理思想及技术手段，它通过将（请作答此空）进行有效的整合，最终为企业涉及到的各个领域提供了集成环境。CRM系统的四个主要模块包括（ ）。",
                    "question_type": 1,
                    "answer_type": 1,
                    "show_type_name": "单选题",
                    "new_parent_id": 208412,
                    "score_rule": "",
                    "material_text": "",
                    "sort_son": "0",
                    "analyze": "通常所指的CRM，指用计算机自动化分析销售、市场营销、客户服务以及应用等流程的软件系统。它的目标是通过提高客户的价值、满意度、赢利性和忠实度来缩减销售周期和销售成本、增加收入、寻找扩展业务所需的新的市场和渠道。CRM通过将人力资源、业务流程与专业技术进行有效的整合，最终为企业涉及到客户或者消费者的各个领域提供了完美的集成，使得企业可以更低成本、更高效率地满足客户的需求，并与客户建立起基于学习性关系基础上的一对一营销模式，从而让企业可以最大程度提高客户满意度和忠诚度。CRM系统的主要模块包括销售自动化、营销自动化、客户服务与支持、商业智能。",
                    "like": 0,
                    "answer": [
                        "D"
                    ],
                    "option": [
                        " 员工资源、客户资源与管理技术 ",
                        " 销售资源、信息资源与商业智能 ",
                        " 销售管理、市场管理与服务管理 ",
                        " 人力资源、业务流程与专业技术 "
                    ]
                },
                {
                    "index": 145,
                    "belong_page": 1,
                    "question_id": 208413,
                    "question_title": "CRM是一套先进的管理思想及技术手段，它通过将（ ）进行有效的整合，最终为企业涉及到的各个领域提供了集成环境。CRM系统的四个主要模块包括（请作答此空）。",
                    "question_type": 1,
                    "answer_type": 1,
                    "show_type_name": "单选题",
                    "new_parent_id": 208413,
                    "score_rule": "",
                    "material_text": "",
                    "sort_son": "0",
                    "analyze": "通常所指的CRM，指用计算机自动化分析销售、市场营销、客户服务以及应用等流程的软件系统。它的目标是通过提高客户的价值、满意度、赢利性和忠实度来缩减销售周期和销售成本、增加收入、寻找扩展业务所需的新的市场和渠道。CRM通过将人力资源、业务流程与专业技术进行有效的整合，最终为企业涉及到客户或者消费者的各个领域提供了完美的集成，使得企业可以更低成本、更高效率地满足客户的需求，并与客户建立起基于学习性关系基础上的一对一营销模式，从而让企业可以最大程度提高客户满意度和忠诚度。CRM系统的主要模块包括销售自动化、营销自动化、客户服务与支持、商业智能。",
                    "like": 0,
                    "answer": [
                        "C"
                    ],
                    "option": [
                        " 电子商务支持、呼叫中心、移动设备支持、数据分析 ",
                        " 信息分析、网络应用支持、客户信息仓库、工作流集成 ",
                        " 销售自动化、营销自动化、客户服务与支持、商业智能 ",
                        " 销售管理、市场管理、服务管理、现场服务管理 "
                    ]
                },
                {
                    "index": 146,
                    "belong_page": 1,
                    "question_id": 208414,
                    "question_title": "企业信息化程度是国家信息化建设的基础和关键，企业信息化方法不包括（ ）。",
                    "question_type": 1,
                    "answer_type": 1,
                    "show_type_name": "单选题",
                    "new_parent_id": 208414,
                    "score_rule": "",
                    "material_text": "",
                    "sort_son": "0",
                    "analyze": "企业信息化就是企业利用现代信息技术，通过信息资源的深入开发和广泛利用，实现企业生产过程的自动化、管理方式的网络化、决策支持的智能化和商务运营的电子化，不断提高生产、经营、管理、决策的效率和水平，进而提高企业经济效益和企业竞争力的过程。企业信息化方法主要包括业务流程重构、核心业务应用、信息系统建设、主题数据库、资源管理和人力资本投资方法。其中资源管理方法包括：ERP（Enterprise Resource Planning企业资源计划）、SCM（Supply Chain Management 供应链管理）。",
                    "like": 0,
                    "answer": [
                        "B"
                    ],
                    "option": [
                        " 业务流程重组 ",
                        " 组织机构变革 ",
                        " 供应链管理 ",
                        " 人力资本投资 "
                    ]
                },
                {
                    "index": 147,
                    "belong_page": 1,
                    "question_id": 208415,
                    "question_title": "企业信息资源集成管理的前提是对企业（请作答此空）的集成，其核心是对企业（ ）的集成。",
                    "question_type": 1,
                    "answer_type": 1,
                    "show_type_name": "单选题",
                    "new_parent_id": 208415,
                    "score_rule": "",
                    "material_text": "",
                    "sort_son": "0",
                    "analyze": "实行企业信息资源集成的前提是对企业历史上形成的企业信息功能的集成，其核心是对企业内部和外部信息流的集成，其实施的基础是各种信息手段的集成。通过集成管理实现企业信息系统各要素的优化组合，使信息系统各要素之间形成强大的协同作用，从而最大限度地放大企业信息的功能，实现企业可持续发展的目的。",
                    "like": 0,
                    "answer": [
                        "A"
                    ],
                    "option": [
                        " 信息功能 ",
                        " 信息设施 ",
                        " 信息活动 ",
                        " 信息处理 "
                    ]
                },
                {
                    "index": 148,
                    "belong_page": 1,
                    "question_id": 208416,
                    "question_title": "<p>企业信息资源集成管理的前提是对企业（ ）的集成，其核心是对企业（请作答此空）的集成。</p>",
                    "question_type": 1,
                    "answer_type": 1,
                    "show_type_name": "单选题",
                    "new_parent_id": 208416,
                    "score_rule": "",
                    "material_text": "",
                    "sort_son": "0",
                    "analyze": "<p>本题考查信息资源管理的基本知识。 <br/>集成管理是企业信息资源管理的主要内容之一。<br/>实行企业信息资源集成的前提是对企业历史上形成的企业信息功能的集成，其核心是对企业内部和外部信息流的集成，其实施的基础是各种信息手段的集成。<br/>通过集成管理实现企业信息系统各要素的优化组合，使信息系统各要素之间形成强大的协同作用，从而最大限度地放大企业信息的功能，实现企业可持续发展的目的。</p>",
                    "like": 0,
                    "answer": [
                        "D"
                    ],
                    "option": [
                        " 业务流 ",
                        " 内部信息流 ",
                        " 外部信息流 ",
                        " 内部和外部信息流 "
                    ]
                },
                {
                    "index": 149,
                    "belong_page": 1,
                    "question_id": 208417,
                    "question_title": "为了加强对企业信息资源的管理，企业应按照信息化和现代化企业管理要求设置信息管理机构，建立信息中心。信息中心的主要职能不包括（ ）。",
                    "question_type": 1,
                    "answer_type": 1,
                    "show_type_name": "单选题",
                    "new_parent_id": 208417,
                    "score_rule": "",
                    "material_text": "",
                    "sort_son": "0",
                    "analyze": "为了加强对企业信息资源的管理，企业应按照信息化和现代化企业管理要求设置信息管理机构，建立信息中心，确定信息主管，统一管理和协调企业信息资源的开发、收集和使用。信息中心是企业的独立机构，直接由最高层领导并为企业最高管理者提供服务。其主要职能是处理信息，确定信息处理的方法，用先进的信息技术提高业务管理水平，建立业务部门期望的信息系统和网络并预测未来的信息系统和网络，培养信息资源的管理人员等。",
                    "like": 0,
                    "answer": [
                        "C"
                    ],
                    "option": [
                        " 处理信息，确定信息处理的方法 ",
                        " 用先进的信息技术提高业务管理水平 ",
                        " 组织招聘信息资源管理员 ",
                        " 建立业务部门期望的信息系统和网络 "
                    ]
                },
                {
                    "index": 150,
                    "belong_page": 1,
                    "question_id": 208420,
                    "question_title": "基于UML的需求分析过程的基本步骤为：利用（请作答此空）表示需求；利用（ ）表示目标软件系统的总体架构。",
                    "question_type": 1,
                    "answer_type": 1,
                    "show_type_name": "单选题",
                    "new_parent_id": 208420,
                    "score_rule": "",
                    "material_text": "",
                    "sort_son": "0",
                    "analyze": "<p>在初步的业务需求描述已经形成的前提下，基于UML的需求分析过程大致可分为以下步骤：</p><p>①利用用例及用例图表示需求。从业务需求描述出发获取执行者和场景；对场景进行汇总、分类、抽象，形成用例；确定执行者与用例、用例与用例图之间的关系，生成用例图。</p><p>②利用包图和类图表示目标软件系统的总体框架结构。根据领域知识、业务需求描述和既往经验设计目标软件系统的顶层架构；从业务需求描述中提取“关键概念”，形成领域概念模型；从概念模型和用例出发，研究系统中主要的类之间的关系，生成类图。</p>",
                    "like": 0,
                    "answer": [
                        "A"
                    ],
                    "option": [
                        " 用例及用例图 ",
                        " 包图及类图 ",
                        " 剧情及序列图 ",
                        " 组件图及部署图 "
                    ]
                },
                {
                    "index": 151,
                    "belong_page": 1,
                    "question_id": 208421,
                    "question_title": "基于UML的需求分析过程的基本步骤为：利用（ ）表示需求；利用（请作答此空）表示目标软件系统的总体架构。",
                    "question_type": 1,
                    "answer_type": 1,
                    "show_type_name": "单选题",
                    "new_parent_id": 208421,
                    "score_rule": "",
                    "material_text": "",
                    "sort_son": "0",
                    "analyze": "<p>在初步的业务需求描述已经形成的前提下，基于UML的需求分析过程大致可分为以下步骤：</p><p>①利用用例及用例图表示需求。从业务需求描述出发获取执行者和场景；对场景进行汇总、分类、抽象，形成用例；确定执行者与用例、用例与用例图之间的关系，生成用例图。</p><p>②利用包图和类图表示目标软件系统的总体框架结构。根据领域知识、业务需求描述和既往经验设计目标软件系统的顶层架构；从业务需求描述中提取“关键概念”，形成领域概念模型；从概念模型和用例出发，研究系统中主要的类之间的关系，生成类图。</p>",
                    "like": 0,
                    "answer": [
                        "B"
                    ],
                    "option": [
                        " 用例及用例图 ",
                        " 包图及类图 ",
                        " 剧情及序列图 ",
                        " 组件图及部署图 "
                    ]
                },
                {
                    "index": 152,
                    "belong_page": 1,
                    "question_id": 208428,
                    "question_title": "对于违反里氏替换原则的两个类A和B，可以采用的候选解决方案中，正确的是（ ）。",
                    "question_type": 1,
                    "answer_type": 1,
                    "show_type_name": "单选题",
                    "new_parent_id": 208428,
                    "score_rule": "",
                    "material_text": "",
                    "sort_son": "0",
                    "analyze": "<p>里氏替换原则是面向对象设计原则之一，由Barbara liskov提出，其基本思想是，一个软件实体如果使用的是一个基类对象，那么一定适用于其子类对象，而且觉察不出基类对象和子类对象的区别，即把基类都替换成它的子类，程序的行为没有变化。反过来则不一定成立，如果一个软件实体使用的是一个子类对象，那么它不一定适用于基类对象。</p><p>在运用里氏替换原则时，尽量将一些需要扩展的类或者存在变化的类设计为抽象类或者接口，并将其作为基类，在程序中尽量使用基类对象进行编程。由于子类继承基类并实现其中的方法，程序运行时，子类对象可以替换基类对象，如果需要对类的行为进行修改，可以扩展基类，增加新的子类，而无需修改调用该基类对象的代码。</p>",
                    "like": 0,
                    "answer": [
                        "A"
                    ],
                    "option": [
                        " 尽量将一些需要扩展的类或者存在变化的类设计为抽象类或者接口，并将其作为基类，在程序中尽量使用基类对象进行编程 ",
                        " 创建一个新的抽象类C，作为两个具体类的超类，将A和B共同的行为移动到C中，从而解决A和B行为不完全一致的问题 ",
                        " 将B到A的继承关系改成组合关系 ",
                        " 区分是“Is-a”还是“Has-a”。如果是Is-a，可以使用继承关系，如果是Has-a，应该改成组合或聚合关系 "
                    ]
                },
                {
                    "index": 153,
                    "belong_page": 1,
                    "question_id": 208486,
                    "question_title": "与电子政务相关的行为主体主要有三个，即（ ），政府的业务活动也主要围绕着这三个行为主体展开。",
                    "question_type": 1,
                    "answer_type": 1,
                    "show_type_name": "单选题",
                    "new_parent_id": 208486,
                    "score_rule": "",
                    "material_text": "",
                    "sort_son": "0",
                    "analyze": "在社会中，与电子政务相关的行为主体主要有三个，即政府、企(事)业单位及公民。因此，政府的业务活动也主要围绕着这三个行为主体展开。政府与政府，政府与企(事)业，以及政府与公民之间的互动构成了不同却又相互关联的领域。",
                    "like": 0,
                    "answer": [
                        "D"
                    ],
                    "option": [
                        " 政府、数据及电子政务系统 ",
                        " 政府、企(事)业单位及中介 ",
                        " 政府、服务机构及企事业单位 ",
                        " 政府、企(事)业单位及公民 "
                    ]
                },
                {
                    "index": 154,
                    "belong_page": 1,
                    "question_id": 208487,
                    "question_title": "企业信息化涉及对企业管理理念的创新，按照市场发展的要求，对企业现有的管理流程重新整合，管理核心从对（请作答此空）的管理，转向对（ ）的管理，并延伸到对企业技术创新、工艺设计、产品设计、生产制造过程的管理，进而还要扩展到对（ ）的管理乃至发展到电子商务。",
                    "question_type": 1,
                    "answer_type": 1,
                    "show_type_name": "单选题",
                    "new_parent_id": 208487,
                    "score_rule": "",
                    "material_text": "",
                    "sort_son": "0",
                    "analyze": "企业信息化涉及对企业管理理念的创新，管理流程的优化，管理团队的重组和管理手段的革新。管理创新是按照市场发展的要求，对企业现有的管理流程重新整合，从作为管理核心的财务、物料管理，转向技术、物资、人力资源的管理，并延伸到企业技术创新、工艺设计、产品设计、生产制造过程的管理，进而还要扩展到客户关系管理、供应链管理乃至发展到电子商务。",
                    "like": 0,
                    "answer": [
                        "C"
                    ],
                    "option": [
                        " 人力资源和物资 ",
                        " 信息技术和知识 ",
                        " 财务和物料 ",
                        " 业务流程和数据 "
                    ]
                },
                {
                    "index": 155,
                    "belong_page": 1,
                    "question_id": 208488,
                    "question_title": "企业信息化涉及对企业管理理念的创新，按照市场发展的要求，对企业现有的管理流程重新整合，管理核心从对（ ）的管理，转向对（请作答此空）的管理，并延伸到对企业技术创新、工艺设计、产品设计、生产制造过程的管理，进而还要扩展到对（ ）的管理乃至发展到电子商务。",
                    "question_type": 1,
                    "answer_type": 1,
                    "show_type_name": "单选题",
                    "new_parent_id": 208488,
                    "score_rule": "",
                    "material_text": "",
                    "sort_son": "0",
                    "analyze": "企业信息化涉及对企业管理理念的创新，管理流程的优化，管理团队的重组和管理手段的革新。管理创新是按照市场发展的要求，对企业现有的管理流程重新整合，从作为管理核心的财务、物料管理，转向技术、物资、人力资源的管理，并延伸到企业技术创新、工艺设计、产品设计、生产制造过程的管理，进而还要扩展到客户关系管理、供应链管理乃至发展到电子商务。",
                    "like": 0,
                    "answer": [
                        "D"
                    ],
                    "option": [
                        " 业务流程和数据 ",
                        " 企业信息系统和技术 ",
                        " 业务流程、数据和接口 ",
                        " 技术、物资和人力资源 "
                    ]
                },
                {
                    "index": 156,
                    "belong_page": 1,
                    "question_id": 208489,
                    "question_title": "企业信息化涉及对企业管理理念的创新，按照市场发展的要求，对企业现有的管理流程重新整合，管理核心从对（ ）的管理，转向对（ ）的管理，并延伸到对企业技术创新、工艺设计、产品设计、生产制造过程的管理，进而还要扩展到对（请作答此空）的管理乃至发展到电子商务。",
                    "question_type": 1,
                    "answer_type": 1,
                    "show_type_name": "单选题",
                    "new_parent_id": 208489,
                    "score_rule": "",
                    "material_text": "",
                    "sort_son": "0",
                    "analyze": "企业信息化涉及对企业管理理念的创新，管理流程的优化，管理团队的重组和管理手段的革新。管理创新是按照市场发展的要求，对企业现有的管理流程重新整合，从作为管理核心的财务、物料管理，转向技术、物资、人力资源的管理，并延伸到企业技术创新、工艺设计、产品设计、生产制造过程的管理，进而还要扩展到客户关系管理、供应链管理乃至发展到电子商务。",
                    "like": 0,
                    "answer": [
                        "A"
                    ],
                    "option": [
                        " 客户关系和供应链 ",
                        " 信息技术和知识 ",
                        " 生产技术和信息技术 ",
                        " 信息采集、存储和共享 "
                    ]
                },
                {
                    "index": 157,
                    "belong_page": 1,
                    "question_id": 208490,
                    "question_title": "企业信息集成按照组织范围分为企业内部的信息集成和外部的信息集成。在企业内部的信息集成中，（请作答此空）实现了不同系统之间的互操作，使得不同系统之间能够实现数据和方法的共享；（ ）实现了不同应用系统之间的连接、协调运作和信息共享。",
                    "question_type": 1,
                    "answer_type": 1,
                    "show_type_name": "单选题",
                    "new_parent_id": 208490,
                    "score_rule": "",
                    "material_text": "",
                    "sort_son": "0",
                    "analyze": "企业信息集成是指企业在不同应用系统之间实现数据共享，即实现数据在不同数据格式和存储方式之间的转换、来源不同、形态不一、内容不等的信息资源进行系统分析、辨清正误、消除冗余、合并同类，进而产生具有统一数据形式的有价值信息的过程。企业信息集成是一个十分复杂的问题，按照组织范围来分，分为企业内部的信息集成和外部的信息集成两个方面。按集成内容，企业内部的信息集成一般可分为以下四个方面：技术平台集成，数据集成，应用系统集成和业务过程集成。其中，应用系统集成是实现不同系统之间的互操作，使得不同应用系统之间能够实现数据和方法的共享；业务过程集成使得在不同应用系统中的流程能够无缝连接，实现流程的协调运作和流程信息的充分共享。",
                    "like": 0,
                    "answer": [
                        "C"
                    ],
                    "option": [
                        " 技术平台集成 ",
                        " 数据集成 ",
                        " 应用系统集成 ",
                        " 业务过程集成 "
                    ]
                },
                {
                    "index": 158,
                    "belong_page": 1,
                    "question_id": 208491,
                    "question_title": "企业信息集成按照组织范围分为企业内部的信息集成和外部的信息集成。在企业内部的信息集成中，（ ）实现了不同系统之间的互操作，使得不同系统之间能够实现数据和方法的共享；（请作答此空）实现了不同应用系统之间的连接、协调运作和信息共享。",
                    "question_type": 1,
                    "answer_type": 1,
                    "show_type_name": "单选题",
                    "new_parent_id": 208491,
                    "score_rule": "",
                    "material_text": "",
                    "sort_son": "0",
                    "analyze": "企业信息集成是指企业在不同应用系统之间实现数据共享，即实现数据在不同数据格式和存储方式之间的转换、来源不同、形态不一、内容不等的信息资源进行系统分析、辨清正误、消除冗余、合并同类，进而产生具有统一数据形式的有价值信息的过程。企业信息集成是一个十分复杂的问题，按照组织范围来分，分为企业内部的信息集成和外部的信息集成两个方面。按集成内容，企业内部的信息集成一般可分为以下四个方面：技术平台集成，数据集成，应用系统集成和业务过程集成。其中，应用系统集成是实现不同系统之间的互操作，使得不同应用系统之间能够实现数据和方法的共享；业务过程集成使得在不同应用系统中的流程能够无缝连接，实现流程的协调运作和流程信息的充分共享。",
                    "like": 0,
                    "answer": [
                        "D"
                    ],
                    "option": [
                        " 技术平台集成 ",
                        " 数据集成 ",
                        " 应用系统集成 ",
                        " 业务过程集成 "
                    ]
                },
                {
                    "index": 159,
                    "belong_page": 1,
                    "question_id": 208492,
                    "question_title": "数据挖掘是从数据库的大量数据中揭示出隐含的、先前未知的并有潜在价值的信息的非平凡过程，主要任务有（ ）。",
                    "question_type": 1,
                    "answer_type": 1,
                    "show_type_name": "单选题",
                    "new_parent_id": 208492,
                    "score_rule": "",
                    "material_text": "",
                    "sort_son": "0",
                    "analyze": "数据挖掘是从数据库的大量数据中揭示出隐含的、先前未知的并有潜在价值的信息的非平凡过程，数据挖掘的任务有关联分析、聚类分析、分类分析、异常分析、特异群组分析和演变分析等等。并非所有的信息发现任务都被视为数据挖掘。例如，使用数据库管理系统查找个别的记录，或通过因特网的搜索引擎查找特定的web页面，则是信息检索领域的任务。虽然这些任务是重要的，可能涉及使用复杂的算法和数据结构，但是它们主要依赖传统的计算机科学技术和数据的明显特征来创建索引结构，从而有效地组织和检索信息。",
                    "like": 0,
                    "answer": [
                        "C"
                    ],
                    "option": [
                        " 聚类分析、联机分析、信息检索等 ",
                        " 信息检索、聚类分析、分类分析等 ",
                        " 聚类分析、分类分析、关联规则挖掘等 ",
                        " 分类分析、联机分析、关联规则挖掘等 "
                    ]
                },
                {
                    "index": 160,
                    "belong_page": 1,
                    "question_id": 281203,
                    "question_title": "<p>在数据库设计的需求分析阶段应完成包括______在内的文档。</p>",
                    "question_type": 1,
                    "answer_type": 1,
                    "show_type_name": "单选题",
                    "new_parent_id": 281203,
                    "score_rule": "",
                    "material_text": "",
                    "sort_son": "0",
                    "analyze": "<p>数据库的需求分析的目标是通过调查研究，了解用户的数据和处理要求，并按一定格式整理形成需求说明书。需求说明书包括数据库所涉及的数据、数据的特征、使用频率和数据量的估计，例如，数据名、属性及其类型、主键属性、保密要求、完整性约束条件、更改要求、使用频率和数据量估计等。这些关于数据的数据称为元数据。在设计大型数据库时，这些数据通常由数据字典来管理。用数据字典管理元数据，有利于避免数据的重复或重名，以保持数据的一致性。同时，有利于提高数据库设计的质量，减轻设计者的负担。</p>",
                    "like": 0,
                    "answer": [
                        "C"
                    ],
                    "option": [
                        " E-R图 ",
                        " 关系模式 ",
                        " 数据字典和数据流图 ",
                        " 任务书和设计方案 "
                    ]
                },
                {
                    "index": 161,
                    "belong_page": 1,
                    "question_id": 281208,
                    "question_title": "<p>雇员类含有计算报酬的行为，利用面向对象的（ ），可以使得其派生类专职雇员类和兼职雇员类计算报酬的行为有相同的名称，但有不同的计算方法。</p>",
                    "question_type": 1,
                    "answer_type": 1,
                    "show_type_name": "单选题",
                    "new_parent_id": 281208,
                    "score_rule": "",
                    "material_text": "",
                    "sort_son": "0",
                    "analyze": "<p>在面向对象技术中，多态考虑的是类与类之间的层次关系，以及类自身内部特定成员函数之间的关系问题，是解决功能和行为的再抽象问题。多态是指类中具有相似功能的不同函数用同一个名称来实现，从而可以使用相同的调用方式来调用这些具有不同功能的同名函数。这也是人类思维方式的一种直接模拟，例如，一个对象中有很多求两个数最大值的行为，虽然可以针对不同的数据类型，写很多不同名称的函数来实现，但事实上，它们的功能几乎完全相同。这时，就可以利用多态的特征，用统一的标识来完成这些功能。这样，就可以达到类的行为的再抽象，进而统一标识，减少程序中标识符的个数。</p>",
                    "like": 0,
                    "answer": [
                        "A"
                    ],
                    "option": [
                        " 多态性 ",
                        " 继承性 ",
                        " 封装性 ",
                        " 复用性 "
                    ]
                },
                {
                    "index": 162,
                    "belong_page": 1,
                    "question_id": 281209,
                    "question_title": "<p>基于SOA和Web Service技术的企业应用集成(EAI)模式是______。</p>",
                    "question_type": 1,
                    "answer_type": 1,
                    "show_type_name": "单选题",
                    "new_parent_id": 281209,
                    "score_rule": "",
                    "material_text": "",
                    "sort_son": "0",
                    "analyze": "<p>面向信息的集成技术采用的主要数据处理技术有数据复制、数据聚合和接口集成等。其中，接口集成仍然是一种主流技术。它通过一种集成代理的方式实现集成，即为应用系统创建适配器作为自己的代理，适配器通过其开放或私有接口将信息从应用系统中提取出来，并通过开放接口与外界系统实现信息交互，而假如适配器的结构支持一定的标准，则将极大地简化集成的复杂度，并有助于标准化，这也是面向接口集成方法的主要优势来源。标准化的适配器技术可以使企业从第三方供应商获取适配器，从而使集成技术简单化。</p><p>面向过程的集成技术其实是一种过程流集成的思想，它不需要处理用户界面开发、数据库逻辑、事务逻辑等，而只是处理系统之间的过程逻辑和核心业务逻辑相分离。在结构上，面向过程的集成方法在面向接口的集成方案之上，定义了另外的过程逻辑层；而在该结构的底层，应用服务器、消息中间件提供了支持数据传输和跨过程协调的基础服务。对于提供集成代理、消息中间件及应用服务器的厂商来说，提供用于业务过程集成是对其产品的重要拓展，也是目前应用集成市场的重要需求。</p><p>基于SOA(面向服务的架构)和Web Services技术的面向服务的集成技术是业务集成技术上的一次重要的变化，被认为是新一代的应用集成技术。集成的对象是一个个的Web服务或者是封装成Web服务的业务处理。Web Serices技术由于是基于最广为接受的、开放的技术标准(如HTTP、XML等)，支持服务接口描述和服务处理的分离、服务描述的集中化存储和发布、服务的自动查找和动态绑定及服务的组合，成为新一代面向服务的应用系统的构建和应用系统集成的基础设施。</p>",
                    "like": 0,
                    "answer": [
                        "D"
                    ],
                    "option": [
                        " 面向信息的集成技术 ",
                        " 面向过程的集成技术 ",
                        " 面向计划的集成技术 ",
                        " 面向服务的集成技术 "
                    ]
                },
                {
                    "index": 163,
                    "belong_page": 1,
                    "question_id": 281210,
                    "question_title": "<p>逆向工程导出的信息分为4个抽象层次。使用用户指导下的搜索与变换(User-Directed Search and Transformation)方法可导出______信息。</p>",
                    "question_type": 1,
                    "answer_type": 1,
                    "show_type_name": "单选题",
                    "new_parent_id": 281210,
                    "score_rule": "",
                    "material_text": "",
                    "sort_son": "0",
                    "analyze": "<p><br/></p><p>逆向工程导</p><img style=\"max-width:100%;height:auto\"  src=\"https://s2.51cto.com/images/20200912/1599877940247403.jpg\" title=\"1599877940247403.jpg\" alt=\"1.jpg\"/>",
                    "like": 0,
                    "answer": [
                        "B"
                    ],
                    "option": [
                        " 实现级和功能级 ",
                        " 实现级和结构级 ",
                        " 功能级和领域级 ",
                        " 结构级和领域级 "
                    ]
                },
                {
                    "index": 164,
                    "belong_page": 1,
                    "question_id": 281343,
                    "question_title": "<p>用户界面设计的“黄金规则”不包含______。</p>",
                    "question_type": 1,
                    "answer_type": 1,
                    "show_type_name": "单选题",
                    "new_parent_id": 281343,
                    "score_rule": "",
                    "material_text": "",
                    "sort_son": "0",
                    "analyze": "<p>Theo MandeI在关于界而设计的著作中，提出了3条“黄金规则”，即①置用户于控制之下；②减少用户的记忆负担；③保持界面一致性。这些黄金规则实际上形成了用于指导人机界面设计活动的一组设计原则的基础。</p>",
                    "like": 0,
                    "answer": [
                        "A"
                    ],
                    "option": [
                        " 为用户提供更多的信息和功能 ",
                        " 减少用户的记忆负担 ",
                        " 保持界面一致性 ",
                        " 置用户于控制之下 "
                    ]
                },
                {
                    "index": 165,
                    "belong_page": 1,
                    "question_id": 281631,
                    "question_title": "软件设计包括了四个既独立又相互联系的活动：高质量的（ ）将改善程序结构和模块划分，降低过程复杂性；（ ）的主要目标是开发一个模块化的程序结构，并表示出模块间的控制关系；（ ）描述了软件与用户之间的交互关系。",
                    "question_type": 9,
                    "answer_type": 1,
                    "show_type_name": "单选题",
                    "new_parent_id": 281630,
                    "score_rule": "",
                    "material_text": null,
                    "sort_son": "1",
                    "analyze": "<p>软件设计包括体系结构设计、接口设计、数据设计和过程设计。</p><p>结构设计：定义软件系统各主要部件之间的关系。</p><p>数据设计：将模型转换成数据结构的定义。好的数据设计将改善程序结构和模块划分，降低过程复杂性。</p><p>接口设计（人机界面设计）：软件内部，软件和操作系统间以及软件和人之间如何通信。</p><p>过程设计：系统结构部件转换成软件的过程描述。</p>",
                    "like": 0,
                    "answer": [
                        "B"
                    ],
                    "option": [
                        "程序设计",
                        "数据设计",
                        "算法设计",
                        "过程设计"
                    ]
                },
                {
                    "index": 166,
                    "belong_page": 1,
                    "question_id": 281632,
                    "question_title": "软件设计包括了四个既独立又相互联系的活动：高质量的（ ）将改善程序结构和模块划分，降低过程复杂性；（ ）的主要目标是开发一个模块化的程序结构，并表示出模块间的控制关系；（ ）描述了软件与用户之间的交互关系。",
                    "question_type": 9,
                    "answer_type": 1,
                    "show_type_name": "单选题",
                    "new_parent_id": 281630,
                    "score_rule": "",
                    "material_text": null,
                    "sort_son": "2",
                    "analyze": "<p>软件设计包括体系结构设计、接口设计、数据设计和过程设计。</p><p>结构设计：定义软件系统各主要部件之间的关系。</p><p>数据设计：将模型转换成数据结构的定义。好的数据设计将改善程序结构和模块划分，降低过程复杂性。</p><p>接口设计（人机界面设计）：软件内部，软件和操作系统间以及软件和人之间如何通信。</p><p>过程设计：系统结构部件转换成软件的过程描述。</p>",
                    "like": 0,
                    "answer": [
                        "A"
                    ],
                    "option": [
                        "软件结构设计",
                        "数据结构设计",
                        "数据流设计",
                        "分布式设计"
                    ]
                },
                {
                    "index": 167,
                    "belong_page": 1,
                    "question_id": 281633,
                    "question_title": "软件设计包括了四个既独立又相互联系的活动：高质量的（ ）将改善程序结构和模块划分，降低过程复杂性；（ ）的主要目标是开发一个模块化的程序结构，并表示出模块间的控制关系；（ ）描述了软件与用户之间的交互关系。",
                    "question_type": 9,
                    "answer_type": 1,
                    "show_type_name": "单选题",
                    "new_parent_id": 281630,
                    "score_rule": "",
                    "material_text": null,
                    "sort_son": "3",
                    "analyze": "<p>软件设计包括体系结构设计、接口设计、数据设计和过程设计。</p><p>结构设计：定义软件系统各主要部件之间的关系。</p><p>数据设计：将模型转换成数据结构的定义。好的数据设计将改善程序结构和模块划分，降低过程复杂性。</p><p>接口设计（人机界面设计）：软件内部，软件和操作系统间以及软件和人之间如何通信。</p><p>过程设计：系统结构部件转换成软件的过程描述。</p>",
                    "like": 0,
                    "answer": [
                        "D"
                    ],
                    "option": [
                        "数据架构设计",
                        "模块化设计",
                        "性能设计",
                        "人机界面设计"
                    ]
                },
                {
                    "index": 168,
                    "belong_page": 1,
                    "question_id": 281634,
                    "question_title": "在面向对象设计的原则中，（ ）原则是指抽象不应该依赖于细节，细节应该依赖于抽象，即应针对接口编程，而不是针对实现编程。",
                    "question_type": 1,
                    "answer_type": 1,
                    "show_type_name": "单选题",
                    "new_parent_id": 281634,
                    "score_rule": "",
                    "material_text": "",
                    "sort_son": "0",
                    "analyze": "要依赖于抽象，不是具体实践。对接口进行编程，不要对实现编程。",
                    "like": 0,
                    "answer": [
                        "D"
                    ],
                    "option": [
                        "开闭",
                        "里氏替换",
                        "最少知识",
                        "依赖倒置"
                    ]
                },
                {
                    "index": 169,
                    "belong_page": 1,
                    "question_id": 281635,
                    "question_title": "<p>概要设计文档的内容不包括( )。</p>",
                    "question_type": 1,
                    "answer_type": 1,
                    "show_type_name": "单选题",
                    "new_parent_id": 281635,
                    "score_rule": "",
                    "material_text": "",
                    "sort_son": "0",
                    "analyze": "<p>本题主要考查软件设计过程相关知识。<br/>概要设计内容包含软件结构设计、数据设计、接口设计、过程设计四个方面，而模块内算法设计是详细设计的主要内容之一。</p>",
                    "like": 0,
                    "answer": [
                        "C"
                    ],
                    "option": [
                        " 体系结构设计 ",
                        " 数据库设计 ",
                        " 模块内算法设计 ",
                        " 逻辑数据结构设计 "
                    ]
                },
                {
                    "index": 170,
                    "belong_page": 1,
                    "question_id": 283637,
                    "question_title": "<p>在一个典型的电子商务应用中，三层架构(即表现层、商业逻辑层和数据访问层)常常是架构师的首选。常见的电子商务应用——网上书城的主要功能是提供在线的各种图书信息的查询和浏览，并且能够订购相关图书。用户可能频繁地进行书目查询操作，网站需要返回众多符合条件的书目并且分页显示；网站管理员需要批量对相关书目信息进行修改，并且将更新信息记录到数据库。针对前一个应用要求，架构师在数据访问层设计时，最可能考虑采用______；针对后一个应用要求，架构师最可能考虑采用______。</p>",
                    "question_type": 9,
                    "answer_type": 1,
                    "show_type_name": "单选题",
                    "new_parent_id": 283636,
                    "score_rule": "",
                    "material_text": null,
                    "sort_son": "1",
                    "analyze": "<p>在线访问模式、Data Access Object模式、Data Transfer Object模式、离线数据模式和对象/关系映射(Object/Relation Mapping)模式是数据持久层(数据访问层)架构设计中常用的数据访问模式。</p><p>在网上书城应用中，用户根据查询条件查询相关的书目，返回符合条件的书目列表，可能内容非常多，而且可能每次查询的内容都不一样。针对用户书目查询的应用，如果查询返回的数据量并不是很大，同时也不频繁，则可以考虑采用在线访问的模式；如果返回的数据量较大(例如返回众多符合条件的书目并且分页显示)而且较为频繁，则可以考虑在线访问模式和离线模式相结合，通过离线数据的缓存来提高查询的性能。</p><p>网站管理员可能需要批量对相关书目信息进行修改，并且需要将更新信息返回至数据库。此类数据应用的特点表现为：与数据库交互的次数并不频繁，但是每次的数据量相对较大；同时，也希望能够使得本地操作有较好的交互体验。针对这种情况，往往适合采用离线数据访问的模式，DT0模式也是不错的选择。如果该网上书城应用系统采用的是IBM WebSphere平台，则可以使用SDO技术，或者使用Java中的CachedRowSet技术；如果采用的是基于微软的应用系统平台，则可以采用ADO.NET技术。</p>",
                    "like": 0,
                    "answer": [
                        "B"
                    ],
                    "option": [
                        "在线访问模式和DAO模式相结合",
                        "在线访问模式和离线数据模式相结合",
                        "DAO模式和DTO模式相结合",
                        "DTO模式和O/R映射模式相结合"
                    ]
                },
                {
                    "index": 171,
                    "belong_page": 1,
                    "question_id": 283638,
                    "question_title": "<p>在一个典型的电子商务应用中，三层架构(即表现层、商业逻辑层和数据访问层)常常是架构师的首选。常见的电子商务应用——网上书城的主要功能是提供在线的各种图书信息的查询和浏览，并且能够订购相关图书。用户可能频繁地进行书目查询操作，网站需要返回众多符合条件的书目并且分页显示；网站管理员需要批量对相关书目信息进行修改，并且将更新信息记录到数据库。针对前一个应用要求，架构师在数据访问层设计时，最可能考虑采用______；针对后一个应用要求，架构师最可能考虑采用______。</p>",
                    "question_type": 9,
                    "answer_type": 1,
                    "show_type_name": "单选题",
                    "new_parent_id": 283636,
                    "score_rule": "",
                    "material_text": null,
                    "sort_son": "2",
                    "analyze": "<p>在线访问模式、Data Access Object模式、Data Transfer Object模式、离线数据模式和对象/关系映射(Object/Relation Mapping)模式是数据持久层(数据访问层)架构设计中常用的数据访问模式。</p><p>在网上书城应用中，用户根据查询条件查询相关的书目，返回符合条件的书目列表，可能内容非常多，而且可能每次查询的内容都不一样。针对用户书目查询的应用，如果查询返回的数据量并不是很大，同时也不频繁，则可以考虑采用在线访问的模式；如果返回的数据量较大(例如返回众多符合条件的书目并且分页显示)而且较为频繁，则可以考虑在线访问模式和离线模式相结合，通过离线数据的缓存来提高查询的性能。</p><p>网站管理员可能需要批量对相关书目信息进行修改，并且需要将更新信息返回至数据库。此类数据应用的特点表现为：与数据库交互的次数并不频繁，但是每次的数据量相对较大；同时，也希望能够使得本地操作有较好的交互体验。针对这种情况，往往适合采用离线数据访问的模式，DT0模式也是不错的选择。如果该网上书城应用系统采用的是IBM WebSphere平台，则可以使用SDO技术，或者使用Java中的CachedRowSet技术；如果采用的是基于微软的应用系统平台，则可以采用ADO.NET技术。</p>",
                    "like": 0,
                    "answer": [
                        "C"
                    ],
                    "option": [
                        "在线访问模式",
                        "DAO模式",
                        "离线数据模式",
                        "O/R映射模式"
                    ]
                },
                {
                    "index": 172,
                    "belong_page": 1,
                    "question_id": 283643,
                    "question_title": "<p>在RUP中采用“4+1”视图模型来描述软件系统的体系结构。在该模型中，最终用户侧重于（），系统工程师侧重于（）。</p>",
                    "question_type": 9,
                    "answer_type": 1,
                    "show_type_name": "单选题",
                    "new_parent_id": 283642,
                    "score_rule": "",
                    "material_text": null,
                    "sort_son": "1",
                    "analyze": "<p>在RUP中采用“4+1”视图模型来描述软件系统的体系结构。“4+1”视图包括逻辑视图、实现视图、进程视图、部署视图和用例视图。</p><p>分析人员和测试人员关心的是系统的行为，因此会侧重于用例视图；最终用户关心的是系统的功能，因此会侧重于逻辑视图；程序员关心的是系统的配置、装配等问题，因此会侧重于实现视图；系统集成人员关心的是系统的性能、可伸缩性、吞吐率等问题，因此会侧重于进程视图；系统工程师关心的是系统的发布、安装、拓扑结构等问题，因此会侧重于部署视图。</p>",
                    "like": 0,
                    "answer": [
                        "C"
                    ],
                    "option": [
                        "实现视图",
                        "进程视图",
                        "逻辑视图",
                        "部署视图"
                    ]
                },
                {
                    "index": 173,
                    "belong_page": 1,
                    "question_id": 283644,
                    "question_title": "<p>在RUP中采用“4+1”视图模型来描述软件系统的体系结构。在该模型中，最终用户侧重于（），系统工程师侧重于（）。</p>",
                    "question_type": 9,
                    "answer_type": 1,
                    "show_type_name": "单选题",
                    "new_parent_id": 283642,
                    "score_rule": "",
                    "material_text": null,
                    "sort_son": "2",
                    "analyze": "<p>在RUP中采用“4+1”视图模型来描述软件系统的体系结构。“4+1”视图包括逻辑视图、实现视图、进程视图、部署视图和用例视图。</p><p>分析人员和测试人员关心的是系统的行为，因此会侧重于用例视图；最终用户关心的是系统的功能，因此会侧重于逻辑视图；程序员关心的是系统的配置、装配等问题，因此会侧重于实现视图；系统集成人员关心的是系统的性能、可伸缩性、吞吐率等问题，因此会侧重于进程视图；系统工程师关心的是系统的发布、安装、拓扑结构等问题，因此会侧重于部署视图。</p>",
                    "like": 0,
                    "answer": [
                        "D"
                    ],
                    "option": [
                        "实现视图",
                        "进程视图",
                        "逻辑视图",
                        "部署视图"
                    ]
                },
                {
                    "index": 174,
                    "belong_page": 1,
                    "question_id": 284657,
                    "question_title": "<p>“4+1”视图主要用于描述系统逻辑架构，最早由Philippe Kruchten于1995年提出。其中（16）视图用于描述对象模型，并说明系统应该为用户提供哪些服务。当采用面向对象的设计方法描述对象模型时，通常使用（17）表达类的内部属性和行为，以及类集合之间的交互关系；采用（18）定义对象的内部行为。</p>",
                    "question_type": 9,
                    "answer_type": 1,
                    "show_type_name": "单选题",
                    "new_parent_id": 284656,
                    "score_rule": "",
                    "material_text": null,
                    "sort_son": "1",
                    "analyze": "<p>“4+1”视图是对逻辑架构进行描述，最早由Philippe Kruchten提出，他在1995年的IEEE Software上发表了题为The 4+1 View Model of Architecture的论文，引起了业界的极大关注，并最终被RUP采纳，现在已经成为架构设计的结构标准。“4+1”视图主要包括：</p><p>①逻辑视图(Logical View)，设计的对象模型(使用面向对象的设计方法时)。</p><p>②过程视图(Process View)，捕捉设计的并发和同步特征。</p><p>③物理视图(Physical View)，描述了软件到硬件的映射，反映了分布式特性。</p><p>④开发视图(Development View)，描述了在开发环境中软件的静态组织结构。</p><p>⑤架构的描述，即所做的各种决定，可以围绕着这四个视图来组织，然后由一些用例(Use Cases)或场景(Scenarios)来说明，从而形成了第五个视图。</p><p>当采用面向对象的设计方法描述对象模型时，通常使用类图表达类的内部属性和行为，以及类集合之间的交互关系；采用状态图定义对象的内部行为。</p>",
                    "like": 0,
                    "answer": [
                        "A"
                    ],
                    "option": [
                        "逻辑",
                        "过程",
                        "开发",
                        "物理"
                    ]
                },
                {
                    "index": 175,
                    "belong_page": 1,
                    "question_id": 284658,
                    "question_title": "<p>“4+1”视图主要用于描述系统逻辑架构，最早由Philippe Kruchten于1995年提出。其中（16）视图用于描述对象模型，并说明系统应该为用户提供哪些服务。当采用面向对象的设计方法描述对象模型时，通常使用（17）表达类的内部属性和行为，以及类集合之间的交互关系；采用（18）定义对象的内部行为。</p>",
                    "question_type": 9,
                    "answer_type": 1,
                    "show_type_name": "单选题",
                    "new_parent_id": 284656,
                    "score_rule": "",
                    "material_text": null,
                    "sort_son": "2",
                    "analyze": "<p>“4+1”视图是对逻辑架构进行描述，最早由Philippe Kruchten提出，他在1995年的IEEE Software上发表了题为The 4+1 View Model of Architecture的论文，引起了业界的极大关注，并最终被RUP采纳，现在已经成为架构设计的结构标准。“4+1”视图主要包括：</p><p>①逻辑视图(Logical View)，设计的对象模型(使用面向对象的设计方法时)。</p><p>②过程视图(Process View)，捕捉设计的并发和同步特征。</p><p>③物理视图(Physical View)，描述了软件到硬件的映射，反映了分布式特性。</p><p>④开发视图(Development View)，描述了在开发环境中软件的静态组织结构。</p><p>⑤架构的描述，即所做的各种决定，可以围绕着这四个视图来组织，然后由一些用例(Use Cases)或场景(Scenarios)来说明，从而形成了第五个视图。</p><p>当采用面向对象的设计方法描述对象模型时，通常使用类图表达类的内部属性和行为，以及类集合之间的交互关系；采用状态图定义对象的内部行为。</p>",
                    "like": 0,
                    "answer": [
                        "D"
                    ],
                    "option": [
                        "对象图",
                        "活动图",
                        "状态图",
                        "类图"
                    ]
                },
                {
                    "index": 176,
                    "belong_page": 1,
                    "question_id": 284659,
                    "question_title": "<p>“4+1”视图主要用于描述系统逻辑架构，最早由Philippe Kruchten于1995年提出。其中（16）视图用于描述对象模型，并说明系统应该为用户提供哪些服务。当采用面向对象的设计方法描述对象模型时，通常使用（17）表达类的内部属性和行为，以及类集合之间的交互关系；采用（18）定义对象的内部行为。</p>",
                    "question_type": 9,
                    "answer_type": 1,
                    "show_type_name": "单选题",
                    "new_parent_id": 284656,
                    "score_rule": "",
                    "material_text": null,
                    "sort_son": "3",
                    "analyze": "<p>“4+1”视图是对逻辑架构进行描述，最早由Philippe Kruchten提出，他在1995年的IEEE Software上发表了题为The 4+1 View Model of Architecture的论文，引起了业界的极大关注，并最终被RUP采纳，现在已经成为架构设计的结构标准。“4+1”视图主要包括：</p><p>①逻辑视图(Logical View)，设计的对象模型(使用面向对象的设计方法时)。</p><p>②过程视图(Process View)，捕捉设计的并发和同步特征。</p><p>③物理视图(Physical View)，描述了软件到硬件的映射，反映了分布式特性。</p><p>④开发视图(Development View)，描述了在开发环境中软件的静态组织结构。</p><p>⑤架构的描述，即所做的各种决定，可以围绕着这四个视图来组织，然后由一些用例(Use Cases)或场景(Scenarios)来说明，从而形成了第五个视图。</p><p>当采用面向对象的设计方法描述对象模型时，通常使用类图表达类的内部属性和行为，以及类集合之间的交互关系；采用状态图定义对象的内部行为。</p>",
                    "like": 0,
                    "answer": [
                        "C"
                    ],
                    "option": [
                        "对象图",
                        "活动图",
                        "状态图",
                        "类图"
                    ]
                },
                {
                    "index": 177,
                    "belong_page": 1,
                    "question_id": 284698,
                    "question_title": "<p>用户界面设计的“黄金规则”不包含_____。</p>",
                    "question_type": 1,
                    "answer_type": 1,
                    "show_type_name": "单选题",
                    "new_parent_id": 284698,
                    "score_rule": "",
                    "material_text": "",
                    "sort_son": "0",
                    "analyze": "<p>Theo MandeI在关于界而设计的著作中，提出了3条“黄金规则”，即①置用户于控制之下；②减少用户的记忆负担；③保持界面一致性。这些黄金规则实际上形成了用于指导人机界面设计活动的一组设计原则的基础。</p>",
                    "like": 0,
                    "answer": [
                        "A"
                    ],
                    "option": [
                        " 为用户提供更多的信息和功能 ",
                        " 减少用户的记忆负担 ",
                        " 保持界面一致性 ",
                        " 置用户于控制之下 "
                    ]
                },
                {
                    "index": 178,
                    "belong_page": 1,
                    "question_id": 302378,
                    "question_title": "安全攸关系统在软件需求分析阶段，应提出安全性需求。软件安全性需求是指通过约束软件的行为，使其不会出现 （9）。软件安全需求的获取是根据己知的 （10） ，如软件危害条件等以及其他一些类似的系统数据和通用惯例，完成通用软件安全性需求的裁剪和特定软件安全性需求的获取工作。",
                    "question_type": 9,
                    "answer_type": 1,
                    "show_type_name": "单选题",
                    "new_parent_id": 302377,
                    "score_rule": "",
                    "material_text": null,
                    "sort_son": "1",
                    "analyze": "<p>生命攸关系统是指一个系统的失效或误动作会产生诸如：人员重伤或死亡，或者设备的严重毁损，或者环境的危害。</p><p>通常在开发安全做关软件时，需求分析阶段必须考虑安全性需求，使其不会出现不可接受的违反系统安全的行为需求。</p><p>软件安全需求的获取是根据已知的系统信息，如：软件危害条件等以及其他一些类似的系统数据和通用惯例，完成通用软件安全性需求的裁剪和特定软件安全性需求的获取工作。</p>",
                    "like": 0,
                    "answer": [
                        "C"
                    ],
                    "option": [
                        "不可接受的系统安全的行为",
                        "有可能影响系统可靠性的行为",
                        "不可接受的违反系统安全的行为",
                        "系统不安全的事故"
                    ]
                },
                {
                    "index": 179,
                    "belong_page": 1,
                    "question_id": 302379,
                    "question_title": "安全攸关系统在软件需求分析阶段，应提出安全性需求。软件安全性需求是指通过约束软件的行为，使其不会出现 （9）。软件安全需求的获取是根据己知的 （10） ，如软件危害条件等以及其他一些类似的系统数据和通用惯例，完成通用软件安全性需求的裁剪和特定软件安全性需求的获取工作。",
                    "question_type": 9,
                    "answer_type": 1,
                    "show_type_name": "单选题",
                    "new_parent_id": 302377,
                    "score_rule": "",
                    "material_text": null,
                    "sort_son": "2",
                    "analyze": "<p>生命攸关系统是指一个系统的失效或误动作会产生诸如：人员重伤或死亡，或者设备的严重毁损，或者环境的危害。</p><p>通常在开发安全做关软件时，需求分析阶段必须考虑安全性需求，使其不会出现不可接受的违反系统安全的行为需求。</p><p>软件安全需求的获取是根据已知的系统信息，如：软件危害条件等以及其他一些类似的系统数据和通用惯例，完成通用软件安全性需求的裁剪和特定软件安全性需求的获取工作。</p>",
                    "like": 0,
                    "answer": [
                        "A"
                    ],
                    "option": [
                        "系统信息",
                        "系统属性",
                        "软件属性",
                        "代码信息"
                    ]
                },
                {
                    "index": 180,
                    "belong_page": 1,
                    "question_id": 303642,
                    "question_title": "通常用户采用评价程序来评价系统的性能，评测准确度最高的评价程序是 （16） 。在计算机性能评估中，通常将评价程序中用得最多、最频繁的 （17）作为评价计算机性能的标准程序，称其为基准测试程序。",
                    "question_type": 9,
                    "answer_type": 1,
                    "show_type_name": "单选题",
                    "new_parent_id": 303641,
                    "score_rule": "",
                    "material_text": null,
                    "sort_son": "1",
                    "analyze": "通常用户采用评价程序来评价系统的性能。评价程序一般有专门的测量程序、仿真程序等，而评测准确度最高的评价程序是真实程序。在计算机性能评估中，通常将评价程序中用得最多、最频繁的那部分核心程序作为评价计算机性能的标准程序，称其为基准测试程序。",
                    "like": 0,
                    "answer": [
                        "A"
                    ],
                    "option": [
                        "真实程序",
                        "核心程序",
                        "小型基准程序",
                        "核心基准程序"
                    ]
                },
                {
                    "index": 181,
                    "belong_page": 1,
                    "question_id": 303643,
                    "question_title": "通常用户采用评价程序来评价系统的性能，评测准确度最高的评价程序是 （16） 。在计算机性能评估中，通常将评价程序中用得最多、最频繁的 （17）作为评价计算机性能的标准程序，称其为基准测试程序。",
                    "question_type": 9,
                    "answer_type": 1,
                    "show_type_name": "单选题",
                    "new_parent_id": 303641,
                    "score_rule": "",
                    "material_text": null,
                    "sort_son": "2",
                    "analyze": "通常用户采用评价程序来评价系统的性能。评价程序一般有专门的测量程序、仿真程序等，而评测准确度最高的评价程序是真实程序。在计算机性能评估中，通常将评价程序中用得最多、最频繁的那部分核心程序作为评价计算机性能的标准程序，称其为基准测试程序。",
                    "like": 0,
                    "answer": [
                        "B"
                    ],
                    "option": [
                        "真实程序",
                        "核心程序",
                        "核心基准程序",
                        "小型基准程序"
                    ]
                },
                {
                    "index": 182,
                    "belong_page": 1,
                    "question_id": 303654,
                    "question_title": "需求变更管理是需求管理的重要内容。需求变更管理的过程主要包括问题分析和变更描述、（24） 、变更实现。具体来说，在关于需求变更管理的描述中， （25） 是不正确的。",
                    "question_type": 9,
                    "answer_type": 1,
                    "show_type_name": "单选题",
                    "new_parent_id": 303653,
                    "score_rule": "",
                    "material_text": null,
                    "sort_son": "1",
                    "analyze": "需求变更管理是需求管理的重要内容。需求变更管理的过程主要包括问题分析和变更描述、变更分析和成本计算、变更实现。 具体来说，需求变更是因为需求发生变化根据软件工程思想，需求说明书一般要经过论证，如果在需求说明书经过论证以后，需要在原有需求基础上追加和补充新的需求或对原有需求进行修改和削减，均属于需求变更。因此，需求变更必然会带来相应的问题，绝不是百利无一害的。",
                    "like": 0,
                    "answer": [
                        "D"
                    ],
                    "option": [
                        "变更调研",
                        "变更判定",
                        "变更定义",
                        "变更分析和成本计算"
                    ]
                },
                {
                    "index": 183,
                    "belong_page": 1,
                    "question_id": 303655,
                    "question_title": "需求变更管理是需求管理的重要内容。需求变更管理的过程主要包括问题分析和变更描述、（24） 、变更实现。具体来说，在关于需求变更管理的描述中， （25） 是不正确的。",
                    "question_type": 9,
                    "answer_type": 1,
                    "show_type_name": "单选题",
                    "new_parent_id": 303653,
                    "score_rule": "",
                    "material_text": null,
                    "sort_son": "2",
                    "analyze": "需求变更管理是需求管理的重要内容。需求变更管理的过程主要包括问题分析和变更描述、变更分析和成本计算、变更实现。 具体来说，需求变更是因为需求发生变化根据软件工程思想，需求说明书一般要经过论证，如果在需求说明书经过论证以后，需要在原有需求基础上追加和补充新的需求或对原有需求进行修改和削减，均属于需求变更。因此，需求变更必然会带来相应的问题，绝不是百利无一害的。",
                    "like": 0,
                    "answer": [
                        "B"
                    ],
                    "option": [
                        "需求变更要进行控制，严格防止因失控而导致项目混乱，出现重大风险",
                        "需求变更对软件项目开发有利无弊",
                        "需求变更通常按特定的流程进行",
                        "在需求变更中，变更审批由CCB负责审批"
                    ]
                },
                {
                    "index": 184,
                    "belong_page": 1,
                    "question_id": 303666,
                    "question_title": "软件结构化设计包括 （33） 等任务。",
                    "question_type": 1,
                    "answer_type": 1,
                    "show_type_name": "单选题",
                    "new_parent_id": 303666,
                    "score_rule": "",
                    "material_text": "",
                    "sort_son": "0",
                    "analyze": "软件结构化设计包括架构设计、接口设计、数据设计和过程设计等任务。它是一种面向数据流的设计方法，是以结构化分析阶段所产生的成果为基础，进一步自顶而下、逐步求精和模块化的过程。",
                    "like": 0,
                    "answer": [
                        "D"
                    ],
                    "option": [
                        "架构设计、数据设计、过程设计、原型设计",
                        "架构设计、过程设计、程序设计、原型设计",
                        "数据设计、过程设计、交互设计、程序设计",
                        "架构设计、接口设计、数据设计、过程设计"
                    ]
                },
                {
                    "index": 185,
                    "belong_page": 1,
                    "question_id": 303667,
                    "question_title": "关于模块化设计， （34） 是错误的。",
                    "question_type": 1,
                    "answer_type": 1,
                    "show_type_name": "单选题",
                    "new_parent_id": 303667,
                    "score_rule": "",
                    "material_text": "",
                    "sort_son": "0",
                    "analyze": "模块化设计是将一个待开发的软件分解成为若干小的简单部分——模块。具体来说，模块是指执行某一特定任务的数据结构和程序代码。通常将模块的结构和功能定义为其外部特性，将模块的局部数据和实现该模块的程序代码称为内部特性。模块独立是指每个模块完成相对独立的特定子功能，与其他模块之间的关系最简单。通常用内聚和耦合两个标准来衡量模块的独立性，其设计原则是”高内聚、低耦合”。",
                    "like": 0,
                    "answer": [
                        "B"
                    ],
                    "option": [
                        "模块是指执行某一特定任务的数据结构和程序代码",
                        "模块的接口和功能定义属于其模块自身的内部特性",
                        "每个模块完成相对独立的特定子功能，与其他模块之间的关系最简单",
                        "模块设计的重要原则是高内聚、低耦合"
                    ]
                },
                {
                    "index": 186,
                    "belong_page": 1,
                    "question_id": 310863,
                    "question_title": "（30）可用于描述数据流图中数据存储及其之间的关系，最初用于数据库概念设计。在某学生选课系统中使用该工具来描述，学生的学号属于（31）。",
                    "question_type": 9,
                    "answer_type": 1,
                    "show_type_name": "单选题",
                    "new_parent_id": 310862,
                    "score_rule": "",
                    "material_text": null,
                    "sort_son": "1",
                    "analyze": "实体联系图（ER）图可用于描述数据流图中数据存储及其之间的关系，最初用干数据库概念设计。在实体联系图中，有实体、联系和属性三个基本成分。在某学生选课系统中，学生属于实体，而学生的学号则属于该实体的属性。",
                    "like": 0,
                    "answer": [
                        "A"
                    ],
                    "option": [
                        "实体关系图",
                        "数据字典",
                        "IPO图",
                        "判定表"
                    ]
                },
                {
                    "index": 187,
                    "belong_page": 1,
                    "question_id": 310864,
                    "question_title": "（30）可用于描述数据流图中数据存储及其之间的关系，最初用于数据库概念设计。在某学生选课系统中使用该工具来描述，学生的学号属于（31）。",
                    "question_type": 9,
                    "answer_type": 1,
                    "show_type_name": "单选题",
                    "new_parent_id": 310862,
                    "score_rule": "",
                    "material_text": null,
                    "sort_son": "2",
                    "analyze": "实体联系图（ER）图可用于描述数据流图中数据存储及其之间的关系，最初用干数据库概念设计。在实体联系图中，有实体、联系和属性三个基本成分。在某学生选课系统中，学生属于实体，而学生的学号则属于该实体的属性。",
                    "like": 0,
                    "answer": [
                        "C"
                    ],
                    "option": [
                        "实体",
                        "关系",
                        "属性",
                        "方法"
                    ]
                },
                {
                    "index": 188,
                    "belong_page": 1,
                    "question_id": 315921,
                    "question_title": "从信息化建设的角度出发，以下说法错误的是(19)",
                    "question_type": 1,
                    "answer_type": 1,
                    "show_type_name": "单选题",
                    "new_parent_id": 315921,
                    "score_rule": "",
                    "material_text": "",
                    "sort_son": "0",
                    "analyze": "<p>企业信息化是一个长期的过程，需要全体社会成员来完成。</p>",
                    "like": 0,
                    "answer": [
                        "D"
                    ],
                    "option": [
                        "有效开发利用信息资源",
                        "大力发展信息产业",
                        " 充分建设信息化政策法规和标准规范 ",
                        "信息化的主体是程序员和项目经理"
                    ]
                },
                {
                    "index": 189,
                    "belong_page": 1,
                    "question_id": 315922,
                    "question_title": "政府、企业等对信息化的需求是能织信息化的原动力，它决定了组织信息化的价值取向和成果效益水平，而需求本身又是极为复杂的，它是一个系统的、多层次的目和体系、组织信息化需求通常包含线个层次，即_(20)，三个层次的需求并不是相互孤立的，而是有着内在的联系。",
                    "question_type": 1,
                    "answer_type": 1,
                    "show_type_name": "单选题",
                    "new_parent_id": 315922,
                    "score_rule": "",
                    "material_text": "",
                    "sort_son": "0",
                    "analyze": "<p>信息化需求包含三个层次，即战略需求、运作需求和技术需求。</p><p>（1）战略需求。组织信息化的目标是提升组织的竞争能力，为组织的可持续发展提 供一个支持环境。</p><p>（2）运作需求。组织信息化的运作需求是组织信息化需求非常重要且关键的一环， 它包含三方面的内容：一是实现信息化战略目标的需要；二是运作策略的需要^三是人 才培养的需要。</p><p>（3）技术需求。由于系统开发时间过长等问题在信息技术层面上对系统的完善、升 级、集成和整合提出了需求。</p>",
                    "like": 0,
                    "answer": [
                        "B"
                    ],
                    "option": [
                        "战略需求，运作需求，功能需求",
                        "战略需术，运作需求，技术需求",
                        "市场需求，技术需求，用户需求",
                        "市场需求，技术需求，领域需求"
                    ]
                },
                {
                    "index": 190,
                    "belong_page": 1,
                    "question_id": 315932,
                    "question_title": "<p>结构化设计是一种面向数据流的设计方法,以下不属于结构化设计工具的是（30）</p>",
                    "question_type": 1,
                    "answer_type": 1,
                    "show_type_name": "单选题",
                    "new_parent_id": 315932,
                    "score_rule": "",
                    "material_text": "",
                    "sort_son": "0",
                    "analyze": "<p>顺序图是一种UML图，主要用于面向对象设计。</p>",
                    "like": 0,
                    "answer": [
                        "C"
                    ],
                    "option": [
                        "盒图",
                        "HIPO图",
                        "顺序图",
                        "程序流程图"
                    ]
                },
                {
                    "index": 191,
                    "belong_page": 1,
                    "question_id": 315934,
                    "question_title": "<p>软件设计过程中,可以用耦合和内聚两个定性标准来衡量模块的独立程度，耦合衡量不同模块彼此间互相依赖的紧密程度,应采用以下设计原则(31),内聚衡量一个模块内部各个元素彼此结合的紧密程度,以下属于高内聚的是(32)</p>",
                    "question_type": 9,
                    "answer_type": 1,
                    "show_type_name": "单选题",
                    "new_parent_id": 315933,
                    "score_rule": "",
                    "material_text": null,
                    "sort_son": "1",
                    "analyze": "内容耦合耦合性最强，模块的独立性最弱，因此不应该使用内容耦合。根据题干信息，数据耦合在这里耦合性最弱，尽量使用数据耦合。",
                    "like": 0,
                    "answer": [
                        "B"
                    ],
                    "option": [
                        "&nbsp;尽量使用内容耦合、少用控制耦合和特征耦合、限制公共环境耦合的范围、完全不用数据耦合",
                        "尽量使用数据耦合、少用控制耦合和特征耦合、限制公共环境耦合的范围、完全不用内容耦合",
                        "尽量使用控制耦合、少用数据耦合和特征耦合、限制公共环境耦合的范围、完全不用内容耦合",
                        "尽量使用特征耦合、少用数据耦合和控制耦合、限制公共环境耦合的范围、完全不用内容耦合"
                    ]
                },
                {
                    "index": 192,
                    "belong_page": 1,
                    "question_id": 315935,
                    "question_title": "<p>软件设计过程中,可以用耦合和内聚两个定性标准来衡量模块的独立程度，耦合衡量不同模块彼此间互相依赖的紧密程度,应采用以下设计原则(31),内聚衡量一个模块内部各个元素彼此结合的紧密程度,以下属于高内聚的是(32)</p>",
                    "question_type": 9,
                    "answer_type": 1,
                    "show_type_name": "单选题",
                    "new_parent_id": 315933,
                    "score_rule": "",
                    "material_text": null,
                    "sort_son": "2",
                    "analyze": "<p>功能内聚内聚性最强，模块独立性也最强。</p>",
                    "like": 0,
                    "answer": [
                        "C"
                    ],
                    "option": [
                        "偶然内聚",
                        "时间内聚",
                        "功能内聚",
                        "逻辑内聚"
                    ]
                },
                {
                    "index": 193,
                    "belong_page": 1,
                    "question_id": 315936,
                    "question_title": "<p>UML(&nbsp;Unified Modeling Language)是面向对象设计的建模工具,独立于任何具体程序设计语言,以下(33)不属于UML中的模型</p>",
                    "question_type": 1,
                    "answer_type": 1,
                    "show_type_name": "单选题",
                    "new_parent_id": 315936,
                    "score_rule": "",
                    "material_text": "",
                    "sort_son": "0",
                    "analyze": "<p>PAD图用于结构化设计的工具。</p>",
                    "like": 0,
                    "answer": [
                        "D"
                    ],
                    "option": [
                        "用例图",
                        "协作图",
                        "活动图",
                        "PAD图"
                    ]
                },
                {
                    "index": 194,
                    "belong_page": 1,
                    "question_id": 315937,
                    "question_title": "使用 McCabe方法可以计算程序流程图的环形复杂度，下图的环形复杂度为(34)<br/><img style=\"max-width:100%;height:auto\"  src=\"https://s2.51cto.com/images/20211118/1637225067584691.png\" title=\"1637225067584691.png\" alt=\"image.png\"/>",
                    "question_type": 1,
                    "answer_type": 1,
                    "show_type_name": "单选题",
                    "new_parent_id": 315937,
                    "score_rule": "",
                    "material_text": "",
                    "sort_son": "0",
                    "analyze": "<p>环路复杂度等于闭环个数+1=4。</p>",
                    "like": 0,
                    "answer": [
                        "B"
                    ],
                    "option": [
                        "3",
                        "4",
                        "5",
                        "6"
                    ]
                },
                {
                    "index": 195,
                    "belong_page": 1,
                    "question_id": 315938,
                    "question_title": "<p>以下关于软件构件的叙述中，错误的是(35)</p>",
                    "question_type": 1,
                    "answer_type": 1,
                    "show_type_name": "单选题",
                    "new_parent_id": 315938,
                    "score_rule": "",
                    "material_text": "",
                    "sort_son": "0",
                    "analyze": "<p>在一个特定进程中只能存在一个特定构件的拷贝。</p>",
                    "like": 0,
                    "answer": [
                        "C"
                    ],
                    "option": [
                        "构件的部署必须能跟它所在的环境及其他构件完全分离",
                        "构件作为一个部署单元是不可拆分的",
                        "在一个特定进程中可能会存在多个特定构件的拷贝",
                        "对于不影响构件功能的某些属性可以对外部可见"
                    ]
                },
                {
                    "index": 196,
                    "belong_page": 1,
                    "question_id": 315941,
                    "question_title": "<p>为实现对象重用，COM支持两种形式的对象组装。在(37)重用形式下，一个外部对象拥有指向一个内部对象的唯一引用，外部对象只是把请求转发给内部对象：在(38)重用形式下，直接把内部对象的接口引用传给外部对象的客户，而不再转发请求。</p>",
                    "question_type": 9,
                    "answer_type": 1,
                    "show_type_name": "单选题",
                    "new_parent_id": 315940,
                    "score_rule": "",
                    "material_text": null,
                    "sort_son": "1",
                    "analyze": "<p>COM支持两种形式的对象组装：包含和聚集。</p><p>包含就是一种简单的对象组装技术，其含义是一个对象拥有指向另一个对象的唯— 引用。</p>",
                    "like": 0,
                    "answer": [
                        "B"
                    ],
                    "option": [
                        "聚集",
                        "包含",
                        "链接",
                        "多态"
                    ]
                },
                {
                    "index": 197,
                    "belong_page": 1,
                    "question_id": 315942,
                    "question_title": "<p>为实现对象重用，COM支持两种形式的对象组装。在(37)重用形式下，一个外部对象拥有指向一个内部对象的唯一引用，外部对象只是把请求转发给内部对象：在(38)重用形式下，直接把内部对象的接口引用传给外部对象的客户，而不再转发请求。</p>",
                    "question_type": 9,
                    "answer_type": 1,
                    "show_type_name": "单选题",
                    "new_parent_id": 315940,
                    "score_rule": "",
                    "material_text": null,
                    "sort_son": "2",
                    "analyze": "<p>聚集是直接把内部对象的接口引用传给外部对象的客户，而不再转发请求。</p>",
                    "like": 0,
                    "answer": [
                        "D"
                    ],
                    "option": [
                        "引用",
                        "转发",
                        "包含",
                        "聚集"
                    ]
                },
                {
                    "index": 198,
                    "belong_page": 1,
                    "question_id": 348934,
                    "question_title": "<p>给定关系R(A,B,C,D)和关系S(C，D，E)，对其进行自然连接运算R ⋈ S后的属性列为（ ）个；与σR.B&gt;S.E\n(R ⋈ S)等价的关系代数表达式为（ ）</p>",
                    "question_type": 9,
                    "answer_type": 1,
                    "show_type_name": "单选题",
                    "new_parent_id": 348933,
                    "score_rule": "",
                    "material_text": null,
                    "sort_son": "1",
                    "analyze": "自然连接运算去掉重复的属性列，结果为5列：A，B，C，D，E。",
                    "like": 0,
                    "answer": [
                        "B"
                    ],
                    "option": [
                        "4&nbsp;",
                        "5&nbsp;",
                        "6&nbsp;",
                        "7"
                    ]
                },
                {
                    "index": 199,
                    "belong_page": 1,
                    "question_id": 348935,
                    "question_title": "<p>给定关系R(A,B,C,D)和关系S(C，D，E)，对其进行自然连接运算R ⋈ S后的属性列为（ ）个；与σR.B&gt;S.E\n(R ⋈ S)等价的关系代数表达式为（ ）</p>",
                    "question_type": 9,
                    "answer_type": 1,
                    "show_type_name": "单选题",
                    "new_parent_id": 348933,
                    "score_rule": "",
                    "material_text": null,
                    "sort_son": "2",
                    "analyze": "自然连接运算去掉重复的属性列，结果为5列：A，B，C，D，E",
                    "like": 0,
                    "answer": [
                        "D"
                    ],
                    "option": [
                        "σ2＞7\n(R×S)&nbsp;",
                        "π1,2,3,4,7 (σ´2´＞´7´Λ3=5Λ4=6 (R×S))&nbsp;",
                        "Σ＇2＇＞＇7＇(R×S)&nbsp;",
                        "π1,2,3,4,7 (σ2＞7Λ3=5Λ4=6 (R×S))"
                    ]
                },
                {
                    "index": 200,
                    "belong_page": 1,
                    "question_id": 348937,
                    "question_title": "<p><br/></p><p>关系R、S 如下表所示， R<img style=\"max-width:100%;height:auto\"  src=\"https://s2.51cto.com/images/20220819/1660906814557120.png\" title=\"1660906814557120.png\" alt=\"image.png\" width=\"24\" height=\"18\"/> S 的结果集有（ ） 个元组， R 、S 的左外联接、\n右外联接的元组个数分别为（ ）。<br/><br/><img style=\"max-width:100%;height:auto\"  src=\"https://s2.51cto.com/images/20220819/1660906838560933.png\" title=\"1660906838560933.png\" alt=\"image.png\"/></p>",
                    "question_type": 9,
                    "answer_type": 1,
                    "show_type_name": "单选题",
                    "new_parent_id": 348936,
                    "score_rule": "",
                    "material_text": null,
                    "sort_son": "1",
                    "analyze": "<img style=\"max-width:100%;height:auto\"  src=\"https://s2.51cto.com/images/20220819/1660906921179574.png\" title=\"1660906921179574.png\" alt=\"image.png\"/><br/><br/>从运算的结果可以看出R 与S 的左外联接、右外联接的元组个数分别为\n4 、 4",
                    "like": 0,
                    "answer": [
                        "B"
                    ],
                    "option": [
                        "1&nbsp;",
                        "2",
                        "3&nbsp;",
                        "4"
                    ]
                },
                {
                    "index": 201,
                    "belong_page": 1,
                    "question_id": 348938,
                    "question_title": "<p><br/></p><p>关系R、S 如下表所示， R<img style=\"max-width:100%;height:auto\"  src=\"https://s2.51cto.com/images/20220819/1660906814557120.png\" title=\"1660906814557120.png\" alt=\"image.png\" width=\"24\" height=\"18\"/> S 的结果集有（ ） 个元组， R 、S 的左外联接、\n右外联接的元组个数分别为（ ）。<br/><br/><img style=\"max-width:100%;height:auto\"  src=\"https://s2.51cto.com/images/20220819/1660906838560933.png\" title=\"1660906838560933.png\" alt=\"image.png\"/></p>",
                    "question_type": 9,
                    "answer_type": 1,
                    "show_type_name": "单选题",
                    "new_parent_id": 348936,
                    "score_rule": "",
                    "material_text": null,
                    "sort_son": "2",
                    "analyze": "从运算的结果可以看出R 与S 的左外联接、右外联接的元组个数分别为\n4 、 4 。",
                    "like": 0,
                    "answer": [
                        "C"
                    ],
                    "option": [
                        "2, 2&nbsp;",
                        "2, 4&nbsp;",
                        "4, 4&nbsp;",
                        "4, 8"
                    ]
                },
                {
                    "index": 202,
                    "belong_page": 1,
                    "question_id": 348940,
                    "question_title": "<p>给定关系模式R（U, F）,其中:属性集U＝｛A1,A2,A3,A4,A5,A6｝,函\n数依赖集F＝｛A1→A2, A1→A3,A3→A4,A1A5→A6｝。关系模式R的候\n选码为 （ ）, 由于R存在非主属性对码的部分函数依赖,所以R属于\n（ ）</p>",
                    "question_type": 9,
                    "answer_type": 1,
                    "show_type_name": "单选题",
                    "new_parent_id": 348939,
                    "score_rule": "",
                    "material_text": null,
                    "sort_son": "1",
                    "analyze": "根据题意只有A1A5可以得到全部属性集里面的属性，因此A1A5是关系\n模式的候选码。\n“存在非主属性对码的部分函数依赖”不满足2NF，因\n此属于1NF。",
                    "like": 0,
                    "answer": [
                        "C"
                    ],
                    "option": [
                        "A1A3&nbsp;",
                        "A1A4&nbsp;",
                        "A1A5&nbsp;",
                        "A1"
                    ]
                },
                {
                    "index": 203,
                    "belong_page": 1,
                    "question_id": 348941,
                    "question_title": "<p>给定关系模式R（U, F）,其中:属性集U＝｛A1,A2,A3,A4,A5,A6｝,函\n数依赖集F＝｛A1→A2, A1→A3,A3→A4,A1A5→A6｝。关系模式R的候\n选码为 （ ）, 由于R存在非主属性对码的部分函数依赖,所以R属于\n（ ）</p>",
                    "question_type": 9,
                    "answer_type": 1,
                    "show_type_name": "单选题",
                    "new_parent_id": 348939,
                    "score_rule": "",
                    "material_text": null,
                    "sort_son": "2",
                    "analyze": "根据题意只有A1A5可以得到全部属性集里面的属性，因此A1A5是关系\n模式的候选码。\n“存在非主属性对码的部分函数依赖”不满足2NF，因\n此属于1NF",
                    "like": 0,
                    "answer": [
                        "A"
                    ],
                    "option": [
                        "1NF&nbsp;",
                        "2NF&nbsp;",
                        "3NF&nbsp;",
                        "BCN"
                    ]
                },
                {
                    "index": 204,
                    "belong_page": 1,
                    "question_id": 348943,
                    "question_title": "<p>给出关系R（U，F），U={A，B，C，D，E}，F={A→B，D→C，\nBC→E，AC→B}，求属性闭包的等式成立的是（ ）。R的候选关键字\n为（ ）</p>",
                    "question_type": 9,
                    "answer_type": 1,
                    "show_type_name": "单选题",
                    "new_parent_id": 348942,
                    "score_rule": "",
                    "material_text": null,
                    "sort_son": "1",
                    "analyze": "<p><img style=\"max-width:100%;height:auto\"  src=\"https://s2.51cto.com/images/20220819/1660907294301799.png\" title=\"1660907294301799.png\" alt=\"image.png\" width=\"479\" height=\"149\"/></p>",
                    "like": 0,
                    "answer": [
                        "D"
                    ],
                    "option": [
                        " <img style=\"max-width:100%;height:auto\" src=\"https://s2.51cto.com/images/20220819/1660907234895037.png\" title=\"1660907234895037.png\" alt=\"image.png\" width=\"119\" height=\"42\"/> ",
                        "<img style=\"max-width:100%;height:auto\" src=\"https://s2.51cto.com/images/20220819/1660907248449273.png\" title=\"1660907248449273.png\" alt=\"image.png\" width=\"109\" height=\"38\"/>",
                        "<img style=\"max-width:100%;height:auto\" src=\"https://s2.51cto.com/images/20220819/1660907260226831.png\" title=\"1660907260226831.png\" alt=\"image.png\" width=\"116\" height=\"31\"/>",
                        "<img style=\"max-width:100%;height:auto\" src=\"https://s2.51cto.com/images/20220819/1660907268210225.png\" title=\"1660907268210225.png\" alt=\"image.png\" width=\"111\" height=\"35\"/>"
                    ]
                },
                {
                    "index": 205,
                    "belong_page": 1,
                    "question_id": 348944,
                    "question_title": "<p>给出关系R（U，F），U={A，B，C，D，E}，F={A→B，D→C，\nBC→E，AC→B}，求属性闭包的等式成立的是（ ）。R的候选关键字\n为（ ）</p>",
                    "question_type": 9,
                    "answer_type": 1,
                    "show_type_name": "单选题",
                    "new_parent_id": 348942,
                    "score_rule": "",
                    "material_text": null,
                    "sort_son": "2",
                    "analyze": "<img style=\"max-width:100%;height:auto\"  src=\"https://s2.51cto.com/images/20220819/1660907328413707.png\" title=\"1660907328413707.png\" alt=\"image.png\" width=\"513\" height=\"165\"/>",
                    "like": 0,
                    "answer": [
                        "A"
                    ],
                    "option": [
                        "AD&nbsp;",
                        "AB&nbsp;",
                        "AC&nbsp;",
                        "BC"
                    ]
                },
                {
                    "index": 206,
                    "belong_page": 1,
                    "question_id": 350320,
                    "question_title": "<p>面向对象的分析模型主要由顶层架构图、用例与用例图和&nbsp;（32） 构成，设计模型则包含以&nbsp;（33） 表示的软件体系结构图、以交互图表示的用例实现图、完整精确的类图、描述复杂对象的&nbsp;（34） 和用于描述流程化处理过程的活动图等。</p>",
                    "question_type": 9,
                    "answer_type": 1,
                    "show_type_name": "单选题",
                    "new_parent_id": 350319,
                    "score_rule": "",
                    "material_text": null,
                    "sort_son": "1",
                    "analyze": "<p>面向对象的分析模型主要由顶层架构图、用例与用例图和领域概念模型构成。</p><p>设计模型则包含以包图表示的软件体系结构图、以交互图表示的用例实现图、完整精确 的类图、描述复杂对象的状态图和用于描述流程化处理过程的活动图等。</p>",
                    "like": 0,
                    "answer": [
                        "B"
                    ],
                    "option": [
                        " 数据流模型 ",
                        " 领域概念模型 ",
                        " 功能分解图 ",
                        " 功能需求模型 "
                    ]
                },
                {
                    "index": 207,
                    "belong_page": 1,
                    "question_id": 350321,
                    "question_title": "<p>面向对象的分析模型主要由顶层架构图、用例与用例图和&nbsp;（32） 构成，设计模型则包含以&nbsp;（33） 表示的软件体系结构图、以交互图表示的用例实现图、完整精确的类图、描述复杂对象的&nbsp;（34） 和用于描述流程化处理过程的活动图等。</p>",
                    "question_type": 9,
                    "answer_type": 1,
                    "show_type_name": "单选题",
                    "new_parent_id": 350319,
                    "score_rule": "",
                    "material_text": null,
                    "sort_son": "2",
                    "analyze": "<p>面向对象的分析模型主要由顶层架构图、用例与用例图和领域概念模型构成。</p><p>设计模型则包含以包图表示的软件体系结构图、以交互图表示的用例实现图、完整精确 的类图、描述复杂对象的状态图和用于描述流程化处理过程的活动图等。</p>",
                    "like": 0,
                    "answer": [
                        "C"
                    ],
                    "option": [
                        " 模型试图控制器 ",
                        " 组件图 ",
                        " 包图 ",
                        " 2 层、 3 层或 N 层 "
                    ]
                },
                {
                    "index": 208,
                    "belong_page": 1,
                    "question_id": 350322,
                    "question_title": "<p>面向对象的分析模型主要由顶层架构图、用例与用例图和&nbsp;（32） 构成，设计模型则包含以&nbsp;（33） 表示的软件体系结构图、以交互图表示的用例实现图、完整精确的类图、描述复杂对象的&nbsp;（34） 和用于描述流程化处理过程的活动图等。</p>",
                    "question_type": 9,
                    "answer_type": 1,
                    "show_type_name": "单选题",
                    "new_parent_id": 350319,
                    "score_rule": "",
                    "material_text": null,
                    "sort_son": "3",
                    "analyze": "<p>面向对象的分析模型主要由顶层架构图、用例与用例图和领域概念模型构成。</p><p>设计模型则包含以包图表示的软件体系结构图、以交互图表示的用例实现图、完整精确 的类图、描述复杂对象的状态图和用于描述流程化处理过程的活动图等。</p>",
                    "like": 0,
                    "answer": [
                        "D"
                    ],
                    "option": [
                        " 序列图 ",
                        " 协作图 ",
                        " 流程图 ",
                        " 状态图 "
                    ]
                },
                {
                    "index": 209,
                    "belong_page": 1,
                    "question_id": 350323,
                    "question_title": "<p>下列关于用户界面设计的叙述中， 错误的是&nbsp;（35） 。</p>",
                    "question_type": 1,
                    "answer_type": 1,
                    "show_type_name": "单选题",
                    "new_parent_id": 350323,
                    "score_rule": "",
                    "material_text": "",
                    "sort_son": "0",
                    "analyze": "<p>用户界面设计的基本原则是从实践中总结出来的一些设计规则，TheoMandel在其界面设计著作中提出如下3条“黄金规则”。</p><p>（1）让用户拥有控制权。</p><p>用户希望控制计算机，而不是被计算机控制。因此在设计人机界面时应遵循的原则是交互模式的定义不能强迫用户进入不必要或不希望的动作方式、提供灵活的交互、允许用户交互可以被中断和撤销、当技能级别增长时可以使交互流水化并允许定制交互，以及使用户隔离内部技术细节。</p><p>（2）减少用户的记忆负担。</p><p>要求用户记住的东西越多，与系统交互时出错的可能性也越大，因此好的用户界面设计不应加重用户的记忆负担。减少用户记忆负担的设计原则为减少对短期记忆的要求、建立有意义的默认值、定义直觉性的捷径、界面的视觉布局应该基于真实世界的隐喻，以及以不断进展的方式揭示信息。</p><p>（3）保持界面一致。</p><p>用户应该以一致的方式展示和获取信息，这意味着所有可视信息的组织遵循统一的设计标准，所有屏幕显示都遵守该标准。输入机制被约束到有限的集合内，在整个软件系统中被一致地使用；同时从任务到任务的导航机制也被一致地定义和实现。保持界面一致性的设计原则一是允许用户将当前任务放在有意义的语境中、在应用系列内保持一致性；二是不要改变用户已经熟悉的用户交互模型。</p>",
                    "like": 0,
                    "answer": [
                        "A"
                    ],
                    "option": [
                        " 界面交互模型应经常进行修改 ",
                        " 界面的视觉布局应该尽量与真实世界保持一致 ",
                        " 所有可视信息的组织需要按照统一的设计标准 ",
                        " 确保用户界面操作和使用的一致性 "
                    ]
                },
                {
                    "index": 210,
                    "belong_page": 1,
                    "question_id": 350324,
                    "question_title": "<p>对于违反里氏替换原则的两个类A和B，可以采用的候选解决方案中，正确的是 &nbsp;（36） 。</p>",
                    "question_type": 1,
                    "answer_type": 1,
                    "show_type_name": "单选题",
                    "new_parent_id": 350324,
                    "score_rule": "",
                    "material_text": "",
                    "sort_son": "0",
                    "analyze": "<p>里氏替换原则是面向对象设计原则之一，由Barbara liskov提出，其基本思想是，一个软件实体如果使用的是一个基类对象，那么一定适用于其子类对象，而且觉察不出基类对象和子类对象的区别，即把基类都替换成它的子类，程序的行为没有变化。反过来则不一定成立，如果一个软件实体使用的是一个子类对象，那么它不一定适用于基类对象。</p><p>在运用里氏替换原则时，尽量将一些需要扩展的类或者存在变化的类设计为抽象类或者接口，并将其作为基类，在程序中尽量使用基类对象进行编程。由于子类继承基类并实现其中的方法，程序运行时，子类对象可以替换基类对象，如果需要对类的行为进行修改，可以扩展基类，增加新的子类，而无需修改调用该基类对象的代码。</p>",
                    "like": 0,
                    "answer": [
                        "A"
                    ],
                    "option": [
                        " 尽量将一些需要扩展的类或者存在变化的类设计为抽象类或者接口，并将其作为基类，在程序中尽量使用基类对象进行编程 ",
                        " 创建一个新的抽象类C，作为两个具体类的超类，将A和B共同的行为移动到C中，从而解决A和B行为不完全一致的问题 ",
                        " 将B到A的继承关系改成组合关系 ",
                        " 区分是“Is-a”还是“Has-a”。如果是Is-a，可以使用继承关系，如果是Has-a，应该改成组合或聚合关系 "
                    ]
                },
                {
                    "index": 211,
                    "belong_page": 1,
                    "question_id": 350325,
                    "question_title": "<p>某网站系统在用户登录时使用数字校验码。为了增强安全性，现在要求在登录校验码中增加字母或图片。如果直接修改原有的生成登录校验码的程序代码，则违反了面向对象设计原则中的&nbsp;（37） 。</p>",
                    "question_type": 1,
                    "answer_type": 1,
                    "show_type_name": "单选题",
                    "new_parent_id": 350325,
                    "score_rule": "",
                    "material_text": "",
                    "sort_son": "0",
                    "analyze": "<p>开闭原则是指软件实体应对扩展开放，而对修改关闭，即尽量在不修改原有代码的情况下进行扩展。</p>",
                    "like": 0,
                    "answer": [
                        "A"
                    ],
                    "option": [
                        " 开闭原则 ",
                        " 里氏替换原则 ",
                        " 最少知识原则 ",
                        " 组合复用原则 "
                    ]
                },
                {
                    "index": 212,
                    "belong_page": 1,
                    "question_id": 350327,
                    "question_title": "<p>在面向对象设计中，&nbsp;（38） 可以实现界面控制、外部接口和环境隔离。&nbsp;（39） 作为完成用例业务的责任承担者，协调、控制其他类共同完成用例规定的功能或行为。</p>",
                    "question_type": 9,
                    "answer_type": 1,
                    "show_type_name": "单选题",
                    "new_parent_id": 350326,
                    "score_rule": "",
                    "material_text": null,
                    "sort_son": "1",
                    "analyze": "<p>类封装了信息和行为，是面向对象程序设计的重要组成部分。它可以分为3种类型，即实体类、边界类和控制类。</p><p>（1）实体类映射需求中的每个实体，保存需要存储在永久存储体中的信息。它是对用户来说最有意义的类，通常采用业务领域术语命名，一般来说是一个名词。在用例模型向领域模型转化中，一个参与者一般对应于实体类。</p><p>（2）控制类是用于控制用例工作的类，一般是由动宾结构的短语（“动词+名词”或“名词+动词”）转化来的名词。控制类用于对一个或几个用例所特有的控制行为进行建模，控制对象通常控制其他对象，因此它们的行为具有协调性。</p><p>（3）边界类用于封装在用例内、外流动的信息或数据流，是一种用于对系统外部环境与其内部运作之间的交互进行建模的类。边界对象将系统与其外部环境的变更隔离开，使这些变更不会对系统其他部分造成影响。</p>",
                    "like": 0,
                    "answer": [
                        "C"
                    ],
                    "option": [
                        " 实体类 ",
                        " 控制类 ",
                        " 边界类 ",
                        " 交互类 "
                    ]
                },
                {
                    "index": 213,
                    "belong_page": 1,
                    "question_id": 350328,
                    "question_title": "<p>在面向对象设计中，&nbsp;（38） 可以实现界面控制、外部接口和环境隔离。&nbsp;（39） 作为完成用例业务的责任承担者，协调、控制其他类共同完成用例规定的功能或行为。</p>",
                    "question_type": 9,
                    "answer_type": 1,
                    "show_type_name": "单选题",
                    "new_parent_id": 350326,
                    "score_rule": "",
                    "material_text": null,
                    "sort_son": "2",
                    "analyze": "<p>类封装了信息和行为，是面向对象程序设计的重要组成部分。它可以分为3种类型，即实体类、边界类和控制类。</p><p>（1）实体类映射需求中的每个实体，保存需要存储在永久存储体中的信息。它是对用户来说最有意义的类，通常采用业务领域术语命名，一般来说是一个名词。在用例模型向领域模型转化中，一个参与者一般对应于实体类。</p><p>（2）控制类是用于控制用例工作的类，一般是由动宾结构的短语（“动词+名词”或“名词+动词”）转化来的名词。控制类用于对一个或几个用例所特有的控制行为进行建模，控制对象通常控制其他对象，因此它们的行为具有协调性。</p><p>（3）边界类用于封装在用例内、外流动的信息或数据流，是一种用于对系统外部环境与其内部运作之间的交互进行建模的类。边界对象将系统与其外部环境的变更隔离开，使这些变更不会对系统其他部分造成影响。</p>",
                    "like": 0,
                    "answer": [
                        "B"
                    ],
                    "option": [
                        " 实体类 ",
                        " 控制类 ",
                        " 边界类 ",
                        " 交互类 "
                    ]
                },
                {
                    "index": 214,
                    "belong_page": 1,
                    "question_id": 350330,
                    "question_title": "<p>应用系统构建中可以采用多种不同的技术，&nbsp;（40） 可以将软件某种形式的描述转换为更高级的抽象表现形式。而利用这些获取的信息，&nbsp;（41） 能够对现有系统进行修改或重构，从而产生系统的一个新版本。</p>",
                    "question_type": 9,
                    "answer_type": 1,
                    "show_type_name": "单选题",
                    "new_parent_id": 350329,
                    "score_rule": "",
                    "material_text": null,
                    "sort_son": "1",
                    "analyze": "<p>所谓软件的逆向工程就是分析已有的程序，寻求比源代码更高级的抽象表现形式。一般认为，凡是在软件生命周期内将软件某种形式的描述转换成更为抽象形式的活动都可称为“逆向工程”。与之相关的概念是重构（Restructuring），指在同一抽象级别上转换系统描述形式；设计恢复（Design Recovery）指借助工具从已有程序中抽象出有关数据设计、总体结构设计和过程设计的信息（不一定是原设计）；再工程（Re-engineering）也称“修复和改造工程”，它是在逆向工程所获信息的基础上修改或重构已有的系统，产生系统的一个新版本。</p>",
                    "like": 0,
                    "answer": [
                        "A"
                    ],
                    "option": [
                        " 逆向工程（Reverse Engineering） ",
                        " 系统改进（System Improvement） ",
                        " 设计恢复（Design Recovery） ",
                        " 再工程（Re-engineering） "
                    ]
                },
                {
                    "index": 215,
                    "belong_page": 1,
                    "question_id": 350331,
                    "question_title": "<p>应用系统构建中可以采用多种不同的技术，&nbsp;（40） 可以将软件某种形式的描述转换为更高级的抽象表现形式。而利用这些获取的信息，&nbsp;（41） 能够对现有系统进行修改或重构，从而产生系统的一个新版本。</p>",
                    "question_type": 9,
                    "answer_type": 1,
                    "show_type_name": "单选题",
                    "new_parent_id": 350329,
                    "score_rule": "",
                    "material_text": null,
                    "sort_son": "2",
                    "analyze": "<p>所谓软件的逆向工程就是分析已有的程序，寻求比源代码更高级的抽象表现形式。一般认为，凡是在软件生命周期内将软件某种形式的描述转换成更为抽象形式的活动都可称为“逆向工程”。与之相关的概念是重构（Restructuring），指在同一抽象级别上转换系统描述形式；设计恢复（Design Recovery）指借助工具从已有程序中抽象出有关数据设计、总体结构设计和过程设计的信息（不一定是原设计）；再工程（Re-engineering）也称“修复和改造工程”，它是在逆向工程所获信息的基础上修改或重构已有的系统，产生系统的一个新版本。</p>",
                    "like": 0,
                    "answer": [
                        "D"
                    ],
                    "option": [
                        " 逆向工程（Reverse Engineering） ",
                        " 系统改进（System Improvement） ",
                        " 设计恢复（Design Recovery） ",
                        " 再工程（Re-engineering） "
                    ]
                },
                {
                    "index": 216,
                    "belong_page": 1,
                    "question_id": 352278,
                    "question_title": "<p>&nbsp;在结构化分析方法中，用&nbsp;（31） 表示数据模型。</p>",
                    "question_type": 1,
                    "answer_type": 1,
                    "show_type_name": "单选题",
                    "new_parent_id": 352278,
                    "score_rule": "",
                    "material_text": "",
                    "sort_son": "0",
                    "analyze": "<p>结构化分析方法的基本思想是自顶向下，逐层分解。把一个大问题分解成若干个小问题，每个小问题再分解成若干个更小的问题。经过逐层分解，每个最低层的问题都是足够简单、 容易解决的。结构化方法分析模型的核心是数据字典，围绕这个核心， 有 3 个层次的模型， 分别是数据模型、功能模型和行为模型(也称为“状态模型”) 。在实际工作中一般使用 E-R图表示数据模型，用 DFD 表示功能模型，用状态转换图表示行为模型。这 3 个模型有密切的关系，它们的建立不具有严格的时序性，而是一个迭代的过程。</p>",
                    "like": 0,
                    "answer": [
                        "B"
                    ],
                    "option": [
                        " 用例图 ",
                        " E-R图 ",
                        " 数据字典 ",
                        " 数据流图 "
                    ]
                },
                {
                    "index": 217,
                    "belong_page": 1,
                    "question_id": 352280,
                    "question_title": "<p>&nbsp;在 UML 提供的系统视图中，&nbsp;（32） 把构件部署到一组物理节点上，表示软件到硬件的映射和分布结构。&nbsp;（33） 对组成基于系统的物理代码的文件和构件进行建模。</p>",
                    "question_type": 9,
                    "answer_type": 1,
                    "show_type_name": "单选题",
                    "new_parent_id": 352279,
                    "score_rule": "",
                    "material_text": null,
                    "sort_son": "1",
                    "analyze": "<p>UML 对系统架构的定义是系统的组织结构，包括系统分解的组成部分，以及它们的关联 性、交互机制和指导原则等提供系统设计的信息。具体来说，就是指以下 5 个系统视图。</p><p>(1) 逻辑视图： 也称为“设计视图”，它表示了设计模型中在架构方面具有重要意义的 部分，即类、子系统、包和用例实现的子集。</p><p>(2) 进程视图：将可执行线程和进程作为活动类的建模，是逻辑视图的一次执行实例， 描述了并发与同步结构。</p><p>(3) 实现视图：对组成基于系统的物理代码的文件和构件进行建模。</p><p>(4) 部署视图：把构件部署到一组物理节点上， 表示软件到硬件的映射和分布结构。</p><p>(5) 用例视图：最基本的需求分析模型。</p>",
                    "like": 0,
                    "answer": [
                        "C"
                    ],
                    "option": [
                        " 进程视图&nbsp; ",
                        " 实现视图&nbsp; ",
                        " 部署视图&nbsp; ",
                        " 用例视图&nbsp; "
                    ]
                },
                {
                    "index": 218,
                    "belong_page": 1,
                    "question_id": 352281,
                    "question_title": "<p>&nbsp;在 UML 提供的系统视图中，&nbsp;（32） 把构件部署到一组物理节点上，表示软件到硬件的映射和分布结构。&nbsp;（33） 对组成基于系统的物理代码的文件和构件进行建模。</p>",
                    "question_type": 9,
                    "answer_type": 1,
                    "show_type_name": "单选题",
                    "new_parent_id": 352279,
                    "score_rule": "",
                    "material_text": null,
                    "sort_son": "2",
                    "analyze": "<p>UML&nbsp; 对系统架构的定义是系统的组织结构，包括系统分解的组成部分，以及它们的关联 性、交互机制和指导原则等提供系统设计的信息。具体来说，就是指以下 的5 个系统视图。</p><p>(1) 逻辑视图： 也称为“设计视图”，它表示了设计模型中在架构方面具有重要意义的 部分，即类、子系统、包和用例实现的子集。</p><p>(2) 进程视图：将可执行线程和进程作为活动类的建模，是逻辑视图的一次执行实例， 描述了并发与同步结构。</p><p>(3) 实现视图：对组成基于系统的物理代码的文件和构件进行建模。</p><p>(4) 部署视图：把构件部署到一组物理节点上， 表示软件到硬件的映射和分布结构。</p><p>(5) 用例视图：最基本的需求分析模型。</p>",
                    "like": 0,
                    "answer": [
                        "B"
                    ],
                    "option": [
                        "&nbsp; 进程视图 ",
                        " 实现视图&nbsp; ",
                        "&nbsp; 部署视图 ",
                        " 用例视图 "
                    ]
                },
                {
                    "index": 219,
                    "belong_page": 1,
                    "question_id": 352283,
                    "question_title": "<p>&nbsp;面向对象动态分析模型描述系统的动态行为，显示对象在系统运行期间不同时刻的动态交互。其中，UML 2.0的交互模型包括&nbsp;（34） 等，其他动态模型还有&nbsp;（35） 等。</p>",
                    "question_type": 9,
                    "answer_type": 1,
                    "show_type_name": "单选题",
                    "new_parent_id": 352282,
                    "score_rule": "",
                    "material_text": null,
                    "sort_son": "1",
                    "analyze": "<p>本题考查UML&nbsp;2.0的图。</p><p>其中交互图包括交互概览图、定时图、顺序图（序列图）与通信图（协作图），除此以外，动态模型还包括状态图和活动图等。</p>",
                    "like": 0,
                    "answer": [
                        "A"
                    ],
                    "option": [
                        " 顺序图和定时图 ",
                        " 顺序图和状态图 ",
                        " 协作图和活动图 ",
                        " 状态图和活动图 "
                    ]
                },
                {
                    "index": 220,
                    "belong_page": 1,
                    "question_id": 352284,
                    "question_title": "<p>&nbsp;面向对象动态分析模型描述系统的动态行为，显示对象在系统运行期间不同时刻的动态交互。其中，UML 2.0的交互模型包括&nbsp;（34） 等，其他动态模型还有&nbsp;（35） 等。</p>",
                    "question_type": 9,
                    "answer_type": 1,
                    "show_type_name": "单选题",
                    "new_parent_id": 352282,
                    "score_rule": "",
                    "material_text": null,
                    "sort_son": "2",
                    "analyze": "<p>本题考查UML&nbsp;2.0的图。</p><p>其中交互图包括交互概览图、定时图、顺序图（序列图）与通信图（协作图），除此以外，动态模型还包括状态图和活动图等。</p>",
                    "like": 0,
                    "answer": [
                        "D"
                    ],
                    "option": [
                        " 用例图和类图 ",
                        " 活动图和部署图 ",
                        " 对象图和复合结构图 ",
                        " 状态图和交互概览图 "
                    ]
                },
                {
                    "index": 221,
                    "belong_page": 1,
                    "question_id": 352286,
                    "question_title": "<p>&nbsp;软件设计活动中，&nbsp;（36） 描述了软件内部、软件和操作系统之间如何通信；&nbsp;（37） 定义软件系统各主要部件之间的关系。</p>",
                    "question_type": 9,
                    "answer_type": 1,
                    "show_type_name": "单选题",
                    "new_parent_id": 352285,
                    "score_rule": "",
                    "material_text": null,
                    "sort_son": "1",
                    "analyze": "<p>软件设计包括体系结构设计、接口设计、数据设计和过程设计。</p><p>(1) 结构设计：定义软件系统各主要部件之间的关系。</p><p>(2) 数据设计：将模型转换成数据结构的定义，好的数据设计将改善程序结构和模块划 分，降低过程复杂性。</p><p>(3) 接口设计(人机界面设计)：软件内部、软件和操作系统之间，以及软件和人之间 如何通信。</p><p>(4) 过程设计：系统结构部件转换成软件的过程描述。</p>",
                    "like": 0,
                    "answer": [
                        "D"
                    ],
                    "option": [
                        " 数据架构设计 ",
                        " 算法设计 ",
                        " 过程设计 ",
                        " 接口设计 "
                    ]
                },
                {
                    "index": 222,
                    "belong_page": 1,
                    "question_id": 352287,
                    "question_title": "<p>&nbsp;软件设计活动中，&nbsp;（36） 描述了软件内部、软件和操作系统之间如何通信；&nbsp;（37） 定义软件系统各主要部件之间的关系。</p>",
                    "question_type": 9,
                    "answer_type": 1,
                    "show_type_name": "单选题",
                    "new_parent_id": 352285,
                    "score_rule": "",
                    "material_text": null,
                    "sort_son": "2",
                    "analyze": "<p>软件设计包括体系结构设计、接口设计、数据设计和过程设计。</p><p>(1) 结构设计：定义软件系统各主要部件之间的关系。</p><p>(2) 数据设计：将模型转换成数据结构的定义，好的数据设计将改善程序结构和模块划 分，降低过程复杂性。</p><p>(3) 接口设计(人机界面设计)：软件内部、软件和操作系统之间，以及软件和人之间 如何通信。</p><p>(4) 过程设计：系统结构部件转换成软件的过程描述。</p>",
                    "like": 0,
                    "answer": [
                        "C"
                    ],
                    "option": [
                        " 性能设计 ",
                        " 模块化设计 ",
                        " 软件结构设计 ",
                        " 数据流设计 "
                    ]
                },
                {
                    "index": 223,
                    "belong_page": 1,
                    "question_id": 352288,
                    "question_title": "<p>&nbsp;在面向对象设计的原则中，&nbsp;（38） 原则允许一个类可以在可以在不改变原有代码的情况下来变更它的行为。</p>",
                    "question_type": 1,
                    "answer_type": 1,
                    "show_type_name": "单选题",
                    "new_parent_id": 352288,
                    "score_rule": "",
                    "material_text": "",
                    "sort_son": "0",
                    "analyze": "<p>在面向对象编程领域中，规定“软件中的对象（类，模块，函数等等）应该对于扩展是开放的，但是对于修改是封闭的”，这意味着一个实体是允许在不改变它的源代码的前提下变更它的行为。</p>",
                    "like": 0,
                    "answer": [
                        "A"
                    ],
                    "option": [
                        " 开闭 ",
                        " 里氏替换 ",
                        " 最少知识 ",
                        " 依赖倒置 "
                    ]
                },
                {
                    "index": 224,
                    "belong_page": 1,
                    "question_id": 352290,
                    "question_title": "<p>&nbsp;类封装了信息和行为，是面向对象的重要组成部分。在系统设计过程中，类可以分为实体类、边界类和控制类。下面用例描述中属于边界类的是&nbsp;（39） ，属于实体类的是&nbsp;（40） 。</p>",
                    "question_type": 9,
                    "answer_type": 1,
                    "show_type_name": "单选题",
                    "new_parent_id": 352289,
                    "score_rule": "",
                    "material_text": null,
                    "sort_son": "1",
                    "analyze": "<p>类封装了信息和行为，是面向对象程序设计的重要组成部分。它可以分为3种类型，即实体类、边界类和控制类。</p><p>（1）实体类映射需求中的每个实体，保存需要存储在永久存储体中的信息。它是对用户来说最有意义的类，通常采用业务领域术语命名，一般来说是一个名词。在用例模型向领域模型转化中，一个参与者一般对应于实体类。</p><p>（2）控制类是用于控制用例工作的类，一般是由动宾结构的短语（“动词+名词”或“名词+动词”）转化来的名词。控制类用于对一个或几个用例所特有的控制行为进行建模，控制对象通常控制其他对象，因此它们的行为具有协调性。</p><p>（3）边界类用于封装在用例内、外流动的信息或数据流，是一种用于对系统外部环境与其内部运作之间的交互进行建模的类。边界对象将系统与其外部环境的变更隔离开，使这些变更不会对系统其他部分造成影响。</p>",
                    "like": 0,
                    "answer": [
                        "C"
                    ],
                    "option": [
                        " 身份验证 ",
                        " 用户 ",
                        " 通信协议 ",
                        " 查询余额 "
                    ]
                },
                {
                    "index": 225,
                    "belong_page": 1,
                    "question_id": 352291,
                    "question_title": "<p>&nbsp;类封装了信息和行为，是面向对象的重要组成部分。在系统设计过程中，类可以分为实体类、边界类和控制类。下面用例描述中属于边界类的是&nbsp;（39） ，属于实体类的是&nbsp;（40） 。</p>",
                    "question_type": 9,
                    "answer_type": 1,
                    "show_type_name": "单选题",
                    "new_parent_id": 352289,
                    "score_rule": "",
                    "material_text": null,
                    "sort_son": "2",
                    "analyze": "<p>类封装了信息和行为，是面向对象程序设计的重要组成部分。它可以分为3种类型，即实体类、边界类和控制类。</p><p>（1）实体类映射需求中的每个实体，保存需要存储在永久存储体中的信息。它是对用户来说最有意义的类，通常采用业务领域术语命名，一般来说是一个名词。在用例模型向领域模型转化中，一个参与者一般对应于实体类。</p><p>（2）控制类是用于控制用例工作的类，一般是由动宾结构的短语（“动词+名词”或“名词+动词”）转化来的名词。控制类用于对一个或几个用例所特有的控制行为进行建模，控制对象通常控制其他对象，因此它们的行为具有协调性。</p><p>（3）边界类用于封装在用例内、外流动的信息或数据流，是一种用于对系统外部环境与其内部运作之间的交互进行建模的类。边界对象将系统与其外部环境的变更隔离开，使这些变更不会对系统其他部分造成影响。</p>",
                    "like": 0,
                    "answer": [
                        "B"
                    ],
                    "option": [
                        " 身份验证 ",
                        " 用户 ",
                        " 通信协议 ",
                        " 查询余额 "
                    ]
                },
                {
                    "index": 226,
                    "belong_page": 1,
                    "question_id": 352293,
                    "question_title": "<p>&nbsp;逆向工程导出的信息可以分为实现级、结构级、功能级和领域级 4 个抽象层次，程 序的符号表属于&nbsp;（41） ；反映程序段功能及程序段之间关系的信息属于&nbsp;（42） 。</p>",
                    "question_type": 9,
                    "answer_type": 1,
                    "show_type_name": "单选题",
                    "new_parent_id": 352292,
                    "score_rule": "",
                    "material_text": null,
                    "sort_son": "1",
                    "analyze": "<p>逆向工程与重构工程是目前预防性维护采用的主要技术，所谓软件的逆向工程就是分析 已有的程序， 寻求比源代码更高级的抽象表现形式。一般认为， 凡是在软件生命周期内将软 件某种形式的描述转换成更为抽象形式的活动都可称为“逆向工程”， 逆向工程导出的信息 可以分为如下 4 个抽象层次。</p><p>(1) &nbsp;实现级： 包括程序的抽象语法树、符号表等信息。</p><p>(2) &nbsp;结构级： 包括反映程序分量之间相互依赖关系的信息， 如调用图、结构图等。</p><p>(3) &nbsp;功能级： 包括反映程序段功能及程序段之间关系的信息。</p><p>(4) &nbsp;领域级： 包括反映程序分量或程序诸实体与应用领域概念之间对应关系的信息。</p><p>显然，上述信息的抽象级别越高，它与代码的距离就越远， 通过逆向工程恢复的难度亦 越大。而自动工具支持的可能性相对变小，要求人参与判断和推理的工作增多。</p>",
                    "like": 0,
                    "answer": [
                        "A"
                    ],
                    "option": [
                        " 实现级&nbsp; ",
                        " 结构级&nbsp; ",
                        " 功能级&nbsp; ",
                        " 领域级&nbsp; "
                    ]
                },
                {
                    "index": 227,
                    "belong_page": 1,
                    "question_id": 352294,
                    "question_title": "<p>&nbsp;逆向工程导出的信息可以分为实现级、结构级、功能级和领域级 4 个抽象层次，程 序的符号表属于&nbsp;（41） ；反映程序段功能及程序段之间关系的信息属于&nbsp;（42） 。</p>",
                    "question_type": 9,
                    "answer_type": 1,
                    "show_type_name": "单选题",
                    "new_parent_id": 352292,
                    "score_rule": "",
                    "material_text": null,
                    "sort_son": "2",
                    "analyze": "<p>逆向工程与重构工程是目前预防性维护采用的主要技术，所谓软件的逆向工程就是分析 已有的程序， 寻求比源代码更高级的抽象表现形式。一般认为，凡是在软件生命周期内将软 件某种形式的描述转换成更为抽象形式的活动都可称为“逆向工程”， 逆向工程导出的信息 可以分为如下的 4 个抽象层次。</p><p>(1) &nbsp;实现级： 包括程序的抽象语法树、符号表等信息。</p><p>(2) &nbsp;结构级： 包括反映程序分量之间相互依赖关系的信息， 如调用图、结构图等。</p><p>(3) &nbsp;功能级： 包括反映程序段功能及程序段之间关系的信息。</p><p>(4) &nbsp;领域级： 包括反映程序分量或程序诸实体与应用领域概念之间对应关系的信息。</p><p>显然，上述信息的抽象级别越高，它与代码的距离就越远， 通过逆向工程恢复的难度亦 越大。而自动工具支持的可能性相对变小，要求人参与判断和推理的工作增多。</p>",
                    "like": 0,
                    "answer": [
                        "C"
                    ],
                    "option": [
                        "&nbsp; 实现级 ",
                        "&nbsp; 结构级 ",
                        "&nbsp; 功能级 ",
                        "&nbsp; 领域级 "
                    ]
                },
                {
                    "index": 228,
                    "belong_page": 1,
                    "question_id": 352358,
                    "question_title": "<p>两个类A和B，如果B的变化可能会引起A的变化，两个事物之间属于（ ）。</p>",
                    "question_type": 1,
                    "answer_type": 1,
                    "show_type_name": "单选题",
                    "new_parent_id": 352358,
                    "score_rule": "",
                    "material_text": "",
                    "sort_son": "0",
                    "analyze": "<p>类之间的主要关系有关联、依赖、泛化、聚合、组合和实现等。</p><p>（1）关联关系。关联提供了不同类的对象之问的结构关系，它在一段时间内将多个类的实例连接在一起。</p><p>（2）依赖关系。两个类A和B，如果B的变化可能会引起A的变化，则称类A依赖于类B。</p><p>（3）泛化关系。泛化关系描述了一般事物与该事物中的特殊种类之间的关系，也就是父类与子类之间的关系。继承关系是泛化关系的反关系，也就是说，子类继承了父类，而父类则是子类的泛化。</p><p>（4）聚合。共享聚集关系通常简称为聚合关系，它表示类之间的整体与部分的关系，其含义是“部分”可能同时属于多个“整体”，“部分”与“整体”的生命周期可以不相同。例如，汽车和车轮就是聚合关系，车子坏了，车轮还可以用；车轮坏了，可以再换一个。</p><p>（5）组合。组合聚集关系通常简称为组合关系，它也是表示类之间的整体与部分的关系。与聚合关系的区别在于，组合关系中的“部分”只能属于一个“整体”，“部分”与“整体”的生命周期相同，“部分”随着“整体”的创建而创建，也随着“整体”的消亡而消亡。例如，一个公司包含多个部门，它们之间的关系就是组合关系。公司一旦倒闭，也就无所谓部门了。</p><p>（6）实现关系。实现关系将说明和实现联系起来。接口是对行为而非实现的说明，而类中则包含了实现的结构。一个或多个类可以实现一个接口，而每个类分别实现接口中的操作。</p>",
                    "like": 0,
                    "answer": [
                        "B"
                    ],
                    "option": [
                        " 关联关系 ",
                        " 依赖关系 ",
                        " 实现关系 ",
                        " 泛化关系 "
                    ]
                },
                {
                    "index": 229,
                    "belong_page": 1,
                    "question_id": 352359,
                    "question_title": "<p>以下关于软件中间件的叙述，错误的是（）。</p>",
                    "question_type": 1,
                    "answer_type": 1,
                    "show_type_name": "单选题",
                    "new_parent_id": 352359,
                    "score_rule": "",
                    "material_text": "",
                    "sort_son": "0",
                    "analyze": "<p>中间件是一种独立的系统软件或服务程序，分布式应用软件借助这种软件在不同的技术之间共享资源，中间件位于客户机服务器的操作系统之上，应用程序之下。管理计算资源和网络通信。</p>",
                    "like": 0,
                    "answer": [
                        "D"
                    ],
                    "option": [
                        " 中间件通过标准接口实现与应用程序的关联，提供特定功能的服务 ",
                        " 使用中间件可以提高应用软件可移植性 ",
                        " 使用中间件有助于提高开发效率 ",
                        " 中间件位于客户机服务器的操作系统之下，应用程序之上。管理计算资源和网络通信。 "
                    ]
                },
                {
                    "index": 230,
                    "belong_page": 1,
                    "question_id": 352396,
                    "question_title": "<p>在面向对象分析中，利用（）表示需求，并从中提炼出中（），以上两者形成（），之后再进行后续的开发工作。</p>",
                    "question_type": 9,
                    "answer_type": 1,
                    "show_type_name": "单选题",
                    "new_parent_id": 352395,
                    "score_rule": "",
                    "material_text": null,
                    "sort_son": "1",
                    "analyze": "<p>在面向对象分析中，利用用例与用例图表示需求，从用例模型中提炼形成领域模型，用例的实现可以用交互图表示。从领域模型和用例图形成类图，用包图和类图形成体系结构图。之后再进行后续的开发工作。</p>",
                    "like": 0,
                    "answer": [
                        "D"
                    ],
                    "option": [
                        " 类图 ",
                        " 数据流图 ",
                        " 包图 ",
                        " 用例与用例图 "
                    ]
                },
                {
                    "index": 231,
                    "belong_page": 1,
                    "question_id": 352397,
                    "question_title": "<p>在面向对象分析中，利用（）表示需求，并从中提炼出中（），以上两者形成（），之后再进行后续的开发工作。</p>",
                    "question_type": 9,
                    "answer_type": 1,
                    "show_type_name": "单选题",
                    "new_parent_id": 352395,
                    "score_rule": "",
                    "material_text": null,
                    "sort_son": "2",
                    "analyze": "<p>在面向对象分析中，利用用例与用例图表示需求，从用例模型中提炼形成领域模型，用例的实现可以用交互图表示。从领域模型和用例图形成类图，用包图和类图形成体系结构图。之后再进行后续的开发工作。</p>",
                    "like": 0,
                    "answer": [
                        "A"
                    ],
                    "option": [
                        " 领域模型 ",
                        " 架构模型 ",
                        " 体系结构图&nbsp; ",
                        " 类图 "
                    ]
                },
                {
                    "index": 232,
                    "belong_page": 1,
                    "question_id": 352398,
                    "question_title": "<p>在面向对象分析中，利用（）表示需求，并从中提炼出中（），以上两者形成（），之后再进行后续的开发工作。</p>",
                    "question_type": 9,
                    "answer_type": 1,
                    "show_type_name": "单选题",
                    "new_parent_id": 352395,
                    "score_rule": "",
                    "material_text": null,
                    "sort_son": "3",
                    "analyze": "<p>在面向对象分析中，利用用例与用例图表示需求，从用例模型中提炼形成领域模型，用例的实现可以用交互图表示。从领域模型和用例图形成类图，用包图和类图形成体系结构图。之后再进行后续的开发工作。</p>",
                    "like": 0,
                    "answer": [
                        "D"
                    ],
                    "option": [
                        " 领域模型 ",
                        " 包图 ",
                        " 体系结构图&nbsp; ",
                        " 类图 "
                    ]
                },
                {
                    "index": 233,
                    "belong_page": 1,
                    "question_id": 352430,
                    "question_title": "<p>在软件设计中，（61）的主要任务是将系统的功能需求分配给软件模块，确定每个模块的功能和调用关系，形成形成软件（62）。而为每个具体任务选择适当的技术手段和处理方法的过程称为（63）。</p>",
                    "question_type": 9,
                    "answer_type": 1,
                    "show_type_name": "单选题",
                    "new_parent_id": 352429,
                    "score_rule": "",
                    "material_text": null,
                    "sort_son": "1",
                    "analyze": "<p>系统设计的主要内容包括概要设计和详细设计。概要设计又称为系统总体结构设计，它是系统开发过程中很关键的一步，其主要任务是将系统的功能需求分配给软件模块，确定每个模块的功能和调用关系，形成软件的模块结构图，即系统结构图。在概要设计中，将系统开发的总任务分解成许多个基本的、具体的任务，为每个具体任务选择适当的技术手段和处理方法的过程称为详细设计。根据任务的不同，详细设计又可分为多种，例如，网络设计、代码设计、输入/输出设计、处理流程设计、数据存储设计、用户界面设计、安全性和可靠性设计等。</p>",
                    "like": 0,
                    "answer": [
                        "B"
                    ],
                    "option": [
                        " 详细设计 ",
                        " 概要设计 ",
                        " 架构设计 ",
                        " 数据结构设计 "
                    ]
                },
                {
                    "index": 234,
                    "belong_page": 1,
                    "question_id": 352431,
                    "question_title": "<p>在软件设计中，（61）的主要任务是将系统的功能需求分配给软件模块，确定每个模块的功能和调用关系，形成形成软件（62）。而为每个具体任务选择适当的技术手段和处理方法的过程称为（63）。</p>",
                    "question_type": 9,
                    "answer_type": 1,
                    "show_type_name": "单选题",
                    "new_parent_id": 352429,
                    "score_rule": "",
                    "material_text": null,
                    "sort_son": "2",
                    "analyze": "<p>系统设计的主要内容包括概要设计和详细设计。概要设计又称为系统总体结构设计，它是系统开发过程中很关键的一步，其主要任务是将系统的功能需求分配给软件模块，确定每个模块的功能和调用关系，形成软件的模块结构图，即系统结构图。在概要设计中，将系统开发的总任务分解成许多个基本的、具体的任务，为每个具体任务选择适当的技术手段和处理方法的过程称为详细设计。根据任务的不同，详细设计又可分为多种，例如，网络设计、代码设计、输入/输出设计、处理流程设计、数据存储设计、用户界面设计、安全性和可靠性设计等。</p>",
                    "like": 0,
                    "answer": [
                        "D"
                    ],
                    "option": [
                        " 数据流图 ",
                        " 4+1视图 ",
                        " IPO图 ",
                        " 系统结构图 "
                    ]
                },
                {
                    "index": 235,
                    "belong_page": 1,
                    "question_id": 352432,
                    "question_title": "<p>在软件设计中，（61）的主要任务是将系统的功能需求分配给软件模块，确定每个模块的功能和调用关系，形成形成软件（62）。而为每个具体任务选择适当的技术手段和处理方法的过程称为（63）。</p>",
                    "question_type": 9,
                    "answer_type": 1,
                    "show_type_name": "单选题",
                    "new_parent_id": 352429,
                    "score_rule": "",
                    "material_text": null,
                    "sort_son": "3",
                    "analyze": "<p>系统设计的主要内容包括概要设计和详细设计。概要设计又称为系统总体结构设计，它是系统开发过程中很关键的一步，其主要任务是将系统的功能需求分配给软件模块，确定每个模块的功能和调用关系，形成软件的模块结构图，即系统结构图。在概要设计中，将系统开发的总任务分解成许多个基本的、具体的任务，为每个具体任务选择适当的技术手段和处理方法的过程称为详细设计。根据任务的不同，详细设计又可分为多种，例如，网络设计、代码设计、输入/输出设计、处理流程设计、数据存储设计、用户界面设计、安全性和可靠性设计等。</p>",
                    "like": 0,
                    "answer": [
                        "A"
                    ],
                    "option": [
                        " 详细设计 ",
                        " 概要设计 ",
                        " 架构设计 ",
                        " 数据结构设计 "
                    ]
                },
                {
                    "index": 236,
                    "belong_page": 1,
                    "question_id": 356211,
                    "question_title": "<p>信息建模方法是从数据的角度对现实世界建立模型，模型是现实系统的一个抽象，信息建模方法的基本工具是（24）。</p>",
                    "question_type": 1,
                    "answer_type": 1,
                    "show_type_name": "单选题",
                    "new_parent_id": 356211,
                    "score_rule": "",
                    "material_text": "",
                    "sort_son": "0",
                    "analyze": "<p>业务流程图（TFD）是分析和描述现有系统的传统工具，是业务流程调查结果的图形化表示。</p><p>实体联系图（E-R图）它是描述概念世界，建立概念模型的实用工具。</p><p>数据流图（DFD）是表达系统内数据的流动并通过数据流描述系统功能的一种方法。</p><p>数据字典（DD）是在DFD的基础上，对DFD中出现的所有命名元素都加以定义，使得每个图形元素的名字都有一个确切的解释。</p>",
                    "like": 0,
                    "answer": [
                        "B"
                    ],
                    "option": [
                        " 流程图 ",
                        " 实体联系图 ",
                        " 数据流图 ",
                        " 数据字典 "
                    ]
                },
                {
                    "index": 237,
                    "belong_page": 1,
                    "question_id": 356212,
                    "question_title": "<p>（25）通常为一个迭代过程，其中的活动包括需求发现、需求分类和组织、需求协商、需求文档化。</p>",
                    "question_type": 1,
                    "answer_type": 1,
                    "show_type_name": "单选题",
                    "new_parent_id": 356212,
                    "score_rule": "",
                    "material_text": "",
                    "sort_son": "0",
                    "analyze": "<p>需求抽取和分析的过程</p><p>1. 发现需求 &nbsp;&nbsp;&nbsp;2.需求分类和组织 &nbsp;&nbsp;&nbsp;3.需求优先级划分和协商 &nbsp;&nbsp;&nbsp;4. 需求规格说明</p>",
                    "like": 0,
                    "answer": [
                        "C"
                    ],
                    "option": [
                        " 需求确认 ",
                        " 需求管理 ",
                        " 需求抽取 ",
                        " 需求规格说明 "
                    ]
                },
                {
                    "index": 238,
                    "belong_page": 1,
                    "question_id": 356213,
                    "question_title": "<p>使用模型驱动的软件开发方法，软件系统被表示为一组可以被自动转换为可执行代码的模型。其中，（26）在不涉及实现的情况下对软件系统进行建模。</p>",
                    "question_type": 1,
                    "answer_type": 1,
                    "show_type_name": "单选题",
                    "new_parent_id": 356213,
                    "score_rule": "",
                    "material_text": "",
                    "sort_son": "0",
                    "analyze": "<p>软件建模的三个层面：<br/>（1）计算无关模型（CIM）：Computational Independent Model<br/>（2）平台无关模型（PIM）：Platform Independent Model<br/>（3）平台相关模型（PSM）：Platform Dependent Model，又称平台特定模型<br/>从1到3，从抽象到具体</p>",
                    "like": 0,
                    "answer": [
                        "A"
                    ],
                    "option": [
                        " 平台无关模型 ",
                        " 计算无关模型 ",
                        " 平台相关模型 ",
                        " 实现相关模型 "
                    ]
                },
                {
                    "index": 239,
                    "belong_page": 1,
                    "question_id": 356214,
                    "question_title": "<p>在分布式系统中，中间件通常提供两种不同类型的支持，即（27）</p>",
                    "question_type": 1,
                    "answer_type": 1,
                    "show_type_name": "单选题",
                    "new_parent_id": 356214,
                    "score_rule": "",
                    "material_text": "",
                    "sort_son": "0",
                    "analyze": "<p>中间件是独立的系统级软件，连接操作系统层和应用程序层，将不同操作系统提供应用的接口标准化，协议统一化，屏蔽具体操作的细节，中间件一般提供如下功能：</p><p>1、通信支持。中间件为其所支持的应用软件提供平台化的运行环境，该环境屏蔽底层通信之间的接口差异，实现互操作，所以通信支持是中间件一个最基本的功能。</p><p>2、应用支持。中间件的目的就是服务上层应用，提供应用层不同服务之间的互操作机制。</p><p>3、公共服务。公共服务是对应用软件中共性功能或约束的提取。将这些共性的功能或者约束分类实现，并支持复用，作为公共服务，提供给应用程序使用。</p>",
                    "like": 0,
                    "answer": [
                        "B"
                    ],
                    "option": [
                        " 数据支持和交互支持 ",
                        " 交互支持和提供公共服务 ",
                        " 数据支持和提供公共服务 ",
                        " 安全支持和提供公共服务 "
                    ]
                },
                {
                    "index": 240,
                    "belong_page": 1,
                    "question_id": 356215,
                    "question_title": "<p>工作流表示的是业务过程模型，通常使用图形形式来描述，以下不可用来描述工作流的是（28）</p>",
                    "question_type": 1,
                    "answer_type": 1,
                    "show_type_name": "单选题",
                    "new_parent_id": 356215,
                    "score_rule": "",
                    "material_text": "",
                    "sort_son": "0",
                    "analyze": "<p>活动图可以用于描述系统的工作流程和并发行为，活动图其实可看作状态图的特殊形式，活动图中一个活动结束后将立即进入下一个活动。</p><p>BPMN（Business Process Modeling Notation）指业务流程建模与标注，包括这些图元如何组合成一个业务流程图（Business Process Diagram）。</p><p>Petri-Net是所有流程定义语言之母。</p>",
                    "like": 0,
                    "answer": [
                        "C"
                    ],
                    "option": [
                        " 活动图 ",
                        " BPMN ",
                        " 用例图 ",
                        " Petri-Net "
                    ]
                },
                {
                    "index": 241,
                    "belong_page": 1,
                    "question_id": 356217,
                    "question_title": "<p>与 UML 1.x 不同，为了更清楚地表达 UML 的结构， 从 UML 2 开始，整个 UML 规范被划分为基础结构和上层结构两个相对独立的部分，基础结构是 UML 的（30），它定义了构造 UML模型的各种基本元素：而上层结构则定义了面向建模用户的各种UML 模型的语法、语义和表示。</p>",
                    "question_type": 1,
                    "answer_type": 1,
                    "show_type_name": "单选题",
                    "new_parent_id": 356217,
                    "score_rule": "",
                    "material_text": "",
                    "sort_son": "0",
                    "analyze": "<p>OMG在发布2.0修订信息需求之后，广泛听取了来自建模工具提供商、用户、学术团体、咨询机构以及其他标准化组织的26个响应者的建议，并于2000年年初发布了UML 2.0的4个组成部分的提案需求(RFP)，分别是：基础结构(Infrastructure)、上层结构(Superstructure)、对象约束语言(OCL)和图交换(Diagram Interchange)的需求。其中基础结构和上层结构构成了UML 2.0提案需求的主体部分。</p><p>UML 2.0基础结构的设计目标是：定义一个元语言的核心InfrastructureLibrary，通过对此核心的复用，除了可以定义一个自展的UML元模型，也可以定义其他元模型，包括MOF和CWM(Common Warehouse Model，公共仓库模型)。</p><p>UML 2.0上层结构的设计目标是：严格地复用基础结构InfrastructureLibrary包中的构造物；提高对基于构件开发和MDA(Model Driven Architecture，模型驱动体系结构)的支持；优化构架规约的能力；增强行为图的可伸缩性、精确性、集成性等。</p>",
                    "like": 0,
                    "answer": [
                        "C"
                    ],
                    "option": [
                        " 元元素 ",
                        " 模型 ",
                        " 元模型 ",
                        " 元元模型 "
                    ]
                },
                {
                    "index": 242,
                    "belong_page": 1,
                    "question_id": 356218,
                    "question_title": "<p>领域驱动设计提出围绕（31）进行软件设计和开发，该模型是由开发人员与领域专家协作构建出的一个反映深层次领域知识的模型。</p>",
                    "question_type": 1,
                    "answer_type": 1,
                    "show_type_name": "单选题",
                    "new_parent_id": 356218,
                    "score_rule": "",
                    "material_text": "",
                    "sort_son": "0",
                    "analyze": "<p>2004年Eric Evans 发表Domain-Driven Design –Tackling Complexity in the Heart of Software （领域驱动设计），简称Evans DDD。领域驱动设计分为两个阶段：</p><p>① 以一种领域专家、设计人员、开发人员都能理解的通用语言作为相互交流的工具，在交流的过程中发现领域概念，然后将这些概念设计成一个领域模型；</p><p>② 由领域模型驱动软件设计，用代码来实现该领域模型；</p><p>由此可见，领域驱动设计的核心是建立正确的领域模型。</p>",
                    "like": 0,
                    "answer": [
                        "B"
                    ],
                    "option": [
                        " 行为模型 ",
                        " 领域模型 ",
                        " 专家模型 ",
                        " 知识库模型 "
                    ]
                },
                {
                    "index": 243,
                    "belong_page": 1,
                    "question_id": 356221,
                    "question_title": "<p>在UML2.0 （Unified Modeling Language）中，顺序图用来描述对象之间的消息交互，其中循环、选择等复杂交互使用（33）表示，对象之间的消息类型包括（34）。</p>",
                    "question_type": 9,
                    "answer_type": 1,
                    "show_type_name": "单选题",
                    "new_parent_id": 356220,
                    "score_rule": "",
                    "material_text": null,
                    "sort_son": "1",
                    "analyze": "<p>UML2.0添加了交互框(Interaction Frame)，交互框指途中的一块区域(Region)或片段(Fragment)，包含一个操作符(或称为标签)，并包含一个警戒。</p>",
                    "like": 0,
                    "answer": [
                        "D"
                    ],
                    "option": [
                        " 嵌套 ",
                        " 泳道 ",
                        " 组合 ",
                        " 序列片段 "
                    ]
                },
                {
                    "index": 244,
                    "belong_page": 1,
                    "question_id": 356222,
                    "question_title": "<p>在UML2.0 （Unified Modeling Language）中，顺序图用来描述对象之间的消息交互，其中循环、选择等复杂交互使用（33）表示，对象之间的消息类型包括（34）。</p>",
                    "question_type": 9,
                    "answer_type": 1,
                    "show_type_name": "单选题",
                    "new_parent_id": 356220,
                    "score_rule": "",
                    "material_text": null,
                    "sort_son": "2",
                    "analyze": "<p>UML2.0的消息类型有：简单消息、同步消息、异步消息、对象创建消息、对象销毁消息、无触发对象和无接收对象的消息。</p>",
                    "like": 0,
                    "answer": [
                        "D"
                    ],
                    "option": [
                        " 同步消息、异步消息、返回消息、动态消息、静态消息 ",
                        " 同步消息、异步消息、动态消息、参与者创建消息、参与者销毁消息 ",
                        " 同步消息、异步消息、静态消息、参与者创建消息、参与者销毁消息 ",
                        " 同步消息、异步消息、返回消息、参与者创建消息、参与者销毁消息 "
                    ]
                },
                {
                    "index": 245,
                    "belong_page": 1,
                    "question_id": 363081,
                    "question_title": "<p>构建用例模型的过程有识别参与者、合并需求获得用例、细化用例描述、调整用例模型，其中哪个阶段不是必须的（ ）。</p>",
                    "question_type": 1,
                    "answer_type": 1,
                    "show_type_name": "单选题",
                    "new_parent_id": 363081,
                    "score_rule": "",
                    "material_text": "",
                    "sort_son": "0",
                    "analyze": "构建用例模型分为四个阶段：识别参与者、合并需求获得用例、细化用例描述、调整用例模型，其中调整用例模型不是必须的。",
                    "like": 0,
                    "answer": [
                        "D"
                    ],
                    "option": [
                        " 识别参与者 ",
                        " 合并需求获得用例 ",
                        " 细化用例描述 ",
                        " 调整用例模型 "
                    ]
                },
                {
                    "index": 246,
                    "belong_page": 1,
                    "question_id": 363082,
                    "question_title": "<p>（ ）是一种以用户需求为动力，以对象为驱动的模型，主要用于描述面向对象的软件开发过程。</p>",
                    "question_type": 1,
                    "answer_type": 1,
                    "show_type_name": "单选题",
                    "new_parent_id": 363082,
                    "score_rule": "",
                    "material_text": "",
                    "sort_son": "0",
                    "analyze": "<p>喷泉模型是一种以用户需求为动力，以对象为驱动的模型，主要用于描述面向对象的软件开发过程。</p><p>瀑布模型属于结构化开发；螺旋模型是瀑布模型与原型模型的结合；原型模型属于原型法也称快速原型法可以根据用户初步需求利用系统工具快速建立一个系统模型，与用户交流。</p>",
                    "like": 0,
                    "answer": [
                        "A"
                    ],
                    "option": [
                        " 喷泉模型 ",
                        " 瀑布模型 ",
                        " 螺旋模型 ",
                        " 原型模型 "
                    ]
                },
                {
                    "index": 247,
                    "belong_page": 1,
                    "question_id": 43728,
                    "question_title": "<p>试题二（25分）<br/>阅读以下关于系统数据分析与建模的叙述，在答题纸上回答问题1 至问题 3。<br/>【说明】<br/>&nbsp;某公司正在研发一套新的库存管理系统。系统中一个关键事件是接收供应商供货。项目组系统分析员小王花了大量时间在仓库观察了整个事件的处理过程，并开发出该过程所执行活动的列表：供应商发送货物和商品清单。公司收到商品后执行收货处理，包括卸载商品、确定收到了订单上的商品、处理与供应商的分歧等。对于已有商品，调整其库存信息，对于新采购的商品，在库存中添加新的商品记录。收货完成后，系统执行入库处理，将商品放到仓库对应的货架上。在付款处理活动中，自动生成应付账款信息，如果查询到该供应商有待付款记录，则进行合并付款，付款完成后消除应付账款记录。最后，仓库管理员根据最新的库存商品，调整出货信息。<br/>&nbsp;&nbsp; &nbsp;小王根据自己观察的过程创建了该事件的1层数据流图，如下图所示。</p><p><img style=\"max-width:100%;height:auto\"  src=\"https://s2.51cto.com/images/201807/d13a8809054b04f6fb751040f39950166f2232.png\"/></p><p><br/></p><p><br/></p><p>【问题1】</p><p>请用300以内文字说明数据流图(Data Flow Diagram)的基本元素及其作用。</p><p><br/></p><p><br/></p><p><br/></p><p>【问题2】</p><p>数据流图在绘制过程中可能出现多种语法错误，请分析题图所示数据流图中哪些地方有错误，并分别说明错误的类型。<span style=\"mso-spacerun:&#39;yes&#39;;font-family:Courier;mso-fareast-font-family:&#39;Times New Roman&#39;;mso-hansi-font-family:&#39;Times New Roman&#39;;font-size:10.5000pt;mso-font-kerning:1.0000pt;\"></span></p><p><br/></p><p><br/></p><p><img style=\"max-width:100%;height:auto\"  src=\"https://s2.51cto.com/images/201807/1652ada006604957347653dfef5a5c6e988d34.png\"/></p><p><br/></p>",
                    "question_type": 5,
                    "answer_type": 5,
                    "show_type_name": null,
                    "new_parent_id": 43728,
                    "score_rule": "",
                    "material_text": null,
                    "sort_son": "0",
                    "analyze": "<p></p><p>CRUD(Create\\Read%update\\Delete)矩阵用于检查系统建模过程中数据模型和过程模型的一致性，分别表示了加工对于数据的新增、读取、修改和删除四种操作。根据需求陈述和所给表所示内容，P5.1收货处理和P5.4付款处理两个加工分别需要获得供应商的货运信息和付款记录，(1)和(2)处为读取操作(R)；P5.2入库处理中需要添加新的商品记录或者查询并修改现有商品的库存信息，(3)处为创建、读取和更新操作；P5.3调整出货会读取并修改库存商品信息，(4)处为读取和修改操作(Ru)；P5.4付款处理中除了生成付款记录、读取或修改付款记录外，对于已经付款的信息要消除应付款信息，所以(5)处为新增、读取、修改和删除四种操作(CRUD)。</p>",
                    "like": 0,
                    "answer": [
                        "<p>【问题1】</p><p>数据流图(Data Flow Diagram)的四种基本元素及其作用：<br/></p><p>&nbsp;&nbsp; &nbsp;(1)External Agent(实体/外部代理)：定义位于项目范围之外，但与正在被研发的系统有交互关系的人、部门、外部系统或组织。</p><p>&nbsp;&nbsp; &nbsp;(2)Process(加工/处理)：在输入数据流或条件上执行，或者对输入数据流或条件做出响应的工作。</p><p>&nbsp;&nbsp; &nbsp;(3)Data Store(数据存储)：静止的数据，表示系统中需要保存的数据。</p><p>&nbsp;&nbsp; &nbsp;(4)Data Flow(数据流)：运动中的数据，表示到一个过程的数据输入，或者来自一个过程的数据输出。</p><p>【问题2】</p><p>&nbsp;&nbsp; &nbsp;(1)D1到A2：缺少移动数据流的加工。</p><p>&nbsp;&nbsp; &nbsp;(2)P5.3：没有输出数据流，输入输出不平衡。</p><p>&nbsp;&nbsp; &nbsp;(3)P5.4：没有输入数据流，输入输出不平衡。</p><p>&nbsp;&nbsp; &nbsp;(4)D2：数据存储没有输出的数据流。（此条可不必写）</p><p>【问题3】</p><p>(1)R &nbsp; &nbsp;(2)R &nbsp; &nbsp;(3)CRU &nbsp; &nbsp;(4)RU &nbsp; &nbsp;(5)CRUD</p><p><br/></p>"
                    ],
                    "option": "[]"
                },
                {
                    "index": 248,
                    "belong_page": 1,
                    "question_id": 43729,
                    "question_title": "<p>试题三（25分）<br/>请详细阅读有关嵌入式构件设计方面的说明，回答下列问题。<br/>【说明】<br/>&nbsp;构件(component)也称为组件，是一个功能相对独立的具有可复用价值的软硬件单元。近年来，构件技术正在逐步应用于大型嵌入式系统的软件设计。某公司长期从事飞行器电子设备研制工作，已积累了大量成熟软件。但是，由于当初管理和设计等原因，公司的大量软件不能被复用，严重影响了公司后续发展。公司领导层高度重视软件复用问题，明确提出了要将本公司的成熟软件进行改造，建立公司可复用的软件构件库，以提升开发效率、降低成本。公司领导层决定将此项任务交给技术部门的王工程师负责组织实施。两个月后，王工程师经过调研、梳理和实验，提交了一份实施方案。此方案得到了公司领导层的肯定，但在实施过程中遇到了许多困难，主要表现在公司软件架构的变更和构件抽取的界面等方面。<br/><br/>【问题1】<br/>请用200字以内文字说明获取构件的方法有哪几种?开发构件通常采用哪几种策略?并列举出两种主流构件标准。</p><p><img style=\"max-width:100%;height:auto\"  src=\"https://s2.51cto.com/images/201807/752de36554881522b66990695a3047e4bfb6e5.png\"/></p><p><img style=\"max-width:100%;height:auto\"  src=\"https://s2.51cto.com/images/201807/6818fd882092250a4ff56120924fc8af1a7fa0.png\"/>【问题3】<br/>王工程师的实施方案指出：本公司的大部分产品是为用户提供标准计算平台的，而此平台中的主要开发工作是为嵌入式操作系统研制板级支持软件(BSP)。为了提高BSP软件的复用，应首先开展BSP构件的开发，且构件架构应符合国外GENESYS规范定义的嵌入式系统架构风格。下图给出了架构风格定义的构件通用接口，其中：链接接口(LIF.是构件对外提供的功能服务接口；局部接口建立了构件和它的局部环境的连接，如传感器、作动器或人机接口；技术相关接口(TDI)提供了查看构件内部、观察构件的内部变量的手段，如诊断等；技术无关接口(TII)用来在运行时配置、复位、重启构件的接口。现需要针对BSP中常用的RS-232串行驱动程序设计一个可复用的软构件，请说明该软构件四类接口的具体功能。</p><p><br/></p><p><img style=\"max-width:100%;height:auto\"  src=\"https://s2.51cto.com/images/201807/a3e843d53b0afd0b8f6047cec681fd4a51ec89.png\"/></p><p><br/></p><p><br/></p>",
                    "question_type": 5,
                    "answer_type": 5,
                    "show_type_name": null,
                    "new_parent_id": 43729,
                    "score_rule": "",
                    "material_text": null,
                    "sort_son": "0",
                    "analyze": "<p>答案：<br/>基于构件的软件开发中，可以通过不同的途径来获取构件，主要包括以下4种方法：<br/>&nbsp;&nbsp; &nbsp;(1)从现有构件中获得符合要求的构件，直接使用或做适应性修改，得到可复用的构件；<br/>&nbsp;&nbsp; &nbsp;(2)通过遗留工程(Legacy Engineering)，将具有潜在复用价值的软件提取出来，得到可复用的构件；<br/>&nbsp;&nbsp; &nbsp;(3)从市场上购买现成的商业构件，即COTS (Commercial Off-The-Shell)构件；<br/>&nbsp;&nbsp; &nbsp;(4)开发新的符合要求的构件。<br/>&nbsp;&nbsp; &nbsp;开发构件通常采取3种策略：<br/>&nbsp;&nbsp; &nbsp;(1)分区(partitioning)：指的是将问题情景的空间分割成几乎可以独立研究的部分；<br/>&nbsp;&nbsp; &nbsp;(2)抽象(abstraction)：是对在给定实践内执行指定计算的软/硬件单元的一种抽象；<br/>&nbsp;&nbsp; &nbsp;(3)分割(segmentation)；是将结构引入构件的行为，支持对行为性质进行时序推理。<br/>&nbsp;&nbsp; &nbsp;当前主流构件标准有：<br/>&nbsp;&nbsp; &nbsp;(1)CORBA：由OMG(对象管理集团)制定；<br/>&nbsp;&nbsp; &nbsp;(2)COM/DCOM：由Microsoft制定；<br/>&nbsp;&nbsp; &nbsp;(3)EJB：由SUN的Java企业Bean制定。<br/><br/>答案：(1)√ &nbsp; &nbsp;(2)× &nbsp; &nbsp;(3)× &nbsp; &nbsp;(4)√ &nbsp; &nbsp;(5)× &nbsp; &nbsp;(6)×<br/>&nbsp;&nbsp;&nbsp; 错误分析：<br/>&nbsp;&nbsp; &nbsp;(2)“构件是解决软件复用的基础，复用的形式可分为垂直式复用和水平式复用。而垂直式复用的主要关键点在于领域分析，具有领域特征和相似性，受到广泛关注”。垂直式复用是与领域特性相关的，而水平式复用是一种公用的服务，不予某个特殊领域相关。<br/>&nbsp;&nbsp; &nbsp;(3)“构件构建在平台之上，平台提供核心平台服务，是构件实现与构件组装的基础。构件组装通常采用基于功能的组装技术、基于数据的组装技术和面向对象的组装技术等三种技术”。配置只是一种构件功能组合动态方法，而不是构件组装的技术。<br/>&nbsp;&nbsp; (5)“构件可分为硬件构件、软件构件、系统构件和应用构件。RTL(运行时库)属于软件构件，由于RTL可适应多种应用领域，所以RTL与属于水平式复用构件”。RTL是C/C++语言为用户提供的一种运行时库，如数学库、stdio库等，它可服务于多种应用，而与领域需求无关，所以说RTL不属于垂直式复用构件。<br/>&nbsp;&nbsp;(6)“硬件构件的功能被给定的硬件结构如ASIC预先确定，他是不能修改的。同样，软件构件的功能由在FPGA或者CPU上的软件确定的，我们将加载在软件构件上的软件称为作业。将作业分配给适当的可以执行该作业的硬件单元就创建了新的构件。软件构件的功能所以在构件的寿命期中可以修改”。<br/><br/>答案：<br/>RS-232驱动程序主要完成对RS-232芯片的初始化，实现RS-232数据发送、接收和控制等功能。依据GENESYS规范定义的构件接口含义，RS-232驱动程序构件的接口定义如下：<br/>&nbsp;&nbsp; &nbsp;(1)链接接口<br/>&nbsp;&nbsp; &nbsp;RS-232驱动构件的使用者是上层的操作系统或应用软件，本构件应该给他们提供串行接口的数据发送、数据接收服务。因此，链接接口至少包括以下功能服务：<br/>&nbsp;&nbsp; &nbsp;●Send()：处理机中的程序向RS-232芯片输出数据；<br/>&nbsp;&nbsp; &nbsp;●Receive()：处理机中的程序通过RS-232芯片从外部接收数据；<br/>&nbsp;&nbsp; &nbsp;●Init232()：初始化RS-232芯片。<br/>&nbsp;&nbsp; &nbsp;(2)局部接口<br/>&nbsp;&nbsp; &nbsp;RS-232驱动构件的局部接口应该是RS-232芯片为编程提供的各类寄存器和CPU对外围芯片的支持，此接口与硬件紧密相关。就RS-232芯片而言，局部接口至少包括以下功能服务：<br/>&nbsp;&nbsp; &nbsp;●Intconnect()：将RS-232芯片的外部中断向量连接到CPU；<br/>&nbsp;&nbsp; &nbsp;●Read()：从RS-232芯片中读取寄存器的内容(包括控制、状态类寄存器和数据输入寄存器)；<br/>&nbsp;&nbsp; &nbsp;●Write()：将控制信息或输出的数据写入RS-232芯片的相应寄存器。<br/>&nbsp;&nbsp; &nbsp;(3)技术相关接口<br/>&nbsp;&nbsp; &nbsp;RS-232驱动构件的技术相关接口应该是RS-232驱动构件为维护人员提供的芯片诊断接口，此接口与硬件和应用紧密相关。就RS-232芯片使用而言，技术相关接口至少包括以下诊断功能服务：<br/>&nbsp;&nbsp; &nbsp;●Datacheck()：诊断数据传输校验的错误。<br/>&nbsp;&nbsp; &nbsp;(4)技术无关接口<br/>&nbsp;&nbsp; &nbsp;RS-232驱动构件的技术无关接口应该是RS-232驱动构件为编程人员提供的芯片初始化或运行时的配置接口。技术无关接口至少包括以下功能服务：<br/>&nbsp;&nbsp; &nbsp;●Reset()：RS-232芯片或驱动构件复位；<br/>&nbsp;&nbsp; &nbsp;●Restart()：RS-232芯片或驱动构件重启动；<br/>&nbsp;&nbsp; &nbsp;●Rateconfigure()：配置、重新配置RS-232传输速率。<br/></p>",
                    "like": 0,
                    "answer": [
                        "<p>见解析</p>"
                    ],
                    "option": "[]"
                },
                {
                    "index": 249,
                    "belong_page": 1,
                    "question_id": 43732,
                    "question_title": "<p><br/></p><p>试题一&nbsp;&nbsp;论软件需求管理</p><p>&nbsp;&nbsp; &nbsp;软件需求管理是一个对系统需求变更了解和控制的过程。需求管理过程与需求开发过程相互关联，初始需求导出的同时就要形成需求管理规划，一旦启动了软件开发过程，需求管理活动就紧密相伴。</p><p>&nbsp;&nbsp; &nbsp;需求管理过程中主要包含变更控制、版本控制、需求跟踪和需求状态跟踪等4项活动，其目标是为项目管理人员建立一个软件需求基线，并保持软件计划、产品和活动与软件需求的一致性。</p><p>&nbsp;&nbsp; &nbsp;请围绕“软件需求管理”论题，依次从以下三个方面进行论述。</p><p>&nbsp;&nbsp; &nbsp;1．概要叙述你参与管理和开发的软件项目以及你在其中所担任的主要工作。</p><p>&nbsp;&nbsp; &nbsp;2．详细描述需求管理过程中各个活动中的主要工作。</p><p>&nbsp;&nbsp; &nbsp;3．详细说明你所参与的软件开发项目中，是如何进行软件需求管理的，实施的具体效果如何。<span style=\"mso-spacerun:&#39;yes&#39;;font-family:Courier;mso-fareast-font-family:宋体;font-size:10.5000pt;mso-font-kerning:1.0000pt;\"></span></p><p><br/></p>",
                    "question_type": 5,
                    "answer_type": 5,
                    "show_type_name": null,
                    "new_parent_id": 43732,
                    "score_rule": "",
                    "material_text": null,
                    "sort_son": "0",
                    "analyze": "<p>略</p>",
                    "like": 0,
                    "answer": [
                        "<p>见解析</p>"
                    ],
                    "option": "[]"
                },
                {
                    "index": 250,
                    "belong_page": 1,
                    "question_id": 45942,
                    "question_title": "<p><br/></p><p style=\"text-indent:32px\">试题一（25分）</p><p>阅读以下关于软件架构设计的叙述，在答题纸上回答问题1至问题3</p><p style=\"margin-top:5px;text-indent:28px;text-align:left\">【说明】</p><p>某软件公司为某品牌手机厂商开发一套手机应用程序集成开发环境，以提高开发手机应用程序的质量和效率。在项目之初，公司的系统分析师对该集成开发环境的需求进行了调研和分析，具体描述如下：</p><p>a．需要同时支持该厂商自行定义的应用编程语言的编辑、界面可视化设计、编译、调试等模块，这些模块产生的模型或数据格式差异较大，集成环境应提供数据集成能力。集成开发环境还要支持以适配方式集成公司现有的应用模拟器工具。</p><p>b．经过调研，手机应用开发人员更倾向于使用Windows系统，因此集成开发环境的界面需要与Windows平台上的主流开发工具的界面风格保持一致口</p><p>c．支持相关开发数据在云端存储，需要保证在云端存储数据的机密性和完整性。</p><p>d．支持用户通过配置界面依据自己的喜好修改界面风格，包括颜色、布局、代码高亮方式等，配置完成后无需重启环境。</p><p>e．支持不同模型的自动转换。在初始需求中定义的机器性能条件下，对于一个包含50个对象的设计模型，将其转换为相应代码框架时所消耗时间不超过5秒。</p><p>f．能够连续运行的时间不小于240水时，意外退出后能够在1 0秒之内自动重启。</p><p>g．集成开发环境具有模块化结构，支持以模块为单位进行调试、测试与发布口</p><p>h．支持应用开发过程中的代码调试功能：开发人员可以设置断点，启动调试，编辑器可以自动卷屏并命中断点，能通过变量监视器查看当前变量取值。</p><p>在对需求进行分析后，公司的架构师小张查阅了相关的资料，认为该集成开发环境应该采用管道—过滤器(Pipe-Filter)的架构风格，公司的资深架构师王工在仔细分析后，认为应该采用数据仓储（Data Repository）的架构风格。公司经过评审，最终采用了王工的方案。</p><p>【问题1】（10分）</p><p>识别软件架构质量属性是进行架构设计的重要步骤。请分析题干中的需求描述，填写表1-1中(1)～(5)处的空白。</p><p><img style=\"max-width:100%;height:auto\"  src=\"https://s1.51ctocdn.cn//images/20180827/1535370410988822.png\" title=\"1535370410988822.png\" alt=\"图片.png\"/><br/><img style=\"max-width:100%;height:auto\"  src=\"https://s1.51ctocdn.cn//images/20180827/1535370434614464.png\" title=\"1535370434614464.png\" alt=\"图片.png\"/><br/></p><p>【问题3】（8分）</p><p>在确定采用数据仓库架构风格后，王工给出了集成开发环境的架构图。请填写图1-1中(1)～(4)处的空白，完成该集成开发环境的架构图。</p><p><img style=\"max-width:100%;height:auto\"  src=\"https://s1.51ctocdn.cn//images/20180827/1535370458828294.png\" title=\"1535370458828294.png\" alt=\"图片.png\"/><br/><br/></p>",
                    "question_type": 5,
                    "answer_type": 5,
                    "show_type_name": null,
                    "new_parent_id": 45942,
                    "score_rule": "",
                    "material_text": null,
                    "sort_son": "0",
                    "analyze": "<p>略<br/></p>",
                    "like": 0,
                    "answer": [
                        "<p>参考答案：</p><p>（1）f （2）性能 （3）d （4）g （5）b</p><p>参考答案：</p><p>（1）通过数据仓储间接交互的星型结构</p><p>（2）流式数据</p><p>（3）数据驱动</p><p>（4）与数据仓储进行模型适配</p><p>参考答案：</p><p>（1）语法结构树<br/>（2）编辑器<br/>（3）适配器<br/>（4）模拟器</p><p><br/></p>"
                    ],
                    "option": "[]"
                },
                {
                    "index": 251,
                    "belong_page": 1,
                    "question_id": 45945,
                    "question_title": "<p><br/></p><p style=\"text-indent:32px\">试题二（25分）</p><p>阅读以下关于软件系统建模的叙述，在答题纸上回答问题1至问题3。</p><p style=\"margin-top:5px;text-indent:28px;text-align:left\">【说明】</p><p>某软件公司计划开发一套教学管理系统，用于为高校提供教学管理服务。该教学管理系统基本的需求包括：</p><p>(1)系统用户必须成功登录到系统后才能使用系统的各项功能服务；</p><p>(2)管理员（Registrar）使用该系统管理学校（University）、系（Department）、教师（Lecturer）、学生（Student）和课程(Course)等教学基础信息；</p><p>(3)学生使用系统选择并注册课程，必须通过所选课程的考试才能获得学分；如果考试不及格，必须参加补考，通过后才能获得课程学分；</p><p>(4)教师使用该系统选择所要教的课程，并从系统获得选择该课程的学生名单；</p><p>(5)管理员使用系统生成课程课表，维护系统所需的有关课程、学生和教师的信息；</p><p>(6)每个月到了月底系统会通过打印机打印学生的考勤信息。</p><p>项目组经过分析和讨论，决定采用面向对象开发技术对系统各项需求建模。</p><p>【问题1】（7分）</p><p>用例建模用来描述待开发系统的功能需求，主要元素是用例和参与者。请根据题目所述需求，说明教学服务系统中有哪些参与者。</p><p><br/></p><p>【问题2】（7分）</p><p>用例是对系统行为的动态描述，用例获取是需求分析阶段的主要任务之一。请指出在面向对象系统建模中，用例之间的关系有哪几种类型？对题目所述教学服务系统的需求建模时， “登录系统”用例与“注册课程”用例之间、“参加考试”用例与“参加补考”用例之间的关系分别属于哪种类型？</p><p>&nbsp;</p><p>【问题3】（11分）</p><p>类图主要用来描述系统的静态结构，是组件图和配置图的基础。请指出在面向对象系统建模中，类之间的关系有哪几种类型？对题目所述教学服务系统的需求建模时，类University与类Student之间、类University和类Department之间、类Student和类Course之间的关系分别属于哪种类型？</p><p><br/></p><br/><br/>",
                    "question_type": 5,
                    "answer_type": 5,
                    "show_type_name": null,
                    "new_parent_id": 45945,
                    "score_rule": "",
                    "material_text": null,
                    "sort_son": "0",
                    "analyze": "<p>略<br/></p>",
                    "like": 0,
                    "answer": [
                        "<p>参考答案：</p><p>学生、教师、管理员、时间、打印机。</p><p>参考答案：</p><p>用例之间的关系包括：包含、扩展。</p><p>“登录系统”用例与“注册课程”用例之间的关系为：包含关系。</p><p>“参加考试”用例与“参加补考”用例之间的关系为：扩展关系。</p><p>&nbsp;</p><p>参考答案：</p><p>类之间的关系包括：关联、聚合、组合、依赖、泛化。</p><p>类University与类Student之间的关系是：聚合关系。</p><p>类University与类Department之间的关系是：组合关系。</p><p>类Student与类Course之间的关系是：关联关系。<br/></p>"
                    ],
                    "option": "[]"
                },
                {
                    "index": 252,
                    "belong_page": 1,
                    "question_id": 45949,
                    "question_title": "<p><br/></p><p style=\"text-indent:32px\">试题三（25分）</p><p>阅读以下关于嵌入式实时系统设计的描述，回答问题1至问题3。</p><p style=\"margin-top:5px;text-indent:28px;text-align:left\">【说明】</p><p>嵌入式系统是当前航空、航天、船舶及工业、医疗等领域的核心技术，嵌入式系统可包括实时系统与非实时系统两种。某宇航公司长期从事航空航天飞行器电子设备的研制工作，随着业务的扩大，需要大量大学毕业生补充到科研生产部门。按照公司规定，大学毕业生必须进行相关基础知识培训，为此，公司经理安排王工对他们进行了长达一个月的培训。</p><p>【问题1】（7分）</p><p>王工在培训中指出：嵌入式系统主要负责对设备的各种传感器进行管理与控制。而航空航天飞行器的电子设备由于对时间具有很强的敏感性，通常由嵌入式实时系统进行管控，请用300字以内文字说明什么是实时系统，实时系统有哪些主要特性。</p><p>【问题2】（8分）</p><p>实时系统根据应用场景、时间特征以及工作方式的不同，存在多种实时特性，大致有三种分类方法，即时间类别、时间需求和工作方式结构。根据自己所掌握的“实时性”知识，将图3-1给出的实时特性按三种分类方式，填写图3-1中(1)～(8)处空白。</p><p>备选答案：时限的危害程度；时间角包；弱；时间响应；固定；时限／反应时间；时间明确；输入输出激励；时间触发；强；周期／零星／非周期；事件触发。</p><p><img style=\"max-width:100%;height:auto\"  src=\"http://s2.51cto.com/images/20180827/1535370602311148.png\" title=\"1535370602311148.png\" alt=\"图片.png\"/><br/></p><p>【问题3】（10分）</p><p>可靠性是实时系统的关键特性之一，区分软件的错误(Error)、缺陷（Defect）、故障(Fault)和失效(Failure)概念是软件可靠性设计工作的基础。请简要说明错误、缺陷、故障和失效的定义；并在图3-2中标出错误、缺陷和失效出现阶段，说明缺陷、故障和失效的表现形式，填写图3-2中(1)～(6)处的空白。</p><p><img style=\"max-width:100%;height:auto\"  src=\"http://s2.51cto.com/images/20180827/1535370630642241.png\" title=\"1535370630642241.png\" alt=\"图片.png\"/><br/><br/></p>",
                    "question_type": 5,
                    "answer_type": 5,
                    "show_type_name": null,
                    "new_parent_id": 45949,
                    "score_rule": "",
                    "material_text": null,
                    "sort_son": "0",
                    "analyze": "<p>略<br/></p>",
                    "like": 0,
                    "answer": [
                        "<p>参考答案：</p><p>实时系统是指向系统发出一指令后，在一个极短的时间内，系统回复结果。</p><p>实时系统的特性：</p><p>（1）时间约束性（及时性）</p><p>（2）可预测性</p><p>（3）高可靠性</p><p>（4）与外部环境的交互作用性</p><p>（5）多任务类型</p><p>（6）约束的复杂性</p><p>（7）具有短暂超载的特点</p><p>参考答案：</p><p>（1）强</p><p>（2）（3）时间响应、时间明确</p><p>（4）（5）（6）时限/反应时间、输入/输出激励、周期/零星/非周期</p><p>（7）（8）时间触发、事件触发</p><p>参考答案：</p><p>软件错误：软件错误是指在软件生存期内的不希望或不可接受的人为错误，其结果是导致软件缺陷的产生。</p><p>软件缺陷：软件缺陷是存在于软件（文档、数据、程序）之中的那些不希望或不可接受的偏差。</p><p>软件故障：软件故障是指软件运行过程中出现的一种不希望或不可接受的内部状态。</p><p>软件失效：软件失效是指软件运行时产生 的一种不希望或不可接受的外部行为结果。</p><p>（1）存在</p><p>（2）引起</p><p>（3）用户经历</p><p>（4）在开发过程中</p><p>（5）在产品中</p><p>（6）在运行时</p><p><br/></p>"
                    ],
                    "option": "[]"
                },
                {
                    "index": 253,
                    "belong_page": 1,
                    "question_id": 54270,
                    "question_title": "<p>某公司拟开发一个商业情报处理系统，使公司能够及时针对市场环境的变化及时调整发展战略，以获取最大的商业利益。项目组经过讨论，决定采用结构化分析和设计方法。在系统分析阶段，为了更好地对情报数据处理流程及其与外部角色的关联进行建模，项目组成员分别给出了自己的设计思路：<br/>（1）小张提出先构建系统流程图（System Flowcharts），以便更精确地反映系统的业务处理过程及数据的输入和输出；<br/>（2）小李提出先构建系统数据流图（Data Flow Diagrams），来展现系统的处理过程和定义业务功能边界，并给出了情报分类子系统的0层和1层数据流图，后者如图2-1所示。<br/><img style=\"max-width:100%;height:auto\"  src=\"http://s2.51cto.com/images/20181012/1539331194120751.jpg\" title=\"1539331194120751.jpg\" alt=\"1.jpg\"/><br/>项目组经讨论确定以数据流图作为本阶段的建模手段。工程师老王详细说明了流程图和数据流图之间的区别与联系，并指出了图2-1的数据流图中存在的错误。<br/>【问题1】（11分）<br/>流程图和数据流图是软件系统分析设计中常用的两种手段，请用300字以内文字简要说明流程图与数据流图的含义及其区别，并说明项目组为何确定采用数据流图作为建模手段。<br/>【问题2】（8分）<br/>请分析指出图2-1所示的数据流图中存在的错误及其原因，并针对图2-1的1层数据流图绘制出情报分类子系统的0层数据流图。<br/>【问题3】（6分）<br/>高质量的数据流图是可读的、内部一致的并能够准确表示系统需求。请用300字以内文字说明在设计高质量的数据流图时应考虑的三个原则。</p>",
                    "question_type": 5,
                    "answer_type": 5,
                    "show_type_name": null,
                    "new_parent_id": 54270,
                    "score_rule": "",
                    "material_text": null,
                    "sort_son": "0",
                    "analyze": "<p>无</p>",
                    "like": 0,
                    "answer": [
                        "<p>【问题1】<br/>数据流图作为一种图形化工具，用来说明业务处理过程、系统边界内所包含的功能和系统中的数据流。<br/>流程图以图形化的方式展示应用程序从数据输入开始到获得输出为止的逻辑过程，描述处理过程的控制流。<br/>两者的区别主要包括：<br/>（1）数据流图中的处理过程可并行；流程图在某个时间点只能处于一个处理过程。<br/>（2）数据流图展现系统的数据流；流程图展现系统的控制流。<br/>（3）数据流图展现全局的处理过程，过程之间遵循不同的计时标准；流程图中处理过程遵循一致的计时标准。<br/>（4）数据流图适用于系统分析中的逻辑建模阶段；流程图适用于系统设计中的物理模阶段。<br/>【问题2】<br/>如图所示的数据流图中存在的错误有以下4种：<br/>（1）&quot;分类训练&quot;加工：只有输入没有输出，产生数据黑洞；<br/>（2）&quot;分类处理&quot;加工：有输出没有输入，无中生有；<br/>（3）&quot;规则文件&quot;数据流：外部实体没有经过加工处理，直接到数据存储；<br/>（4）&quot;配置信息&quot;数据流：外部实体之间没有加工处理，存在直接数据流。<br/><img style=\"max-width:100%;height:auto\"  src=\"http://s2.51cto.com/images/20181012/1539331217728457.jpg\" title=\"1539331217728457.jpg\" alt=\"1.jpg\"/><br/>【问题3】<br/>高质量数据流图设计时应考虑的三个原则：<br/>（1）复杂性最小化原则。DFD分层结构就是把信息划分为小的且相对独立的一大批子集例子，这样就可以单独考查每一个DFD。如果要了解某个过程更加详的信息，可以跳转到该过程的下一层；如果要知道一个DFD如何与其他DFD相关联，可以跳转到上一层的DFD进行考查。<br/>（2）接口最小化原则。接口最小化是复杂性最小化的一种具体规则。在设计模式时，应使得模型中各个元素之间的接口数或连接数最小化。<br/>（3）数据流一致性原则。一个过程和它的过程分解在数据流内容中是否有差别？是否存在有数据流出但没有相应的数据流入的加工？是否存在有数据流入但没有相应的数据流出的加工？</p>"
                    ],
                    "option": "[]"
                },
                {
                    "index": 254,
                    "belong_page": 1,
                    "question_id": 63700,
                    "question_title": "<p>阅读以下关于软件系统建模的叙述，在答题纸上回答问题1至问题3。</p><p>[说明]某公司欲建设-一个房屋租赁服务系统，统一管理房主和租赁者的信息，提供快捷的租赁服务。本系统的主要功能描述如下:&nbsp;</p><p>1.登记房主信息。记录房主的姓名、住址、身份证号和联系电话等信息，并写入房主信息文件。</p><p>2.登记房屋信息。记录房屋的地址、房屋类型(如平房、带阳台的楼房、独立式住宅等)、楼层、租金及房屋状态(待租赁、已出租)等信息，并写入房屋信息文件。-名房主可以在系统中登记多套待租赁的房屋。</p><p>3.登记租赁者信息。记录租赁者的个人信息，包括:姓名、性别、住址、身份证号和电话号码等，并写入租赁者信息文件。</p><p>4.安排看房。已经登记在系统中的租赁者，可以从待租赁房屋列表中查询待租赁房屋信息。租赁者可以提出看房请求，系统安排租赁者看房。对于每次看房，系统会生成一条看房记录并将其写入看房记录文件中。</p><p>5.收取手续费。房主登记完房屋后，系统会生成一份费用单，房主根据费用单交纳相应的费用。</p><p>6.变更房屋状态。当租赁者与房主达成租房或退房协议后，房主向系统提交变更房屋状态的请求。系统将根据房主的请求，修改房屋信息文件。</p><p><img style=\"max-width:100%;height:auto\"  src=\"http://s2.51cto.com/images/20181127/1543312351968704.jpg\" title=\"1543312351968704.jpg\" alt=\"1.jpg\"/></p><p>[问题1](12分)<br/></p><p>若来用结构化方法对房屋租赁服务系统进行分析，得到如图2-1所示的顶层DFD,使用题干中给出的词语，给出图2-1中外部实体E1~E2、加工P1~P6以及数据存储D1~D4的名称。</p><p>[问题2] (5分)</p><p>若采用信息工程(Information Engineering)方法对房屋租赁服务系统进行分析，得到如图2-2所示的ERD.请给出图2-2中实体(1) ~ (5) 的名称。</p><p>[问题3](8分)</p><p>(1)信息工程方法中的&#39;实体(entity) ”与面向对象方法中的“类(class) ”之间有哪些不同之处?</p><p>(2)在面向对象方法中通常采用用例(Use Case)来捕获系统的功能需求。用例可以按照不同的层次来进行划分,其中的Essential Use Cases和Real Use Cases有哪些区别?<br/><img style=\"max-width:100%;height:auto\"  src=\"http://s2.51cto.com/images/20181127/1543312360520122.jpg\" title=\"1543312360520122.jpg\" alt=\"2.jpg\"/></p>",
                    "question_type": 5,
                    "answer_type": 5,
                    "show_type_name": null,
                    "new_parent_id": 63700,
                    "score_rule": "",
                    "material_text": null,
                    "sort_son": "0",
                    "analyze": "<p>略</p>",
                    "like": 0,
                    "answer": [
                        "<p>[问题1]</p><p>E1:房主</p><p>E2:租赁者</p><p>P1:登记房主信息</p><p>P2:登记房屋信息</p><p>P3:登记租赁者信息</p><p>P4:查询租赁房屋信息</p><p>P5:安排看房</p><p>P6:变更房屋状态</p><p>D1:房主信息文件</p><p>D2:租赁者信息文件</p><p>D3:房屋信息文件</p><p>D4:看房记录文件</p><p>[问题2]</p><p>(1) 房主</p><p>(2) 房屋</p><p>(3) 房屋信息文件</p><p>(4) 租赁者</p><p>(5) 看房记录</p><p>[问题3]</p><p>(1)实体用于数据建模，而类用于面向对象建模。实体只有属性，而类有属性和操作。</p><p>(2) Essential Use Cases可翻译为抽象用例，Real Use Cases可翻译为基础用例。他们是区别在于: 基础用例是实实在在与用户需求有对应关系的用例，是从用户需求获取的渠道得到的，而抽象用例是从基础用例中抽取的用例的公共部分，是为了避免重复工作，优化结构而提出的用例。</p>"
                    ],
                    "option": "[]"
                },
                {
                    "index": 255,
                    "belong_page": 1,
                    "question_id": 63707,
                    "question_title": "<p>阅读以下关于分布式数据库缓存设计的叙述，在答题纸，上回答问题1至问题3.</p><p>[说明]某企业是为城市高端用户提供高品质蔬菜生鲜服务的初创企业，创业初期为快速开展业务，该企业采用轻量型的开发架构(脚本语言+关系型数据库)研制了一套业务系统。业务开展后受到用户普遍欢迎，用户数和业务数量迅速增长，原有的数据库服务器已不能满足高度并发的业务要求。为此，该企业成立了专门的研发团队来解决该问题。张工建议重新开发整个系统，采用新的服务器和数据架构，解决当前问题的同时为日后的扩展提供支持。但是，李工认为张工的方案开发周期过长，投入过大，当前应该在改动尽量小的前提下解决该问题。李工认为访问量很大的只是部分数据，建议采用缓存工具MemCache来减轻数据库服务器的压力，这样开发量小，开发周期短，比较适合初创公司，同时将来也可以通过集群进行扩展。然而，刘工又认为李工的方案中存在数据可靠性和一致性问题，在宕机时容易丢失交易数据，建议采用Redis来解决问题。 在经过充分讨论，该公司最终决定采用刘工的方案。</p><p><br/></p><p>[问题1](9分)</p><p>在李工和刘工的方案中，均采用分布式数据库缓存技术来解决问题。请说明分布式数据库缓存的基本概念。</p><p>表4- 1中对MemCache和Redis两种工具的优缺点进行了比较，请补充完善表4-1中的空(1) ~ (6) 。</p><p>表4-1</p><p><img style=\"max-width:100%;height:auto\"  src=\"https://s1.51ctocdn.cn//images/20181127/1543312497669959.jpg\" title=\"1543312497669959.jpg\" alt=\"1.jpg\"/></p><p><br/></p><p>[问题2](8分)</p><p>刘工认为李工的方案存在数据可靠性和一致性的问题，请说明原因。</p><p>为避免数据可靠性和一致性的问题，刘工的方案采用Redis作为数据库缓存，请说明基本的Redis与原有关系数据库的数据同步方案。</p><p>[问题3](8分)</p><p>请给出Redis分布式存储的2种常见方案和Redis集群切片的几种常见方式。</p>",
                    "question_type": 5,
                    "answer_type": 5,
                    "show_type_name": null,
                    "new_parent_id": 63707,
                    "score_rule": "",
                    "material_text": null,
                    "sort_son": "0",
                    "analyze": "<p>略</p>",
                    "like": 0,
                    "answer": [
                        "<p>[问题1]</p><p>（1）Redis不仅仅支持简单的k/v类型的数据，同时还提供list，set，hash等数据结构的存储。</p><p>（2）不支持</p><p>（3）支持</p><p>（4）不支持</p><p>（5）支持</p><p>（6）弱支持，只能保证事务中的每个操作连续执行</p><p><br/></p><p>[问题2]<br/>数据仅存在于内存中,宕机或重启数据将全部失效，这属于数据可靠性问题。<br/>MemCache不支持事务，存在数据一致性问题。<br/></p><p>读数据时，先读Redis中的数据,如果Redis没有，则从原数据库读取，并同步更新Redis数据。写数据时，先写入原数据库中，并同步更新至Redis中。</p><p><br/></p><p>[问题3]</p><p>（1）主从、Cluster<br/>（2）客户端分片、Twemproxy、Redis&nbsp;Cluster、Proxy&nbsp;+&nbsp;Redis&nbsp;Cluster</p>"
                    ],
                    "option": "[]"
                },
                {
                    "index": 256,
                    "belong_page": 1,
                    "question_id": 63709,
                    "question_title": "<p>阅读以下关于Web系统设计的叙述，在答题纸上回答问题1至问题3。</p><p>[说明]</p><p>某银行拟将以分行为主体的银行信息系统，全面整合为由总行统一管理维护的银行信息系统，实现统一的用户账户管理、转账汇款、自助缴费、理财投资、贷款管理、网上支付、财务报表分析等业务功能。但是，由于原有以分行为主体的银行信息系统中，多个业务系统采用异构平台、数据库和中间件，使用的报文交换标准和通信协议也不尽相同，使用传统的EAI解决方案根本无法实现新的业务模式下异构系统间灵活的交互和集成。因此，为了以最小的系统改进整合现有的基于不同技术实现的银行业务系统，该银行拟采用基于ESB的面向服务架构(SOA)集成方案实现业务整合。</p><p>[问题1](7分)</p><p>请说明什么是面向服务架构(SOA)以及ESB在SOA中的作用与特点。</p><p>[问题2](12分)</p><p>基于该信息系统整合的实际需求，项目组完成了基于SOA的银行信息系统架构设计方案。该系统架构图如图5-1所示:</p><p><img style=\"max-width:100%;height:auto\"  src=\"https://s1.51ctocdn.cn//images/20181127/1543312554977896.jpg\" title=\"1543312554977896.jpg\" alt=\"1.jpg\"/></p><p>请从(a) ~ (j)中选择相应内容填入图5-1的(1) ~ (6)，补充完善架构设计图。</p><p>(a)数据层</p><p>(b)界面层</p><p>(c)业务层</p><p>(d) bind</p><p>(e) 企业服务总线ESB</p><p>(f)XML</p><p>(g)安全验证和质量管理</p><p>(h)publish</p><p>(i) UDDI</p><p>(j)组件层</p><p>(k)BPEL</p><p><br/></p><p>[问题3] (6分)</p><p>针对银行信息系统的数据交互安全性需求，列举3种可实现信息系统安全保障的措施。</p>",
                    "question_type": 5,
                    "answer_type": 5,
                    "show_type_name": null,
                    "new_parent_id": 63709,
                    "score_rule": "",
                    "material_text": null,
                    "sort_son": "0",
                    "analyze": "<p>略</p>",
                    "like": 0,
                    "answer": [
                        "<p>[问题1]</p><p>SOA是一个组件模型,它将应用程序的不同功能单元(称为服务)通过这些服务之间定义良好的接口和契约联系起来。接口是采用中立的方式进行定义的,它应该独立于实现服务的硬件平台、操作系统和编程语言。这使得构建在各种这样的系统中的服务可以一种统-和通用的方式进行交互。</p><p>ESB作用与特点:</p><p>1、SOA的一种实现方式, ESB在面向服务的架构中起到的是总线作用,将各种服务进行连接与整合;</p><p>2、描述服务的元数据和服务注册管理;</p><p>3、 在服务请求者和提供者之间传递数据,以及对这些数据进行转换的能力,并支持由实践中总结出来的一些模式如同步</p><p>模式、异步模式等;</p><p>4、发现、路由、匹配和选择的能力,以支持服务之间的动态交互,解耦服务请求者和服务提供者。高级一些的能力,包括对安全的支持、服务质量保证、可管理性和负载平衡等。</p><p>(问题2)</p><p>(c)业务层</p><p>(i) UDDI</p><p>(h) publish</p><p>(e)企业服务总线ESB</p><p>(g)安全验证和质量管理</p><p>(j)组件层</p><p>[问题3]</p><p>1、引入https协议或采用加密技术对数据先加密再传输</p><p>2、采用信息摘要技术对重要信息进行完整性验证</p><p>3、交易类敏感信息采用数字签名机制</p>"
                    ],
                    "option": "[]"
                },
                {
                    "index": 257,
                    "belong_page": 1,
                    "question_id": 315998,
                    "question_title": "<p>【问题 1】(6 分)</p><p>若采用面向对象方法对预约挂号管理系统进行分析，得到如图 2-1 所示的用例图。请将合适的参与者名称填入图 2-1中的(1)和(2)处，使用题干给出的功能描述(a)~(j)，完善用例(3)~(12)的名称，将正确答案填在答题纸上。</p><p><img style=\"max-width:100%;height:auto\"  src=\"https://s2.51cto.com/images/20211118/1637239460234408.png\" title=\"1637239460234408.png\" alt=\"image.png\"/></p>",
                    "question_type": 14,
                    "answer_type": 5,
                    "show_type_name": "问答题",
                    "new_parent_id": 315997,
                    "score_rule": "",
                    "material_text": "试题二(共 25分)<p>阅读以下关于软件系统设计与建模的叙述，在答题纸上回答问题 1 至问题 3.</p><p>【说明】</p><p>某医院拟委托软件公司开发一套预约挂号管理系统，以便为患者提供更好的就医体验，为医院提供更加科学的预约管理。本系统的主要功能描述如下:(a)注册登录，(b)信息浏览，(c)账号管理，(d)预约挂号，(e)查询与取消预约，(F)号源管理，(g)报告查询，(h)预约管理，(i)报表管理和(j)信用管理等。</p>",
                    "sort_son": "1",
                    "analyze": "无",
                    "like": 0,
                    "answer": [
                        "<p>(1) 系统管理员&nbsp; &nbsp;(2) 患者&nbsp; &nbsp;(3) a</p><p>(4) c&nbsp; &nbsp; (5) f &nbsp; &nbsp;(6)h <br/>(7)&nbsp;i &nbsp; &nbsp; (8) j&nbsp; &nbsp; (9) b <br/>(10) d&nbsp; (11) e&nbsp; (12) g</p>"
                    ],
                    "option": ""
                },
                {
                    "index": 258,
                    "belong_page": 1,
                    "question_id": 315999,
                    "question_title": "<p>【问题 2】(10分)</p><p>预约人员(患者)登录系统后发起预约挂号请求，进入预约界面。进行预约挂号时使用数据库访问类获取医生的相关信息，在数据库中调用医生列表，并调取医生出诊时段表，将医生出诊时段反馈到预的界面，并显示给预的人员;预约人员选择医生及就诊时间后确认预的，系统返网预约结果，并向用户显示是否预约成功。</p><p>采用面向对象方法对预约挂号过程进行分析，得到如图 2-2 所示的顺序图，使用题干中给出的描述，完善图 2-2 中对象(1)，及消息(2)~(4)的名称，将正确答案填在普题纸上请简要说明在描述对象之间的动态交互关系时，协作图与顺序图存在哪些区别。</p><img style=\"max-width:100%;height:auto\"  src=\"https://s2.51cto.com/images/20211118/1637239579171785.png\" title=\"1637239579171785.png\" alt=\"image.png\"/><br/>",
                    "question_type": 14,
                    "answer_type": 5,
                    "show_type_name": "问答题",
                    "new_parent_id": 315997,
                    "score_rule": "",
                    "material_text": "试题二(共 25分)<p>阅读以下关于软件系统设计与建模的叙述，在答题纸上回答问题 1 至问题 3.</p><p>【说明】</p><p>某医院拟委托软件公司开发一套预约挂号管理系统，以便为患者提供更好的就医体验，为医院提供更加科学的预约管理。本系统的主要功能描述如下:(a)注册登录，(b)信息浏览，(c)账号管理，(d)预约挂号，(e)查询与取消预约，(F)号源管理，(g)报告查询，(h)预约管理，(i)报表管理和(j)信用管理等。</p>",
                    "sort_son": "2",
                    "analyze": "无",
                    "like": 0,
                    "answer": [
                        "(1) 预约人员 (2) 发起预约挂号请求 (3) 显示医生出诊时段 (4) 显示是否预约成功<p>序列图强调交互的消息时间顺序。</p><p>协作图强调接受和发送消息的对象的结构组织，强调通信的方式。</p>"
                    ],
                    "option": ""
                },
                {
                    "index": 259,
                    "belong_page": 1,
                    "question_id": 316000,
                    "question_title": "<p>【问题 3】(9分)</p><p>采用面向对象方法开发软件，通常需要建立对象模型、动态模型和功能模型，请分别介绍这3种模型，并详细说明它们之间的关联关系，针对上述模型，说明哪些模型可用于软件的需求分析?</p>",
                    "question_type": 14,
                    "answer_type": 5,
                    "show_type_name": "问答题",
                    "new_parent_id": 315997,
                    "score_rule": "",
                    "material_text": "试题二(共 25分)<p>阅读以下关于软件系统设计与建模的叙述，在答题纸上回答问题 1 至问题 3.</p><p>【说明】</p><p>某医院拟委托软件公司开发一套预约挂号管理系统，以便为患者提供更好的就医体验，为医院提供更加科学的预约管理。本系统的主要功能描述如下:(a)注册登录，(b)信息浏览，(c)账号管理，(d)预约挂号，(e)查询与取消预约，(F)号源管理，(g)报告查询，(h)预约管理，(i)报表管理和(j)信用管理等。</p>",
                    "sort_son": "3",
                    "analyze": "无",
                    "like": 0,
                    "answer": [
                        "<p>对象模型描述系统中对象的静态结构、对象之间的关系、属性和操作，主要用对象图来实现。</p><p>动态模型描述与时间和操作顺序有关的系统特征，例如，激发事件、事件序列、确定事件先后关系的状态等，主要用状态图来实现。</p><p>功能模型描述一个计算如何从输入值得到输出值，它不考虑计算的次序，主要用用例图来实现。</p><p>功能模型指发生了什么，动态模型确定什么时候发生，而对象模型确定发生的客体。</p><p>对象设计建立基于分析模型的设计模型并考虑实现细节，以上3个模型均可用于需求分析。</p>"
                    ],
                    "option": ""
                },
                {
                    "index": 260,
                    "belong_page": 1,
                    "question_id": 348854,
                    "question_title": "1、某公司欲开发一个大型多人即时战略游戏，游戏设计的目标之一是能够支持玩家自行创建战役地图，定义游戏对象的行为和对象之间的关系。针对该需求，在层次风格、解释器风格、黑板和事件驱动风中公司应该采用什么架构风格最为合适？<br/><br/>2、在基于体系结构的软件设计方法中，采用什么来描述软件架构？<br/><br/>3、哪种视图能解决并发性、分布性等问题？<br/><br/>4、某公司欲开发一个在线教育平台。在架构设计阶段，公司的架构师识别出3&nbsp;个核心质量<br/>属性场景。其中“网站在并发用户数量10&nbsp;万的负载情况下，用户请求的平均响应时间应小<br/>于3&nbsp;秒”这一场景主要与什么质量属性相关？<br/><br/>5、ABSDM模型把整个基于体系结构的软件过程划分为体系结构需求、设计、文档化、复审、实现和什么等6个子过程？<br/><br/>",
                    "question_type": 5,
                    "answer_type": 5,
                    "show_type_name": "问答题",
                    "new_parent_id": 348854,
                    "score_rule": "",
                    "material_text": "",
                    "sort_son": "0",
                    "analyze": "详见答案",
                    "like": 0,
                    "answer": [
                        "1、某公司欲开发一个大型多人即时战略游戏，游戏设计的目标之一是能够支持玩家自行创建战役地图，定义游戏对象的行为和对象之间的关系。针对该需求，在层次风格、解释器风格、黑板和事件驱动风中公司应该采用什么架构风格最为合适？<br/>答：解释器风格<br/>2、在基于体系结构的软件设计方法中，采用什么来描述软件架构？<br/>答：采用视角与视图来描述软件架构<br/>3、哪种视图能解决并发性、分布性等问题？<br/>答：&nbsp;进程视图<br/>4、某公司欲开发一个在线教育平台。在架构设计阶段，公司的架构师识别出3&nbsp;个核心质量<br/>属性场景。其中“网站在并发用户数量10&nbsp;万的负载情况下，用户请求的平均响应时间应小<br/>于3&nbsp;秒”这一场景主要与什么质量属性相关？<br/>答：性能<br/>5、ABSDM模型把整个基于体系结构的软件过程划分为体系结构需求、设计、文档化、复审、实现和什么等6个子过程？<br/>答：体系结构演化"
                    ],
                    "option": ""
                }
            ],
            "total_question": 260,
            "summary": {
                "radio": {
                    "total_question": 246,
                    "total_score": 0
                },
                "multiple": {
                    "total_question": 0,
                    "total_score": 0
                },
                "fill": {
                    "total_question": 0,
                    "total_score": 0
                },
                "program": {
                    "total_question": 0,
                    "total_score": 0
                },
                "qanda": {
                    "total_question": 14,
                    "total_score": 0
                },
                "cloze": {
                    "total_question": 0,
                    "total_score": 0
                },
                "budingxiang": {
                    "total_question": 0,
                    "total_score": 0
                },
                "material": {
                    "total_question": 0,
                    "total_score": 0
                }
            },
            "title": "系统分析与设计"
        },
        "pagination": {
            "curPage": 1,
            "pageSize": 1000,
            "total": 260,
            "hasNextPage": false
        },
        "totalOrder": [
            {
                "index": 1,
                "question_type": "1",
                "belong_page": 1,
                "question_id": "43219",
                "answer_type": 1
            },
            {
                "index": 2,
                "question_type": "1",
                "belong_page": 1,
                "question_id": "43220",
                "answer_type": 1
            },
            {
                "index": 3,
                "question_type": "1",
                "belong_page": 1,
                "question_id": "43221",
                "answer_type": 1
            },
            {
                "index": 4,
                "question_type": "1",
                "belong_page": 1,
                "question_id": "43223",
                "answer_type": 1
            },
            {
                "index": 5,
                "question_type": "1",
                "belong_page": 1,
                "question_id": "43225",
                "answer_type": 1
            },
            {
                "index": 6,
                "question_type": "1",
                "belong_page": 1,
                "question_id": "43226",
                "answer_type": 1
            },
            {
                "index": 7,
                "question_type": "1",
                "belong_page": 1,
                "question_id": "43227",
                "answer_type": 1
            },
            {
                "index": 8,
                "question_type": "1",
                "belong_page": 1,
                "question_id": "43228",
                "answer_type": 1
            },
            {
                "index": 9,
                "question_type": "1",
                "belong_page": 1,
                "question_id": "43232",
                "answer_type": 1
            },
            {
                "index": 10,
                "question_type": "1",
                "belong_page": 1,
                "question_id": "43234",
                "answer_type": 1
            },
            {
                "index": 11,
                "question_type": "1",
                "belong_page": 1,
                "question_id": "43235",
                "answer_type": 1
            },
            {
                "index": 12,
                "question_type": "1",
                "belong_page": 1,
                "question_id": "43243",
                "answer_type": 1
            },
            {
                "index": 13,
                "question_type": "1",
                "belong_page": 1,
                "question_id": "43245",
                "answer_type": 1
            },
            {
                "index": 14,
                "question_type": "1",
                "belong_page": 1,
                "question_id": "43247",
                "answer_type": 1
            },
            {
                "index": 15,
                "question_type": "1",
                "belong_page": 1,
                "question_id": "43249",
                "answer_type": 1
            },
            {
                "index": 16,
                "question_type": "1",
                "belong_page": 1,
                "question_id": "43251",
                "answer_type": 1
            },
            {
                "index": 17,
                "question_type": "1",
                "belong_page": 1,
                "question_id": "43255",
                "answer_type": 1
            },
            {
                "index": 18,
                "question_type": "1",
                "belong_page": 1,
                "question_id": "43256",
                "answer_type": 1
            },
            {
                "index": 19,
                "question_type": "1",
                "belong_page": 1,
                "question_id": "43259",
                "answer_type": 1
            },
            {
                "index": 20,
                "question_type": "1",
                "belong_page": 1,
                "question_id": "43260",
                "answer_type": 1
            },
            {
                "index": 21,
                "question_type": "1",
                "belong_page": 1,
                "question_id": "43261",
                "answer_type": 1
            },
            {
                "index": 22,
                "question_type": "1",
                "belong_page": 1,
                "question_id": "43262",
                "answer_type": 1
            },
            {
                "index": 23,
                "question_type": "1",
                "belong_page": 1,
                "question_id": "43263",
                "answer_type": 1
            },
            {
                "index": 24,
                "question_type": "1",
                "belong_page": 1,
                "question_id": "43264",
                "answer_type": 1
            },
            {
                "index": 25,
                "question_type": "1",
                "belong_page": 1,
                "question_id": "43265",
                "answer_type": 1
            },
            {
                "index": 26,
                "question_type": "1",
                "belong_page": 1,
                "question_id": "43266",
                "answer_type": 1
            },
            {
                "index": 27,
                "question_type": "1",
                "belong_page": 1,
                "question_id": "43314",
                "answer_type": 1
            },
            {
                "index": 28,
                "question_type": "1",
                "belong_page": 1,
                "question_id": "43340",
                "answer_type": 1
            },
            {
                "index": 29,
                "question_type": "1",
                "belong_page": 1,
                "question_id": "43762",
                "answer_type": 1
            },
            {
                "index": 30,
                "question_type": "1",
                "belong_page": 1,
                "question_id": "43791",
                "answer_type": 1
            },
            {
                "index": 31,
                "question_type": "1",
                "belong_page": 1,
                "question_id": "43874",
                "answer_type": 1
            },
            {
                "index": 32,
                "question_type": "1",
                "belong_page": 1,
                "question_id": "43888",
                "answer_type": 1
            },
            {
                "index": 33,
                "question_type": "1",
                "belong_page": 1,
                "question_id": "46899",
                "answer_type": 1
            },
            {
                "index": 34,
                "question_type": "1",
                "belong_page": 1,
                "question_id": "46914",
                "answer_type": 1
            },
            {
                "index": 35,
                "question_type": "1",
                "belong_page": 1,
                "question_id": "46936",
                "answer_type": 1
            },
            {
                "index": 36,
                "question_type": "1",
                "belong_page": 1,
                "question_id": "46937",
                "answer_type": 1
            },
            {
                "index": 37,
                "question_type": "1",
                "belong_page": 1,
                "question_id": "46938",
                "answer_type": 1
            },
            {
                "index": 38,
                "question_type": "1",
                "belong_page": 1,
                "question_id": "46956",
                "answer_type": 1
            },
            {
                "index": 39,
                "question_type": "1",
                "belong_page": 1,
                "question_id": "46957",
                "answer_type": 1
            },
            {
                "index": 40,
                "question_type": "1",
                "belong_page": 1,
                "question_id": "46965",
                "answer_type": 1
            },
            {
                "index": 41,
                "question_type": "1",
                "belong_page": 1,
                "question_id": "46966",
                "answer_type": 1
            },
            {
                "index": 42,
                "question_type": "1",
                "belong_page": 1,
                "question_id": "46967",
                "answer_type": 1
            },
            {
                "index": 43,
                "question_type": "1",
                "belong_page": 1,
                "question_id": "46968",
                "answer_type": 1
            },
            {
                "index": 44,
                "question_type": "1",
                "belong_page": 1,
                "question_id": "49839",
                "answer_type": 1
            },
            {
                "index": 45,
                "question_type": "1",
                "belong_page": 1,
                "question_id": "49843",
                "answer_type": 1
            },
            {
                "index": 46,
                "question_type": "1",
                "belong_page": 1,
                "question_id": "49844",
                "answer_type": 1
            },
            {
                "index": 47,
                "question_type": "1",
                "belong_page": 1,
                "question_id": "49847",
                "answer_type": 1
            },
            {
                "index": 48,
                "question_type": "1",
                "belong_page": 1,
                "question_id": "49855",
                "answer_type": 1
            },
            {
                "index": 49,
                "question_type": "1",
                "belong_page": 1,
                "question_id": "49856",
                "answer_type": 1
            },
            {
                "index": 50,
                "question_type": "1",
                "belong_page": 1,
                "question_id": "49857",
                "answer_type": 1
            },
            {
                "index": 51,
                "question_type": "1",
                "belong_page": 1,
                "question_id": "49858",
                "answer_type": 1
            },
            {
                "index": 52,
                "question_type": "1",
                "belong_page": 1,
                "question_id": "49859",
                "answer_type": 1
            },
            {
                "index": 53,
                "question_type": "1",
                "belong_page": 1,
                "question_id": "49877",
                "answer_type": 1
            },
            {
                "index": 54,
                "question_type": "1",
                "belong_page": 1,
                "question_id": "49878",
                "answer_type": 1
            },
            {
                "index": 55,
                "question_type": "1",
                "belong_page": 1,
                "question_id": "49879",
                "answer_type": 1
            },
            {
                "index": 56,
                "question_type": "1",
                "belong_page": 1,
                "question_id": "49881",
                "answer_type": 1
            },
            {
                "index": 57,
                "question_type": "1",
                "belong_page": 1,
                "question_id": "49882",
                "answer_type": 1
            },
            {
                "index": 58,
                "question_type": "1",
                "belong_page": 1,
                "question_id": "49885",
                "answer_type": 1
            },
            {
                "index": 59,
                "question_type": "1",
                "belong_page": 1,
                "question_id": "49886",
                "answer_type": 1
            },
            {
                "index": 60,
                "question_type": "1",
                "belong_page": 1,
                "question_id": "49897",
                "answer_type": 1
            },
            {
                "index": 61,
                "question_type": "1",
                "belong_page": 1,
                "question_id": "49898",
                "answer_type": 1
            },
            {
                "index": 62,
                "question_type": "1",
                "belong_page": 1,
                "question_id": "49917",
                "answer_type": 1
            },
            {
                "index": 63,
                "question_type": "1",
                "belong_page": 1,
                "question_id": "49918",
                "answer_type": 1
            },
            {
                "index": 64,
                "question_type": "1",
                "belong_page": 1,
                "question_id": "49919",
                "answer_type": 1
            },
            {
                "index": 65,
                "question_type": "1",
                "belong_page": 1,
                "question_id": "49929",
                "answer_type": 1
            },
            {
                "index": 66,
                "question_type": "1",
                "belong_page": 1,
                "question_id": "49930",
                "answer_type": 1
            },
            {
                "index": 67,
                "question_type": "1",
                "belong_page": 1,
                "question_id": "49931",
                "answer_type": 1
            },
            {
                "index": 68,
                "question_type": "1",
                "belong_page": 1,
                "question_id": "49952",
                "answer_type": 1
            },
            {
                "index": 69,
                "question_type": "1",
                "belong_page": 1,
                "question_id": "49953",
                "answer_type": 1
            },
            {
                "index": 70,
                "question_type": "1",
                "belong_page": 1,
                "question_id": "49955",
                "answer_type": 1
            },
            {
                "index": 71,
                "question_type": "1",
                "belong_page": 1,
                "question_id": "49961",
                "answer_type": 1
            },
            {
                "index": 72,
                "question_type": "1",
                "belong_page": 1,
                "question_id": "49968",
                "answer_type": 1
            },
            {
                "index": 73,
                "question_type": "1",
                "belong_page": 1,
                "question_id": "50901",
                "answer_type": 1
            },
            {
                "index": 74,
                "question_type": "1",
                "belong_page": 1,
                "question_id": "50912",
                "answer_type": 1
            },
            {
                "index": 75,
                "question_type": "1",
                "belong_page": 1,
                "question_id": "50913",
                "answer_type": 1
            },
            {
                "index": 76,
                "question_type": "1",
                "belong_page": 1,
                "question_id": "50914",
                "answer_type": 1
            },
            {
                "index": 77,
                "question_type": "1",
                "belong_page": 1,
                "question_id": "50926",
                "answer_type": 1
            },
            {
                "index": 78,
                "question_type": "1",
                "belong_page": 1,
                "question_id": "50927",
                "answer_type": 1
            },
            {
                "index": 79,
                "question_type": "1",
                "belong_page": 1,
                "question_id": "54188",
                "answer_type": 1
            },
            {
                "index": 80,
                "question_type": "1",
                "belong_page": 1,
                "question_id": "54189",
                "answer_type": 1
            },
            {
                "index": 81,
                "question_type": "1",
                "belong_page": 1,
                "question_id": "54190",
                "answer_type": 1
            },
            {
                "index": 82,
                "question_type": "1",
                "belong_page": 1,
                "question_id": "54226",
                "answer_type": 1
            },
            {
                "index": 83,
                "question_type": "1",
                "belong_page": 1,
                "question_id": "54227",
                "answer_type": 1
            },
            {
                "index": 84,
                "question_type": "1",
                "belong_page": 1,
                "question_id": "54228",
                "answer_type": 1
            },
            {
                "index": 85,
                "question_type": "1",
                "belong_page": 1,
                "question_id": "54233",
                "answer_type": 1
            },
            {
                "index": 86,
                "question_type": "1",
                "belong_page": 1,
                "question_id": "54275",
                "answer_type": 1
            },
            {
                "index": 87,
                "question_type": "1",
                "belong_page": 1,
                "question_id": "54276",
                "answer_type": 1
            },
            {
                "index": 88,
                "question_type": "1",
                "belong_page": 1,
                "question_id": "54286",
                "answer_type": 1
            },
            {
                "index": 89,
                "question_type": "1",
                "belong_page": 1,
                "question_id": "54287",
                "answer_type": 1
            },
            {
                "index": 90,
                "question_type": "1",
                "belong_page": 1,
                "question_id": "54307",
                "answer_type": 1
            },
            {
                "index": 91,
                "question_type": "1",
                "belong_page": 1,
                "question_id": "54310",
                "answer_type": 1
            },
            {
                "index": 92,
                "question_type": "1",
                "belong_page": 1,
                "question_id": "54311",
                "answer_type": 1
            },
            {
                "index": 93,
                "question_type": "1",
                "belong_page": 1,
                "question_id": "54312",
                "answer_type": 1
            },
            {
                "index": 94,
                "question_type": "1",
                "belong_page": 1,
                "question_id": "54323",
                "answer_type": 1
            },
            {
                "index": 95,
                "question_type": "1",
                "belong_page": 1,
                "question_id": "54324",
                "answer_type": 1
            },
            {
                "index": 96,
                "question_type": "1",
                "belong_page": 1,
                "question_id": "54335",
                "answer_type": 1
            },
            {
                "index": 97,
                "question_type": "1",
                "belong_page": 1,
                "question_id": "54337",
                "answer_type": 1
            },
            {
                "index": 98,
                "question_type": "1",
                "belong_page": 1,
                "question_id": "54349",
                "answer_type": 1
            },
            {
                "index": 99,
                "question_type": "1",
                "belong_page": 1,
                "question_id": "54350",
                "answer_type": 1
            },
            {
                "index": 100,
                "question_type": "1",
                "belong_page": 1,
                "question_id": "54351",
                "answer_type": 1
            },
            {
                "index": 101,
                "question_type": "1",
                "belong_page": 1,
                "question_id": "54352",
                "answer_type": 1
            },
            {
                "index": 102,
                "question_type": "1",
                "belong_page": 1,
                "question_id": "54353",
                "answer_type": 1
            },
            {
                "index": 103,
                "question_type": "1",
                "belong_page": 1,
                "question_id": "63636",
                "answer_type": 1
            },
            {
                "index": 104,
                "question_type": "1",
                "belong_page": 1,
                "question_id": "63667",
                "answer_type": 1
            },
            {
                "index": 105,
                "question_type": "1",
                "belong_page": 1,
                "question_id": "63669",
                "answer_type": 1
            },
            {
                "index": 106,
                "question_type": "1",
                "belong_page": 1,
                "question_id": "63671",
                "answer_type": 1
            },
            {
                "index": 107,
                "question_type": "1",
                "belong_page": 1,
                "question_id": "63673",
                "answer_type": 1
            },
            {
                "index": 108,
                "question_type": "1",
                "belong_page": 1,
                "question_id": "63674",
                "answer_type": 1
            },
            {
                "index": 109,
                "question_type": "1",
                "belong_page": 1,
                "question_id": "103112",
                "answer_type": 1
            },
            {
                "index": 110,
                "question_type": "1",
                "belong_page": 1,
                "question_id": "103113",
                "answer_type": 1
            },
            {
                "index": 111,
                "question_type": "1",
                "belong_page": 1,
                "question_id": "103114",
                "answer_type": 1
            },
            {
                "index": 112,
                "question_type": "1",
                "belong_page": 1,
                "question_id": "103115",
                "answer_type": 1
            },
            {
                "index": 113,
                "question_type": "1",
                "belong_page": 1,
                "question_id": "103116",
                "answer_type": 1
            },
            {
                "index": 114,
                "question_type": "1",
                "belong_page": 1,
                "question_id": "103117",
                "answer_type": 1
            },
            {
                "index": 115,
                "question_type": "1",
                "belong_page": 1,
                "question_id": "103118",
                "answer_type": 1
            },
            {
                "index": 116,
                "question_type": "1",
                "belong_page": 1,
                "question_id": "103125",
                "answer_type": 1
            },
            {
                "index": 117,
                "question_type": "1",
                "belong_page": 1,
                "question_id": "151187",
                "answer_type": 1
            },
            {
                "index": 118,
                "question_type": "1",
                "belong_page": 1,
                "question_id": "151213",
                "answer_type": 1
            },
            {
                "index": 119,
                "question_type": "1",
                "belong_page": 1,
                "question_id": "151214",
                "answer_type": 1
            },
            {
                "index": 120,
                "question_type": "1",
                "belong_page": 1,
                "question_id": "151215",
                "answer_type": 1
            },
            {
                "index": 121,
                "question_type": "1",
                "belong_page": 1,
                "question_id": "151217",
                "answer_type": 1
            },
            {
                "index": 122,
                "question_type": "1",
                "belong_page": 1,
                "question_id": "151218",
                "answer_type": 1
            },
            {
                "index": 123,
                "question_type": "1",
                "belong_page": 1,
                "question_id": "159188",
                "answer_type": 1
            },
            {
                "index": 124,
                "question_type": "1",
                "belong_page": 1,
                "question_id": "159189",
                "answer_type": 1
            },
            {
                "index": 125,
                "question_type": "1",
                "belong_page": 1,
                "question_id": "159190",
                "answer_type": 1
            },
            {
                "index": 126,
                "question_type": "1",
                "belong_page": 1,
                "question_id": "159191",
                "answer_type": 1
            },
            {
                "index": 127,
                "question_type": "1",
                "belong_page": 1,
                "question_id": "159192",
                "answer_type": 1
            },
            {
                "index": 128,
                "question_type": "1",
                "belong_page": 1,
                "question_id": "159206",
                "answer_type": 1
            },
            {
                "index": 129,
                "question_type": "1",
                "belong_page": 1,
                "question_id": "159207",
                "answer_type": 1
            },
            {
                "index": 130,
                "question_type": "1",
                "belong_page": 1,
                "question_id": "159208",
                "answer_type": 1
            },
            {
                "index": 131,
                "question_type": "1",
                "belong_page": 1,
                "question_id": "159209",
                "answer_type": 1
            },
            {
                "index": 132,
                "question_type": "1",
                "belong_page": 1,
                "question_id": "159210",
                "answer_type": 1
            },
            {
                "index": 133,
                "question_type": "1",
                "belong_page": 1,
                "question_id": "159211",
                "answer_type": 1
            },
            {
                "index": 134,
                "question_type": "1",
                "belong_page": 1,
                "question_id": "159212",
                "answer_type": 1
            },
            {
                "index": 135,
                "question_type": "1",
                "belong_page": 1,
                "question_id": "159213",
                "answer_type": 1
            },
            {
                "index": 136,
                "question_type": "1",
                "belong_page": 1,
                "question_id": "159214",
                "answer_type": 1
            },
            {
                "index": 137,
                "question_type": "1",
                "belong_page": 1,
                "question_id": "159226",
                "answer_type": 1
            },
            {
                "index": 138,
                "question_type": "1",
                "belong_page": 1,
                "question_id": "159243",
                "answer_type": 1
            },
            {
                "index": 139,
                "question_type": "1",
                "belong_page": 1,
                "question_id": "159244",
                "answer_type": 1
            },
            {
                "index": 140,
                "question_type": "1",
                "belong_page": 1,
                "question_id": "159249",
                "answer_type": 1
            },
            {
                "index": 141,
                "question_type": "1",
                "belong_page": 1,
                "question_id": "159250",
                "answer_type": 1
            },
            {
                "index": 142,
                "question_type": "1",
                "belong_page": 1,
                "question_id": "159251",
                "answer_type": 1
            },
            {
                "index": 143,
                "question_type": "1",
                "belong_page": 1,
                "question_id": "208411",
                "answer_type": 1
            },
            {
                "index": 144,
                "question_type": "1",
                "belong_page": 1,
                "question_id": "208412",
                "answer_type": 1
            },
            {
                "index": 145,
                "question_type": "1",
                "belong_page": 1,
                "question_id": "208413",
                "answer_type": 1
            },
            {
                "index": 146,
                "question_type": "1",
                "belong_page": 1,
                "question_id": "208414",
                "answer_type": 1
            },
            {
                "index": 147,
                "question_type": "1",
                "belong_page": 1,
                "question_id": "208415",
                "answer_type": 1
            },
            {
                "index": 148,
                "question_type": "1",
                "belong_page": 1,
                "question_id": "208416",
                "answer_type": 1
            },
            {
                "index": 149,
                "question_type": "1",
                "belong_page": 1,
                "question_id": "208417",
                "answer_type": 1
            },
            {
                "index": 150,
                "question_type": "1",
                "belong_page": 1,
                "question_id": "208420",
                "answer_type": 1
            },
            {
                "index": 151,
                "question_type": "1",
                "belong_page": 1,
                "question_id": "208421",
                "answer_type": 1
            },
            {
                "index": 152,
                "question_type": "1",
                "belong_page": 1,
                "question_id": "208428",
                "answer_type": 1
            },
            {
                "index": 153,
                "question_type": "1",
                "belong_page": 1,
                "question_id": "208486",
                "answer_type": 1
            },
            {
                "index": 154,
                "question_type": "1",
                "belong_page": 1,
                "question_id": "208487",
                "answer_type": 1
            },
            {
                "index": 155,
                "question_type": "1",
                "belong_page": 1,
                "question_id": "208488",
                "answer_type": 1
            },
            {
                "index": 156,
                "question_type": "1",
                "belong_page": 1,
                "question_id": "208489",
                "answer_type": 1
            },
            {
                "index": 157,
                "question_type": "1",
                "belong_page": 1,
                "question_id": "208490",
                "answer_type": 1
            },
            {
                "index": 158,
                "question_type": "1",
                "belong_page": 1,
                "question_id": "208491",
                "answer_type": 1
            },
            {
                "index": 159,
                "question_type": "1",
                "belong_page": 1,
                "question_id": "208492",
                "answer_type": 1
            },
            {
                "index": 160,
                "question_type": "1",
                "belong_page": 1,
                "question_id": "281203",
                "answer_type": 1
            },
            {
                "index": 161,
                "question_type": "1",
                "belong_page": 1,
                "question_id": "281208",
                "answer_type": 1
            },
            {
                "index": 162,
                "question_type": "1",
                "belong_page": 1,
                "question_id": "281209",
                "answer_type": 1
            },
            {
                "index": 163,
                "question_type": "1",
                "belong_page": 1,
                "question_id": "281210",
                "answer_type": 1
            },
            {
                "index": 164,
                "question_type": "1",
                "belong_page": 1,
                "question_id": "281343",
                "answer_type": 1
            },
            {
                "index": 165,
                "question_type": "9",
                "belong_page": 1,
                "question_id": "281631",
                "answer_type": 1
            },
            {
                "index": 166,
                "question_type": "9",
                "belong_page": 1,
                "question_id": "281632",
                "answer_type": 1
            },
            {
                "index": 167,
                "question_type": "9",
                "belong_page": 1,
                "question_id": "281633",
                "answer_type": 1
            },
            {
                "index": 168,
                "question_type": "1",
                "belong_page": 1,
                "question_id": "281634",
                "answer_type": 1
            },
            {
                "index": 169,
                "question_type": "1",
                "belong_page": 1,
                "question_id": "281635",
                "answer_type": 1
            },
            {
                "index": 170,
                "question_type": "9",
                "belong_page": 1,
                "question_id": "283637",
                "answer_type": 1
            },
            {
                "index": 171,
                "question_type": "9",
                "belong_page": 1,
                "question_id": "283638",
                "answer_type": 1
            },
            {
                "index": 172,
                "question_type": "9",
                "belong_page": 1,
                "question_id": "283643",
                "answer_type": 1
            },
            {
                "index": 173,
                "question_type": "9",
                "belong_page": 1,
                "question_id": "283644",
                "answer_type": 1
            },
            {
                "index": 174,
                "question_type": "9",
                "belong_page": 1,
                "question_id": "284657",
                "answer_type": 1
            },
            {
                "index": 175,
                "question_type": "9",
                "belong_page": 1,
                "question_id": "284658",
                "answer_type": 1
            },
            {
                "index": 176,
                "question_type": "9",
                "belong_page": 1,
                "question_id": "284659",
                "answer_type": 1
            },
            {
                "index": 177,
                "question_type": "1",
                "belong_page": 1,
                "question_id": "284698",
                "answer_type": 1
            },
            {
                "index": 178,
                "question_type": "9",
                "belong_page": 1,
                "question_id": "302378",
                "answer_type": 1
            },
            {
                "index": 179,
                "question_type": "9",
                "belong_page": 1,
                "question_id": "302379",
                "answer_type": 1
            },
            {
                "index": 180,
                "question_type": "9",
                "belong_page": 1,
                "question_id": "303642",
                "answer_type": 1
            },
            {
                "index": 181,
                "question_type": "9",
                "belong_page": 1,
                "question_id": "303643",
                "answer_type": 1
            },
            {
                "index": 182,
                "question_type": "9",
                "belong_page": 1,
                "question_id": "303654",
                "answer_type": 1
            },
            {
                "index": 183,
                "question_type": "9",
                "belong_page": 1,
                "question_id": "303655",
                "answer_type": 1
            },
            {
                "index": 184,
                "question_type": "1",
                "belong_page": 1,
                "question_id": "303666",
                "answer_type": 1
            },
            {
                "index": 185,
                "question_type": "1",
                "belong_page": 1,
                "question_id": "303667",
                "answer_type": 1
            },
            {
                "index": 186,
                "question_type": "9",
                "belong_page": 1,
                "question_id": "310863",
                "answer_type": 1
            },
            {
                "index": 187,
                "question_type": "9",
                "belong_page": 1,
                "question_id": "310864",
                "answer_type": 1
            },
            {
                "index": 188,
                "question_type": "1",
                "belong_page": 1,
                "question_id": "315921",
                "answer_type": 1
            },
            {
                "index": 189,
                "question_type": "1",
                "belong_page": 1,
                "question_id": "315922",
                "answer_type": 1
            },
            {
                "index": 190,
                "question_type": "1",
                "belong_page": 1,
                "question_id": "315932",
                "answer_type": 1
            },
            {
                "index": 191,
                "question_type": "9",
                "belong_page": 1,
                "question_id": "315934",
                "answer_type": 1
            },
            {
                "index": 192,
                "question_type": "9",
                "belong_page": 1,
                "question_id": "315935",
                "answer_type": 1
            },
            {
                "index": 193,
                "question_type": "1",
                "belong_page": 1,
                "question_id": "315936",
                "answer_type": 1
            },
            {
                "index": 194,
                "question_type": "1",
                "belong_page": 1,
                "question_id": "315937",
                "answer_type": 1
            },
            {
                "index": 195,
                "question_type": "1",
                "belong_page": 1,
                "question_id": "315938",
                "answer_type": 1
            },
            {
                "index": 196,
                "question_type": "9",
                "belong_page": 1,
                "question_id": "315941",
                "answer_type": 1
            },
            {
                "index": 197,
                "question_type": "9",
                "belong_page": 1,
                "question_id": "315942",
                "answer_type": 1
            },
            {
                "index": 198,
                "question_type": "9",
                "belong_page": 1,
                "question_id": "348934",
                "answer_type": 1
            },
            {
                "index": 199,
                "question_type": "9",
                "belong_page": 1,
                "question_id": "348935",
                "answer_type": 1
            },
            {
                "index": 200,
                "question_type": "9",
                "belong_page": 1,
                "question_id": "348937",
                "answer_type": 1
            },
            {
                "index": 201,
                "question_type": "9",
                "belong_page": 1,
                "question_id": "348938",
                "answer_type": 1
            },
            {
                "index": 202,
                "question_type": "9",
                "belong_page": 1,
                "question_id": "348940",
                "answer_type": 1
            },
            {
                "index": 203,
                "question_type": "9",
                "belong_page": 1,
                "question_id": "348941",
                "answer_type": 1
            },
            {
                "index": 204,
                "question_type": "9",
                "belong_page": 1,
                "question_id": "348943",
                "answer_type": 1
            },
            {
                "index": 205,
                "question_type": "9",
                "belong_page": 1,
                "question_id": "348944",
                "answer_type": 1
            },
            {
                "index": 206,
                "question_type": "9",
                "belong_page": 1,
                "question_id": "350320",
                "answer_type": 1
            },
            {
                "index": 207,
                "question_type": "9",
                "belong_page": 1,
                "question_id": "350321",
                "answer_type": 1
            },
            {
                "index": 208,
                "question_type": "9",
                "belong_page": 1,
                "question_id": "350322",
                "answer_type": 1
            },
            {
                "index": 209,
                "question_type": "1",
                "belong_page": 1,
                "question_id": "350323",
                "answer_type": 1
            },
            {
                "index": 210,
                "question_type": "1",
                "belong_page": 1,
                "question_id": "350324",
                "answer_type": 1
            },
            {
                "index": 211,
                "question_type": "1",
                "belong_page": 1,
                "question_id": "350325",
                "answer_type": 1
            },
            {
                "index": 212,
                "question_type": "9",
                "belong_page": 1,
                "question_id": "350327",
                "answer_type": 1
            },
            {
                "index": 213,
                "question_type": "9",
                "belong_page": 1,
                "question_id": "350328",
                "answer_type": 1
            },
            {
                "index": 214,
                "question_type": "9",
                "belong_page": 1,
                "question_id": "350330",
                "answer_type": 1
            },
            {
                "index": 215,
                "question_type": "9",
                "belong_page": 1,
                "question_id": "350331",
                "answer_type": 1
            },
            {
                "index": 216,
                "question_type": "1",
                "belong_page": 1,
                "question_id": "352278",
                "answer_type": 1
            },
            {
                "index": 217,
                "question_type": "9",
                "belong_page": 1,
                "question_id": "352280",
                "answer_type": 1
            },
            {
                "index": 218,
                "question_type": "9",
                "belong_page": 1,
                "question_id": "352281",
                "answer_type": 1
            },
            {
                "index": 219,
                "question_type": "9",
                "belong_page": 1,
                "question_id": "352283",
                "answer_type": 1
            },
            {
                "index": 220,
                "question_type": "9",
                "belong_page": 1,
                "question_id": "352284",
                "answer_type": 1
            },
            {
                "index": 221,
                "question_type": "9",
                "belong_page": 1,
                "question_id": "352286",
                "answer_type": 1
            },
            {
                "index": 222,
                "question_type": "9",
                "belong_page": 1,
                "question_id": "352287",
                "answer_type": 1
            },
            {
                "index": 223,
                "question_type": "1",
                "belong_page": 1,
                "question_id": "352288",
                "answer_type": 1
            },
            {
                "index": 224,
                "question_type": "9",
                "belong_page": 1,
                "question_id": "352290",
                "answer_type": 1
            },
            {
                "index": 225,
                "question_type": "9",
                "belong_page": 1,
                "question_id": "352291",
                "answer_type": 1
            },
            {
                "index": 226,
                "question_type": "9",
                "belong_page": 1,
                "question_id": "352293",
                "answer_type": 1
            },
            {
                "index": 227,
                "question_type": "9",
                "belong_page": 1,
                "question_id": "352294",
                "answer_type": 1
            },
            {
                "index": 228,
                "question_type": "1",
                "belong_page": 1,
                "question_id": "352358",
                "answer_type": 1
            },
            {
                "index": 229,
                "question_type": "1",
                "belong_page": 1,
                "question_id": "352359",
                "answer_type": 1
            },
            {
                "index": 230,
                "question_type": "9",
                "belong_page": 1,
                "question_id": "352396",
                "answer_type": 1
            },
            {
                "index": 231,
                "question_type": "9",
                "belong_page": 1,
                "question_id": "352397",
                "answer_type": 1
            },
            {
                "index": 232,
                "question_type": "9",
                "belong_page": 1,
                "question_id": "352398",
                "answer_type": 1
            },
            {
                "index": 233,
                "question_type": "9",
                "belong_page": 1,
                "question_id": "352430",
                "answer_type": 1
            },
            {
                "index": 234,
                "question_type": "9",
                "belong_page": 1,
                "question_id": "352431",
                "answer_type": 1
            },
            {
                "index": 235,
                "question_type": "9",
                "belong_page": 1,
                "question_id": "352432",
                "answer_type": 1
            },
            {
                "index": 236,
                "question_type": "1",
                "belong_page": 1,
                "question_id": "356211",
                "answer_type": 1
            },
            {
                "index": 237,
                "question_type": "1",
                "belong_page": 1,
                "question_id": "356212",
                "answer_type": 1
            },
            {
                "index": 238,
                "question_type": "1",
                "belong_page": 1,
                "question_id": "356213",
                "answer_type": 1
            },
            {
                "index": 239,
                "question_type": "1",
                "belong_page": 1,
                "question_id": "356214",
                "answer_type": 1
            },
            {
                "index": 240,
                "question_type": "1",
                "belong_page": 1,
                "question_id": "356215",
                "answer_type": 1
            },
            {
                "index": 241,
                "question_type": "1",
                "belong_page": 1,
                "question_id": "356217",
                "answer_type": 1
            },
            {
                "index": 242,
                "question_type": "1",
                "belong_page": 1,
                "question_id": "356218",
                "answer_type": 1
            },
            {
                "index": 243,
                "question_type": "9",
                "belong_page": 1,
                "question_id": "356221",
                "answer_type": 1
            },
            {
                "index": 244,
                "question_type": "9",
                "belong_page": 1,
                "question_id": "356222",
                "answer_type": 1
            },
            {
                "index": 245,
                "question_type": "1",
                "belong_page": 1,
                "question_id": "363081",
                "answer_type": 1
            },
            {
                "index": 246,
                "question_type": "1",
                "belong_page": 1,
                "question_id": "363082",
                "answer_type": 1
            },
            {
                "index": 247,
                "question_type": "5",
                "belong_page": 1,
                "question_id": "43728",
                "answer_type": 5
            },
            {
                "index": 248,
                "question_type": "5",
                "belong_page": 1,
                "question_id": "43729",
                "answer_type": 5
            },
            {
                "index": 249,
                "question_type": "5",
                "belong_page": 1,
                "question_id": "43732",
                "answer_type": 5
            },
            {
                "index": 250,
                "question_type": "5",
                "belong_page": 1,
                "question_id": "45942",
                "answer_type": 5
            },
            {
                "index": 251,
                "question_type": "5",
                "belong_page": 1,
                "question_id": "45945",
                "answer_type": 5
            },
            {
                "index": 252,
                "question_type": "5",
                "belong_page": 1,
                "question_id": "45949",
                "answer_type": 5
            },
            {
                "index": 253,
                "question_type": "5",
                "belong_page": 1,
                "question_id": "54270",
                "answer_type": 5
            },
            {
                "index": 254,
                "question_type": "5",
                "belong_page": 1,
                "question_id": "63700",
                "answer_type": 5
            },
            {
                "index": 255,
                "question_type": "5",
                "belong_page": 1,
                "question_id": "63707",
                "answer_type": 5
            },
            {
                "index": 256,
                "question_type": "5",
                "belong_page": 1,
                "question_id": "63709",
                "answer_type": 5
            },
            {
                "index": 257,
                "question_type": "14",
                "belong_page": 1,
                "question_id": "315998",
                "answer_type": 5
            },
            {
                "index": 258,
                "question_type": "14",
                "belong_page": 1,
                "question_id": "315999",
                "answer_type": 5
            },
            {
                "index": 259,
                "question_type": "14",
                "belong_page": 1,
                "question_id": "316000",
                "answer_type": 5
            },
            {
                "index": 260,
                "question_type": "5",
                "belong_page": 1,
                "question_id": "348854",
                "answer_type": 5
            }
        ],
        "progress": []
    }
}
