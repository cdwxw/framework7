{
    "msg": "成功",
    "status": 0,
    "data": {
        "data": {
            "question": [
                {
                    "index": 1,
                    "belong_page": 1,
                    "question_id": 4606,
                    "question_title": "<p>在数据库设计的需求分析阶段应完成包括（5）在内的文档。</p>",
                    "question_type": 1,
                    "answer_type": 1,
                    "show_type_name": null,
                    "new_parent_id": 4606,
                    "score_rule": "",
                    "material_text": null,
                    "sort_son": "0",
                    "analyze": "<p>本题考察数据库设计方面的相关知识。</p>",
                    "like": 0,
                    "answer": [
                        "C"
                    ],
                    "option": [
                        " E-R图 ",
                        " 关系模式 ",
                        " 数据字典和数据流图 ",
                        " 任务书和设计方案 "
                    ]
                },
                {
                    "index": 2,
                    "belong_page": 1,
                    "question_id": 4609,
                    "question_title": "<p>设有职务工资P（职务、最低工资、最高工资），员工关系EMP（员工号、职务、工资），要求任何一名员工，其工资值必须在其职务对应的工资范围之内，实现该需求的方法是（6）。</p>",
                    "question_type": 1,
                    "answer_type": 1,
                    "show_type_name": null,
                    "new_parent_id": 4609,
                    "score_rule": "",
                    "material_text": null,
                    "sort_son": "0",
                    "analyze": "<p>考察数据完整性约束方面基础知识。</p>",
                    "like": 0,
                    "answer": [
                        "C"
                    ],
                    "option": [
                        " 建立EMP.职务向P.职务的参照完整性约束 ",
                        " 建立P.职务向EMP.职务的参照完整性约束 ",
                        " 建立EMP上的触发器程序审定该需求 ",
                        " 建立P上的触发器程序审定该需求 "
                    ]
                },
                {
                    "index": 3,
                    "belong_page": 1,
                    "question_id": 4612,
                    "question_title": "<p>设关系模式R(U，F），其中R上的属性集U={A，B，C，D，E}，R上的函数依赖集F=｛A→B，DE→B，CB→E，E→A，B→D｝。（）为关系R的候选关键字。</p>",
                    "question_type": 1,
                    "answer_type": 1,
                    "show_type_name": null,
                    "new_parent_id": 4612,
                    "score_rule": "",
                    "material_text": null,
                    "sort_son": "0",
                    "analyze": "<p>本题考察求解关键字</p>",
                    "like": 0,
                    "answer": [
                        "C"
                    ],
                    "option": [
                        " AB ",
                        " DE ",
                        " CE ",
                        " DB "
                    ]
                },
                {
                    "index": 4,
                    "belong_page": 1,
                    "question_id": 4613,
                    "question_title": "<p>设关系模式R(U，F），其中R上的属性集U={A，B，C，D，E}，R上的函数依赖集F=｛A→B，DE→B，CB→E，E→A，B→D｝。分解（）是无损连接，并保持函数依赖的。</p>",
                    "question_type": 1,
                    "answer_type": 1,
                    "show_type_name": null,
                    "new_parent_id": 4613,
                    "score_rule": "",
                    "material_text": null,
                    "sort_son": "0",
                    "analyze": "<p>本题考察模式分解知识的掌握</p>",
                    "like": 0,
                    "answer": [
                        "D"
                    ],
                    "option": [
                        " ρ={R1(AC),R2(ED),R3(B)} ",
                        " ρ={R1(AC),R2(E),R3(DB)} ",
                        " ρ={R1(AC),R2(ED),R3(AB)} ",
                        " ρ={R1(ABC),R2(ED),R3(ACE)} "
                    ]
                },
                {
                    "index": 5,
                    "belong_page": 1,
                    "question_id": 4614,
                    "question_title": "<p>在数据库设计的（）阶段进行关系规范化。</p>",
                    "question_type": 1,
                    "answer_type": 1,
                    "show_type_name": null,
                    "new_parent_id": 4614,
                    "score_rule": "",
                    "material_text": null,
                    "sort_son": "0",
                    "analyze": "<p>考察数据库设计基础知识</p>",
                    "like": 0,
                    "answer": [
                        "C"
                    ],
                    "option": [
                        " 需求分析 ",
                        " 概念设计 ",
                        " 逻辑设计 ",
                        " 物理设计 "
                    ]
                },
                {
                    "index": 6,
                    "belong_page": 1,
                    "question_id": 4617,
                    "question_title": "<p>某数据库中有员工关系E（员工号，姓名，部门，职称，月薪）；产品关系P（产品号，产品名称，型号，尺寸，颜色）；仓库关系W（仓库号，仓库名称，地址，负责人）；库存关系I（仓库号，产品号，产品数量）。&nbsp;a.若数据库设计中要求：&nbsp;①仓库关系W中的“负责人”引用员工关系的员工号&nbsp;②库存关系I中的“仓库号，产品号”惟一标识I中的每一个记录&nbsp;③员工关系E中的职称为“工程师”的月薪不能低于3500元&nbsp;则①②③依次要满足的完整性约束是（）。</p>",
                    "question_type": 1,
                    "answer_type": 1,
                    "show_type_name": null,
                    "new_parent_id": 4617,
                    "score_rule": "",
                    "material_text": null,
                    "sort_son": "0",
                    "analyze": "<p>考察数据库设计基础知识</p>",
                    "like": 0,
                    "answer": [
                        "B"
                    ],
                    "option": [
                        " 实体完整性、参照完整性、用户定义完整性 ",
                        " 参照完整性、实体完整性、用户定义完整性 ",
                        " 用户定义完整性、实体完整性、参照完整性 ",
                        " 实体完整性、用户定义完整性、参照完整性 "
                    ]
                },
                {
                    "index": 7,
                    "belong_page": 1,
                    "question_id": 4618,
                    "question_title": "<p>若需得到每种产品的名称和该产品的总库存量，则对应的查询语句为： SELELCT 产品名称, SUM(产品数量) FROM P, I WHERE P.产品号 = I.产品号 （ ）</p>",
                    "question_type": 1,
                    "answer_type": 1,
                    "show_type_name": null,
                    "new_parent_id": 4618,
                    "score_rule": "",
                    "material_text": null,
                    "sort_son": "0",
                    "analyze": "<p>考察SQL基本知识</p>",
                    "like": 0,
                    "answer": [
                        "C"
                    ],
                    "option": [
                        " ORDER&nbsp;BY 产品名称 ",
                        " ORDER&nbsp;BY&nbsp;产品数量 ",
                        " GROUP&nbsp;BY 产品名称 ",
                        " GROUP&nbsp;BY&nbsp;产品数量 "
                    ]
                },
                {
                    "index": 8,
                    "belong_page": 1,
                    "question_id": 4619,
                    "question_title": "<p>若对关系 R(A, B, C, D) 和 S(C, D, E) 进行关系代数运算，则表达式 π<sub>3,4,7</sub>(σ<sub>4&lt;5</sub>(R×S))&nbsp;与（ ）等价。</p>",
                    "question_type": 1,
                    "answer_type": 1,
                    "show_type_name": null,
                    "new_parent_id": 4619,
                    "score_rule": "",
                    "material_text": null,
                    "sort_son": "0",
                    "analyze": "<p>考察关系代数运算的知识。</p>",
                    "like": 0,
                    "answer": [
                        "B"
                    ],
                    "option": [
                        " π<sub>C,D,E</sub>(σ<sub>D&lt;C</sub>(R×S)) ",
                        " π<sub>R.C,R.D,E</sub>(σ<sub>R.D&lt;S.C</sub>(R×S)) ",
                        " π<sub>C,D,E</sub>(σ<sub>R.D&lt;S.C</sub>(R×S)) ",
                        " π<sub>R.C,R.D,E</sub>(σ<sub>D&lt;C</sub>(R×S)) "
                    ]
                },
                {
                    "index": 9,
                    "belong_page": 1,
                    "question_id": 43237,
                    "question_title": "<p><br/></p><p><img style=\"max-width:100%;height:auto\"  src=\"https://s2.51cto.com/images/201808/a4c1ba9736faa6ed6fb126d76c32bc93c7aa1a.png\"/><br/></p><p><br/><br/><br/></p><p><br/></p><br/><p><br/></p>",
                    "question_type": 1,
                    "answer_type": 1,
                    "show_type_name": null,
                    "new_parent_id": 43237,
                    "score_rule": "",
                    "material_text": null,
                    "sort_son": "0",
                    "analyze": "<p>本题考查关系代数运算与SQL查询方面的基础知识。<br/>第一空：自然连接R⋈S是指R与S关系中相同属性列名的等值连接运算后，再去掉右边重复的属性列名S.B、S.C，所以经R⋈S运算后的属性列名为：R.A、R.B、R.C、R.D、S.E和S.F，共有6个属性列。<br/>第二空：π1,3,5,6（σ3&lt;6（R⋈S））的含义是从R⋈S结果集中选取R.C&lt;S.F的元组，再进行R.A、R.C、S.E和S.F投影。<br/>第三空：由于自然连接R⋈S是指R与S关系中相同属性列名的等值连接，故需要用条件“WHERE R.B=S.B AND R.C=S.C”来限定；又由于经自然连接R⋈S运算后，去掉了右边重复的属性列名S.B、S.C，使得第三列属性列名和第六列属性列名分别为R.C、S.F，所以选取运算σ3&lt;6需要用条件“WHERE R.C&lt;S.F”来限定。&#39;&#39;<br/></p>",
                    "like": 0,
                    "answer": [
                        "B"
                    ],
                    "option": [
                        " R.B=S.BAND&nbsp;R.C=S.CAND&nbsp;R.C＜S.B ",
                        " R.B=S.BAND&nbsp;R.C=S.CAND&nbsp;R.C＜S.F ",
                        " R.B=S.B&nbsp;OR&nbsp;R.C=S.C&nbsp;OR&nbsp;R.C＜S.B ",
                        " R.B=S.B&nbsp;OR&nbsp;R.C=S.C&nbsp;OR&nbsp;RC＜S.F "
                    ]
                },
                {
                    "index": 10,
                    "belong_page": 1,
                    "question_id": 43740,
                    "question_title": "<p><br/></p><p><br/></p><p><br/></p><p><br/></p><p><br/></p><p class=\"MsoNormal\" style=\"text-indent:0.0000pt;mso-char-indent-count:0.0000;text-align:left;\"><span style=\"mso-spacerun:&#39;yes&#39;;font-family:宋体;font-size:10.5000pt;mso-font-kerning:1.0000pt;\"><span style=\"font-family:宋体\">若系统中存在</span></span><span style=\"mso-spacerun:&#39;yes&#39;;font-family:宋体;font-size:10.5000pt;mso-font-kerning:1.0000pt;\">n</span><span style=\"mso-spacerun:&#39;yes&#39;;font-family:宋体;font-size:10.5000pt;mso-font-kerning:1.0000pt;\"><span style=\"font-family:宋体\">个等待事务</span></span><span style=\"mso-spacerun:&#39;yes&#39;;font-family:宋体;font-size:10.5000pt;mso-font-kerning:1.0000pt;\">T</span><sub><span style=\"mso-spacerun:&#39;yes&#39;;font-family:宋体;font-size:10.5000pt;mso-font-kerning:1.0000pt;vertical-align:sub;\">i</span></sub><span style=\"mso-spacerun:&#39;yes&#39;;font-family:宋体;font-size:10.5000pt;mso-font-kerning:1.0000pt;\">(i=0</span><span style=\"mso-spacerun:&#39;yes&#39;;font-family:宋体;font-size:10.5000pt;mso-font-kerning:1.0000pt;\"><span style=\"font-family:宋体\">，</span></span><span style=\"mso-spacerun:&#39;yes&#39;;font-family:宋体;font-size:10.5000pt;mso-font-kerning:1.0000pt;\">1</span><span style=\"mso-spacerun:&#39;yes&#39;;font-family:宋体;font-size:10.5000pt;mso-font-kerning:1.0000pt;\"><span style=\"font-family:宋体\">，</span></span><span style=\"mso-spacerun:&#39;yes&#39;;font-family:宋体;font-size:10.5000pt;mso-font-kerning:1.0000pt;\">2</span><span style=\"mso-spacerun:&#39;yes&#39;;font-family:宋体;font-size:10.5000pt;mso-font-kerning:1.0000pt;\"><span style=\"font-family:宋体\">，</span>…，</span><span style=\"mso-spacerun:&#39;yes&#39;;font-family:宋体;font-size:10.5000pt;mso-font-kerning:1.0000pt;\">n-1)</span><span style=\"mso-spacerun:&#39;yes&#39;;font-family:宋体;font-size:10.5000pt;mso-font-kerning:1.0000pt;\"><span style=\"font-family:宋体\">，其中：</span></span><span style=\"mso-spacerun:&#39;yes&#39;;font-family:宋体;font-size:10.5000pt;mso-font-kerning:1.0000pt;\">T</span><sub><span style=\"mso-spacerun:&#39;yes&#39;;font-family:宋体;font-size:10.5000pt;mso-font-kerning:1.0000pt;vertical-align:sub;\">0</span></sub><span style=\"mso-spacerun:&#39;yes&#39;;font-family:宋体;font-size:10.5000pt;mso-font-kerning:1.0000pt;\"><span style=\"font-family:宋体\">正等待被</span></span><span style=\"mso-spacerun:&#39;yes&#39;;font-family:宋体;font-size:10.5000pt;mso-font-kerning:1.0000pt;\">T</span><sub><span style=\"mso-spacerun:&#39;yes&#39;;font-family:宋体;font-size:10.5000pt;mso-font-kerning:1.0000pt;vertical-align:sub;\">1</span></sub><span style=\"mso-spacerun:&#39;yes&#39;;font-family:宋体;font-size:10.5000pt;mso-font-kerning:1.0000pt;\"><span style=\"font-family:宋体\">锁住的数据项</span></span><span style=\"mso-spacerun:&#39;yes&#39;;font-family:宋体;font-size:10.5000pt;mso-font-kerning:1.0000pt;\">A</span><sub><span style=\"mso-spacerun:&#39;yes&#39;;font-family:宋体;font-size:10.5000pt;mso-font-kerning:1.0000pt;vertical-align:sub;\">1</span></sub><span style=\"mso-spacerun:&#39;yes&#39;;font-family:宋体;font-size:10.5000pt;mso-font-kerning:1.0000pt;\"><span style=\"font-family:宋体\">，</span></span><span style=\"mso-spacerun:&#39;yes&#39;;font-family:宋体;font-size:10.5000pt;mso-font-kerning:1.0000pt;\">T</span><sub><span style=\"mso-spacerun:&#39;yes&#39;;font-family:宋体;font-size:10.5000pt;mso-font-kerning:1.0000pt;vertical-align:sub;\">1</span></sub><span style=\"mso-spacerun:&#39;yes&#39;;font-family:宋体;font-size:10.5000pt;mso-font-kerning:1.0000pt;\"><span style=\"font-family:宋体\">正等待被</span></span><span style=\"mso-spacerun:&#39;yes&#39;;font-family:宋体;font-size:10.5000pt;mso-font-kerning:1.0000pt;\">T</span><sub><span style=\"mso-spacerun:&#39;yes&#39;;font-family:宋体;font-size:10.5000pt;mso-font-kerning:1.0000pt;vertical-align:sub;\">2</span></sub><span style=\"mso-spacerun:&#39;yes&#39;;font-family:宋体;font-size:10.5000pt;mso-font-kerning:1.0000pt;\"><span style=\"font-family:宋体\">锁住的数据项</span></span><span style=\"mso-spacerun:&#39;yes&#39;;font-family:宋体;font-size:10.5000pt;mso-font-kerning:1.0000pt;\">A</span><sub><span style=\"mso-spacerun:&#39;yes&#39;;font-family:宋体;font-size:10.5000pt;mso-font-kerning:1.0000pt;vertical-align:sub;\">2</span></sub><span style=\"mso-spacerun:&#39;yes&#39;;font-family:宋体;font-size:10.5000pt;mso-font-kerning:1.0000pt;\"><span style=\"font-family:宋体\">，</span>…，</span><span style=\"mso-spacerun:&#39;yes&#39;;font-family:宋体;font-size:10.5000pt;mso-font-kerning:1.0000pt;\">T</span><sub><span style=\"mso-spacerun:&#39;yes&#39;;font-family:宋体;font-size:10.5000pt;mso-font-kerning:1.0000pt;vertical-align:sub;\">i</span></sub><span style=\"mso-spacerun:&#39;yes&#39;;font-family:宋体;font-size:10.5000pt;mso-font-kerning:1.0000pt;\"><span style=\"font-family:宋体\">正等待被</span></span><span style=\"mso-spacerun:&#39;yes&#39;;font-family:宋体;font-size:10.5000pt;mso-font-kerning:1.0000pt;\">T</span><sub><span style=\"mso-spacerun:&#39;yes&#39;;font-family:宋体;font-size:10.5000pt;mso-font-kerning:1.0000pt;vertical-align:sub;\">i</span></sub><span style=\"mso-spacerun:&#39;yes&#39;;font-family:宋体;font-size:10.5000pt;mso-font-kerning:1.0000pt;\">+1</span><span style=\"mso-spacerun:&#39;yes&#39;;font-family:宋体;font-size:10.5000pt;mso-font-kerning:1.0000pt;\"><span style=\"font-family:宋体\">锁住的数据项</span></span><span style=\"mso-spacerun:&#39;yes&#39;;font-family:宋体;font-size:10.5000pt;mso-font-kerning:1.0000pt;\">A</span><sub><span style=\"mso-spacerun:&#39;yes&#39;;font-family:宋体;font-size:10.5000pt;mso-font-kerning:1.0000pt;vertical-align:sub;\">i+1</span></sub><span style=\"mso-spacerun:&#39;yes&#39;;font-family:宋体;font-size:10.5000pt;mso-font-kerning:1.0000pt;\"><span style=\"font-family:宋体\">，</span>…，</span><span style=\"mso-spacerun:&#39;yes&#39;;font-family:宋体;font-size:10.5000pt;mso-font-kerning:1.0000pt;\">T</span><sub><span style=\"mso-spacerun:&#39;yes&#39;;font-family:宋体;font-size:10.5000pt;mso-font-kerning:1.0000pt;vertical-align:sub;\">n-1</span></sub><span style=\"mso-spacerun:&#39;yes&#39;;font-family:宋体;font-size:10.5000pt;mso-font-kerning:1.0000pt;\"><span style=\"font-family:宋体\">正等待被</span></span><span style=\"mso-spacerun:&#39;yes&#39;;font-family:宋体;font-size:10.5000pt;mso-font-kerning:1.0000pt;\">T</span><sub><span style=\"mso-spacerun:&#39;yes&#39;;font-family:宋体;font-size:10.5000pt;mso-font-kerning:1.0000pt;vertical-align:sub;\">0</span></sub><span style=\"mso-spacerun:&#39;yes&#39;;font-family:宋体;font-size:10.5000pt;mso-font-kerning:1.0000pt;\"><span style=\"font-family:宋体\">锁住的数据项</span></span><span style=\"mso-spacerun:&#39;yes&#39;;font-family:宋体;font-size:10.5000pt;mso-font-kerning:1.0000pt;\">A</span><sub><span style=\"mso-spacerun:&#39;yes&#39;;font-family:宋体;font-size:10.5000pt;mso-font-kerning:1.0000pt;vertical-align:sub;\">0</span></sub><span style=\"mso-spacerun:&#39;yes&#39;;font-family:宋体;font-size:10.5000pt;mso-font-kerning:1.0000pt;\"><span style=\"font-family:宋体\">，则系统处于</span></span><span style=\"text-decoration:underline;\"><span style=\"mso-spacerun:&#39;yes&#39;;font-family:宋体;text-decoration:underline;text-underline:single;font-size:10.5000pt;mso-font-kerning:1.0000pt;\">(5)</span></span><span style=\"mso-spacerun:&#39;yes&#39;;font-family:宋体;font-size:10.5000pt;mso-font-kerning:1.0000pt;\"><span style=\"font-family:宋体\">状态。</span></span><span style=\"mso-spacerun:&#39;yes&#39;;font-family:宋体;mso-hansi-font-family:&#39;Times New Roman&#39;;font-size:10.5000pt;mso-font-kerning:1.0000pt;\"></span></p><p><br/></p><p><br/></p>",
                    "question_type": 1,
                    "answer_type": 1,
                    "show_type_name": null,
                    "new_parent_id": 43740,
                    "score_rule": "",
                    "material_text": null,
                    "sort_son": "0",
                    "analyze": "<p>略</p>",
                    "like": 0,
                    "answer": [
                        "B"
                    ],
                    "option": [
                        " 封锁 ",
                        " 死锁&nbsp; ",
                        " 循环 ",
                        " 并发处理 "
                    ]
                },
                {
                    "index": 11,
                    "belong_page": 1,
                    "question_id": 43741,
                    "question_title": "<p><br/></p><p><br/></p><p class=\"MsoNormal\" style=\"text-indent:0.0000pt;mso-char-indent-count:0.0000;text-align:left;\"><span style=\"mso-spacerun:&#39;yes&#39;;font-family:宋体;font-size:10.5000pt;mso-font-kerning:1.0000pt;\"><span style=\"font-family:宋体\">在分布式数据库中包括分片透明、复制透明、位置透明和逻辑透明等基本概念，其中：</span></span><span style=\"text-decoration:underline;\"><span style=\"mso-spacerun:&#39;yes&#39;;font-family:宋体;text-decoration:underline;text-underline:single;font-size:10.5000pt;mso-font-kerning:1.0000pt;\">(6)</span></span><span style=\"mso-spacerun:&#39;yes&#39;;font-family:宋体;font-size:10.5000pt;mso-font-kerning:1.0000pt;\"><span style=\"font-family:宋体\">是指局部数据模型透明，即用户或应用程序无须知道局部场地使用的是哪种数据模型。</span></span><span style=\"mso-spacerun:&#39;yes&#39;;font-family:宋体;mso-hansi-font-family:&#39;Times New Roman&#39;;font-size:10.5000pt;mso-font-kerning:1.0000pt;\"></span></p><p><br/></p>",
                    "question_type": 1,
                    "answer_type": 1,
                    "show_type_name": null,
                    "new_parent_id": 43741,
                    "score_rule": "",
                    "material_text": null,
                    "sort_son": "0",
                    "analyze": "<p>略</p>",
                    "like": 0,
                    "answer": [
                        "D"
                    ],
                    "option": [
                        " 分片透明&nbsp;&nbsp; ",
                        " 复制透明&nbsp; ",
                        " 位置透明 ",
                        " 逻辑透明 "
                    ]
                },
                {
                    "index": 12,
                    "belong_page": 1,
                    "question_id": 43742,
                    "question_title": "<p><img style=\"max-width:100%;height:auto\"  src=\"https://s2.51cto.com/images/201807/113569c4576553f64b54031a745f798533ea39.png\"/></p><p><br/></p>",
                    "question_type": 1,
                    "answer_type": 1,
                    "show_type_name": null,
                    "new_parent_id": 43742,
                    "score_rule": "",
                    "material_text": null,
                    "sort_son": "0",
                    "analyze": "<p><img style=\"max-width:100%;height:auto\"  src=\"https://s2.51cto.com/images/201807/2417afe8517fd04c0e22531f2f193f300973a6.png\"/></p>",
                    "like": 0,
                    "answer": [
                        "D"
                    ],
                    "option": [
                        " A ",
                        " B ",
                        " C ",
                        " D "
                    ]
                },
                {
                    "index": 13,
                    "belong_page": 1,
                    "question_id": 43743,
                    "question_title": "<p>若关系R、S如下图所示，则关系R与S进行自然连接运算后的元组个数和属性列数分别为（ ）；关系代数表达式π<sub>1,4</sub>(σ<sub>3=6</sub>(R×S))与关系代数表达式（请作答此空）等价。<br/><img style=\"max-width:100%;height:auto\"  src=\"https://s2.51cto.com/images/20210419/1618807296363986.png\" title=\"1618807296363986.png\" alt=\"rs.png\"/></p>",
                    "question_type": 1,
                    "answer_type": 1,
                    "show_type_name": null,
                    "new_parent_id": 43743,
                    "score_rule": "",
                    "material_text": null,
                    "sort_son": "0",
                    "analyze": "<p>本题考查关系运算方面的基础知识。</p><p>根据自然连接要求，两个关系中进行比较的分量必须是相同的属性组，并且在结果中将重复属性列去掉，故R⋈S后的属性列数为4。同时，自然连接是一种特殊的等值连接，即R关系中的C、D属性与S关系中的C、D属性进行等值连接，然后去掉重复属性列，其结果为：</p><p><img style=\"max-width:100%;height:auto\"  src=\"https://s2.51cto.com/images/20211202/1638432666452115.png\" title=\"1638432666452115.png\" alt=\"屏幕截图 2021-12-02.png\"/></p><p>可见自然连接后的元组个数为3。</p><p>R⋈S关系代数表达式π<sub>1,4</sub>(σ<sub>3=6</sub>(R×S))中，R×S的6个属性列为：R.A、R.B、R.C、R.D、S.C和S.D，σ<sub>3=6</sub>(R×S)表示R与S关系进行笛卡尔积运算后，选取第三个属性R.C等于第六个属性S.D的元组；π<sub>1,4</sub>(σ<sub>3=6</sub>(R×S))表示从σ<sub>3=6</sub>(R×S)的结果中投影第一个和第四个属性列，即投影R.A和R.D属性列。</p><p><br/></p>",
                    "like": 0,
                    "answer": [
                        "C"
                    ],
                    "option": [
                        " π<sub>A,D</sub>(σ<sub>C=D</sub>(R×S) ",
                        " π<sub>A,R.D</sub>(σ<sub>S.C=R.D</sub>(R×S)) ",
                        " π<sub>A,R.D</sub>(σ<sub>R.C=S.D</sub>(R×S)) ",
                        " π<sub>A,R.D</sub>(σ<sub>S.C=S.D</sub>(R×S)) "
                    ]
                },
                {
                    "index": 14,
                    "belong_page": 1,
                    "question_id": 43756,
                    "question_title": "<p><br/></p><p><br/></p><p class=\"MsoNormal\" style=\"text-indent:20.7000pt;text-align:left;\"><span style=\"mso-spacerun:&#39;yes&#39;;font-family:宋体;font-size:10.5000pt;mso-font-kerning:1.0000pt;\"><span style=\"font-family:宋体\">电子商务系统中参与电子商务活动的实体包括</span></span><span style=\"text-decoration:underline;\"><span style=\"mso-spacerun:&#39;yes&#39;;font-family:宋体;text-decoration:underline;text-underline:single;font-size:10.5000pt;mso-font-kerning:1.0000pt;\"><span style=\"font-family:宋体\">（</span></span></span><span style=\"text-decoration:underline;\"><span style=\"mso-spacerun:&#39;yes&#39;;font-family:宋体;text-decoration:underline;text-underline:single;font-size:10.5000pt;mso-font-kerning:1.0000pt;\">21</span></span><span style=\"text-decoration:underline;\"><span style=\"mso-spacerun:&#39;yes&#39;;font-family:宋体;text-decoration:underline;text-underline:single;font-size:10.5000pt;mso-font-kerning:1.0000pt;\"><span style=\"font-family:宋体\">）</span></span></span><span style=\"mso-spacerun:&#39;yes&#39;;font-family:宋体;font-size:10.5000pt;mso-font-kerning:1.0000pt;\"><span style=\"font-family:宋体\">。</span></span><span style=\"mso-spacerun:&#39;yes&#39;;font-family:宋体;mso-hansi-font-family:&#39;Times New Roman&#39;;font-size:10.5000pt;mso-font-kerning:1.0000pt;\"></span></p><p><br/></p>",
                    "question_type": 1,
                    "answer_type": 1,
                    "show_type_name": null,
                    "new_parent_id": 43756,
                    "score_rule": "",
                    "material_text": null,
                    "sort_son": "0",
                    "analyze": "<p>略</p>",
                    "like": 0,
                    "answer": [
                        "A"
                    ],
                    "option": [
                        " 客户、商户、银行和认证中心&nbsp; ",
                        " 客户、银行、商户和政府机构 ",
                        " 客户、商户、银行和物流企业 ",
                        " 客户、商户、政府和物流企业 "
                    ]
                },
                {
                    "index": 15,
                    "belong_page": 1,
                    "question_id": 43759,
                    "question_title": "<p><br/></p><p><br/></p><p class=\"MsoNormal\" style=\"text-indent:20.7000pt;text-align:left;\"><span style=\"mso-spacerun:&#39;yes&#39;;font-family:宋体;font-size:10.5000pt;mso-font-kerning:1.0000pt;\"><span style=\"font-family:宋体\">商业智能系统的处理过程包括四个主要阶段：数据预处理通过</span></span><span style=\"text-decoration:underline;\"><span style=\"mso-spacerun:&#39;yes&#39;;font-family:宋体;text-decoration:underline;text-underline:single;font-size:10.5000pt;mso-font-kerning:1.0000pt;\"><span style=\"font-family:宋体\">（</span></span></span><span style=\"text-decoration:underline;\"><span style=\"mso-spacerun:&#39;yes&#39;;font-family:宋体;text-decoration:underline;text-underline:single;font-size:10.5000pt;mso-font-kerning:1.0000pt;\"><span style=\"font-family:宋体\">）</span></span></span><span style=\"mso-spacerun:&#39;yes&#39;;font-family:宋体;font-size:10.5000pt;mso-font-kerning:1.0000pt;\"><span style=\"font-family:宋体\">实现企业原始数据的初步整合；建立数据仓库是后续数据处理的基础；数据分析是体现系统智能的关键，主要采用</span></span><span style=\"text-decoration:underline;\"><span style=\"mso-spacerun:&#39;yes&#39;;font-family:宋体;text-decoration:underline;text-underline:single;font-size:10.5000pt;mso-font-kerning:1.0000pt;\"><span style=\"font-family:宋体\">（</span></span></span><span style=\"text-decoration:underline;\"><span style=\"mso-spacerun:&#39;yes&#39;;font-family:宋体;text-decoration:underline;text-underline:single;font-size:10.5000pt;mso-font-kerning:1.0000pt;\"><span style=\"font-family:宋体\">）</span></span></span><span style=\"mso-spacerun:&#39;yes&#39;;font-family:宋体;font-size:10.5000pt;mso-font-kerning:1.0000pt;\"><span style=\"font-family:宋体\">和</span></span><span style=\"text-decoration:underline;\"><span style=\"mso-spacerun:&#39;yes&#39;;font-family:宋体;text-decoration:underline;text-underline:single;font-size:10.5000pt;mso-font-kerning:1.0000pt;\"><span style=\"font-family:宋体\">（请作答此空</span></span></span><span style=\"text-decoration:underline;\"><span style=\"mso-spacerun:&#39;yes&#39;;font-family:宋体;text-decoration:underline;text-underline:single;font-size:10.5000pt;mso-font-kerning:1.0000pt;\"><span style=\"font-family:宋体\">）</span></span></span><span style=\"mso-spacerun:&#39;yes&#39;;font-family:宋体;font-size:10.5000pt;mso-font-kerning:1.0000pt;\"><span style=\"font-family:宋体\">技术，前者能够实现数据的上卷、下钻和旋转分析，后者利用隐藏的知识，通过建立分析模型预测企业未来发展趋势；数据展现主要完成数据处理结果的可视化。</span></span><span style=\"mso-spacerun:&#39;yes&#39;;font-family:宋体;mso-hansi-font-family:&#39;Times New Roman&#39;;font-size:10.5000pt;mso-font-kerning:1.0000pt;\"></span></p><p><br/></p>",
                    "question_type": 1,
                    "answer_type": 1,
                    "show_type_name": null,
                    "new_parent_id": 43759,
                    "score_rule": "",
                    "material_text": null,
                    "sort_son": "0",
                    "analyze": "<p>略</p>",
                    "like": 0,
                    "answer": [
                        "B"
                    ],
                    "option": [
                        " 知识库&nbsp; ",
                        " 数据挖掘&nbsp;&nbsp; ",
                        " 联机事务处理&nbsp; ",
                        " 联机分析处理 "
                    ]
                },
                {
                    "index": 16,
                    "belong_page": 1,
                    "question_id": 43806,
                    "question_title": "<p><br/></p><p>&nbsp;The objective of (请作答此空)&nbsp;is to determine what parts of the application software will be assigned to what hardware. The major software components of the system being developed have to be identified and then allocated to the various hardware components on which the system will operate. All software systems can be divided into four basic functions. The first is (72). Most information systems require data to be stored and retrieved, whether a small file, such as a memo produced by a word processor, or a large database, such as one that stores an organization&#39;s accounting records. The second function is the (73), the processing required to access data, which often means database queries in Structured Query Language. The third function is the (74), which is the logic documented in the DFDs, use cases, and functional requirements. The fourth function is the presentation logic, the display of information to the user and the acceptance of the user&#39;s commands. The three primary hardware components of a system are (75).</p><p><br/></p>",
                    "question_type": 1,
                    "answer_type": 1,
                    "show_type_name": null,
                    "new_parent_id": 43806,
                    "score_rule": "",
                    "material_text": null,
                    "sort_son": "0",
                    "analyze": "<p><br/></p><p><br/></p><p>架构设计的目标是确定应用软件的哪些部分将被分配到何种硬件。识别出正在开发系统的主要软件构件并分配到系统将要运行的硬件构件。所有软件系统可分为四项基本功能。首项是数据存储。大多数信息系统需要数据进行存储并检索，无论是一个小文件，比如一个字处理器产生的一个备忘录，还是一个大型数据库，比如存储一个企业会计记录的数据库。第二项功能是数据访问逻辑，处理过程需要访问数据，这通常是指用SQL进行数据库查询。第三项功能是应用程序逻辑，这些逻辑通过数据流图，用例和功能需求来记录。第四项功能是表示逻辑，给用户显示信息并接收用户命令。一个系统的三类主要硬件构件是客户机、服务器和网络。</p><p><br/></p>",
                    "like": 0,
                    "answer": [
                        "A"
                    ],
                    "option": [
                        " architecture&nbsp;design&nbsp; ",
                        " modular&nbsp;design ",
                        " &nbsp;physical&nbsp;design&nbsp;&nbsp; ",
                        " distribution&nbsp;design "
                    ]
                },
                {
                    "index": 17,
                    "belong_page": 1,
                    "question_id": 43807,
                    "question_title": "<p><br/></p><p><br/></p><p>The objective of (71)&nbsp;is to determine what parts of the application software will be assigned to what hardware. The major software components of the system being developed have to be identified and then allocated to the various hardware components on which the system will operate. All software systems can be divided into four basic functions. The first is (请作答此空). Most information systems require data to be stored and retrieved, whether a small file, such as a memo produced by a word processor, or a large database, such as one that stores an organization&#39;s accounting records. The second function is the (73), the processing required to access data, which often means database queries in Structured Query Language. The third function is the (74), which is the logic documented in the DFDs, use cases, and functional requirements. The fourth function is the presentation logic, the display of information to the user and the acceptance of the user&#39;s commands. The three primary hardware components of a system are (75).</p><p><br/></p>",
                    "question_type": 1,
                    "answer_type": 1,
                    "show_type_name": null,
                    "new_parent_id": 43807,
                    "score_rule": "",
                    "material_text": null,
                    "sort_son": "0",
                    "analyze": "<p><br/></p><p><br/></p><p>架构设计的目标是确定应用软件的哪些部分将被分配到何种硬件。识别出正在开发系统的主要软件构件并分配到系统将要运行的硬件构件。所有软件系统可分为四项基本功能。首项是数据存储。大多数信息系统需要数据进行存储并检索，无论是一个小文件，比如一个字处理器产生的一个备忘录，还是一个大型数据库，比如存储一个企业会计记录的数据库。第二项功能是数据访问逻辑，处理过程需要访问数据，这通常是指用SQL进行数据库查询。第三项功能是应用程序逻辑，这些逻辑通过数据流图，用例和功能需求来记录。第四项功能是表示逻辑，给用户显示信息并接收用户命令。一个系统的三类主要硬件构件是客户机、服务器和网络。</p><p><br/></p>",
                    "like": 0,
                    "answer": [
                        "C"
                    ],
                    "option": [
                        " data&nbsp;access&nbsp;components&nbsp;&nbsp;&nbsp;&nbsp; ",
                        " database&nbsp;management&nbsp;system ",
                        " data&nbsp;storage&nbsp;&nbsp;&nbsp;&nbsp; ",
                        " data&nbsp;entities "
                    ]
                },
                {
                    "index": 18,
                    "belong_page": 1,
                    "question_id": 43808,
                    "question_title": "<p><br/></p><p><br/></p><p>The objective of (71)&nbsp;is to determine what parts of the application software will be assigned to what hardware. The major software components of the system being developed have to be identified and then allocated to the various hardware components on which the system will operate. All software systems can be divided into four basic functions. The first is (72). Most information systems require data to be stored and retrieved, whether a small file, such as a memo produced by a word processor, or a large database, such as one that stores an organization&#39;s accounting records. The second function is the (请作答此空), the processing required to access data, which often means database queries in Structured Query Language. The third function is the (74), which is the logic documented in the DFDs, use cases, and functional requirements. The fourth function is the presentation logic, the display of information to the user and the acceptance of the user&#39;s commands. The three primary hardware components of a system are (75).</p><p><br/></p>",
                    "question_type": 1,
                    "answer_type": 1,
                    "show_type_name": null,
                    "new_parent_id": 43808,
                    "score_rule": "",
                    "material_text": null,
                    "sort_son": "0",
                    "analyze": "<p><br/></p><p><br/></p><p>架构设计的目标是确定应用软件的哪些部分将被分配到何种硬件。识别出正在开发系统的主要软件构件并分配到系统将要运行的硬件构件。所有软件系统可分为四项基本功能。首项是数据存储。大多数信息系统需要数据进行存储并检索，无论是一个小文件，比如一个字处理器产生的一个备忘录，还是一个大型数据库，比如存储一个企业会计记录的数据库。第二项功能是数据访问逻辑，处理过程需要访问数据，这通常是指用SQL进行数据库查询。第三项功能是应用程序逻辑，这些逻辑通过数据流图，用例和功能需求来记录。第四项功能是表示逻辑，给用户显示信息并接收用户命令。一个系统的三类主要硬件构件是客户机、服务器和网络。</p><p><br/></p>",
                    "like": 0,
                    "answer": [
                        "D"
                    ],
                    "option": [
                        " data&nbsp;persistence&nbsp;&nbsp; ",
                        " data&nbsp;access&nbsp;objects ",
                        " database&nbsp;connection&nbsp;&nbsp; ",
                        " &nbsp;data&nbsp;access&nbsp;logic "
                    ]
                },
                {
                    "index": 19,
                    "belong_page": 1,
                    "question_id": 43809,
                    "question_title": "<p><br/></p><p><br/></p><p>The objective of (71)&nbsp;is to determine what parts of the application software will be assigned to what hardware. The major software components of the system being developed have to be identified and then allocated to the various hardware components on which the system will operate. All software systems can be divided into four basic functions. The first is (72). Most information systems require data to be stored and retrieved, whether a small file, such as a memo produced by a word processor, or a large database, such as one that stores an organization&#39;s accounting records. The second function is the (73), the processing required to access data, which often means database queries in Structured Query Language. The third function is the (请作答此空), which is the logic documented in the DFDs, use cases, and functional requirements. The fourth function is the presentation logic, the display of information to the user and the acceptance of the user&#39;s commands. The three primary hardware components of a system are (75).</p><p><br/></p>",
                    "question_type": 1,
                    "answer_type": 1,
                    "show_type_name": null,
                    "new_parent_id": 43809,
                    "score_rule": "",
                    "material_text": null,
                    "sort_son": "0",
                    "analyze": "<p><br/></p><p><br/></p><p>架构设计的目标是确定应用软件的哪些部分将被分配到何种硬件。识别出正在开发系统的主要软件构件并分配到系统将要运行的硬件构件。所有软件系统可分为四项基本功能。首项是数据存储。大多数信息系统需要数据进行存储并检索，无论是一个小文件，比如一个字处理器产生的一个备忘录，还是一个大型数据库，比如存储一个企业会计记录的数据库。第二项功能是数据访问逻辑，处理过程需要访问数据，这通常是指用SQL进行数据库查询。第三项功能是应用程序逻辑，这些逻辑通过数据流图，用例和功能需求来记录。第四项功能是表示逻辑，给用户显示信息并接收用户命令。一个系统的三类主要硬件构件是客户机、服务器和网络。</p><p><br/></p>",
                    "like": 0,
                    "answer": [
                        "C"
                    ],
                    "option": [
                        " system&nbsp;requirements&nbsp;&nbsp; ",
                        " system&nbsp;architecture ",
                        " application&nbsp;logic&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ",
                        " application&nbsp;program "
                    ]
                },
                {
                    "index": 20,
                    "belong_page": 1,
                    "question_id": 43810,
                    "question_title": "<p><br/></p><p><br/></p><p>The objective of (71)&nbsp;is to determine what parts of the application software will be assigned to what hardware. The major software components of the system being developed have to be identified and then allocated to the various hardware components on which the system will operate. All software systems can be divided into four basic functions. The first is (72). Most information systems require data to be stored and retrieved, whether a small file, such as a memo produced by a word processor, or a large database, such as one that stores an organization&#39;s accounting records. The second function is the (73), the processing required to access data, which often means database queries in Structured Query Language. The third function is the (74), which is the logic documented in the DFDs, use cases, and functional requirements. The fourth function is the presentation logic, the display of information to the user and the acceptance of the user&#39;s commands. The three primary hardware components of a system are (请作答此空).</p><p><br/></p>",
                    "question_type": 1,
                    "answer_type": 1,
                    "show_type_name": null,
                    "new_parent_id": 43810,
                    "score_rule": "",
                    "material_text": null,
                    "sort_son": "0",
                    "analyze": "<p><br/></p><p><br/></p><p>架构设计的目标是确定应用软件的哪些部分将被分配到何种硬件。识别出正在开发系统的主要软件构件并分配到系统将要运行的硬件构件。所有软件系统可分为四项基本功能。首项是数据存储。大多数信息系统需要数据进行存储并检索，无论是一个小文件，比如一个字处理器产生的一个备忘录，还是一个大型数据库，比如存储一个企业会计记录的数据库。第二项功能是数据访问逻辑，处理过程需要访问数据，这通常是指用SQL进行数据库查询。第三项功能是应用程序逻辑，这些逻辑通过数据流图，用例和功能需求来记录。第四项功能是表示逻辑，给用户显示信息并接收用户命令。一个系统的三类主要硬件构件是客户机、服务器和网络。</p><p><br/></p>",
                    "like": 0,
                    "answer": [
                        "B"
                    ],
                    "option": [
                        " computers,&nbsp;cables&nbsp;and&nbsp;network ",
                        " clients,&nbsp;servers,&nbsp;and&nbsp;network ",
                        " &nbsp;CPUs,&nbsp;memories&nbsp;and&nbsp;I/O&nbsp;devices ",
                        " CPUs,&nbsp;hard&nbsp;disks&nbsp;and&nbsp;I/O&nbsp;devices "
                    ]
                },
                {
                    "index": 21,
                    "belong_page": 1,
                    "question_id": 43832,
                    "question_title": "<p><br/></p><p>VRAPS原则不包括（ ）</p><p><br/></p>",
                    "question_type": 1,
                    "answer_type": 1,
                    "show_type_name": null,
                    "new_parent_id": 43832,
                    "score_rule": "",
                    "material_text": null,
                    "sort_son": "0",
                    "analyze": "<p>略<br/></p>",
                    "like": 0,
                    "answer": [
                        "B"
                    ],
                    "option": [
                        " 构想原则 ",
                        " 模型原则 ",
                        " 预见原则 ",
                        " 简化原则 "
                    ]
                },
                {
                    "index": 22,
                    "belong_page": 1,
                    "question_id": 43834,
                    "question_title": "<p><br/></p><p><br/></p><p>VRAPS原则表述不正确的是（ &nbsp;）</p><p><br/></p>",
                    "question_type": 1,
                    "answer_type": 1,
                    "show_type_name": null,
                    "new_parent_id": 43834,
                    "score_rule": "",
                    "material_text": null,
                    "sort_son": "0",
                    "analyze": "<p>略<br/></p>",
                    "like": 0,
                    "answer": [
                        "B"
                    ],
                    "option": [
                        " 构想原则向受益人描述未来图景 ",
                        " 简化原则要最大化架构 ",
                        " 节奏原则要预测进度 ",
                        " 预见原则要做未来与现状的绩效做平衡 "
                    ]
                },
                {
                    "index": 23,
                    "belong_page": 1,
                    "question_id": 43835,
                    "question_title": "<p><br/></p><p><br/></p><p>关于准则、模式和反模式的说法不正确的是（ ）</p><p><br/></p>",
                    "question_type": 1,
                    "answer_type": 1,
                    "show_type_name": null,
                    "new_parent_id": 43835,
                    "score_rule": "",
                    "material_text": null,
                    "sort_son": "0",
                    "analyze": "<p>略<br/></p>",
                    "like": 0,
                    "answer": [
                        "B"
                    ],
                    "option": [
                        " 准则用于判断每项原则的实施效果，说明是否和如何执行原则的问题 ",
                        " 准则用于判断每项原则的实施效果，可以不用说明执行原则的问题<br/> ",
                        " 反模式是组织在实践中可能遇到的各种陷阱，描述了不该做的事，可以帮助更深入地理解原则 ",
                        " 模式是在开发和使用软件中可能遇到的基本常见问题和解决问题的方法，能够帮助组织来更好地改进原则。 "
                    ]
                },
                {
                    "index": 24,
                    "belong_page": 1,
                    "question_id": 43836,
                    "question_title": "<p><br/></p><p><br/></p><p class=\"MsoNormal\"><span style=\"mso-spacerun:&#39;yes&#39;;font-family:&#39;Times New Roman&#39;;mso-fareast-font-family:宋体;color:#000000;font-size:10.5000pt;mso-font-kerning:1.0000pt;\"><span style=\"font-family:宋体\">关于</span>VRAPS<span style=\"font-family:宋体\">原则、准则、模式和反模式的说法正确的是（ ）</span></span></p><p><br/></p>",
                    "question_type": 1,
                    "answer_type": 1,
                    "show_type_name": null,
                    "new_parent_id": 43836,
                    "score_rule": "",
                    "material_text": null,
                    "sort_son": "0",
                    "analyze": "<p>结合本题只有D选项描述正确。</p>",
                    "like": 0,
                    "answer": [
                        "D"
                    ],
                    "option": [
                        " VRAPS原则的5个原则分别是构想原则、节奏原则、预见原则、统一原则 ",
                        " 反模式是在开发和使用软件中可能遇到的基本常见问题和解决问题的方法，能够帮助组织来更好地改进原则 ",
                        " 模式是组织在实践中可能遇到的各种陷阱，描述了不该做的事，可以帮助更深入地理解原则 ",
                        " VRAPS各个原则之间不是孤立的 "
                    ]
                },
                {
                    "index": 25,
                    "belong_page": 1,
                    "question_id": 43859,
                    "question_title": "<p><br/></p><p>数据库完整性的作用不包括（ ）</p><p><br/></p>",
                    "question_type": 1,
                    "answer_type": 1,
                    "show_type_name": null,
                    "new_parent_id": 43859,
                    "score_rule": "",
                    "material_text": null,
                    "sort_son": "0",
                    "analyze": "<p>略<br/></p>",
                    "like": 0,
                    "answer": [
                        "B"
                    ],
                    "option": [
                        " 能够防止合法用户使用数据库时向数据库中添加不合语义的数据 ",
                        " 数据库完整性无法同时兼顾数据库的完整性和系统效能 ",
                        " 有助于尽早发现应用软件的错误 ",
                        " 实现业务规则，易于定义，易于理解 "
                    ]
                },
                {
                    "index": 26,
                    "belong_page": 1,
                    "question_id": 46857,
                    "question_title": "<p>在数据库设计的需求分析阶段应当形成（）</p>",
                    "question_type": 1,
                    "answer_type": 1,
                    "show_type_name": null,
                    "new_parent_id": 46857,
                    "score_rule": "",
                    "material_text": null,
                    "sort_son": "0",
                    "analyze": "<p>数据库设计主要分为用户需求分析、概念结构、逻辑结构和物理结构设计四个阶段。其中，在用户需求分析阶段中，数据库设计人员采用一定的辅助工具对应用对象的功能、性能、 限制等要求所进行的科学分析，并形成需求说明文档、数据字典和数据流程图。</p>",
                    "like": 0,
                    "answer": [
                        "C"
                    ],
                    "option": [
                        " 程序文档、数据字典和数据流图 ",
                        " 需求说明文档、程序文档和数据流图 ",
                        " 需求说明文档、数据字典和数据流图 ",
                        " 需求说明文档、数据字典和程序文档 "
                    ]
                },
                {
                    "index": 27,
                    "belong_page": 1,
                    "question_id": 46858,
                    "question_title": "<p>在数据库设计的需求分析阶段应当形成需求说明文档、数据字典和数据流图，这些文档可以作为（）阶段的设计依据。</p>",
                    "question_type": 1,
                    "answer_type": 1,
                    "show_type_name": null,
                    "new_parent_id": 46858,
                    "score_rule": "",
                    "material_text": null,
                    "sort_son": "0",
                    "analyze": "<p>用户需求分析阶段形成的相关文档用以作为概念结构设计的设计依据。</p>",
                    "like": 0,
                    "answer": [
                        "B"
                    ],
                    "option": [
                        " 逻辑结构设计 ",
                        " 概念结构设计 ",
                        " 物理结构设计 ",
                        " 数据库运行和维护 "
                    ]
                },
                {
                    "index": 28,
                    "belong_page": 1,
                    "question_id": 46859,
                    "question_title": "<p>某商场商品数据库的商品关系模式P(商品代码，商品名称，供应商，联系方式，库存量)，函数依赖集F={商品代码→商品名称，(商品代码，供应商)→库存量，供应商→联系方式}。商品关系模式P达到（）</p>",
                    "question_type": 1,
                    "answer_type": 1,
                    "show_type_name": null,
                    "new_parent_id": 46859,
                    "score_rule": "",
                    "material_text": null,
                    "sort_son": "0",
                    "analyze": "<p>本题考查的是应试者关系数据库方面的基础知识。</p><p>根据题意，P关系中的(商品代码，供应商)可决定的P关系的所有属性，所以P关系的主键为(商品代码，供应商)；又因为，根据题意(商品代码，供应商)→商品名称，而商品代码→商品名称，供应商→联系方式，可以得出商品名称和联系方式都部分依赖于码，所以，该关系模式属于1NF。</p><p><br/></p>",
                    "like": 0,
                    "answer": [
                        "A"
                    ],
                    "option": [
                        " 1NF ",
                        " 2NF ",
                        " 3NF ",
                        " BCNF "
                    ]
                },
                {
                    "index": 29,
                    "belong_page": 1,
                    "question_id": 46860,
                    "question_title": "<p>某商场商品数据库的商品关系模式P(商品代码，商品名称，供应商，联系方式，库存量)，函数依赖集F={商品代码→商品名称，(商品代码，供应商)→库存量，供应商→联系方式}。商品关系模式P达到1NF，该关系模式分解成（）后，具有无损连接的特性，并能够保持函数依赖。</p>",
                    "question_type": 1,
                    "answer_type": 1,
                    "show_type_name": null,
                    "new_parent_id": 46860,
                    "score_rule": "",
                    "material_text": null,
                    "sort_son": "0",
                    "analyze": "<p>关系模式P属于1NF，1NF存在冗余度大、修改操作的不一致性、插入异常和删除异常四个问题。所以需要对模式分解，其中选项A、选项B和选项C的分解是有损且不保持函数依赖。例如，选项A中的分解P1的函数依赖集F1=Ф，分解P2的函数依赖集F2=Ф，丢失了F中的函数依赖，即不保持函数依赖。</p><p><br/></p>",
                    "like": 0,
                    "answer": [
                        "D"
                    ],
                    "option": [
                        " P1(商品代码，联系方式)，P2(商品名称，供应商，库存量) ",
                        " P1(商品名称，联系方式)，P2(商品代码，供应商，库存量) ",
                        " P1(商品代码，商品名称，联系方式)，P2(供应商，库存量) ",
                        " P1(商品代码，商品名称)，P2(商品代码，供应商，库存量)，P3(供应商，联系方式) "
                    ]
                },
                {
                    "index": 30,
                    "belong_page": 1,
                    "question_id": 46883,
                    "question_title": "<p>给定关系模式 R(U，F)，其中: 属性集 U={A1 ,A2,A3，A4，A5,A6}， 函数依赖集F={A1→A2， A1→A3， A3→A4， A1A5→A6}。关系模式 R 的候选码为(&nbsp;&nbsp;&nbsp;&nbsp;)</p>",
                    "question_type": 1,
                    "answer_type": 1,
                    "show_type_name": null,
                    "new_parent_id": 46883,
                    "score_rule": "",
                    "material_text": null,
                    "sort_son": "0",
                    "analyze": "<p>先求候选码：关系模式码的确定，设关系模式R&lt;U,F&gt;</p><p>1.首先应该找出F中所有的决定因素，即找出出现在函数依赖规则中“→”左边的所有属性，组成集合U1.</p><p>2.再从U1中找出一个属性或属性组K，运用Armstrong公理系统及推论，使得K→U，而K的真子集K&#39;→U不成立,这样就得到了关系模式R的一个候选码，找遍U1属性的所有组合。重复此步骤，最终得到关系模式R的所有候选码。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;</p>",
                    "like": 0,
                    "answer": [
                        "C"
                    ],
                    "option": [
                        " A1A3 ",
                        " A1A4 ",
                        " A1 A5 ",
                        " A1A6 "
                    ]
                },
                {
                    "index": 31,
                    "belong_page": 1,
                    "question_id": 46884,
                    "question_title": "<p>给定关系模式 R(U，F)，其中: 属性集 U={A1 ,A2,A3，A4，A5,A6}， 函数依赖集F={A1→A2， A1→A3， A3→A4， A1A5→A6}。由于 R 存在非主属性对码的部分函数依赖，所以 R 属于()</p>",
                    "question_type": 1,
                    "answer_type": 1,
                    "show_type_name": null,
                    "new_parent_id": 46884,
                    "score_rule": "",
                    "material_text": null,
                    "sort_son": "0",
                    "analyze": "<p>第一范式（1NF）是指数据库表的每一列都是不可分割的基本数据项，同一列中不能有多个值，即实体中的某个属性不能有多个值或者不能有重复的属性。如果出现重复的属性，就可能需要定义一个新的实体，新的实体由重复的属性构成，新实体与原实体之间为一对多关系。在第一范式（1NF）中表的每一行只包含一个实例的信息。</p>",
                    "like": 0,
                    "answer": [
                        "A"
                    ],
                    "option": [
                        " 1NF ",
                        " 2NF ",
                        " 3NF ",
                        " BCNF "
                    ]
                },
                {
                    "index": 32,
                    "belong_page": 1,
                    "question_id": 46885,
                    "question_title": "<p>分布式数据库两阶段提交协议中的两个阶段是指()</p>",
                    "question_type": 1,
                    "answer_type": 1,
                    "show_type_name": null,
                    "new_parent_id": 46885,
                    "score_rule": "",
                    "material_text": null,
                    "sort_son": "0",
                    "analyze": "<p>二阶段提交(Two-phaseCommit)是指，在计算机网络以及数据库领域内，为了使基于分布式系统架构下的所有节点在进行事务提交时保持一致性而设计的一种算法(Algorithm)。通常，二阶段提交也被称为是一种协议(Protocol))。在分布式系统中，每个节点虽然可以知晓自己的操作时成功或者失败，却无法知道其他节点的操作的成功或失败。当一个事务跨越多个节点时，为了保持事务的ACID特性，需要引入一个作为协调者的组件来统一掌控所有节点(称作参与者)的操作结果并最终指示这些节点是否要把操作结果进行真正的提交(比如将更新后的数据写入磁盘等等)。因此，二阶段提交的算法思路可以概括为：参与者将操作成败通知协调者，再由协调者根据所有参与者的反馈情报决定各参与者是否要提交操作还是中止操作。</p><p>所谓的两个阶段是指：第一阶段：准备阶段(表决阶段)和第二阶段：提交阶段（执行阶段）。</p><p>准备阶段：事务协调者(事务管理器)给每个参与者(资源管理器)发送Prepare消息，每个参与者要么直接返回失败(如权限验证失败)，要么在本地执行事务，写本地的redo和undo日志，但不提交，到达一种万事俱备，只欠东风的状态。</p><p>提交阶段：如果协调者收到了参与者的失败消息或者超时，直接给每个参与者发送回滚(Rollback)消息；否则，发送提交(Commit)消息；参与者根据协调者的指令执行提交或者回滚操作，释放所有事务处理过程中使用的锁资源。(注意:必须在最后阶段释放锁资源)。</p><p><br/></p>",
                    "like": 0,
                    "answer": [
                        "C"
                    ],
                    "option": [
                        " 加锁阶段、解锁阶段 ",
                        " 获取阶段、运行阶段 ",
                        " 表决阶段、执行阶段 ",
                        " 扩展阶段、收缩阶段 "
                    ]
                },
                {
                    "index": 33,
                    "belong_page": 1,
                    "question_id": 46890,
                    "question_title": "<p>对数据库管理系统评价的主要性能指标有（）、数据库所允许的索引数量和最大并发实物处理能力等。</p>",
                    "question_type": 1,
                    "answer_type": 1,
                    "show_type_name": null,
                    "new_parent_id": 46890,
                    "score_rule": "",
                    "material_text": null,
                    "sort_son": "0",
                    "analyze": "<p>衡量数据库管理系统的主要性能指标包括数据库本身和管理系统两部分，有：数据库的大小、数据库中表的数量、单个表的大小、表中允许的记录（行）数量、单个记录（行）的大小、表上所允许的索引数量、数据库所允许的索引数量、最大并发事务处理能力、负载均衡能力、最大连接数等等。</p>",
                    "like": 0,
                    "answer": [
                        "C"
                    ],
                    "option": [
                        " MIPS ",
                        " 支持协议和标准 ",
                        " 最大连接数 ",
                        " 时延抖动 "
                    ]
                },
                {
                    "index": 34,
                    "belong_page": 1,
                    "question_id": 46982,
                    "question_title": "<p>给定关系模式 R(A, B, C, D, E)、S(D, E, F, G) 和 π<sub>1,2,4,6</sub>(R⋈S)，经过自然连接和投影运算后的属性列数分别为（ ）</p>",
                    "question_type": 1,
                    "answer_type": 1,
                    "show_type_name": null,
                    "new_parent_id": 46982,
                    "score_rule": "",
                    "material_text": null,
                    "sort_son": "0",
                    "analyze": "<p>进行自然连接后，结果属性集为：A,B,C,D,E,F,G，共7列。</p><p>进行投影操作后，结果为：A,B,D,F，共4列。</p><p><br/></p>",
                    "like": 0,
                    "answer": [
                        "B"
                    ],
                    "option": [
                        " 9和4 ",
                        " 7和4 ",
                        " 9和7 ",
                        " 7和7 "
                    ]
                },
                {
                    "index": 35,
                    "belong_page": 1,
                    "question_id": 46984,
                    "question_title": "<p>给定关系 R(A1, A2, A3, A4, A5) 上的函数依赖集F={A1→A2A5, A2→A3A4, A3→A2}，R 的候选关键字为（ ）。</p>",
                    "question_type": 1,
                    "answer_type": 1,
                    "show_type_name": null,
                    "new_parent_id": 46984,
                    "score_rule": "",
                    "material_text": null,
                    "sort_son": "0",
                    "analyze": "<p>通过A1能推导出关系R的全部属性，因此关键字为A1。</p>",
                    "like": 0,
                    "answer": [
                        "A"
                    ],
                    "option": [
                        " A1 ",
                        " A1A2 ",
                        " A1A3 ",
                        " A1A2A3 "
                    ]
                },
                {
                    "index": 36,
                    "belong_page": 1,
                    "question_id": 46985,
                    "question_title": "<p>给定关系R（A1，A2，A3，A4）上的函数依赖集F={A1→A2A5，A2→A3A4，A3→A2}，函数依赖（）∈F+。</p>",
                    "question_type": 1,
                    "answer_type": 1,
                    "show_type_name": null,
                    "new_parent_id": 46985,
                    "score_rule": "",
                    "material_text": null,
                    "sort_son": "0",
                    "analyze": "<p>第2题，F+是代表，F函数依赖集的闭包，通俗一点，就是从F函数依赖集能推导出来的依赖关系。原依赖集有A3→A2，A2→A3A4，因此可以得到A3→A2A4。</p>",
                    "like": 0,
                    "answer": [
                        "C"
                    ],
                    "option": [
                        " A5→A1A2 ",
                        " A4→A1A2 ",
                        " A3→A2A4 ",
                        " A2→A1A5 "
                    ]
                },
                {
                    "index": 37,
                    "belong_page": 1,
                    "question_id": 49832,
                    "question_title": "给定关系模式&nbsp;R(U,&nbsp;F)，其中：属性集&nbsp;U={A1,&nbsp;A2,&nbsp;A3,&nbsp;A4,&nbsp;A5,&nbsp;A6}，函数依赖集&nbsp;F={A1→A2,&nbsp;A1→A3,&nbsp;A3→A4,&nbsp;A1A5→A6}。关系模式&nbsp;R&nbsp;的候选码为（请作答此空），由于&nbsp;R&nbsp;存在非主属性对码的部分函数依赖，所以&nbsp;R&nbsp;属于（&nbsp;）。",
                    "question_type": 1,
                    "answer_type": 1,
                    "show_type_name": null,
                    "new_parent_id": 49832,
                    "score_rule": "",
                    "material_text": null,
                    "sort_son": "0",
                    "analyze": "<p>先求候选码：关系模式码的确定，设关系模式R&lt;U,F&gt;</p><p>1.首先应该找出F中所有的决定因素，即找出出现在函数依赖规则中&quot;→&quot;左边的所有属性，组成集合U1.</p><p>2.再从U1中找出一个属性或属性组K，运用Armstrong公理系统及推论，使得K→U，而K的真子集K&#39;→U不成立,这样就得到了关系模式R的一个候选码，找遍U1属性的所有组合。重复此步骤，最终得到关系模式R的所有候选码。</p><p>第一范式（1NF）是指数据库表的每一列都是不可分割的基本数据项，同一列中不能有多个值，即实体中的某个属性不能有多个值或者不能有重复的属性。如果出现重复的属性，就可能需要定义一个新的实体，新的实体由重复的属性构成，新实体与原实体之间为一对多关系。在第一范式（1NF）中表的每一行只包含一个实例的信息。</p>",
                    "like": 0,
                    "answer": [
                        "C"
                    ],
                    "option": [
                        " A1A3 ",
                        " A1A4 ",
                        " A1A5 ",
                        " A1A6 "
                    ]
                },
                {
                    "index": 38,
                    "belong_page": 1,
                    "question_id": 49833,
                    "question_title": "<p>给定关系模式 R(U，F)，其中: 属性集 U={A1 ,A2,A3，A4，A5,A6}， 函数依赖集F={A1→A2， A1→A3， A3→A4， A1A5→A6}。关系模式 R 的候选码为(),由于 R 存在非主属性对码的部分函数依赖，所以 R 属于(请作答此空 ).</p>",
                    "question_type": 1,
                    "answer_type": 1,
                    "show_type_name": null,
                    "new_parent_id": 49833,
                    "score_rule": "",
                    "material_text": null,
                    "sort_son": "0",
                    "analyze": "<p>先求候选码：关系模式码的确定，设关系模式R&lt;U,F&gt;</p><p>1.首先应该找出F中所有的决定因素，即找出出现在函数依赖规则中&quot;→&quot;左边的所有属性，组成集合U1.</p><p>2.再从U1中找出一个属性或属性组K，运用Armstrong公理系统及推论，使得K→U，而K的真子集K&#39;→U不成立,这样就得到了关系模式R的一个候选码，找遍U1属性的所有组合。重复此步骤，最终得到关系模式R的所有候选码。</p><p>第一范式（1NF）是指数据库表的每一列都是不可分割的基本数据项，同一列中不能有多个值，即实体中的某个属性不能有多个值或者不能有重复的属性。如果出现重复的属性，就可能需要定义一个新的实体，新的实体由重复的属性构成，新实体与原实体之间为一对多关系。在第一范式（1NF）中表的每一行只包含一个实例的信息。</p>",
                    "like": 0,
                    "answer": [
                        "A"
                    ],
                    "option": [
                        " 1NF ",
                        " 2NF ",
                        " 3NF ",
                        " BCNF "
                    ]
                },
                {
                    "index": 39,
                    "belong_page": 1,
                    "question_id": 49834,
                    "question_title": "<p>给定元组演算表达式 R*={t│(Эu)(R(t)∧S(u)∧t[3]&lt;u[2])} ，若关系 R、s 如下图所示，则 ( )<br/><img style=\"max-width:100%;height:auto\"  src=\"http://s2.51cto.com/images/20180909/1536467855721579.jpg\" title=\"1536467855721579.jpg\" alt=\"1.jpg\"/></p>",
                    "question_type": 1,
                    "answer_type": 1,
                    "show_type_name": null,
                    "new_parent_id": 49834,
                    "score_rule": "",
                    "material_text": null,
                    "sort_son": "0",
                    "analyze": "<p>元组演算式解释：找出这样的元组t（t是R中的元组），t要满足这样的条件：存在u（u是S关系中的元组），u第2列值大于t的第3列值。</p><p>t关系中前3个元组都达到了要求，而第4个元组没有达到要求。第4个元组的第3列值是12，而u[2]的可能值为{7，5，9，10}，没谁大于12。</p>",
                    "like": 0,
                    "answer": [
                        "C"
                    ],
                    "option": [
                        " A.R*={(3,7,11),(5,9，13），（6,10,14）} ",
                        " R*={(3.7.11),(4.5.6),(5.9.13),(6,10,14)} ",
                        " R*={(1,2,3),(4,5,6),(7,8,9)} ",
                        " R*={（1,2,3）,(4,5,6),(7,8,9),(10,11,12）} "
                    ]
                },
                {
                    "index": 40,
                    "belong_page": 1,
                    "question_id": 49835,
                    "question_title": "<p>分布式数据库两阶段提交协议中的两个阶段是指（ ）。</p>",
                    "question_type": 1,
                    "answer_type": 1,
                    "show_type_name": null,
                    "new_parent_id": 49835,
                    "score_rule": "",
                    "material_text": null,
                    "sort_son": "0",
                    "analyze": "<p>二阶段提交（Two-Phase Commit）是指，在计算机网络以及数据库领域内，为了使基于分布式系统架构下的所有节点在进行事务提交时保持一致性而设计的一种算法（Algorithm）。通常，二阶段提交也被称为是一种协议(Protocol)。在分布式系统中，每个节点虽然可以知晓自己的操作时成功或者失败，却无法知道其他节点的操作的成功或失败。当一个事务跨越多个节点时，为了保持事务的ACID特性，需要引入一个作为协调者的组件来统一掌控所有节点（称作参与者）的操作结果并最终指示这些节点是否要把操作结果进行真正的提交（比如将更新后的数据写入磁盘等等）。因此，二阶段提交的算法思路可以概括为：参与者将操作成败通知协调者，再由协调者根据所有参与者的反馈情报决定各参与者是否要提交操作还是中止操作。</p><p>所谓的两个阶段是指：第一阶段：准备阶段（表决阶段）和第二阶段：提交阶段（执行阶段）。</p><p>准备阶段：事务协调者（事务管理器）给每个参与者（资源管理器）发送Prepare消息，每个参与者要么直接返回失败（如权限验证失败），要么在本地执行事务，写本地的redo和undo日志，但不提交，到达一种万事俱备，只欠东风的状态。</p><p>提交阶段：如果协调者收到了参与者的失败消息或者超时，直接给每个参与者发送回滚（Rollback）消息；否则，发送提交（Commit）消息；参与者根据协调者的指令执行提交或者回滚操作，释放所有事务处理过程中使用的锁资源。（注意:必须在最后阶段释放锁资源）。</p>",
                    "like": 0,
                    "answer": [
                        "C"
                    ],
                    "option": [
                        " 加锁阶段、解锁阶段 ",
                        " 获取阶段、运行阶段 ",
                        " 表决阶段、执行阶段 ",
                        " 扩展阶段、收缩阶段 "
                    ]
                },
                {
                    "index": 41,
                    "belong_page": 1,
                    "question_id": 49907,
                    "question_title": "<p>给定关系模式 R(A, B, C, D, E)、S(D, E, F, G) 和 π<sub>1,2,4,6</sub>(R⋈S)，经过自然连接和投影运算后的属性列数分别为（ ）。</p>",
                    "question_type": 1,
                    "answer_type": 1,
                    "show_type_name": null,
                    "new_parent_id": 49907,
                    "score_rule": "",
                    "material_text": null,
                    "sort_son": "0",
                    "analyze": "<p>进行自然连接后，结果属性集为：A,B,C,D,E,F,G，共7列。</p><p>进行投影操作后，结果为：A,B,D,F，共4列。</p>",
                    "like": 0,
                    "answer": [
                        "B"
                    ],
                    "option": [
                        " 9和4 ",
                        " 7和4 ",
                        " 9和7 ",
                        " 7和7 "
                    ]
                },
                {
                    "index": 42,
                    "belong_page": 1,
                    "question_id": 49908,
                    "question_title": "<p>给定关系R（A1，A2，A3，A4）上的函数依赖集F={A1→A2A5，A2→A3A4，A3→A2}，R的候选关键字为（ 请作答此空&nbsp;）。函数依赖（ ）<img style=\"max-width:100%;height:auto\"  src=\"http://s2.51cto.com/images/20180909/1536477482798993.jpg\" title=\"1536477482798993.jpg\" alt=\"1.jpg\"/>。</p>",
                    "question_type": 1,
                    "answer_type": 1,
                    "show_type_name": null,
                    "new_parent_id": 49908,
                    "score_rule": "",
                    "material_text": null,
                    "sort_son": "0",
                    "analyze": "<p>通过A1能推导出关系R的全部属性，因此关键字为A1。</p>",
                    "like": 0,
                    "answer": [
                        "A"
                    ],
                    "option": [
                        " A1 ",
                        " A1A2 ",
                        " A1A3 ",
                        " A1A2A3 "
                    ]
                },
                {
                    "index": 43,
                    "belong_page": 1,
                    "question_id": 49909,
                    "question_title": "<p>给定关系R（A1，A2，A3，A4）上的函数依赖集F={A1→A2A5，A2→A3A4，A3→A2}，R的候选关键字为（ ）。函数依赖（请作答此空 ）<img style=\"max-width:100%;height:auto\"  src=\"http://s2.51cto.com/images/20180909/1536477509254112.jpg\" title=\"1536477509254112.jpg\" alt=\"1.jpg\"/>。</p>",
                    "question_type": 1,
                    "answer_type": 1,
                    "show_type_name": null,
                    "new_parent_id": 49909,
                    "score_rule": "",
                    "material_text": null,
                    "sort_son": "0",
                    "analyze": "<p>F+是代表，F函数依赖集的闭包，通俗一点，就是从F函数依赖集能推导出来的依赖关系。原依赖集有A3→A2，A2→A3A4，因此可以得到A3→A2A4。</p>",
                    "like": 0,
                    "answer": [
                        "C"
                    ],
                    "option": [
                        " A5→A1A2 ",
                        " A4→A1A2 ",
                        " A3→A2A4 ",
                        " A2→A1A5 "
                    ]
                },
                {
                    "index": 44,
                    "belong_page": 1,
                    "question_id": 50872,
                    "question_title": "<p>设关系模式R(U，F)，其中U为属性集，F是U上的一组函数依赖，那么函数依赖的公理系统(Armstrong公理系统)中的合并规则是指（）为F所蕴涵。<br/><img style=\"max-width:100%;height:auto\"  src=\"http://s2.51cto.com/images/20180920/1537433258543919.png\" title=\"1537433258543919.png\" alt=\"QQ截图20180920164733.png\"/></p>",
                    "question_type": 1,
                    "answer_type": 1,
                    "show_type_name": null,
                    "new_parent_id": 50872,
                    "score_rule": "",
                    "material_text": null,
                    "sort_son": "0",
                    "analyze": "<p><img style=\"max-width:100%;height:auto\"  src=\"http://s2.51cto.com/images/20180920/1537433292779450.png\" title=\"1537433292779450.png\" alt=\"QQ截图20180920164806.png\"/></p>",
                    "like": 0,
                    "answer": [
                        "C"
                    ],
                    "option": [
                        " A<br/> ",
                        " B<br/> ",
                        " C<br/> ",
                        " D<br/> "
                    ]
                },
                {
                    "index": 45,
                    "belong_page": 1,
                    "question_id": 54216,
                    "question_title": "<p>商业智能将企业中现有的数据转化为知识，帮助企业做出明智的业务经营决策，包括数据预处理、建立数据模型、数据分析及数据展现 4 个阶段;其主要应用的 3 个关键技术是（ ）。</p>",
                    "question_type": 1,
                    "answer_type": 1,
                    "show_type_name": null,
                    "new_parent_id": 54216,
                    "score_rule": "",
                    "material_text": null,
                    "sort_son": "0",
                    "analyze": "<p>商业智能使用数据仓库、联机分析处理（OLAP）和数据挖掘技术。</p>",
                    "like": 0,
                    "answer": [
                        "A"
                    ],
                    "option": [
                        " 数据仓库/OLAP/数据挖掘 ",
                        " ETL/OLAP/数据展现 ",
                        " 数据仓库/OLTP/OLAP ",
                        " 数据集市/数据挖掘/数据质量标准 "
                    ]
                },
                {
                    "index": 46,
                    "belong_page": 1,
                    "question_id": 54243,
                    "question_title": "<p>在某企业的营销管理系统设计阶段，属性&quot;员工&quot;在考勤管理子系统中被称为&quot;员工&quot;，而在档案管理子系统中被称为&quot;职工&quot;，这类冲突称为（ &nbsp;）冲突。</p>",
                    "question_type": 1,
                    "answer_type": 1,
                    "show_type_name": null,
                    "new_parent_id": 54243,
                    "score_rule": "",
                    "material_text": null,
                    "sort_son": "0",
                    "analyze": "<p>在本题中显然是存在命名冲突，同一个实体在同系统中存在不同的命名，这是不被允许的。</p>",
                    "like": 0,
                    "answer": [
                        "D"
                    ],
                    "option": [
                        " 语义 ",
                        " 结构 ",
                        " 属性 ",
                        " 命名 "
                    ]
                },
                {
                    "index": 47,
                    "belong_page": 1,
                    "question_id": 54244,
                    "question_title": "<p>若对关系R（A，B，C，D）进行π1.3（R）运算，则该关系运算与（52请作答此空）等价，表示（&nbsp; &nbsp;53&nbsp; 此空不作答 &nbsp;）。</p>",
                    "question_type": 1,
                    "answer_type": 1,
                    "show_type_name": null,
                    "new_parent_id": 54244,
                    "score_rule": "",
                    "material_text": null,
                    "sort_son": "0",
                    "analyze": "<p>本题要求作答“52”。<br/>投影运算是从一个关系里面抽取指明的属性（列）组成一个新的关系，这种运算是一种对列进行操作的运算。本题中π1.3（R）的含义就是从关系R中，选取第1列（A）和第3列（C）组成一个新的关系模式，因此52题答案选C，而53题的答案选D。</p>",
                    "like": 0,
                    "answer": [
                        "C"
                    ],
                    "option": [
                        " πA=1，C=3（R） ",
                        " πA=1<img style=\"max-width:100%;height:auto\" src=\"https://s1.51ctocdn.cn//images/20181012/1539329979796904.jpg\" title=\"1539329979796904.jpg\" alt=\"1.jpg\"/>C=3（R） ",
                        " πA，C（R） ",
                        " πA=1<img style=\"max-width:100%;height:auto\" src=\"https://s1.51ctocdn.cn//images/20181012/1539329986481677.jpg\" title=\"1539329986481677.jpg\" alt=\"2.jpg\"/>C=3（R） "
                    ]
                },
                {
                    "index": 48,
                    "belong_page": 1,
                    "question_id": 54245,
                    "question_title": "<p>若对关系R（A，B，C，D）进行π1.3（R）运算，则该关系运算与（ ）等价，表示（请作答此空）。</p>",
                    "question_type": 1,
                    "answer_type": 1,
                    "show_type_name": null,
                    "new_parent_id": 54245,
                    "score_rule": "",
                    "material_text": null,
                    "sort_son": "0",
                    "analyze": "<p>投影运算是从一个关系里面抽取指明的属性（列）组成一个新的关系，这种运算是一种对列进行操作的运算。本题中π1.3（R）的含义就是从关系R中，选取第1列（A）和第3列（C）组成一个新的关系模式，因此52题答案选C，而53题的答案选D。</p>",
                    "like": 0,
                    "answer": [
                        "D"
                    ],
                    "option": [
                        " 属性A和C的值分别等于1和3的元组为结果集 ",
                        " 属性A和C的值分别等于1和3的两列为结果集 ",
                        " 对R关系进行A=1、C=3的投影运算 ",
                        " 对R关系进行属性A和C的投影运算 "
                    ]
                },
                {
                    "index": 49,
                    "belong_page": 1,
                    "question_id": 54246,
                    "question_title": "<p>设有关系模式R (课程，教师，学生，成绩，时间，教室），其中函数依赖集F如下：<br/>F=｛课程→→教师，（学生，课程）→成绩，（时间，教室）→课程，<br/>（时间，教师）→教室，（时间，学生）→教室｝<br/>关系模式R的一个主键是（请作答此空），R规范化程度最高达到（ &nbsp;）。若将关系模式R分解为3个关系模式R1（课程，教师）、R2（学生，课程，成绩）、R3（学生，时间，教室，课程），其中R2的规范化程度最高达到（ &nbsp;）。</p>",
                    "question_type": 1,
                    "answer_type": 1,
                    "show_type_name": null,
                    "new_parent_id": 54246,
                    "score_rule": "",
                    "material_text": null,
                    "sort_son": "0",
                    "analyze": "<p>通过主键应该是可以推导出关系中的所有其它属性的，那么通过函数依赖集F我们可以知道，通过（时间，学生）可以推导出教室，然后通过（时间，教室）可以推导出课程，通过（学生，课程）又能推导出成绩，通过课程又可能推导出教师，所有其它属性都可以被推导出来，因此（时间，学生）是主键。<br/>从函数依赖集F我们可以看到，没有对主键中单个属性的依赖关系，所有不存在非主属性对码的部分依赖，但存在传递依赖，因此关系模式只满足第2范式。<br/>分解后的R2只包含了学生，课程及成绩三个属性，它们之间的依赖关系是（学生，课程）→成绩，那么主键应该是（学生，课程），这里不存在部分依赖，也不存在传递依赖，因此满足BC范式。</p>",
                    "like": 0,
                    "answer": [
                        "D"
                    ],
                    "option": [
                        " （学生，课程） ",
                        " （时间，教室） ",
                        " （时间，教师） ",
                        " （时间，学生） "
                    ]
                },
                {
                    "index": 50,
                    "belong_page": 1,
                    "question_id": 54248,
                    "question_title": "<p>设有关系模式 R(课程, 教师, 学生, 成绩, 时间, 教室)，其中函数依赖集 F如下：<br/>F={课程→教师, (学生, 课程)→成绩, (时间, 教室)→课程, (时间, 教师)→教室, (时间, 学生)→教室}<br/>关系模式 R 的一个主键是（ ），R 规范化程度最高达到（请作答此空）。<br/>若将关系模式 R 分解为 3 个关系模式 R1(课程, 教师)、R2(学生, 课程, 成绩)、R3(学生, 时间, 教室, 课程)，其中 R2 的规范化程度最高达到（ ）。</p>",
                    "question_type": 1,
                    "answer_type": 1,
                    "show_type_name": null,
                    "new_parent_id": 54248,
                    "score_rule": "",
                    "material_text": null,
                    "sort_son": "0",
                    "analyze": "<p>通过主键应该是可以推导出关系中的所有其它属性的，那么通过函数依赖集 F 我们可以知道，通过（时间，学生）可以推导出教室，然后通过（时间，教室）可以推导出课程，通过（学生，课程）又能推导出成绩，通过课程又可能推导出教师，所有其它属性都可以被推导出来，因此（时间，学生）是主键。<br/>从函数依赖集F我们可以看到，没有对主键中单个属性的依赖关系，所有不存在非主属性对码的部分依赖，但存在传递依赖，因此关系模式 R 只满足第 2 范式。<br/>分解后的 R2 只包含了学生，课程及成绩三个属性，它们之间的依赖关系是（学生，课程）→成绩，那么主键应该是（学生，课程），这里不存在部分依赖，也不存在传递依赖，因此满足 BC 范式。</p>",
                    "like": 0,
                    "answer": [
                        "B"
                    ],
                    "option": [
                        " 1NF ",
                        " 2NF ",
                        " 3NF ",
                        " BCNF "
                    ]
                },
                {
                    "index": 51,
                    "belong_page": 1,
                    "question_id": 54249,
                    "question_title": "<p>设有关系模式R (课程，教师，学生，成绩，时间，教室），其中函数依赖集F如下：<br/>F=｛课程→→教师，（学生，课程）→成绩，（时间，教室）→课程，<br/>（时间，教师）→教室，（时间，学生）→教室｝<br/>关系模式R的一个主键是（ ），R规范化程度最高达到（ ）。若将关系模式R分解为3个关系模式R1（课程，教师）、R2（学生，课程，成绩）、R3（学生，时间，教室，课程），其中R2的规范化程度最高达到（请作答此空）。</p>",
                    "question_type": 1,
                    "answer_type": 1,
                    "show_type_name": null,
                    "new_parent_id": 54249,
                    "score_rule": "",
                    "material_text": null,
                    "sort_son": "0",
                    "analyze": "<p>通过主键应该是可以推导出关系中的所有其它属性的，那么通过函数依赖集F我们可以知道，通过（时间，学生）可以推导出教室，然后通过（时间，教室）可以推导出课程，通过（学生，课程）又能推导出成绩，通过课程又可能推导出教师，所有其它属性都可以被推导出来，因此（时间，学生）是主键。<br/>从函数依赖集F我们可以看到，没有对主键中单个属性的依赖关系，所有不存在非主属性对码的部分依赖，但存在传递依赖，因此关系模式只满足第2范式。<br/>分解后的R2只包含了学生，课程及成绩三个属性，它们之间的依赖关系是（学生，课程）→成绩，那么主键应该是（学生，课程），这里不存在部分依赖，也不存在传递依赖，因此满足BC范式。</p>",
                    "like": 0,
                    "answer": [
                        "C"
                    ],
                    "option": [
                        " 2NF ",
                        " 3NF ",
                        " BCNF ",
                        " 4NF "
                    ]
                },
                {
                    "index": 52,
                    "belong_page": 1,
                    "question_id": 54267,
                    "question_title": "<p>The data（ &nbsp;）includes the function of updating data on a database， and retrieving data from a database.</p>",
                    "question_type": 1,
                    "answer_type": 1,
                    "show_type_name": null,
                    "new_parent_id": 54267,
                    "score_rule": "",
                    "material_text": null,
                    "sort_son": "0",
                    "analyze": "<p>数据管理包括更新数据库中的数据，从数据库中检索数据等功能。</p>",
                    "like": 0,
                    "answer": [
                        "A"
                    ],
                    "option": [
                        " management ",
                        " storage ",
                        " analysis ",
                        " communication "
                    ]
                },
                {
                    "index": 53,
                    "belong_page": 1,
                    "question_id": 54278,
                    "question_title": "<p>在数据库设计的需求分析阶段应完成包括（ &nbsp;）在内的文档。</p>",
                    "question_type": 1,
                    "answer_type": 1,
                    "show_type_name": null,
                    "new_parent_id": 54278,
                    "score_rule": "",
                    "material_text": null,
                    "sort_son": "0",
                    "analyze": "<p>需求分析阶段的任务是对现实世界要处理的对象（组织、部门和企业等）进行详细调查，在了解现行系统的概况，确定新系统功能的过程中收集支持系统目标的基础数据及处理方法。需求分析是在用户调查的基础上，通过分析，逐步明确用户对系统的需求。在需求分析阶段应完成的文档是数据字典和数据流图。</p>",
                    "like": 0,
                    "answer": [
                        "C"
                    ],
                    "option": [
                        " E-R图 ",
                        " 关系模式 ",
                        " 数据字典和数据流图 ",
                        " 任务书和设计方案 "
                    ]
                },
                {
                    "index": 54,
                    "belong_page": 1,
                    "question_id": 54284,
                    "question_title": "<p><br/></p><p>某数据库中有员工关系E（员工号，姓名，部门，职称，月薪）；产品关系P（产品号，产品名称，型号，尺寸，颜色）；仓库关系W（仓库号，仓库名称，地址，负责人）；库存关系I（仓库号，产品号，产品数量）。<br/>a. 若数据库设计中要求：<br/>① 仓库关系W中的&quot;负责人&quot;引用员工关系的员工号<br/>② 库存关系I中的&quot;仓库号，产品号&quot;惟一标识I中的每一个记录<br/>③ 员工关系E中的职称为&quot;工程师&quot;的月薪不能低于3500元<br/>则①②③依次要满足的完整性约束是（请作答此空）。<br/>b. 若需得到每种产品的名称和该产品的总库存量，则对应的查询语句为：</p><pre class=\"brush:html;toolbar:false\">SELELCT&nbsp;产品名称，&nbsp;SUM(产品数量\nFROM&nbsp;P，&nbsp;I\nWHERE&nbsp;P.产品号&nbsp;=&nbsp;I.产品号（&nbsp;&nbsp;）;</pre><p><br/></p>",
                    "question_type": 1,
                    "answer_type": 1,
                    "show_type_name": null,
                    "new_parent_id": 54284,
                    "score_rule": "",
                    "material_text": null,
                    "sort_son": "0",
                    "analyze": "<p>关系模型的完整性规则是对关系的某种约束条件。关系模型中可以有三类完整性约束：实体完整性、参照完整性和用户定义的完整性。实体完整性规定基本关系的主属性不能取空值。由于①仓库关系W中的&quot;负责人&quot;引用员工关系的员工号，所以应满足参照完整性约束；② 库存关系I中的&quot;仓库号，产品号&quot;惟一标识I中的每一个记录，所以应满足实体完整性约束；③ 职称为&quot;工程师&quot;的月薪不能低于3500元，是针对某一具体关系数据库的约束条件，它反映某一具体应用所涉及的数据必须满足的语义要求，所以应满足用户定义完整性约束。因此，试题（1）的正确答案为B。<br/>SQL查询是数据库中非常重要的内容。该SQL查询要求对查询结果进行分组，即具有相同名称的产品的元组为一组，然后计算每组的库存数量。由此可排除A、B和D，所以试题（2）正确答案为C。</p>",
                    "like": 0,
                    "answer": [
                        "B"
                    ],
                    "option": [
                        " 实体完整性、参照完整性、用户定义完整性 ",
                        " 参照完整性、实体完整性、用户定义完整性 ",
                        " 用户定义完整性、实体完整性、参照完整性 ",
                        " 实体完整性、用户定义完整性、参照完整性 "
                    ]
                },
                {
                    "index": 55,
                    "belong_page": 1,
                    "question_id": 54285,
                    "question_title": "<p>某数据库中有员工关系E（员工号，姓名，部门，职称，月薪）；产品关系P（产品号，产品名称，型号，尺寸，颜色）；仓库关系W（仓库号，仓库名称，地址，负责人）；库存关系I（仓库号，产品号，产品数量）。<br/>a. 若数据库设计中要求：<br/>① 仓库关系W中的&quot;负责人&quot;引用员工关系的员工号<br/>② 库存关系I中的&quot;仓库号，产品号&quot;惟一标识I中的每一个记录<br/>③ 员工关系E中的职称为&quot;工程师&quot;的月薪不能低于3500元<br/>则①②③依次要满足的完整性约束是（ ）。<br/>b. 若需得到每种产品的名称和该产品的总库存量，则对应的查询语句为：</p><pre class=\"brush:html;toolbar:false\">SELELCT&nbsp;产品名称，&nbsp;SUM(产品数量\nFROM&nbsp;P，&nbsp;I\nWHERE&nbsp;P.产品号&nbsp;=&nbsp;I.产品号（请作答此空）;</pre><p></p>",
                    "question_type": 1,
                    "answer_type": 1,
                    "show_type_name": null,
                    "new_parent_id": 54285,
                    "score_rule": "",
                    "material_text": null,
                    "sort_son": "0",
                    "analyze": "<p>关系模型的完整性规则是对关系的某种约束条件。关系模型中可以有三类完整性约束：实体完整性、参照完整性和用户定义的完整性。实体完整性规定基本关系的主属性不能取空值。由于①仓库关系W中的&quot;负责人&quot;引用员工关系的员工号，所以应满足参照完整性约束；② 库存关系I中的&quot;仓库号，产品号&quot;惟一标识I中的每一个记录，所以应满足实体完整性约束；③ 职称为&quot;工程师&quot;的月薪不能低于3500元，是针对某一具体关系数据库的约束条件，它反映某一具体应用所涉及的数据必须满足的语义要求，所以应满足用户定义完整性约束。因此，试题（1）的正确答案为B。<br/>SQL查询是数据库中非常重要的内容。该SQL查询要求对查询结果进行分组，即具有相同名称的产品的元组为一组，然后计算每组的库存数量。由此可排除A、B和D，所以试题（2）正确答案为C。</p>",
                    "like": 0,
                    "answer": [
                        "C"
                    ],
                    "option": [
                        " ORDER BY产品名称 ",
                        " ORDER BY 产品数量 ",
                        " GROUP BY产品名称 ",
                        " GROUP BY 产品数量 "
                    ]
                },
                {
                    "index": 56,
                    "belong_page": 1,
                    "question_id": 54290,
                    "question_title": "<p>某公司销售数据库的商品、仓库关系模式及函数依赖集F1、F2如下：<br/>商品（商品号，商品名称，生产商，单价），F1={商品号→商品名称，商品号→生产商，商品号→单价}，商品关系的主键是 （请作答此空）。仓库（仓库号，地址，电话，商品号，库存量），F2={仓库号→（地址，电话），（仓库号，商品号）→库存量}。仓库关系的主键是 （ &nbsp;），外键是（ &nbsp;）。<br/>仓库关系模式（ &nbsp;），为了解决这一问题，需要将仓库关系分解为（ &nbsp;）。</p>",
                    "question_type": 1,
                    "answer_type": 1,
                    "show_type_name": null,
                    "new_parent_id": 54290,
                    "score_rule": "",
                    "material_text": null,
                    "sort_son": "0",
                    "analyze": "<p>本题考查应试者对关系模式中主键、外键和模式分解及相关知识的掌握程度。<br/>从商品关系的函数依赖集F1可以导出商品号决定商品关系的全属性，所以商品号是商品关系的主键。<br/>从仓库关系的函数依赖集F2可以导出（仓库号，商品号）决定仓库关系的全属性，所以仓库关系的主键是（仓库号，商品号）。又由于商品号是商品关系的主键，故商品号是仓库关系的外键。<br/>仓库关系存在冗余、插入异常和删除异常，以及修改操作的不一致。例如，仓库号为&quot;12&quot;的商品有3种，其地址就要重复3次，如下表所示，故仓库关系存在冗余<br/><img style=\"max-width:100%;height:auto\"  src=\"https://s1.51ctocdn.cn//images/20181012/1539332103128110.jpg\" title=\"1539332103128110.jpg\" alt=\"1.jpg\"/><br/></p>",
                    "like": 0,
                    "answer": [
                        "A"
                    ],
                    "option": [
                        " 商品号 ",
                        " 商品号，商品名称 ",
                        " 商品号，生产商 ",
                        " 商品名称，生产商 "
                    ]
                },
                {
                    "index": 57,
                    "belong_page": 1,
                    "question_id": 54292,
                    "question_title": "<p>某公司销售数据库的商品、仓库关系模式及函数依赖集F1、F2如下：<br/>商品（商品号，商品名称，生产商，单价），F1={商品号→商品名称，商品号→生产商，商品号→单价）}，商品关系的主键是 &nbsp;（ ）。仓库（仓库号，地址，电话，商品号，库存量），F2={仓库号→（地址，电话），（仓库号，商品号）→库存量}。仓库关系的主键是（请作答此空），外键是（ &nbsp;）。<br/>仓库关系模式（ &nbsp;），为了解决这一问题，需要将仓库关系分解为（ &nbsp;）。</p>",
                    "question_type": 1,
                    "answer_type": 1,
                    "show_type_name": null,
                    "new_parent_id": 54292,
                    "score_rule": "",
                    "material_text": null,
                    "sort_son": "0",
                    "analyze": "<p>本题考查应试者对关系模式中主键、外键和模式分解及相关知识的掌握程度。<br/>从商品关系的函数依赖集F1可以导出商品号决定商品关系的全属性，所以商品号是商品关系的主键。<br/>从仓库关系的函数依赖集F2可以导出（仓库号，商品号）决定仓库关系的全属性，所以仓库关系的主键是（仓库号，商品号）。又由于商品号是商品关系的主键，故商品号是仓库关系的外键。<br/>仓库关系存在冗余、插入异常和删除异常，以及修改操作的不一致。例如，仓库号为&quot;12&quot;的商品有3种，其地址就要重复3次，如下表所示，故仓库关系存在冗余<br/><img style=\"max-width:100%;height:auto\"  src=\"http://s2.51cto.com/images/20181012/1539332150844576.jpg\" title=\"1539332150844576.jpg\" alt=\"1.jpg\"/><br/></p>",
                    "like": 0,
                    "answer": [
                        "B"
                    ],
                    "option": [
                        " 仓库号 ",
                        " 仓库号，商品号 ",
                        " 仓库号，电话 ",
                        " 地址，电话 "
                    ]
                },
                {
                    "index": 58,
                    "belong_page": 1,
                    "question_id": 54293,
                    "question_title": "<p>某公司销售数据库的商品、仓库关系模式及函数依赖集F1、F2如下：<br/>商品（商品号，商品名称，生产商，单价），F1={商品号→商品名称，商品号→生产商，商品号→单价）}，商品关系的主键是 &nbsp;（ ）。仓库（仓库号，地址，电话，商品号，库存量），F2={仓库号→（地址，电话），（仓库号，商品号）→库存量}。仓库关系的主键是（ ），外键是（请作答此空）。<br/>仓库关系模式（ &nbsp;），为了解决这一问题，需要将仓库关系分解为（ &nbsp;）。</p>",
                    "question_type": 1,
                    "answer_type": 1,
                    "show_type_name": null,
                    "new_parent_id": 54293,
                    "score_rule": "",
                    "material_text": null,
                    "sort_son": "0",
                    "analyze": "<p>本题考查应试者对关系模式中主键、外键和模式分解及相关知识的掌握程度。<br/>从商品关系的函数依赖集F1可以导出商品号决定商品关系的全属性，所以商品号是商品关系的主键。<br/>从仓库关系的函数依赖集F2可以导出（仓库号，商品号）决定仓库关系的全属性，所以仓库关系的主键是（仓库号，商品号）。又由于商品号是商品关系的主键，故商品号是仓库关系的外键。<br/>仓库关系存在冗余、插入异常和删除异常，以及修改操作的不一致。例如，仓库号为&quot;12&quot;的商品有3种，其地址就要重复3次，如下表所示，故仓库关系存在冗余<br/><img style=\"max-width:100%;height:auto\"  src=\"http://s2.51cto.com/images/20181012/1539332205612922.jpg\" title=\"1539332205612922.jpg\" alt=\"1.jpg\"/><br/></p>",
                    "like": 0,
                    "answer": [
                        "D"
                    ],
                    "option": [
                        " 仓库号 ",
                        " 地址 ",
                        " 电话 ",
                        " 商品号 "
                    ]
                },
                {
                    "index": 59,
                    "belong_page": 1,
                    "question_id": 54294,
                    "question_title": "<p>某公司销售数据库的商品、仓库关系模式及函数依赖集F1、F2如下：<br/>商品（商品号，商品名称，生产商，单价），F1={商品号→商品名称，商品号→生产商，商品号→单价）}，商品关系的主键是 &nbsp;（ ）。仓库（仓库号，地址，电话，商品号，库存量），F2={仓库号→（地址，电话），（仓库号，商品号）→库存量}。仓库关系的主键是（ ），外键是（ ）。<br/>仓库关系模式（请作答此空），为了解决这一问题，需要将仓库关系分解为（ &nbsp;）。</p>",
                    "question_type": 1,
                    "answer_type": 1,
                    "show_type_name": null,
                    "new_parent_id": 54294,
                    "score_rule": "",
                    "material_text": null,
                    "sort_son": "0",
                    "analyze": "<p>本题考查应试者对关系模式中主键、外键和模式分解及相关知识的掌握程度。<br/>从商品关系的函数依赖集F1可以导出商品号决定商品关系的全属性，所以商品号是商品关系的主键。<br/>从仓库关系的函数依赖集F2可以导出（仓库号，商品号）决定仓库关系的全属性，所以仓库关系的主键是（仓库号，商品号）。又由于商品号是商品关系的主键，故商品号是仓库关系的外键。<br/>仓库关系存在冗余、插入异常和删除异常，以及修改操作的不一致。例如，仓库号为&quot;12&quot;的商品有3种，其地址就要重复3次，如下表所示，故仓库关系存在冗余<br/><img style=\"max-width:100%;height:auto\"  src=\"http://s2.51cto.com/images/20181012/1539332258526970.jpg\" title=\"1539332258526970.jpg\" alt=\"1.jpg\"/><br/><br/></p>",
                    "like": 0,
                    "answer": [
                        "A"
                    ],
                    "option": [
                        " 存在冗余、插入异常和删除异常，以及修改操作的不一致 ",
                        " 不存在冗余，但存在插入异常和删除异常 ",
                        " 不存在修改操作的不一致，但存在冗余和插入异常 ",
                        " 不存在冗余、插入异常，但存在删除异常和修改操作的不一致 "
                    ]
                },
                {
                    "index": 60,
                    "belong_page": 1,
                    "question_id": 54296,
                    "question_title": "<p>某公司销售数据库的商品、仓库关系模式及函数依赖集F1、F2如下：<br/>商品（商品号，商品名称，生产商，单价），F1={商品号→商品名称，商品号→生产商，商品号→单价）}，商品关系的主键是 &nbsp;（ ）。仓库（仓库号，地址，电话，商品号，库存量），F2={仓库号→（地址，电话），（仓库号，商品号）→库存量}。仓库关系的主键是（ ），外键是（ ）。<br/>仓库关系模式（ ），为了解决这一问题，需要将仓库关系分解为（请作答此空）。</p>",
                    "question_type": 1,
                    "answer_type": 1,
                    "show_type_name": null,
                    "new_parent_id": 54296,
                    "score_rule": "",
                    "material_text": null,
                    "sort_son": "0",
                    "analyze": "<p>本题正确的答案D。为了解决仓库关系模式存在的问题需要进行模式分解，其中，选项A分解存在的问题是仓库2不属于第三范式，因为存在非主属性对码的部分函数依赖，即仓库号→电话。选项B分解存在的问题是分解有损连接，即分解的新关系模式仓库1和仓库2无法恢复到原关系。选项C分解存在的问题与A类同，分析略。<br/>选项D分解是即保持函数依赖，又无损连接，分解的结果如下：<br/><img style=\"max-width:100%;height:auto\"  src=\"http://s2.51cto.com/images/20181012/1539332332824104.jpg\" title=\"1539332332824104.jpg\" alt=\"2.jpg\"/></p>",
                    "like": 0,
                    "answer": [
                        "D"
                    ],
                    "option": [
                        " 仓库1（仓库号，地址）和仓库2（仓库号，电话，商品号，库存量） ",
                        " 仓库1（仓库号，地址，电话）和仓库2（商品号，库存量） ",
                        " 仓库1（仓库号，电话）和仓库2（仓库号，地址，商品号，库存量） ",
                        " 仓库1（仓库号，地址，电话）和仓库2（仓库号，商品号，库存量） "
                    ]
                },
                {
                    "index": 61,
                    "belong_page": 1,
                    "question_id": 54297,
                    "question_title": "<p>若对关系R（A，B，C，D）、S（C，D，E）进行π1,2,3,4,7(σ3=5∧4=6(R×S))运算，则该关系代数表达式与 （ &nbsp;） 是等价的。</p>",
                    "question_type": 1,
                    "answer_type": 1,
                    "show_type_name": null,
                    "new_parent_id": 54297,
                    "score_rule": "",
                    "material_text": null,
                    "sort_son": "0",
                    "analyze": "<p>本题考查关系代数运算方面的基础知识。<br/>自然联接 是一种特殊的等值连接，它要求两个关系中进行比较的分量必须是相同的属性组，并且在结果集中将重复属性列去掉。本试题中<img style=\"max-width:100%;height:auto\"  src=\"http://s2.51cto.com/images/20181012/1539332419180761.jpg\" title=\"1539332419180761.jpg\" alt=\"1.jpg\"/>的含义是R×S后，选取R和S关系中<img style=\"max-width:100%;height:auto\"  src=\"http://s2.51cto.com/images/20181012/1539332432685452.jpg\" title=\"1539332432685452.jpg\" alt=\"1.jpg\"/>的元组，再进行R.A、R.B、R.C、R.D和S.E 的投影关系运算。可见该关系运算表达式与 &nbsp;<img style=\"max-width:100%;height:auto\"  src=\"http://s2.51cto.com/images/20181012/1539332442787852.jpg\" title=\"1539332442787852.jpg\" alt=\"1.jpg\"/>是等价的。</p>",
                    "like": 0,
                    "answer": [
                        "A"
                    ],
                    "option": [
                        " <img style=\"max-width:100%;height:auto\" src=\"http://s2.51cto.com/images/20181012/1539332364937127.jpg\" title=\"1539332364937127.jpg\" alt=\"1.jpg\"/> ",
                        " <img style=\"max-width:100%;height:auto\" src=\"http://s2.51cto.com/images/20181012/1539332386248099.jpg\" title=\"1539332386248099.jpg\" alt=\"2.jpg\"/> ",
                        " <img style=\"max-width:100%;height:auto\" src=\"http://s2.51cto.com/images/20181012/1539332390196173.jpg\" title=\"1539332390196173.jpg\" alt=\"3.jpg\"/> ",
                        " <img style=\"max-width:100%;height:auto\" src=\"http://s2.51cto.com/images/20181012/1539332393198551.jpg\" title=\"1539332393198551.jpg\" alt=\"4.jpg\"/> "
                    ]
                },
                {
                    "index": 62,
                    "belong_page": 1,
                    "question_id": 54342,
                    "question_title": "<p>以下关于数据处理的叙述中，不正确的是（ &nbsp;）。</p>",
                    "question_type": 1,
                    "answer_type": 1,
                    "show_type_name": null,
                    "new_parent_id": 54342,
                    "score_rule": "",
                    "material_text": null,
                    "sort_son": "0",
                    "analyze": "<p>数据是为应用服务的。数据解释的重要性最近得到重视，因为不同立场的人对同－批数据进行了不同的解释，会产生不同的效果即使数据是正确的，有的人只利用其中 &nbsp;一部分数据进行了解释；有的人利用特殊的坐标系统对数据进行图示，给人以错觉；有的人用平均数掩盖了数据中较大的差异。因此，科学合理地解释数据是数据处理工作者 应具有的基本素质。<br/>大批数据处理的过程中，出现数据问题是很常见的。数据问题包括：数据的错误、数据的多余或遗漏、数据的延误、数据的混乱、对数据的非法访问（窃取或篡改）等。 &nbsp; &nbsp;数据处理技术市场包括了数据收集、输入、编辑、存储、分类、加工、统计、传输、检索、输出等各个环节采用的技术。办公软件只是简单数据处理的常用工具，许多数据统计软件、多媒体演示系统、数据挖掘软件、联机数据处理系统、商业智能软件、决策支持系统等具有更强的功能。计算机最广泛的应用中数据处理，计算机应用基础的主要内容不应该只是强调办公软件的使用方法，应该更强调数据处理各个阶段所采用的基本方法。正如农业基础不能只强调农业工具的使用。不同的观念和视野将引发教学内容的变革。<br/>数据也是有生命周期的，数据从产生、存储、变更、散布、使用、备份、恢复，直到删除，不同阶段具有不同的使用频率和使用价值。现代企业的海策数据右储系统需要基于数据生命周期进行备份和处理，包括对数据安全的设计。现在，数据生命周期管理和信息生命周期管理是非常活跃的应用领域。</p>",
                    "like": 0,
                    "answer": [
                        "C"
                    ],
                    "option": [
                        " 对正确的数据也可能做出错误解释 ",
                        " 软件会有故障，数据也会现问题 ",
                        " 数据处理技术主要指办公软件的使用方法 ",
                        " 也有生命周期 "
                    ]
                },
                {
                    "index": 63,
                    "belong_page": 1,
                    "question_id": 63590,
                    "question_title": "<p>给定关系R(A,B,C,D,E)与S(A,B,C,F,G)，那么与表达式<img style=\"max-width:100%;height:auto\"  src=\"http://s2.51cto.com/images/20181127/1543309956828085.jpg\" title=\"1543309956828085.jpg\" alt=\"1.jpg\"/>等价的SQL语句如下：select (请作答此空) from R, S where (　);</p>",
                    "question_type": 1,
                    "answer_type": 1,
                    "show_type_name": null,
                    "new_parent_id": 63590,
                    "score_rule": "",
                    "material_text": null,
                    "sort_son": "0",
                    "analyze": "<p>本题考查关系代数运算与SQL语言的对应关系。注意本题中R与S是做自然联接操作，操作时会将R与S中相同字段名做等值联接，并将结果集去重复。所以R与S自然联接后的结果包括以下属性：</p><p>R.A，R.B，R.C，D，E，F，G。</p><p>关系代数选择条件为“1&lt;6”，即R.A&lt;F。</p><p>关系代数投影操作条件为“1,2,4,6,7”，对应的属性为：R.A，R.B，D，F，G。</p>",
                    "like": 0,
                    "answer": [
                        "B"
                    ],
                    "option": [
                        " R.A，R.B，R.E，S.C，G ",
                        " R.A，R.B，D，F，G ",
                        " R.A，R.B，R.D，S.C，F ",
                        " R.A，R.B，R.D，S.C，G "
                    ]
                },
                {
                    "index": 64,
                    "belong_page": 1,
                    "question_id": 63591,
                    "question_title": "<p>给定关系R(A,B,C,D,E)与S(A,B,C,F,G)，那么与表达式<img style=\"max-width:100%;height:auto\"  src=\"http://s2.51cto.com/images/20181127/1543309989426596.jpg\" title=\"1543309989426596.jpg\" alt=\"1.jpg\"/>等价的SQL语句如下：select (　) from R, S where (请作答此空);</p>",
                    "question_type": 1,
                    "answer_type": 1,
                    "show_type_name": null,
                    "new_parent_id": 63591,
                    "score_rule": "",
                    "material_text": null,
                    "sort_son": "0",
                    "analyze": "<p>本题考查关系代数运算与SQL语言的对应关系。注意本题中R与S是做自然联接操作，操作时会将R与S中相同字段名做等值联接，并将结果集去重复。所以R与S自然联接后的结果包括以下属性：</p><p>R.A，R.B，R.C，D，E，F，G。</p><p>关系代数选择条件为“1&lt;6”，即R.A&lt;F。</p><p>关系代数投影操作条件为“1,2,4,6,7”，对应的属性为：R.A，R.B，D，F，G。</p>",
                    "like": 0,
                    "answer": [
                        "C"
                    ],
                    "option": [
                        " R.A=S.A OR R.B=S.B OR R.C=S.C OR R.A&lt;S.F ",
                        " R.A=S.A OR R.B=S.B OR R.C=S.C OR R.A&lt;S.B ",
                        " R.A=S.A AND R.B=S.B AND R.C=S.C AND R.A&lt;S.F ",
                        " R.A=S.A AND R.B=S.B AND R.C=S.C AND R.A&lt;S.B "
                    ]
                },
                {
                    "index": 65,
                    "belong_page": 1,
                    "question_id": 63593,
                    "question_title": "<p>在关系<img style=\"max-width:100%;height:auto\"  src=\"https://s1.51ctocdn.cn//images/20181127/1543310042967949.jpg\" title=\"1543310042967949.jpg\" alt=\"1.jpg\"/>上进行关系运算的4个等价的表达式<img style=\"max-width:100%;height:auto\"  src=\"https://s1.51ctocdn.cn//images/20181127/1543310054238987.jpg\" title=\"1543310054238987.jpg\" alt=\"2.jpg\"/>，如下所示：</p><p><img style=\"max-width:100%;height:auto\"  src=\"https://s1.51ctocdn.cn//images/20181127/1543310061725739.jpg\" title=\"1543310061725739.jpg\" alt=\"3.jpg\"/></p><p>如果严格按照表达式运算顺序执行，则查询效率最高的是表达式（　）。</p>",
                    "question_type": 1,
                    "answer_type": 1,
                    "show_type_name": null,
                    "new_parent_id": 63593,
                    "score_rule": "",
                    "material_text": null,
                    "sort_son": "0",
                    "analyze": "<p>本题考查关系代数运行效率问题。解决这类问题，有一个通用原则，即，存在联接操作与选择操作的，尽可能早的完成选择操作，这样能降低参与联接操作的数据量，极大提升运算效率。</p>",
                    "like": 0,
                    "answer": [
                        "B"
                    ],
                    "option": [
                        " <img style=\"max-width:100%;height:auto\" src=\"https://s1.51ctocdn.cn//images/20181127/1543310094707342.jpg\" title=\"1543310094707342.jpg\" alt=\"1.jpg\"/> ",
                        " <img style=\"max-width:100%;height:auto\" src=\"https://s1.51ctocdn.cn//images/20181127/1543310098858560.jpg\" title=\"1543310098858560.jpg\" alt=\"2.jpg\"/> ",
                        " <img style=\"max-width:100%;height:auto\" src=\"https://s1.51ctocdn.cn//images/20181127/1543310102940136.jpg\" title=\"1543310102940136.jpg\" alt=\"3.jpg\"/> ",
                        " <img style=\"max-width:100%;height:auto\" src=\"https://s1.51ctocdn.cn//images/20181127/1543310106299862.jpg\" title=\"1543310106299862.jpg\" alt=\"4.jpg\"/> "
                    ]
                },
                {
                    "index": 66,
                    "belong_page": 1,
                    "question_id": 63595,
                    "question_title": "<p>数据仓库中，数据（　）是指数据一旦进入数据仓库后，将被长期保留并定期加载和刷新，可以进行各种查询操作，但很少对数据进行修改和删除操作。</p>",
                    "question_type": 1,
                    "answer_type": 1,
                    "show_type_name": null,
                    "new_parent_id": 63595,
                    "score_rule": "",
                    "material_text": null,
                    "sort_son": "0",
                    "analyze": "<p>数据仓库4大特点：</p><p>面向主题：数据按主题组织。</p><p>集成的：消除了源数据中的不一致性，提供整个企业的一致性全局信息。</p><p>相对稳定的(非易失的)：主要进行查询操作，只有少量的修改和删除操作（或是不删除）。</p><p>反映历史变化(随着时间变化)：记录了企业从过去某一时刻到当前各个阶段的信息，可对发展历程和未来趋势做定量分析和预测。</p>",
                    "like": 0,
                    "answer": [
                        "C"
                    ],
                    "option": [
                        " 面向主题 ",
                        " 集成性 ",
                        " 相对稳定性 ",
                        " 反映历史变化 "
                    ]
                },
                {
                    "index": 67,
                    "belong_page": 1,
                    "question_id": 63694,
                    "question_title": "<p>Designing the data storage architecture is an important activity in system design. There are two main types of data storage formats: files and databases. Files are electronic of data that have been optimized to perform a particular transaction. There are several types of files that differ in the way they are used to support an application. （　） store core information that is important to the business and , more specifically , to the application , such as order information or customer mailing information. （　） contain static values , such as a list of valid codes or the names of cities . Typically, the list is used for validation. A database is a collection of groupings of information that are related to each other in some way. There are many different types of databases that exist on the market today. （　） is given to those databases which are based on older , sometimes outdated technology that is seldom used to develop new applications . （请作答此空） are collections of records that are related to each other through pointers In relational database , （ 　） can be used in ensuring that values linking the tables together through the primary and foreign keys are valid and correctly synchronized.</p>",
                    "question_type": 1,
                    "answer_type": 1,
                    "show_type_name": null,
                    "new_parent_id": 63694,
                    "score_rule": "",
                    "material_text": null,
                    "sort_son": "0",
                    "analyze": "<p>（　）存储的核心信息对业务很重要，更具体地说，对应用程序而言，例如订单信息或客户邮件信息。（　）包含静态值，例如有效代码列表或城市名称。通常，该列表用于验证。数据库是以某种方式彼此相关的信息分组的集合。目前市场上存在许多不同类型的数据库。（　）给予那些基于较旧的，有时过时的技术的数据库，这些技术很少用于开发新的应用程序。（请作答此空）是通过指针彼此相关的记录集合在关系数据库中，（　）可用于确保通过主键和外键将表链接在一起的值是有效且正确同步的。</p><p>&nbsp;A. 分层数据库 &nbsp; &nbsp;B. 工作组数据库 &nbsp; &nbsp; &nbsp;C. 链接表数据库 &nbsp; &nbsp; D. 网络数据库</p>",
                    "like": 0,
                    "answer": [
                        "A"
                    ],
                    "option": [
                        " Hierarchical database ",
                        " Workgroup database ",
                        " Linked table database ",
                        " Network database "
                    ]
                },
                {
                    "index": 68,
                    "belong_page": 1,
                    "question_id": 63696,
                    "question_title": "<p>Designing the data storage architecture is an important activity in system design. There are two main types of data storage formats: files and databases. Files are electronic of data that have been optimized to perform a particular transaction. There are several types of files that differ in the way they are used to support an application. （　） store core information that is important to the business and , more specifically , to the application , such as order information or customer mailing information. （　） contain static values , such as a list of valid codes or the names of cities . Typically, the list is used for validation. A database is a collection of groupings of information that are related to each other in some way. There are many different types of databases that exist on the market today. （　） is given to those databases which are based on older , sometimes outdated technology that is seldom used to develop new applications . （　） are collections of records that are related to each other through pointers In relational database , （请作答此空） can be used in ensuring that values linking the tables together through the primary and foreign keys are valid and correctly synchronized.</p>",
                    "question_type": 1,
                    "answer_type": 1,
                    "show_type_name": null,
                    "new_parent_id": 63696,
                    "score_rule": "",
                    "material_text": null,
                    "sort_son": "0",
                    "analyze": "<p>（　）存储的核心信息对业务很重要，更具体地说，对应用程序而言，例如订单信息或客户邮件信息。（　）包含静态值，例如有效代码列表或城市名称。通常，该列表用于验证。数据库是以某种方式彼此相关的信息分组的集合。目前市场上存在许多不同类型的数据库。（　）给予那些基于较旧的，有时过时的技术的数据库，这些技术很少用于开发新的应用程序。（　）是通过指针彼此相关的记录集合在关系数据库中，（请作答此空）可用于确保通过主键和外键将表链接在一起的值是有效且正确同步的。</p><p>&nbsp;A. 识别关系 &nbsp; &nbsp; &nbsp;B. 正常化 &nbsp; &nbsp; &nbsp; &nbsp;\t &nbsp; &nbsp;C. 参照完整性 &nbsp; &nbsp; &nbsp; D. 商店程序</p>",
                    "like": 0,
                    "answer": [
                        "C"
                    ],
                    "option": [
                        " identifying relationships ",
                        " normalization ",
                        " referential integrity ",
                        " store procedure "
                    ]
                },
                {
                    "index": 69,
                    "belong_page": 1,
                    "question_id": 103093,
                    "question_title": "给定关系R(A,B,C,D,E)与S(A,B,C,F,G)，那么与表达式<img style=\"max-width:100%;height:auto\"  src=\"https://s2.51cto.com/images/20190622/1561189974587457.jpg\" title=\"1561189974587457.jpg\" alt=\"1.jpg\"/>等价的SQL语句如下：select (请作答此空) from R, S where ( &nbsp;)；",
                    "question_type": 1,
                    "answer_type": 1,
                    "show_type_name": null,
                    "new_parent_id": 103093,
                    "score_rule": "",
                    "material_text": null,
                    "sort_son": "0",
                    "analyze": "<p>本题考查关系代数运算与SQL语言的对应关系。注意本题中R与S是做自然联接操作，操作时会将R与S中相同字段名做等值联接，并将结果集去重复。所以R与S自然联接后的结果包括以下属性：</p><p>R.A，R.B，R.C，D，E，F，G。</p><p>关系代数选择条件为“1&lt;6”，即R.A&lt;F。</p><p>关系代数投影操作条件为“1,2,4,6,7”，对应的属性为：R.A，R.B，D，F，G。</p>",
                    "like": 0,
                    "answer": [
                        "B"
                    ],
                    "option": [
                        " R.A，R.B，R.E，S.C，G ",
                        " R.A，R.B，D，F，G ",
                        " R.A，R.B，R.D，S.C，F ",
                        " R.A，R.B，R.D，S.C，G "
                    ]
                },
                {
                    "index": 70,
                    "belong_page": 1,
                    "question_id": 103094,
                    "question_title": "给定关系R(A,B,C,D,E)与S(A,B,C,F,G)，那么与表达式<img style=\"max-width:100%;height:auto\"  src=\"https://s2.51cto.com/images/20190622/1561190006103496.jpg\" title=\"1561190006103496.jpg\" alt=\"1.jpg\"/>等价的SQL语句如下：select ( ) from R, S where (请作答此空)；",
                    "question_type": 1,
                    "answer_type": 1,
                    "show_type_name": null,
                    "new_parent_id": 103094,
                    "score_rule": "",
                    "material_text": null,
                    "sort_son": "0",
                    "analyze": "<p>本题考查关系代数运算与SQL语言的对应关系。注意本题中R与S是做自然联接操作，操作时会将R与S中相同字段名做等值联接，并将结果集去重复。所以R与S自然联接后的结果包括以下属性：</p><p>R.A，R.B，R.C，D，E，F，G。</p><p>关系代数选择条件为“1&lt;6”，即R.A&lt;F。</p><p>关系代数投影操作条件为“1,2,4,6,7”，对应的属性为：R.A，R.B，D，F，G。</p>",
                    "like": 0,
                    "answer": [
                        "C"
                    ],
                    "option": [
                        " R.A=S.A OR R.B=S.B OR R.C=S.C OR R.A&lt;S.F ",
                        " R.A=S.A OR R.B=S.B OR R.C=S.C OR R.A&lt;S.B ",
                        " R.A=S.A AND R.B=S.B AND R.C=S.C AND R.A&lt;S.F ",
                        " R.A=S.A AND R.B=S.B AND R.C=S.C AND R.A&lt;S.B "
                    ]
                },
                {
                    "index": 71,
                    "belong_page": 1,
                    "question_id": 103095,
                    "question_title": "给定关系R（A1，A2，A3，A4）上的函数依赖集F={A1→A2A5，A2→A3A4，A3→A2}，R的候选关键字为（请作答此空）。函数依赖（ &nbsp;）∈F+。",
                    "question_type": 1,
                    "answer_type": 1,
                    "show_type_name": null,
                    "new_parent_id": 103095,
                    "score_rule": "",
                    "material_text": null,
                    "sort_son": "0",
                    "analyze": "<p>通过A1能推导出关系R的全部属性，因此关键字为A1。</p><p>第11题，F+是代表，F函数依赖集的闭包，通俗一点，就是从F函数依赖集能推导出来的依赖关系。原依赖集有A3→A2，A2→A3A4，因此可以得到A3→A2A4。</p>",
                    "like": 0,
                    "answer": [
                        "A"
                    ],
                    "option": [
                        " A1 ",
                        " A1A2 ",
                        " A1A3 ",
                        " A1A2A3 "
                    ]
                },
                {
                    "index": 72,
                    "belong_page": 1,
                    "question_id": 103096,
                    "question_title": "给定关系R（A1，A2，A3，A4）上的函数依赖集F={A1→A2A5，A2→A3A4，A3→A2}，R的候选关键字为（ ）。函数依赖（请作答此空）∈F+。",
                    "question_type": 1,
                    "answer_type": 1,
                    "show_type_name": null,
                    "new_parent_id": 103096,
                    "score_rule": "",
                    "material_text": null,
                    "sort_son": "0",
                    "analyze": "<p>第10题，通过A1能推导出关系R的全部属性，因此关键字为A1。</p><p>第11题，F+是代表，F函数依赖集的闭包，通俗一点，就是从F函数依赖集能推导出来的依赖关系。原依赖集有A3→A2，A2→A3A4，因此可以得到A3→A2A4。</p>",
                    "like": 0,
                    "answer": [
                        "C"
                    ],
                    "option": [
                        " A5→A1A2 ",
                        " A4→A1A2 ",
                        " A3→A2A4 ",
                        " A2→A1A5 "
                    ]
                },
                {
                    "index": 73,
                    "belong_page": 1,
                    "question_id": 103097,
                    "question_title": "<p>设有关系模式R（A1，A2，A3，A4，A5，A6），函数依赖集F={A1→A3，A1 A2→A4，A5 A6→A1，A3 A5→A6，A2 A5→A6}。关系模式R的一个主键是（请作答此空）， 从函数依赖集F可以推出关系模式R（ ）。</p>",
                    "question_type": 1,
                    "answer_type": 1,
                    "show_type_name": null,
                    "new_parent_id": 103097,
                    "score_rule": "",
                    "material_text": null,
                    "sort_son": "0",
                    "analyze": "<p>把每个选项代入求它的闭包，A2A5能推出所有属性的为主键。</p>",
                    "like": 0,
                    "answer": [
                        "B"
                    ],
                    "option": [
                        " A1A4 ",
                        " A2A5 ",
                        " A3A4 ",
                        " A4A5 "
                    ]
                },
                {
                    "index": 74,
                    "belong_page": 1,
                    "question_id": 103098,
                    "question_title": "设有关系模式R（A1，A2，A3，A4，A5，A6），函数依赖集F={A1→A3，A1 A2→A4，A5 A6→A1，A3 A5→A6，A2 A5→A6}。关系模式R的一个主键是（）， 从函数依赖集F可以推出关系模式R（请作答此空）。",
                    "question_type": 1,
                    "answer_type": 1,
                    "show_type_name": null,
                    "new_parent_id": 103098,
                    "score_rule": "",
                    "material_text": null,
                    "sort_son": "0",
                    "analyze": "<p>把每个选项代入求它的闭包，A2A5能推出所有属性的为主键。</p><p>第二空，根据第一空可知R的一个主键为A2A5，由函数依赖集F可知，存在A2A5→A6，A5A6→A1，A1→A3，这里存在传递函数依赖，故A、B选项均不正确，C选项本身不正确，存在非主属性对候选键的传递函数依赖，是不满足3NF的。因此本题选择D选项。</p>",
                    "like": 0,
                    "answer": [
                        "D"
                    ],
                    "option": [
                        " 不存在传递依赖，故R为1NF ",
                        " 不存在传递依赖，故R为2NF ",
                        " 存在传递依赖，故R为3NF ",
                        " 每个非主属性完全函数依赖于主键，故R为2NF "
                    ]
                },
                {
                    "index": 75,
                    "belong_page": 1,
                    "question_id": 103099,
                    "question_title": "<p>给定关系R(A, B, C, D)和S(C, D, E)，若关系R与S进行自然连接运算，则运算后的元组属性列数为（请作答此空）；关系代数表达式<img style=\"max-width:100%;height:auto\"  src=\"https://s2.51cto.com/images/20190622/1561190190630668.jpg\" title=\"1561190190630668.jpg\" alt=\"1.jpg\"/>与（ ）等价。</p>",
                    "question_type": 1,
                    "answer_type": 1,
                    "show_type_name": null,
                    "new_parent_id": 103099,
                    "score_rule": "",
                    "material_text": null,
                    "sort_son": "0",
                    "analyze": "<p>对于自然连接只要把重复的列去掉就可以所以为5.</p><p>第二空和选项等价的为D选项</p>",
                    "like": 0,
                    "answer": [
                        "B"
                    ],
                    "option": [
                        " 4 ",
                        " 5 ",
                        " 6 ",
                        " 7 "
                    ]
                },
                {
                    "index": 76,
                    "belong_page": 1,
                    "question_id": 103100,
                    "question_title": "<p>给定关系R（A, B,C,D）和S（C,D,E），若关系R与S进行自然连接运算，则运算后的元组属性列数为（ ）；关系代数表达式<img style=\"max-width:100%;height:auto\"  src=\"https://s2.51cto.com/images/20211201/1638322661798593.png\" title=\"1638322661798593.png\" alt=\"屏幕截图 2021-12-01.png\"/>与（请作答此空）等价。</p>",
                    "question_type": 1,
                    "answer_type": 1,
                    "show_type_name": null,
                    "new_parent_id": 103100,
                    "score_rule": "",
                    "material_text": null,
                    "sort_son": "0",
                    "analyze": "<p>对于自然连接只要把重复的列去掉就可以所以为5.</p><p>第二空和选项等价的为D选项</p>",
                    "like": 0,
                    "answer": [
                        "D"
                    ],
                    "option": [
                        " <img style=\"max-width:100%;height:auto\" src=\"https://s2.51cto.com/images/20211201/1638322774339745.png\" title=\"1638322774339745.png\" alt=\"屏幕截图 2021-12-01.png\"/> ",
                        " <img style=\"max-width:100%;height:auto\" src=\"https://s2.51cto.com/images/20211201/1638322841160748.png\" title=\"1638322841160748.png\" alt=\"屏幕截图 2021-12-01.png\"/> ",
                        " <img style=\"max-width:100%;height:auto\" src=\"https://s2.51cto.com/images/20211201/1638322900469968.png\" title=\"1638322900469968.png\" alt=\"屏幕截图 2021-12-01.png\"/> ",
                        " <img style=\"max-width:100%;height:auto\" src=\"https://s2.51cto.com/images/20211201/1638322971951058.png\" title=\"1638322971951058.png\" alt=\"屏幕截图 2021-12-01.png\"/> "
                    ]
                },
                {
                    "index": 77,
                    "belong_page": 1,
                    "question_id": 103101,
                    "question_title": "给定关系模式 R(U，F)，其中: 属性集 U={A1 ,A2,A3，A4，A5,A6}， 函数依赖集F={A1→A2， A1→A3， A3→A4， A1A5→A6}。关系模式 R 的候选码为(请作答此空),由于 R 存在非主属性对码的部分函数依赖，所以 R 属于_( )_.&nbsp;",
                    "question_type": 1,
                    "answer_type": 1,
                    "show_type_name": null,
                    "new_parent_id": 103101,
                    "score_rule": "",
                    "material_text": null,
                    "sort_son": "0",
                    "analyze": "<p>先求候选码：关系模式码的确定，设关系模式R&lt;U,F&gt;</p><p>1.首先应该找出F中所有的决定因素，即找出出现在函数依赖规则中“→”左边的所有属性，组成集合U1.</p><p>2.再从U1中找出一个属性或属性组K，运用Armstrong公理系统及推论，使得K→U，而K的真子集K&#39;→U不成立,这样就得到了关系模式R的一个候选码，找遍U1属性的所有组合。重复此步骤，最终得到关系模式R的所有候选码。</p><p>第一范式（1NF）是指数据库表的每一列都是不可分割的基本数据项，同一列中不能有多个值，即实体中的某个属性不能有多个值或者不能有重复的属性。如果出现重复的属性，就可能需要定义一个新的实体，新的实体由重复的属性构成，新实体与原实体之间为一对多关系。在第一范式（1NF）中表的每一行只包含一个实例的信息。</p>",
                    "like": 0,
                    "answer": [
                        "C"
                    ],
                    "option": [
                        " A1A3 ",
                        " A1A4 ",
                        " A1 A5 ",
                        " A1A6 "
                    ]
                },
                {
                    "index": 78,
                    "belong_page": 1,
                    "question_id": 103102,
                    "question_title": "给定关系模式 R(U，F)，其中: 属性集 U={A1 ,A2,A3，A4，A5,A6}， 函数依赖集F={A1→A2， A1→A3， A3→A4， A1A5→A6}。关系模式 R 的候选码为( ),由于 R 存在非主属性对码的部分函数依赖，所以 R 属于_(请作答此空)_.&nbsp;",
                    "question_type": 1,
                    "answer_type": 1,
                    "show_type_name": null,
                    "new_parent_id": 103102,
                    "score_rule": "",
                    "material_text": null,
                    "sort_son": "0",
                    "analyze": "<p>先求候选码：关系模式码的确定，设关系模式R&lt;U,F&gt;</p><p>1.首先应该找出F中所有的决定因素，即找出出现在函数依赖规则中“→”左边的所有属性，组成集合U1.</p><p>2.再从U1中找出一个属性或属性组K，运用Armstrong公理系统及推论，使得K→U，而K的真子集K&#39;→U不成立,这样就得到了关系模式R的一个候选码，找遍U1属性的所有组合。重复此步骤，最终得到关系模式R的所有候选码。</p><p>第一范式（1NF）是指数据库表的每一列都是不可分割的基本数据项，同一列中不能有多个值，即实体中的某个属性不能有多个值或者不能有重复的属性。如果出现重复的属性，就可能需要定义一个新的实体，新的实体由重复的属性构成，新实体与原实体之间为一对多关系。在第一范式（1NF）中表的每一行只包含一个实例的信息。</p>",
                    "like": 0,
                    "answer": [
                        "A"
                    ],
                    "option": [
                        " 1NF ",
                        " 2NF ",
                        " 3NF ",
                        " BCNF "
                    ]
                },
                {
                    "index": 79,
                    "belong_page": 1,
                    "question_id": 103103,
                    "question_title": "<p>在分步设计法中，通常将数据库的设计分为 4 个阶段。其中（请作答此空）是数据库设计的第二阶段，其目标是对需求说明书提供的所有数据和处理要求进行抽象与综合处理建立企业数据模型。（）阶段将得到的应用视图转换成外部模式，即特定 DBMS 下的应用视图。</p>",
                    "question_type": 1,
                    "answer_type": 1,
                    "show_type_name": null,
                    "new_parent_id": 103103,
                    "score_rule": "",
                    "material_text": null,
                    "sort_son": "0",
                    "analyze": "<p>&nbsp;数据库概念结构设计是数据库设计的第二阶段，其目标是对需求说明书提供的所有数据和处理要求进行抽象与综合处理，按一定的方法构造反映用户环境的数据及其相互联系的概念模型，即用户的数据模型或企业数据模型。逻辑结构设计的设计目标是把上一阶段得到的与&nbsp;DBMS&nbsp;无关的概念数据模型转换成等价的，并为某个特定的&nbsp;DBMS&nbsp;所接受的逻辑模型所表示的概念模式，同时将概念设计阶段得到的应用视图转换成外部模式，即特定&nbsp;DBMS&nbsp;下的应用视图。<br/></p>",
                    "like": 0,
                    "answer": [
                        "B"
                    ],
                    "option": [
                        " 系统结构设计 ",
                        " 概念结构设计 ",
                        " 逻辑结构设计 ",
                        " 需求概念设计 "
                    ]
                },
                {
                    "index": 80,
                    "belong_page": 1,
                    "question_id": 103104,
                    "question_title": "<p>在分步设计法中，通常将数据库的设计分为 4 个阶段。其中（）是数据库设计的第二阶段，其目标是对需求说明书提供的所有数据和处理要求进行抽象与综合处理建立企业数据模型。（请作答此空）阶段将得到的应用视图转换成外部模式，即特定 DBMS 下的应用视图。</p>",
                    "question_type": 1,
                    "answer_type": 1,
                    "show_type_name": null,
                    "new_parent_id": 103104,
                    "score_rule": "",
                    "material_text": null,
                    "sort_son": "0",
                    "analyze": "<p>&nbsp;数据库概念结构设计是数据库设计的第二阶段，其目标是对需求说明书提供的所有数据和处理要求进行抽象与综合处理，按一定的方法构造反映用户环境的数据及其相互联系的概念模型，即用户的数据模型或企业数据模型。逻辑结构设计的设计目标是把上一阶段得到的与&nbsp;DBMS&nbsp;无关的概念数据模型转换成等价的，并为某个特定的&nbsp;DBMS&nbsp;所接受的逻辑模型所表示的概念模式，同时将概念设计阶段得到的应用视图转换成外部模式，即特定&nbsp;DBMS&nbsp;下的应用视图。<br/></p>",
                    "like": 0,
                    "answer": [
                        "C"
                    ],
                    "option": [
                        " 系统结构设计 ",
                        " 概念结构设计 ",
                        " 逻辑结构设计 ",
                        " 物理结构设计 "
                    ]
                },
                {
                    "index": 81,
                    "belong_page": 1,
                    "question_id": 103105,
                    "question_title": "<p>分布透明性指用户不必关心数据的逻辑分片，不必关心数据存储的物理位置分配细节，也不必关心局部场地上数据库的数据模型。（请作答此空）是分布透明性的最高层次。（）指用户或应用程序应当了解分片情况，但不必了解片段的存储场地。（）透明性是指用户或应用程序应当了解分片及各片断存储的场地，但不必了解局部场地上使用的是何种数据模型。</p>",
                    "question_type": 1,
                    "answer_type": 1,
                    "show_type_name": null,
                    "new_parent_id": 103105,
                    "score_rule": "",
                    "material_text": null,
                    "sort_son": "0",
                    "analyze": "<p>&nbsp;分布透明性包括：分片透明性、位置透明性和局部数据模型透明性。</p><p>&nbsp; &nbsp; （1）分片透明性是分布透明性的最高层次。所谓分片透明性是指用户或应用程序只对全局关系进行操作而不必考虑数据的分片。当分片模式改变时，只要改变全局模式到分片模式的映像（映像 2），而不影响全局模式和应用程序。全局模式不变，应用程序不必改写，这就是分片透明性。</p><p>&nbsp; &nbsp; （2）位置透明性是分布透明性的下一层次。所谓位置透明性是指，用户或应用程序应当了解分片情况，但不必了解片段的存储场地。当存储场地改变时，只要改变分片模式到分配模式的映像（映像 3），而不影响应用程序。同时，若片段的重复副本数目改变了，那么数据的冗余也会改变，但用户不必关心如何保持各副本的一致性，这也提供了重复副本的透明性。</p><p>&nbsp; &nbsp; （3）局部数据模型（逻辑透明）透明性是指用户或应用程序应当了解分片及各片断存储的场地，但不必了解局部场地上使用的是何种数据模型。</p>",
                    "like": 0,
                    "answer": [
                        "A"
                    ],
                    "option": [
                        " 分片透明性 ",
                        " 逻辑透明性 ",
                        " 位置透明性 ",
                        " 全局透明性 "
                    ]
                },
                {
                    "index": 82,
                    "belong_page": 1,
                    "question_id": 103106,
                    "question_title": "<p>分布透明性指用户不必关心数据的逻辑分片，不必关心数据存储的物理位置分配细节，也不必关心局部场地上数据库的数据模型。（ ）是分布透明性的最高层次。（请作答此空）指用户或应用程序应当了解分片情况，但不必了解片段的存储场地。（）透明性是指用户或应用程序应当了解分片及各片断存储的场地，但不必了解局部场地上使用的是何种数据模型。</p>",
                    "question_type": 1,
                    "answer_type": 1,
                    "show_type_name": null,
                    "new_parent_id": 103106,
                    "score_rule": "",
                    "material_text": null,
                    "sort_son": "0",
                    "analyze": "<p>&nbsp;分布透明性包括：分片透明性、位置透明性和局部数据模型透明性。</p><p>&nbsp; &nbsp; （1）分片透明性是分布透明性的最高层次。所谓分片透明性是指用户或应用程序只对全局关系进行操作而不必考虑数据的分片。当分片模式改变时，只要改变全局模式到分片模式的映像（映像 2），而不影响全局模式和应用程序。全局模式不变，应用程序不必改写，这就是分片透明性。</p><p>&nbsp; &nbsp; （2）位置透明性是分布透明性的下一层次。所谓位置透明性是指，用户或应用程序应当了解分片情况，但不必了解片段的存储场地。当存储场地改变时，只要改变分片模式到分配模式的映像（映像 3），而不影响应用程序。同时，若片段的重复副本数目改变了，那么数据的冗余也会改变，但用户不必关心如何保持各副本的一致性，这也提供了重复副本的透明性。</p><p>&nbsp; &nbsp; （3）局部数据模型（逻辑透明）透明性是指用户或应用程序应当了解分片及各片断存储的场地，但不必了解局部场地上使用的是何种数据模型。</p><p><br/></p>",
                    "like": 0,
                    "answer": [
                        "C"
                    ],
                    "option": [
                        " 分片透明性 ",
                        " 逻辑透明性 ",
                        " 位置透明性 ",
                        " 全局透明性 "
                    ]
                },
                {
                    "index": 83,
                    "belong_page": 1,
                    "question_id": 103107,
                    "question_title": "<p>分布透明性指用户不必关心数据的逻辑分片，不必关心数据存储的物理位置分配细节，也不必关心局部场地上数据库的数据模型。（）是分布透明性的最高层次。（ ）指用户或应用程序应当了解分片情况，但不必了解片段的存储场地。（请作答此空）透明性是指用户或应用程序应当了解分片及各片断存储的场地，但不必了解局部场地上使用的是何种数据模型。</p>",
                    "question_type": 1,
                    "answer_type": 1,
                    "show_type_name": null,
                    "new_parent_id": 103107,
                    "score_rule": "",
                    "material_text": null,
                    "sort_son": "0",
                    "analyze": "<p>&nbsp;分布透明性包括：分片透明性、位置透明性和局部数据模型透明性。</p><p>&nbsp; &nbsp; （1）分片透明性是分布透明性的最高层次。所谓分片透明性是指用户或应用程序只对全局关系进行操作而不必考虑数据的分片。当分片模式改变时，只要改变全局模式到分片模式的映像（映像 2），而不影响全局模式和应用程序。全局模式不变，应用程序不必改写，这就是分片透明性。</p><p>&nbsp; &nbsp; （2）位置透明性是分布透明性的下一层次。所谓位置透明性是指，用户或应用程序应当了解分片情况，但不必了解片段的存储场地。当存储场地改变时，只要改变分片模式到分配模式的映像（映像 3），而不影响应用程序。同时，若片段的重复副本数目改变了，那么数据的冗余也会改变，但用户不必关心如何保持各副本的一致性，这也提供了重复副本的透明性。</p><p>&nbsp; &nbsp; （3）局部数据模型（逻辑透明）透明性是指用户或应用程序应当了解分片及各片断存储的场地，但不必了解局部场地上使用的是何种数据模型。</p><p><br/></p>",
                    "like": 0,
                    "answer": [
                        "B"
                    ],
                    "option": [
                        " 分片透明性 ",
                        " 逻辑透明性 ",
                        " 位置透明性 ",
                        " 全局透明性 "
                    ]
                },
                {
                    "index": 84,
                    "belong_page": 1,
                    "question_id": 151193,
                    "question_title": "数据库系统运行的基本工作单位是事务，事务相当于操作系统中的进程，是用户定义的一个数据库操作序列，这些操作序列要么全做要么全不做，是一个不可分割的工作单位。数据库的（请作答此空）是指操作序列要么全做要么全不做。设计时用（ ）实现。数据库从一个一致性状态变到另一个一致性状态的性质称为（ ）。设计时用（ ）检查实现。",
                    "question_type": 1,
                    "answer_type": 1,
                    "show_type_name": null,
                    "new_parent_id": 151193,
                    "score_rule": "",
                    "material_text": null,
                    "sort_son": "0",
                    "analyze": "数据库的原子性是指操作序列要么全做要么全不做。设计时用影子拷贝（浅拷贝）实现。浅拷贝就是你的影子,深拷贝是你的克隆人,你没了影子也就没了,但是克隆人还活着。数据库从一个一致性状态变到另一个一致性状态称为一致性。设计时用完整性约束检查实现。",
                    "like": 0,
                    "answer": [
                        "C"
                    ],
                    "option": [
                        " 一致性 ",
                        " 可用性 ",
                        " 原子性 ",
                        " 隔离性 "
                    ]
                },
                {
                    "index": 85,
                    "belong_page": 1,
                    "question_id": 151194,
                    "question_title": "数据库系统运行的基本工作单位是事务，事务相当于操作系统中的进程，是用户定义的一个数据库操作序列，这些操作序列要么全做要么全不做，是一个不可分割的工作单位。数据库的（ ）是指操作序列要么全做要么全不做。设计时用（请作答此空）实现。数据库从一个一致性状态变到另一个一致性状态的性质称为（ ）。设计时用（ ）检查实现。",
                    "question_type": 1,
                    "answer_type": 1,
                    "show_type_name": null,
                    "new_parent_id": 151194,
                    "score_rule": "",
                    "material_text": null,
                    "sort_son": "0",
                    "analyze": "数据库的原子性是指操作序列要么全做要么全不做。设计时用影子拷贝（浅拷贝）实现。浅拷贝就是你的影子,深拷贝是你的克隆人,你没了影子也就没了,但是克隆人还活着。数据库从一个一致性状态变到另一个一致性状态称为一致性。设计时用完整性约束检查实现。",
                    "like": 0,
                    "answer": [
                        "A"
                    ],
                    "option": [
                        " 影子拷贝 ",
                        " 差异备份 ",
                        " 深拷贝 ",
                        " 完全备份 "
                    ]
                },
                {
                    "index": 86,
                    "belong_page": 1,
                    "question_id": 151195,
                    "question_title": "数据库系统运行的基本工作单位是事务，事务相当于操作系统中的进程，是用户定义的一个数据库操作序列，这些操作序列要么全做要么全不做，是一个不可分割的工作单位。数据库的（ ）是指操作序列要么全做要么全不做。设计时用（ ）实现。数据库从一个一致性状态变到另一个一致性状态的性质称为（请作答此空）。设计时用（ ）检查实现。",
                    "question_type": 1,
                    "answer_type": 1,
                    "show_type_name": null,
                    "new_parent_id": 151195,
                    "score_rule": "",
                    "material_text": null,
                    "sort_son": "0",
                    "analyze": "数据库的原子性是指操作序列要么全做要么全不做。设计时用影子拷贝（浅拷贝）实现。浅拷贝就是你的影子,深拷贝是你的克隆人,你没了影子也就没了,但是克隆人还活着。数据库从一个一致性状态变到另一个一致性状态称为一致性。设计时用完整性约束检查实现。",
                    "like": 0,
                    "answer": [
                        "A"
                    ],
                    "option": [
                        " 一致性 ",
                        " 完整性 ",
                        " 原子性 ",
                        " 隔离性 "
                    ]
                },
                {
                    "index": 87,
                    "belong_page": 1,
                    "question_id": 151196,
                    "question_title": "数据库系统运行的基本工作单位是事务，事务相当于操作系统中的进程，是用户定义的一个数据库操作序列，这些操作序列要么全做要么全不做，是一个不可分割的工作单位。数据库的（ ）是指操作序列要么全做要么全不做。设计时用（ ）实现。数据库从一个一致性状态变到另一个一致性状态的性质称为（ ）。设计时用（请作答此空）检查实现。",
                    "question_type": 1,
                    "answer_type": 1,
                    "show_type_name": null,
                    "new_parent_id": 151196,
                    "score_rule": "",
                    "material_text": null,
                    "sort_son": "0",
                    "analyze": "数据库的原子性是指操作序列要么全做要么全不做。设计时用影子拷贝（浅拷贝）实现。浅拷贝就是你的影子,深拷贝是你的克隆人,你没了影子也就没了,但是克隆人还活着。数据库从一个一致性状态变到另一个一致性状态称为一致性。设计时用完整性约束检查实现。",
                    "like": 0,
                    "answer": [
                        "B"
                    ],
                    "option": [
                        " 封锁协议 ",
                        " 完整性约束 ",
                        " 影子拷贝 ",
                        " 测试 "
                    ]
                },
                {
                    "index": 88,
                    "belong_page": 1,
                    "question_id": 151197,
                    "question_title": "数据仓库不包括（）",
                    "question_type": 1,
                    "answer_type": 1,
                    "show_type_name": null,
                    "new_parent_id": 151197,
                    "score_rule": "",
                    "material_text": null,
                    "sort_son": "0",
                    "analyze": "数据仓库包括数据源、数据的存储与管理、OLAP 服务器与各种报表工具、查询工具、数据分析工具、数据挖掘工具及各种基于数据仓库或数据集市的应用开发工具。OLTP是传统的关系型数据库联机事务处理过程。",
                    "like": 0,
                    "answer": [
                        "C"
                    ],
                    "option": [
                        " 数据源 ",
                        " OLAP 服务器 ",
                        " OLTP 服务器 ",
                        " 报表工具 "
                    ]
                },
                {
                    "index": 89,
                    "belong_page": 1,
                    "question_id": 151198,
                    "question_title": "分布式数据库缓存技术有Memcache与Redis，关于两者的说法正确的是（）",
                    "question_type": 1,
                    "answer_type": 1,
                    "show_type_name": null,
                    "new_parent_id": 151198,
                    "score_rule": "",
                    "material_text": null,
                    "sort_son": "0",
                    "analyze": "<p>两者的对比如下所示：</p><img style=\"max-width:100%;height:auto\"  src=\"https://s2.51cto.com/images/20190925/1569395627436724.jpg\" title=\"1569395627436724.jpg\" alt=\"1.jpg\"/>",
                    "like": 0,
                    "answer": [
                        "D"
                    ],
                    "option": [
                        " Memcache不仅仅支持简单的k/v类型的数据，同时还提供list，set，hash等数据结构的存储。 ",
                        " Redis支持多线程 ",
                        " Memcache不能进行内存管理 ",
                        " Redis支持主从、sentinel、cluster等分布式存储方式 "
                    ]
                },
                {
                    "index": 90,
                    "belong_page": 1,
                    "question_id": 151200,
                    "question_title": "分布透明性指用户不必关心数据的逻辑分片，不必关心数据存储的物理位置分配细节，也不必关心局部场地上数据库的数据模型。（请作答此空）是分布透明性的最高层次。（ ）指用户或应用程序应当了解分片情况，但不必了解片段的存储场地。（）透明性是指用户或应用程序应当了解分片及各片断存储的场地，但不必了解局部场地上使用的是何种数据模型。",
                    "question_type": 1,
                    "answer_type": 1,
                    "show_type_name": null,
                    "new_parent_id": 151200,
                    "score_rule": "",
                    "material_text": null,
                    "sort_son": "0",
                    "analyze": "<p>分布透明性包括：分片透明性、位置透明性和局部数据模型透明性。</p><p>（1）分片透明性是分布透明性的最高层次。所谓分片透明性是指用户或应用程序只对全局关系进行操作而不必考虑数据的分片。当分片模式改变时，只要改变全局模式到分片模式的映像，而不影响全局模式和应用程序。全局模式不变，应用程序不必改写，这就是分片透明性。</p><p>（2）位置透明性是分布透明性的下一层次。所谓位置透明性是指，用户或应用程序应当了解分片情况，但不必了解片段的存储场地。</p><p>（3）局部数据模型（逻辑透明）透明性是指用户或应用程序应当了解分片及各片断存储的场地，但不必了解局部场地上使用的是何种数据模型。</p>",
                    "like": 0,
                    "answer": [
                        "A"
                    ],
                    "option": [
                        " 分片透明性 ",
                        " 逻辑透明性 ",
                        " 位置透明性 ",
                        " 全局透明性 "
                    ]
                },
                {
                    "index": 91,
                    "belong_page": 1,
                    "question_id": 151201,
                    "question_title": "分布透明性指用户不必关心数据的逻辑分片，不必关心数据存储的物理位置分配细节，也不必关心局部场地上数据库的数据模型。（ ）是分布透明性的最高层次。（请作答此空）指用户或应用程序应当了解分片情况，但不必了解片段的存储场地。（ &nbsp;）透明性是指用户或应用程序应当了解分片及各片断存储的场地，但不必了解局部场地上使用的是何种数据模型。",
                    "question_type": 1,
                    "answer_type": 1,
                    "show_type_name": null,
                    "new_parent_id": 151201,
                    "score_rule": "",
                    "material_text": null,
                    "sort_son": "0",
                    "analyze": "<p>分布透明性包括：分片透明性、位置透明性和局部数据模型透明性。</p><p>（1）分片透明性是分布透明性的最高层次。所谓分片透明性是指用户或应用程序只对全局关系进行操作而不必考虑数据的分片。当分片模式改变时，只要改变全局模式到分片模式的映像，而不影响全局模式和应用程序。全局模式不变，应用程序不必改写，这就是分片透明性。</p><p>（2）位置透明性是分布透明性的下一层次。所谓位置透明性是指，用户或应用程序应当了解分片情况，但不必了解片段的存储场地。</p><p>（3）局部数据模型（逻辑透明）透明性是指用户或应用程序应当了解分片及各片断存储的场地，但不必了解局部场地上使用的是何种数据模型。</p>",
                    "like": 0,
                    "answer": [
                        "C"
                    ],
                    "option": [
                        " 分片透明性 ",
                        " 逻辑透明性 ",
                        " 位置透明性 ",
                        " 全局透明性 "
                    ]
                },
                {
                    "index": 92,
                    "belong_page": 1,
                    "question_id": 151202,
                    "question_title": "分布透明性指用户不必关心数据的逻辑分片，不必关心数据存储的物理位置分配细节，也不必关心局部场地上数据库的数据模型。（ ）是分布透明性的最高层次。（ &nbsp;）指用户或应用程序应当了解分片情况，但不必了解片段的存储场地。（请作答此空）透明性是指用户或应用程序应当了解分片及各片断存储的场地，但不必了解局部场地上使用的是何种数据模型。",
                    "question_type": 1,
                    "answer_type": 1,
                    "show_type_name": null,
                    "new_parent_id": 151202,
                    "score_rule": "",
                    "material_text": null,
                    "sort_son": "0",
                    "analyze": "<p>分布透明性包括：分片透明性、位置透明性和局部数据模型透明性。</p><p>（1）分片透明性是分布透明性的最高层次。所谓分片透明性是指用户或应用程序只对全局关系进行操作而不必考虑数据的分片。当分片模式改变时，只要改变全局模式到分片模式的映像，而不影响全局模式和应用程序。全局模式不变，应用程序不必改写，这就是分片透明性。</p><p>（2）位置透明性是分布透明性的下一层次。所谓位置透明性是指，用户或应用程序应当了解分片情况，但不必了解片段的存储场地。</p><p>（3）局部数据模型（逻辑透明）透明性是指用户或应用程序应当了解分片及各片断存储的场地，但不必了解局部场地上使用的是何种数据模型。</p>",
                    "like": 0,
                    "answer": [
                        "B"
                    ],
                    "option": [
                        " 分片透明性 ",
                        " 逻辑透明性 ",
                        " 位置透明性 ",
                        " 全局透明性 "
                    ]
                },
                {
                    "index": 93,
                    "belong_page": 1,
                    "question_id": 151203,
                    "question_title": "给定关系模式 R&lt;U,F&gt;;其中 U 为属性集，F 是 U 上的一组函数依赖，那么Armstroog 公理系统的增广律是指（ &nbsp;）。",
                    "question_type": 1,
                    "answer_type": 1,
                    "show_type_name": null,
                    "new_parent_id": 151203,
                    "score_rule": "",
                    "material_text": null,
                    "sort_son": "0",
                    "analyze": "<p>从已知的一些函数依赖，可以推导出另外一些函数依赖，这就需要一系列推理规则。函数依赖的推理规则最早出现在1974年W.W.Armstrong 的论文里，这些规则常被称作“Armstrong 公理”</p><p>设U 是关系模式R 的属性集，F 是R 上成立的只涉及U 中属性的函数依赖集。函数依赖的推理规则有以下三条：</p><p>自反律：若属性集Y 包含于属性集X，属性集X 包含于U，则X→Y 在R 上成立。(此处X→Y是平凡函数依赖)</p><p>增广律：若X→Y 在R 上成立，且属性集Z 包含于属性集U，则XZ→YZ 在R 上成立。</p><p>传递律：若X→Y 和 Y→Z在R 上成立，则X →Z 在R 上成立。</p><p>其他的所有函数依赖的推理规则可以使用这三条规则推导出。</p>",
                    "like": 0,
                    "answer": [
                        "D"
                    ],
                    "option": [
                        " 若 X→Y，X→Z，则 X→YZ 为 F 所蕴涵 ",
                        " 若 X→Y，WY→Z，则 XW→Z 为 F 所蕴涵 ",
                        " 若 X→Y，Y→Z 为 F 所蕴涵，则 X→Z 为 F 所蕴涵 ",
                        " 若 X→Y，为 F 所蕴涵，且 Z?U,则入 XZ→YZ 为 F 所蕴涵 "
                    ]
                },
                {
                    "index": 94,
                    "belong_page": 1,
                    "question_id": 151204,
                    "question_title": "<p>给定关系模式&nbsp;R(A,&nbsp;B,&nbsp;C,&nbsp;D),&nbsp;S(C,&nbsp;D,&nbsp;E),&nbsp;与&nbsp;π<sub>1,3,5</sub>(σ<sub>2=&#39;软件工程&#39;</sub>(R⋈S))&nbsp;等价的SQL语句如下：SELECT&nbsp;(请作答此空)&nbsp;FROM&nbsp;R,&nbsp;S&nbsp;WHERE&nbsp;(&nbsp;)；下列查询&nbsp;B=&#39;信息&#39;&nbsp;且&nbsp;E=&#39;北京&#39;&nbsp;的&nbsp;A、B、E&nbsp;的关系代数表示式中，查询效率最高的是&nbsp;(&nbsp;)。</p>",
                    "question_type": 1,
                    "answer_type": 1,
                    "show_type_name": null,
                    "new_parent_id": 151204,
                    "score_rule": "",
                    "material_text": null,
                    "sort_son": "0",
                    "analyze": "<p>本题考查关系代数运算与SQL查询方面的基础知识。<br/>一小题的正确答案为选项C。π<sub>1,3,5</sub>(σ<sub>2=&#39;软件工程&#39;</sub>(R⋈S))的含义是从R⋈S结果集中选取B=&#39;软件工程&#39;的元组，再进行 R.A、R.C 和 S.E 投影。</p>",
                    "like": 0,
                    "answer": [
                        "C"
                    ],
                    "option": [
                        " A,C,S.C ",
                        " A,B,E ",
                        " A,R.C,E ",
                        " A,R.C,S.D "
                    ]
                },
                {
                    "index": 95,
                    "belong_page": 1,
                    "question_id": 151206,
                    "question_title": "<p><img style=\"max-width:100%;height:auto\"  src=\"https://s2.51cto.com/images/20210414/1618379686341838.png\" title=\"1618379686341838.png\" alt=\"image.png\"/><span style=\"font-size: 16px;\"></span></p>",
                    "question_type": 1,
                    "answer_type": 1,
                    "show_type_name": null,
                    "new_parent_id": 151206,
                    "score_rule": "",
                    "material_text": null,
                    "sort_son": "0",
                    "analyze": "<p>B的最长查询语句最短，因此可以并行执行，提高效率。</p>",
                    "like": 0,
                    "answer": [
                        "B"
                    ],
                    "option": [
                        "选择A  ",
                        " 选择B ",
                        " 选择C ",
                        " 选择D "
                    ]
                },
                {
                    "index": 96,
                    "belong_page": 1,
                    "question_id": 159227,
                    "question_title": "<p>某公司网上销售管理系统的数据库部分关系模式如下所示。其中，客户号唯一标识一位客户，产品号唯一标识一件产品，订单号唯一标识一份订单。一份订单必须且仅对应一位客户，一份订单可由一到多条订单明细组成，一位客户可以有多份订单。</p><p>客户（客户号，姓名，性别，地址，邮编）</p><p>产品（产品号，名称，库存，单价）</p><p>订单（订单号，时间，金额，客户号）</p><p>订单明细（订单号，产品号，数量）</p><p>订单关系模式的主键为（请作答此空）；订单明细关系模式的主键为（ ）；其中订单的外键为（ ）。</p>",
                    "question_type": 1,
                    "answer_type": 1,
                    "show_type_name": null,
                    "new_parent_id": 159227,
                    "score_rule": "",
                    "material_text": null,
                    "sort_son": "0",
                    "analyze": "<p>本题考查的是应试者对关系数据库基本概念的掌握程度,</p><p>本题正确答案为A.根据题意,订单号唯一标识一份订单,订单关系模式的主键为订单号。</p>",
                    "like": 0,
                    "answer": [
                        "A"
                    ],
                    "option": [
                        " 订单号 ",
                        " 客户号 ",
                        " （订单号，客户号） ",
                        " （订单号，时间） "
                    ]
                },
                {
                    "index": 97,
                    "belong_page": 1,
                    "question_id": 159228,
                    "question_title": "<p>某公司网上销售管理系统的数据库部分关系模式如下所示。其中，客户号唯一标识一位客户，产品号唯一标识一件产品，订单号唯一标识一份订单。一份订单必须且仅对应一位客户，一份订单可由一到多条订单明细组成，一位客户可以有多份订单。</p><p>客户（客户号，姓名，性别，地址，邮编）</p><p>产品（产品号，名称，库存，单价）</p><p>订单（订单号，时间，金额，客户号）</p><p>订单明细（订单号，产品号，数量）</p><p>订单关系模式的主键为（ ）；订单明细关系模式的主键为（请作答此空）；其中订单的外键为（ ）。<span style=\"font-size: 16px;\"></span></p>",
                    "question_type": 1,
                    "answer_type": 1,
                    "show_type_name": null,
                    "new_parent_id": 159228,
                    "score_rule": "",
                    "material_text": null,
                    "sort_son": "0",
                    "analyze": "<p>本题考查的是应试者对关系数据库基本概念的掌握程度,</p><p>本题正确的答案是C.根据题意,因为一份订单可由一到多条订单明细组成,而订单明细指出的是产品号和数量,因此订单明细关系模式的主键为订单号,产品号。</p>",
                    "like": 0,
                    "answer": [
                        "C"
                    ],
                    "option": [
                        " 订单号 ",
                        " 产品号 ",
                        " （订单号，产品号） ",
                        " （订单号，数量） "
                    ]
                },
                {
                    "index": 98,
                    "belong_page": 1,
                    "question_id": 159229,
                    "question_title": "<p>某公司网上销售管理系统的数据库部分关系模式如下所示。其中，客户号唯一标识一位客户，产品号唯一标识一件产品，订单号唯一标识一份订单。一份订单必须且仅对应一位客户，一份订单可由一到多条订单明细组成，一位客户可以有多份订单。</p><p>客户（客户号，姓名，性别，地址，邮编）</p><p>产品（产品号，名称，库存，单价）</p><p>订单（订单号，时间，金额，客户号）</p><p>订单明细（订单号，产品号，数量）</p><p>订单关系模式的主键为（ ）；订单明细关系模式的主键为（ ）；其中订单的外键为（请作答此空）。<span style=\"font-size: 16px;\"></span></p>",
                    "question_type": 1,
                    "answer_type": 1,
                    "show_type_name": null,
                    "new_parent_id": 159229,
                    "score_rule": "",
                    "material_text": null,
                    "sort_son": "0",
                    "analyze": "<p>本题考查的是应试者对关系数据库基本概念的掌握程度,</p><p>本题正确的答案是B.因为客户关系模的主键为客户号,所以订单的外键为“客户号”;而“订单号”和“产品号”分别为订单和产品的主键,因此订单明细的外键为“订单号,产品号”。</p>",
                    "like": 0,
                    "answer": [
                        "B"
                    ],
                    "option": [
                        " 客户号，订单明细的外键为订单号 ",
                        " 客户号，订单明细的外键为订单号和产品号 ",
                        " 订单号，订单明细的外键为产品号 ",
                        " 订单号，订单明细的外键为订单号和产品号 "
                    ]
                },
                {
                    "index": 99,
                    "belong_page": 1,
                    "question_id": 159230,
                    "question_title": "某高校管理信息系统的数据库设计过程中，（请作答此空）阶段是在需求分析的基础上，对用户信息加以分类、聚集和概括，建立信息模型，并依照选定的数据库管理系统软件，转换成为数据的（ ），再依照软硬件环境，最终实现数据的合理存储。",
                    "question_type": 1,
                    "answer_type": 1,
                    "show_type_name": null,
                    "new_parent_id": 159230,
                    "score_rule": "",
                    "material_text": null,
                    "sort_son": "0",
                    "analyze": "<p>本题考查的是应试者对数据库基本概念的掌握程度。</p><p>第一空、第二空的正确答案分别为D和B。数据库概念结构设计阶段是在需求分析的基础上,依照需求分析中的信息要求,对用户信息方加以分类、聚集和概括,建立信息模型,并依照选定的数据库管理系统软件,转换成为数据库的逻辑模式，再依照软硬件环境,最终实现数据的合理存储。这—过程也称为数据建模。</p>",
                    "like": 0,
                    "answer": [
                        "D"
                    ],
                    "option": [
                        " 物理设计 ",
                        " 逻辑结构设计 ",
                        " 数据库实施 ",
                        " 概念结构设计 "
                    ]
                },
                {
                    "index": 100,
                    "belong_page": 1,
                    "question_id": 159231,
                    "question_title": "某高校管理信息系统的数据库设计过程中，（ ）阶段是在需求分析的基础上，对用户信息加以分类、聚集和概括，建立信息模型，并依照选定的数据库管理系统软件，转换成为数据的（请作答此空），再依照软硬件环境，最终实现数据的合理存储。",
                    "question_type": 1,
                    "answer_type": 1,
                    "show_type_name": null,
                    "new_parent_id": 159231,
                    "score_rule": "",
                    "material_text": null,
                    "sort_son": "0",
                    "analyze": "<p>本题考查的是应试者对数据库基本概念的掌握程度。</p><p>第一空、第二空的正确答案分别为D和B。数据库概念结构设计阶段是在需求分析的基础上,依照需求分析中的信息要求,对用户信息方加以分类、聚集和概括,建立信息模型,并依照选定的数据库管理系统软件,转换成为数据库的逻辑模式，再依照软硬件环境,最终实现数据的合理存储。这—过程也称为数据建模。</p>",
                    "like": 0,
                    "answer": [
                        "B"
                    ],
                    "option": [
                        " 物理模式 ",
                        " 逻辑模式 ",
                        " 内模式 ",
                        " 概念模式 "
                    ]
                },
                {
                    "index": 101,
                    "belong_page": 1,
                    "question_id": 159232,
                    "question_title": "在数据库系统中，数据的完整性是指数据的（ ）。",
                    "question_type": 1,
                    "answer_type": 1,
                    "show_type_name": null,
                    "new_parent_id": 159232,
                    "score_rule": "",
                    "material_text": null,
                    "sort_son": "0",
                    "analyze": "本题考查的是应试者对数据库基本概念的掌握程度。所谓数据的完整性,是指数据的有效性、正确性和一致性。在数据库设计时如果没有一定的措施确保数据库中数据的完整件,就无法从数据库中获得可信的数据。数据的完整性设计,应该贯穿在数据库设计的全过程中。例如,在数据需求分析价段,收集数据信息时,应该向有关用户调查该数的有效值范围。",
                    "like": 0,
                    "answer": [
                        "A"
                    ],
                    "option": [
                        " 有效性、正确性和一致性 ",
                        " 有效性、正确性和可维护性 ",
                        " 有效性、正确性和安全性 ",
                        " 正确性、一致性和安全性 "
                    ]
                },
                {
                    "index": 102,
                    "belong_page": 1,
                    "question_id": 159247,
                    "question_title": "<p>分布式事务的执行可能会涉及到多个站点上的数据操作，在两阶段提交协议中，当事务Ti的所有读写操作执行结束后，事务Ti的发起者协调器Ci向所有参与Ti的执行站点发送&lt;prepare Ti&gt;的消息，当收到所有执行站点返回的&lt;ready Ti&gt;消息后，Ci再向所有执行站点发送&lt;commit Ti&gt;消息。若参与事务Ti执行的某个站点故障恢复后日志中有&lt;ready Ti&gt;记录，而没有&lt;commit Ti&gt;记录，则（ ）。</p>",
                    "question_type": 1,
                    "answer_type": 1,
                    "show_type_name": null,
                    "new_parent_id": 159247,
                    "score_rule": "",
                    "material_text": null,
                    "sort_son": "0",
                    "analyze": "<p>分布式事务，统一由事务协调器控制各节点进行事务操作。<br/>系统故障恢复时，对于故障发生前已经提交的事务，应记入重做（Redo）队列；对于故障发生时尚未完成的事务，应记入撤销（Undo）队列。因为站点故障恢复后日志中已有&lt;ready Ti&gt;记录，因此需要执行REDO操作。</p>",
                    "like": 0,
                    "answer": [
                        "D"
                    ],
                    "option": [
                        " 事务Ti已完成提交，该站点无需做任何操作 ",
                        " 事务Ti已完成提交，该站点应做REDO操作 ",
                        " 事务Ti未完成提交，该站点应做UNDO操作 ",
                        " 应向协调器询问以决定Ti的最终结果 "
                    ]
                },
                {
                    "index": 103,
                    "belong_page": 1,
                    "question_id": 208398,
                    "question_title": "<p>在数据库设计的需求分析阶段应当形成（请作答此空），这些文档可以作为（ ）阶段的设计依据。</p>",
                    "question_type": 1,
                    "answer_type": 1,
                    "show_type_name": "单选题",
                    "new_parent_id": 208398,
                    "score_rule": "",
                    "material_text": "",
                    "sort_son": "0",
                    "analyze": "<p>数据库设计主要分为用户需求分析、概念结构、逻辑结构和物理结构设计四个阶段。其中，在用户需求分析阶段中，数据库设计人员采用一定的辅助工具对应用对象的功能、性能、 限制等要求所进行的科学分析，并形成需求说明文档、数据字典和数据流程图。用户需求分析阶段形成的相关文档用以作为概念结构设计的设计依据。</p>",
                    "like": 0,
                    "answer": [
                        "C"
                    ],
                    "option": [
                        " 程序文档、数据字典和数据流图 ",
                        " 需求说明文档、程序文档和数据流图 ",
                        " 需求说明文档、数据字典和数据流图 ",
                        " 需求说明文档、数据字典和程序文档 "
                    ]
                },
                {
                    "index": 104,
                    "belong_page": 1,
                    "question_id": 208399,
                    "question_title": "在数据库设计的需求分析阶段应当形成（ ），这些文档可以作为（请作答此空）阶段的设计依据。",
                    "question_type": 1,
                    "answer_type": 1,
                    "show_type_name": "单选题",
                    "new_parent_id": 208399,
                    "score_rule": "",
                    "material_text": "",
                    "sort_son": "0",
                    "analyze": "数据库设计主要分为用户需求分析、概念结构、逻辑结构和物理结构设计四个阶段。其中，在用户需求分析阶段中，数据库设计人员采用一定的辅助工具对应用对象的功能、性能、 限制等要求所进行的科学分析，并形成需求说明文档、数据字典和数据流程图。用户需求分析阶段形成的相关文档用以作为概念结构设计的设计依据。",
                    "like": 0,
                    "answer": [
                        "B"
                    ],
                    "option": [
                        " 逻辑结构设计 ",
                        " 概念结构设计 ",
                        " 物理结构设计 ",
                        " 数据库运行和维护 "
                    ]
                },
                {
                    "index": 105,
                    "belong_page": 1,
                    "question_id": 208400,
                    "question_title": "某商场商品数据库的商品关系模式P(商品代码，商品名称，供应商，联系方式，库存量)，函数依赖集F={商品代码→商品名称，(商品代码，供应商)→库存量，供应商→联系方式}。商品关系模式P达到（请作答此空）；该关系模式分解成（ ）后，具有无损连接的特性，并能够保持函数依赖。",
                    "question_type": 1,
                    "answer_type": 1,
                    "show_type_name": "单选题",
                    "new_parent_id": 208400,
                    "score_rule": "",
                    "material_text": "",
                    "sort_son": "0",
                    "analyze": "<p>根据题意，零件P关系中的(商品代码，供应商)可决定的零件P关系的所有属性，所以零件P关系的主键为(商品代码，供应商)；又因为，根据题意(商品代码，供应商)→商品名称，而商品代码→商品名称，存在部分依赖关系不满足2NF，因此该关系模式属于1NF。</p><p>由于关系模式P属于1NF，1NF存在冗余度大、修改操作的不一致性、插入异常和删除异常四个问题。所以需要对模式分解，其中选项A、选项B和选项C分解后的P1∩P2=?，是有损连接，并且分解后的关系式丢失了函数依赖，如选项A中的P1(商品代码，联系方式)与原F关系式中的“商品代码→商品”不相符，即不保持函数依赖。</p>",
                    "like": 0,
                    "answer": [
                        "A"
                    ],
                    "option": [
                        " 1NF ",
                        " 2NF ",
                        " 3NF ",
                        " BCNF "
                    ]
                },
                {
                    "index": 106,
                    "belong_page": 1,
                    "question_id": 208401,
                    "question_title": "某商场商品数据库的商品关系模式P(商品代码，商品名称，供应商，联系方式，库存量)，函数依赖集F={商品代码→商品名称，(商品代码，供应商)→库存量，供应商→联系方式}。商品关系模式P达到（ ）；该关系模式分解成（请作答此空）后，具有无损连接的特性，并能够保持函数依赖。",
                    "question_type": 1,
                    "answer_type": 1,
                    "show_type_name": "单选题",
                    "new_parent_id": 208401,
                    "score_rule": "",
                    "material_text": "",
                    "sort_son": "0",
                    "analyze": "<p>根据题意，零件P关系中的(商品代码，供应商)可决定的零件P关系的所有属性，所以零件P关系的主键为(商品代码，供应商)；又因为，根据题意(商品代码，供应商)→商品名称，而商品代码→商品名称，存在部分依赖关系不满足2NF，因此该关系模式属于1NF。</p><p>由于关系模式P属于1NF，1NF存在冗余度大、修改操作的不一致性、插入异常和删除异常四个问题。所以需要对模式分解，其中选项A、选项B和选项C分解后的P1∩P2=?，是有损连接，并且分解后的关系式丢失了函数依赖，如选项A中的P1(商品代码，联系方式)与原F关系式中的“商品代码→商品”不相符，即不保持函数依赖。</p>",
                    "like": 0,
                    "answer": [
                        "D"
                    ],
                    "option": [
                        " P1(商品代码，联系方式)，P2(商品名称，供应商，库存量) ",
                        " P1(商品名称，联系方式)，P2(商品代码，供应商，库存量) ",
                        " P1(商品代码，商品名称，联系方式)，P2(供应商，库存量) ",
                        " P1(商品代码，商品名称)，P2(商品代码，供应商，库存量)，P3(供应商，联系方式) "
                    ]
                },
                {
                    "index": 107,
                    "belong_page": 1,
                    "question_id": 208437,
                    "question_title": "<span style=\"font-size: 16px;\">在数据库系统中，“事务”是访问数据库并可能更新各种数据项的一个程序执行单元。为了保证数据完整性，要求数据库系统维护事务的原子性、一致性、隔离性和持久性。针对事务的这4种特性，考虑以下的架构设计场景：</span><p>假设在某一个时刻只有一个活动的事务，为了保证事务的原子性，对于要执行写操作的数据项，数据库系统在磁盘上维护数据库的一个副本，所有的写操作都在数据库副本上执行，而保持原始数据库不变，如果在任一时刻操作不得不中止，系统仅需要删除副本，原数据库没有受到任何影响。这种设计策略称为（请作答此空）。</p><p>事务的一致性要求在没有其他事务并发执行的情况下，事务的执行应该保证数据库的一致性。数据库系统通常采用（ ）机制保证单个事务的一致性。</p><p>事务的隔离性保证操作并发执行后的系统状态与这些操作以某种次序顺序执行(即可串行化执行)后的状态是等价的。两阶段锁协议是实现隔离性的常见方案，该协议（ ）。</p><p>持久性保证一旦事务完成，该事务对数据库所做的所有更新都是永久的，如果事务完成后系统出现故障，则需要通过恢复机制保证事务的持久性。假设在日志中记录所有对数据库的修改操作，将一个事务的所有写操作延迟到事务提交后才执行，则在日志中（ ），当系统发生故障时，如果某个事务已经开始，但没有提交，则该事务应该（ ）。</p>",
                    "question_type": 1,
                    "answer_type": 1,
                    "show_type_name": "单选题",
                    "new_parent_id": 208437,
                    "score_rule": "",
                    "material_text": "",
                    "sort_son": "0",
                    "analyze": "<p>题干中第1个架构设计场景描述了数据库设计中为了实现原子性和持久性的最为简单的策略：“影子拷贝”。该策略假设在某一个时刻只有一个活动的事务，首先对数据库做副本(称为影子副本)，并在磁盘上维护一个dp_poimer指针，指向数据库的当前副本。对于要执行写操作的数据项，数据库系统在磁盘上维护数据库的一个副本，所有的写操作都在数据库副本上执行，而保持原始数据库不变，如果在任一时刻操作不得不中止，系统仅需要删除新副本，原数据库副本没有受到任何影响。</p><p>题干中的第2个架构设计场景主要考查考生对事务一致性实现机制的理解。事务的一致性要求在没有其他事务并发执行的情况下，事务的执行应该保证数据库的一致性。数据库系统通常采用完整性约束检查机制保证单个事务的一致性。</p><p>题干中的第3个架构设计场景主要考查数据库的锁协议。两阶段锁协议是实现事务隔离性的常见方案，该协议通过定义锁的增长和收缩两个阶段约束事务的加锁和解锁过程，能够保证事务的串行化执行，但由于事务不能一次得到所有需要的锁，因此该协议会可能会导致死锁。</p><p>题干中的第4个架构设计场景主要考查数据库的恢复机制，主要描述了基于日志的延迟修改技术(deferred-modification technique)的设计与恢复过程。该技术通过在日志中记录所有对数据库的修改操作，将一个事务的所有写操作延迟到事务提交后才执行，日志中需要记录“事务开始”和“事务提交”时间，还需要记录数据项被事务修改后的新值，无需记录数据项被事务修改前的原始值。当系统发生故障时，如果某个事务已经开始，但没有提交，则该事务对数据项的修改尚未体现在数据库中，因此无需做任何恢复动作。如果事务已经提交则进行重做处理，而尚未完成的事务是进行撤销处理。</p>",
                    "like": 0,
                    "answer": [
                        "B"
                    ],
                    "option": [
                        " 主动冗余 ",
                        " 影子拷贝 ",
                        " 热备份 ",
                        " 多版本编程 "
                    ]
                },
                {
                    "index": 108,
                    "belong_page": 1,
                    "question_id": 208438,
                    "question_title": "<p>在数据库系统中，“事务”是访问数据库并可能更新各种数据项的一个程序执行单元。为了保证数据完整性，要求数据库系统维护事务的原子性、一致性、隔离性和持久性。针对事务的这4种特性，考虑以下的架构设计场景：</p><p>假设在某一个时刻只有一个活动的事务，为了保证事务的原子性，对于要执行写操作的数据项，数据库系统在磁盘上维护数据库的一个副本，所有的写操作都在数据库副本上执行，而保持原始数据库不变，如果在任一时刻操作不得不中止，系统仅需要删除副本，原数据库没有受到任何影响。这种设计策略称为（ ）。</p><p>事务的一致性要求在没有其他事务并发执行的情况下，事务的执行应该保证数据库的一致性。数据库系统通常采用（请作答此空）机制保证单个事务的一致性。</p><p>事务的隔离性保证操作并发执行后的系统状态与这些操作以某种次序顺序执行(即可串行化执行)后的状态是等价的。两阶段锁协议是实现隔离性的常见方案，该协议（ ）。</p><p>持久性保证一旦事务完成，该事务对数据库所做的所有更新都是永久的，如果事务完成后系统出现故障，则需要通过恢复机制保证事务的持久性。假设在日志中记录所有对数据库的修改操作，将一个事务的所有写操作延迟到事务提交后才执行，则在日志中（ ），当系统发生故障时，如果某个事务已经开始，但没有提交，则该事务应该（ ）。<span style=\"font-size: 16px;\"></span></p>",
                    "question_type": 1,
                    "answer_type": 1,
                    "show_type_name": "单选题",
                    "new_parent_id": 208438,
                    "score_rule": "",
                    "material_text": "",
                    "sort_son": "0",
                    "analyze": "<p>题干中第1个架构设计场景描述了数据库设计中为了实现原子性和持久性的最为简单的策略：“影子拷贝”。该策略假设在某一个时刻只有一个活动的事务，首先对数据库做副本(称为影子副本)，并在磁盘上维护一个dp_poimer指针，指向数据库的当前副本。对于要执行写操作的数据项，数据库系统在磁盘上维护数据库的一个副本，所有的写操作都在数据库副本上执行，而保持原始数据库不变，如果在任一时刻操作不得不中止，系统仅需要删除新副本，原数据库副本没有受到任何影响。</p><p>题干中的第2个架构设计场景主要考查考生对事务一致性实现机制的理解。事务的一致性要求在没有其他事务并发执行的情况下，事务的执行应该保证数据库的一致性。数据库系统通常采用完整性约束检查机制保证单个事务的一致性。</p><p>题干中的第3个架构设计场景主要考查数据库的锁协议。两阶段锁协议是实现事务隔离性的常见方案，该协议通过定义锁的增长和收缩两个阶段约束事务的加锁和解锁过程，能够保证事务的串行化执行，但由于事务不能一次得到所有需要的锁，因此该协议会可能会导致死锁。</p><p>题干中的第4个架构设计场景主要考查数据库的恢复机制，主要描述了基于日志的延迟修改技术(deferred-modification technique)的设计与恢复过程。该技术通过在日志中记录所有对数据库的修改操作，将一个事务的所有写操作延迟到事务提交后才执行，日志中需要记录“事务开始”和“事务提交”时间，还需要记录数据项被事务修改后的新值，无需记录数据项被事务修改前的原始值。当系统发生故障时，如果某个事务已经开始，但没有提交，则该事务对数据项的修改尚未体现在数据库中，因此无需做任何恢复动作。如果事务已经提交则进行重做处理，而尚未完成的事务是进行撤销处理。</p>",
                    "like": 0,
                    "answer": [
                        "C"
                    ],
                    "option": [
                        " 逻辑正确性检查 ",
                        " 物理正确性检查 ",
                        " 完整性约束检查 ",
                        " 唯一性检查 "
                    ]
                },
                {
                    "index": 109,
                    "belong_page": 1,
                    "question_id": 208439,
                    "question_title": "<p>在数据库系统中，“事务”是访问数据库并可能更新各种数据项的一个程序执行单元。为了保证数据完整性，要求数据库系统维护事务的原子性、一致性、隔离性和持久性。针对事务的这4种特性，考虑以下的架构设计场景：</p><p>假设在某一个时刻只有一个活动的事务，为了保证事务的原子性，对于要执行写操作的数据项，数据库系统在磁盘上维护数据库的一个副本，所有的写操作都在数据库副本上执行，而保持原始数据库不变，如果在任一时刻操作不得不中止，系统仅需要删除副本，原数据库没有受到任何影响。这种设计策略称为（ ）。</p><p>事务的一致性要求在没有其他事务并发执行的情况下，事务的执行应该保证数据库的一致性。数据库系统通常采用（ ）机制保证单个事务的一致性。</p><p>事务的隔离性保证操作并发执行后的系统状态与这些操作以某种次序顺序执行(即可串行化执行)后的状态是等价的。两阶段锁协议是实现隔离性的常见方案，该协议（请作答此空）。</p><p>持久性保证一旦事务完成，该事务对数据库所做的所有更新都是永久的，如果事务完成后系统出现故障，则需要通过恢复机制保证事务的持久性。假设在日志中记录所有对数据库的修改操作，将一个事务的所有写操作延迟到事务提交后才执行，则在日志中（ ），当系统发生故障时，如果某个事务已经开始，但没有提交，则该事务应该（ ）。<span style=\"font-size: 16px;\"></span></p>",
                    "question_type": 1,
                    "answer_type": 1,
                    "show_type_name": "单选题",
                    "new_parent_id": 208439,
                    "score_rule": "",
                    "material_text": "",
                    "sort_son": "0",
                    "analyze": "<p>题干中第1个架构设计场景描述了数据库设计中为了实现原子性和持久性的最为简单的策略：“影子拷贝”。该策略假设在某一个时刻只有一个活动的事务，首先对数据库做副本(称为影子副本)，并在磁盘上维护一个dp_poimer指针，指向数据库的当前副本。对于要执行写操作的数据项，数据库系统在磁盘上维护数据库的一个副本，所有的写操作都在数据库副本上执行，而保持原始数据库不变，如果在任一时刻操作不得不中止，系统仅需要删除新副本，原数据库副本没有受到任何影响。</p><p>题干中的第2个架构设计场景主要考查考生对事务一致性实现机制的理解。事务的一致性要求在没有其他事务并发执行的情况下，事务的执行应该保证数据库的一致性。数据库系统通常采用完整性约束检查机制保证单个事务的一致性。</p><p>题干中的第3个架构设计场景主要考查数据库的锁协议。两阶段锁协议是实现事务隔离性的常见方案，该协议通过定义锁的增长和收缩两个阶段约束事务的加锁和解锁过程，能够保证事务的串行化执行，但由于事务不能一次得到所有需要的锁，因此该协议会可能会导致死锁。</p><p>题干中的第4个架构设计场景主要考查数据库的恢复机制，主要描述了基于日志的延迟修改技术(deferred-modification technique)的设计与恢复过程。该技术通过在日志中记录所有对数据库的修改操作，将一个事务的所有写操作延迟到事务提交后才执行，日志中需要记录“事务开始”和“事务提交”时间，还需要记录数据项被事务修改后的新值，无需记录数据项被事务修改前的原始值。当系统发生故障时，如果某个事务已经开始，但没有提交，则该事务对数据项的修改尚未体现在数据库中，因此无需做任何恢复动作。如果事务已经提交则进行重做处理，而尚未完成的事务是进行撤销处理。</p>",
                    "like": 0,
                    "answer": [
                        "A"
                    ],
                    "option": [
                        " 能够保证事务的可串行化执行，可能发生死锁 ",
                        " 不能保证事务的可串行化执行，不会发生死锁 ",
                        " 不能保证事务的可串行化执行，可能发生死锁 ",
                        " 能够保证事务的可串行化执行，不会发生死锁 "
                    ]
                },
                {
                    "index": 110,
                    "belong_page": 1,
                    "question_id": 208440,
                    "question_title": "<p>在数据库系统中，“事务”是访问数据库并可能更新各种数据项的一个程序执行单元。为了保证数据完整性，要求数据库系统维护事务的原子性、一致性、隔离性和持久性。针对事务的这4种特性，考虑以下的架构设计场景：</p><p>假设在某一个时刻只有一个活动的事务，为了保证事务的原子性，对于要执行写操作的数据项，数据库系统在磁盘上维护数据库的一个副本，所有的写操作都在数据库副本上执行，而保持原始数据库不变，如果在任一时刻操作不得不中止，系统仅需要删除副本，原数据库没有受到任何影响。这种设计策略称为（ ）。</p><p>事务的一致性要求在没有其他事务并发执行的情况下，事务的执行应该保证数据库的一致性。数据库系统通常采用（ ）机制保证单个事务的一致性。</p><p>事务的隔离性保证操作并发执行后的系统状态与这些操作以某种次序顺序执行(即可串行化执行)后的状态是等价的。两阶段锁协议是实现隔离性的常见方案，该协议（ ）。</p><p>持久性保证一旦事务完成，该事务对数据库所做的所有更新都是永久的，如果事务完成后系统出现故障，则需要通过恢复机制保证事务的持久性。假设在日志中记录所有对数据库的修改操作，将一个事务的所有写操作延迟到事务提交后才执行，则在日志中（请作答此空），当系统发生故障时，如果某个事务已经开始，但没有提交，则该事务应该（ ）。<span style=\"font-size: 16px;\"></span></p>",
                    "question_type": 1,
                    "answer_type": 1,
                    "show_type_name": "单选题",
                    "new_parent_id": 208440,
                    "score_rule": "",
                    "material_text": "",
                    "sort_son": "0",
                    "analyze": "<p>题干中第1个架构设计场景描述了数据库设计中为了实现原子性和持久性的最为简单的策略：“影子拷贝”。该策略假设在某一个时刻只有一个活动的事务，首先对数据库做副本(称为影子副本)，并在磁盘上维护一个dp_poimer指针，指向数据库的当前副本。对于要执行写操作的数据项，数据库系统在磁盘上维护数据库的一个副本，所有的写操作都在数据库副本上执行，而保持原始数据库不变，如果在任一时刻操作不得不中止，系统仅需要删除新副本，原数据库副本没有受到任何影响。</p><p>题干中的第2个架构设计场景主要考查考生对事务一致性实现机制的理解。事务的一致性要求在没有其他事务并发执行的情况下，事务的执行应该保证数据库的一致性。数据库系统通常采用完整性约束检查机制保证单个事务的一致性。</p><p>题干中的第3个架构设计场景主要考查数据库的锁协议。两阶段锁协议是实现事务隔离性的常见方案，该协议通过定义锁的增长和收缩两个阶段约束事务的加锁和解锁过程，能够保证事务的串行化执行，但由于事务不能一次得到所有需要的锁，因此该协议会可能会导致死锁。</p><p>题干中的第4个架构设计场景主要考查数据库的恢复机制，主要描述了基于日志的延迟修改技术(deferred-modification technique)的设计与恢复过程。该技术通过在日志中记录所有对数据库的修改操作，将一个事务的所有写操作延迟到事务提交后才执行，日志中需要记录“事务开始”和“事务提交”时间，还需要记录数据项被事务修改后的新值，无需记录数据项被事务修改前的原始值。当系统发生故障时，如果某个事务已经开始，但没有提交，则该事务对数据项的修改尚未体现在数据库中，因此无需做任何恢复动作。如果事务已经提交则进行重做处理，而尚未完成的事务是进行撤销处理。</p>",
                    "like": 0,
                    "answer": [
                        "D"
                    ],
                    "option": [
                        " 无需记录“事务开始执行”这一事件 ",
                        " 无需记录“事务已经提交”这一事件 ",
                        " 无需记录数据项被事务修改后的新值 ",
                        " 无需记录数据项被事务修改前的原始值 "
                    ]
                },
                {
                    "index": 111,
                    "belong_page": 1,
                    "question_id": 208441,
                    "question_title": "<p>在数据库系统中，“事务”是访问数据库并可能更新各种数据项的一个程序执行单元。为了保证数据完整性，要求数据库系统维护事务的原子性、一致性、隔离性和持久性。针对事务的这4种特性，考虑以下的架构设计场景：</p><p>假设在某一个时刻只有一个活动的事务，为了保证事务的原子性，对于要执行写操作的数据项，数据库系统在磁盘上维护数据库的一个副本，所有的写操作都在数据库副本上执行，而保持原始数据库不变，如果在任一时刻操作不得不中止，系统仅需要删除副本，原数据库没有受到任何影响。这种设计策略称为（ ）。</p><p>事务的一致性要求在没有其他事务并发执行的情况下，事务的执行应该保证数据库的一致性。数据库系统通常采用（ ）机制保证单个事务的一致性。</p><p>事务的隔离性保证操作并发执行后的系统状态与这些操作以某种次序顺序执行(即可串行化执行)后的状态是等价的。两阶段锁协议是实现隔离性的常见方案，该协议（ ）。</p><p>持久性保证一旦事务完成，该事务对数据库所做的所有更新都是永久的，如果事务完成后系统出现故障，则需要通过恢复机制保证事务的持久性。假设在日志中记录所有对数据库的修改操作，将一个事务的所有写操作延迟到事务提交后才执行，则在日志中（ ），当系统发生故障时，如果某个事务已经开始，但没有提交，则该事务应该（请作答此空）。<span style=\"font-size: 16px;\"></span></p>",
                    "question_type": 1,
                    "answer_type": 1,
                    "show_type_name": "单选题",
                    "new_parent_id": 208441,
                    "score_rule": "",
                    "material_text": "",
                    "sort_son": "0",
                    "analyze": "<p>题干中第1个架构设计场景描述了数据库设计中为了实现原子性和持久性的最为简单的策略：“影子拷贝”。该策略假设在某一个时刻只有一个活动的事务，首先对数据库做副本(称为影子副本)，并在磁盘上维护一个dp_poimer指针，指向数据库的当前副本。对于要执行写操作的数据项，数据库系统在磁盘上维护数据库的一个副本，所有的写操作都在数据库副本上执行，而保持原始数据库不变，如果在任一时刻操作不得不中止，系统仅需要删除新副本，原数据库副本没有受到任何影响。</p><p>题干中的第2个架构设计场景主要考查考生对事务一致性实现机制的理解。事务的一致性要求在没有其他事务并发执行的情况下，事务的执行应该保证数据库的一致性。数据库系统通常采用完整性约束检查机制保证单个事务的一致性。</p><p>题干中的第3个架构设计场景主要考查数据库的锁协议。两阶段锁协议是实现事务隔离性的常见方案，该协议通过定义锁的增长和收缩两个阶段约束事务的加锁和解锁过程，能够保证事务的串行化执行，但由于事务不能一次得到所有需要的锁，因此该协议会可能会导致死锁。</p><p>题干中的第4个架构设计场景主要考查数据库的恢复机制，主要描述了基于日志的延迟修改技术(deferred-modification technique)的设计与恢复过程。该技术通过在日志中记录所有对数据库的修改操作，将一个事务的所有写操作延迟到事务提交后才执行，日志中需要记录“事务开始”和“事务提交”时间，还需要记录数据项被事务修改后的新值，无需记录数据项被事务修改前的原始值。当系统发生故障时，如果某个事务已经开始，但没有提交，则该事务对数据项的修改尚未体现在数据库中，因此无需做任何恢复动作。如果事务已经提交则进行重做处理，而尚未完成的事务是进行撤销处理。</p>",
                    "like": 0,
                    "answer": [
                        "C"
                    ],
                    "option": [
                        " 重做 ",
                        " 撤销 ",
                        " 什么都不做 ",
                        " 抛出异常后退出 "
                    ]
                },
                {
                    "index": 112,
                    "belong_page": 1,
                    "question_id": 208473,
                    "question_title": "假设关系模式R(U，F)，属性集U={A，B，C}，函数依赖集F={A→B，B→C}。若将其分解为ρ={R1(U1，F1)，R2(U2，F2)}，其中U1={A，B}，U2={A，C}。那么，关系模式R、R1、R2分别达到了（请作答此空）；分解ρ（ ）。",
                    "question_type": 1,
                    "answer_type": 1,
                    "show_type_name": "单选题",
                    "new_parent_id": 208473,
                    "score_rule": "",
                    "material_text": "",
                    "sort_son": "0",
                    "analyze": "<p>由关系模式R的函数依赖集F={A→B，B→C}可以得出A→C，存在传递依赖，但不存在非主属性对码的部分函数依赖，故R为2NF。又由于分解后的关系模式R1的函数依赖集F1={A→B}，关系模式R2的函数依赖集F2={A→C}，因此R1、R2分别达到了3NF。因为F=F1∪F2，所以分解p保持函数依赖。又由于关系模式R(U，F)的一个分解ρ={R1(U1，F1)，R2(U2，F2)}具有无损连接的充分必要的条件是：U1∩U2→U1-U2∈F+或U1∩U2→U2-U1∈F+。分解ρ是否无损连接分析如下：</p><p>AB∩AC=A，AB-AC=B，AC-AB=C</p><p>A→B∈F+，A→C∈F+</p><p>根据无损连接的充分必要的条件可知ρ为无损连接。</p>",
                    "like": 0,
                    "answer": [
                        "D"
                    ],
                    "option": [
                        " 1NF、2NF、3NF ",
                        " 1NF、3NF、3NF ",
                        " 2NF、2NF、3NF ",
                        " 2NF、3NF、3NF "
                    ]
                },
                {
                    "index": 113,
                    "belong_page": 1,
                    "question_id": 208474,
                    "question_title": "<p>假设关系模式R(U，F)，属性集U={A，B，C}，函数依赖集F={A→B，B→C}。若将其分解为ρ={R1(U1，F1)，R2(U2，F2)}，其中U1={A，B}，U2={A，C}。那么，关系模式R、R1、R2分别达到了（ ）；分解ρ（请作答此空）。</p>",
                    "question_type": 1,
                    "answer_type": 1,
                    "show_type_name": "单选题",
                    "new_parent_id": 208474,
                    "score_rule": "",
                    "material_text": "",
                    "sort_son": "0",
                    "analyze": "<p>因为F=F1∪F2，所以分解ρ保持函数依赖。又由于关系模式R（U，F）的一个分解ρ｛R1（U1，F1），R2（U2，F2）｝具有无损连接的充分必要条件是：U1∩U2→U1-U2∈F<sup>+</sup>或U1∩U2→U2-U1∈F<sup>+</sup>。分解ρ是否无损连接分析如下：<br/>∵ AB∩AC=A，AB-AC=B, AC-AB=C<br/>∴ A→B∈F<sup>+</sup>，A→C∈F<sup>+</sup><br/>∴ 根据无损连接的充分必要条件可知ρ为无损连接<br/></p>",
                    "like": 0,
                    "answer": [
                        "B"
                    ],
                    "option": [
                        " 有损连接但保持函数依赖 ",
                        " 既无损连接又保持函数依赖 ",
                        " 有损连接且不保持函数依赖 ",
                        " 无损连接但不保持函数依赖 "
                    ]
                },
                {
                    "index": 114,
                    "belong_page": 1,
                    "question_id": 208475,
                    "question_title": "<p>给定员工关系EMP(EmpID，Ename，sex，age，tel，DepID)，其属性含义分别为：员工号、姓名、性别、年龄、电话、部门号；部门关系DEP(DepID，Dname，Dtel，DEmpID)，其属性含义分别为：部门号、部门名、电话，负责人号。若要求DepID参照部门关系DEP的主码DepID，则可以在定义EMP时用（请作答此空）进行约束。若要查询开发部的负责人姓名、年龄，则正确的关系代数表达式为（ ）。</p>",
                    "question_type": 1,
                    "answer_type": 1,
                    "show_type_name": "单选题",
                    "new_parent_id": 208475,
                    "score_rule": "",
                    "material_text": "",
                    "sort_son": "0",
                    "analyze": "<p>员工关系中的：DepID是一个外键，为了保证数据的正确性，通过参照完整性加以约束。SQL语言通过使用保留字Foreign Key定义外键，References指明外码对应于哪个表的主码。参照完整性定义格式如下：</p><p>Foreign Key(属性名) References表名(属性名)</p><p>可见，若要求DepID参照部门关系DEP的主码DepID，则可以在定义EMP时用“Foreign Key(DepID) References DEP(DepID)”进行约束。</p>",
                    "like": 0,
                    "answer": [
                        "C"
                    ],
                    "option": [
                        " Primary Key(DepID) On DEP(DepID) ",
                        " Primary Key(DepID) On EMP(DepID) ",
                        " Foreign Key(DepID) References DEP(DepID) ",
                        " Foreign Key(DepID) References EMP(DepID) "
                    ]
                },
                {
                    "index": 115,
                    "belong_page": 1,
                    "question_id": 208476,
                    "question_title": "<p>给定员工关系&nbsp;EMP(EmpID,&nbsp;Ename,&nbsp;sex,&nbsp;age,&nbsp;tel,&nbsp;DepID)，其属性含义分别为：员工号、姓名、性别、年龄、电话、部门号；部门关系&nbsp;DEP(DepID,&nbsp;Dname,&nbsp;Dtel,&nbsp;DEmpID)，其属性含义分别为：部门号、部门名、电话，负责人号。若要求&nbsp;DepID&nbsp;参照部门关系&nbsp;DEP&nbsp;的主码&nbsp;DepID，则可以在定义&nbsp;EMP&nbsp;时用（&nbsp;）进行约束。若要查询开发部的负责人姓名、年龄，则正确的关系代数表达式为（请作答此空）。</p>",
                    "question_type": 1,
                    "answer_type": 1,
                    "show_type_name": "单选题",
                    "new_parent_id": 208476,
                    "score_rule": "",
                    "material_text": "",
                    "sort_son": "0",
                    "analyze": "<p>本题要求“查询开发部的负责人姓名、年龄”的关系代数表达式，选项B是先进行σ2=&#39;开发部&#39;(DEP)运算，即在DEP关系中选择部门名Dname=&#39;开发部&#39;的元组；然后将EMP关系与其进行EMP.DepID=DEP.DepID的自然连接，并去掉右边的重复属性“DERDepID”，自然连接后的属性列为(EmpID，Ename，sex，age，tel，DepID，Dname，Dtel，DEmpID)；在此基础上进行σ1=9运算，即进行员工号EmpID等于部门负责人号DEmpID的选取运算；最后进行属性列2(Ename)和属性列4(age)的投影运算。</p>",
                    "like": 0,
                    "answer": [
                        "B"
                    ],
                    "option": [
                        " <img style=\"max-width:100%;height:auto\" src=\"https://s2.51cto.com/images/20210419/1618812921804654.png\" title=\"1618812921804654.png\" alt=\"208476-a.png\"/> ",
                        " <img style=\"max-width:100%;height:auto\" src=\"https://s2.51cto.com/images/20220729/1659065505311462.png\" title=\"1659065505311462.png\" alt=\"fe27b949cb6838970da3f1f2e0170a0.png\"/> ",
                        " <img style=\"max-width:100%;height:auto\" src=\"https://s2.51cto.com/images/20210419/1618812930677452.png\" title=\"1618812930677452.png\" alt=\"208476-c.png\"/> ",
                        " <img style=\"max-width:100%;height:auto\" src=\"https://s2.51cto.com/images/20210419/1618812934838563.png\" title=\"1618812934838563.png\" alt=\"208476-d.png\"/> "
                    ]
                },
                {
                    "index": 116,
                    "belong_page": 1,
                    "question_id": 281180,
                    "question_title": "<p>假设员工关系EMP(员工号，姓名，性别，部门，部门电话，部门负责人，家庭住址，家庭成员，成员关系)如下表所示。如果一个部门只能有一部电话和一位负责人，一个员工可以有多个家庭成员，那么关系EMP属于（），且（）问题；为了解决这一问题，应该将员工关系EMP分解为 （）。<br/><img style=\"max-width:100%;height:auto\"  src=\"https://s2.51cto.com/images/20200912/1599876514727094.jpg\" title=\"1599876514727094.jpg\" alt=\"1.jpg\"/></p>",
                    "question_type": 9,
                    "answer_type": 1,
                    "show_type_name": "单选题",
                    "new_parent_id": 281179,
                    "score_rule": "",
                    "material_text": null,
                    "sort_son": "1",
                    "analyze": "主键是（员工号、家庭成员）部门名等非主属性对其存在部分依赖，不符合2NF。",
                    "like": 0,
                    "answer": [
                        "A"
                    ],
                    "option": [
                        "1NF",
                        "2NF",
                        "3NF",
                        "BCNF"
                    ]
                },
                {
                    "index": 117,
                    "belong_page": 1,
                    "question_id": 281181,
                    "question_title": "<p>假设员工关系EMP(员工号，姓名，性别，部门，部门电话，部门负责人，家庭住址，家庭成员，成员关系)如下表所示。如果一个部门只能有一部电话和一位负责人，一个员工可以有多个家庭成员，那么关系EMP属于（），且（）问题；为了解决这一问题，应该将员工关系EMP分解为 （）。<br/><img style=\"max-width:100%;height:auto\"  src=\"https://s2.51cto.com/images/20200912/1599876514727094.jpg\" title=\"1599876514727094.jpg\" alt=\"1.jpg\"/></p>",
                    "question_type": 9,
                    "answer_type": 1,
                    "show_type_name": "单选题",
                    "new_parent_id": 281179,
                    "score_rule": "",
                    "material_text": null,
                    "sort_son": "2",
                    "analyze": "存在存在冗余、修改操作的不一致，以及插入异常和删除异常。",
                    "like": 0,
                    "answer": [
                        "D"
                    ],
                    "option": [
                        "无冗余、无插入异常和删除异常",
                        "无冗余，但存在插入异常和删除异常",
                        "存在冗余，但不存在修改操作的不一致",
                        "存在冗余、修改操作的不一致，以及插入异常和删除异常"
                    ]
                },
                {
                    "index": 118,
                    "belong_page": 1,
                    "question_id": 281182,
                    "question_title": "<p>假设员工关系EMP(员工号，姓名，性别，部门，部门电话，部门负责人，家庭住址，家庭成员，成员关系)如下表所示。如果一个部门只能有一部电话和一位负责人，一个员工可以有多个家庭成员，那么关系EMP属于（），且（）问题；为了解决这一问题，应该将员工关系EMP分解为 （）。<br/><img style=\"max-width:100%;height:auto\"  src=\"https://s2.51cto.com/images/20200912/1599876514727094.jpg\" title=\"1599876514727094.jpg\" alt=\"1.jpg\"/></p>",
                    "question_type": 9,
                    "answer_type": 1,
                    "show_type_name": "单选题",
                    "new_parent_id": 281179,
                    "score_rule": "",
                    "material_text": null,
                    "sort_son": "3",
                    "analyze": "<p>因为对一个给定的关系模式进行分解，使得分解后的模式是否与原来的模式等价有如下三种情况：</p><p>①分解具有无损连接性；</p><p>②分解要保持函数依赖；</p><p>③分解既要无损连接性，又要保持函数依赖。</p><p>选项A是错误的，因为将原关系模式分解成EMP1(员工号，姓名，家庭住址)，</p><p>EMP2(部门，部门电话，部门负责人)和EMP3(员工号，家庭成员，成员关系)三个关系模式，分解后的关系模式既具有损连接，又不能保持函数依赖。因为此时给定员工号已无法查找所在的部门。</p><p>选项B是正确的，因为将原关系模式分解成EMP1(员工号，姓名，部门，家庭住址)，EMP2(部门，部门电话，部门负责人)和EMP3(员工号，家庭成员，成员关系)既具有无损连接性，又保持了函数依赖。</p><p>选项C是错误的，因为将原关系模式分解成EMP1(员工号，姓名，家庭住址)和 EMP2(部门，部门电话，部门负责人，家庭成员，成员关系)两个关系模式，分解后的关系模式既具有损连接，又不能保持函数依赖。例如，给定员工号无法查找所在的部门，无法查找其家庭成员等信息。</p><p>选项D是错误的，因为将原关系模式分解成EMP1(员工号，姓名，部门，部门电话，部门负责人，家庭住址)和EMP2(员工号，家庭住址，家庭成员，成员关系)两个关系模式后，所得的关系模式存在冗余和修改操作的不一致性。例如，EMP1中某员工的家庭住址从“陕西省西安市太白路2号”修改为“陕西省西安市雁塔路18号”，而 EMP2中该员工的家庭住址未修改，导致修改操作的不一致性。又如，EMP2中某员工的家庭成员有5个，那么其家庭住址就要重复出现5次，导致数据的冗余。<span style=\"font-size: 16px;\"></span></p>",
                    "like": 0,
                    "answer": [
                        "B"
                    ],
                    "option": [
                        " EMP1(员工号，姓名，性别，家庭住址)  EMP2(部门，部门电话，部门负责人)  EMP3(员工号，家庭成员，成员关系) ",
                        " EMP1(员工号，姓名，性别，部门，家庭住址)  EMP2(部门，部门电话，部门负责人)  EMP3(员工号，家庭成员，成员关系) ",
                        " EMP1(员工号，姓名，性别，家庭住址)  EMP2 (部门，部门电话，部门负责人，家庭成员，成员关系) ",
                        " EMP1(员工号，姓名，性别，部门，部门电话，部门负责人，家庭住址)  EMP2(员工号，家庭住址，家庭成员，成员关系) "
                    ]
                },
                {
                    "index": 119,
                    "belong_page": 1,
                    "question_id": 281184,
                    "question_title": "关系R、S如下图所示，关系代数表达式π3,4,5(σ1＜6(R×S)= （ ） ，对关系R、S进行自然连接后的属性列数和元组个数分别为（ ）。<br/><img style=\"max-width:100%;height:auto\"  src=\"https://s2.51cto.com/images/20200912/1599876679352814.jpg\" title=\"1599876679352814.jpg\" alt=\"1.jpg\"/>",
                    "question_type": 9,
                    "answer_type": 1,
                    "show_type_name": "单选题",
                    "new_parent_id": 281183,
                    "score_rule": "",
                    "material_text": null,
                    "sort_son": "1",
                    "analyze": "<p>R×S后的结果如表7.6所示。</p><p><img style=\"max-width:100%;height:auto\"  src=\"https://s2.51cto.com/images/20200912/1599876762263919.jpg\" title=\"1599876762263919.jpg\" alt=\"1.jpg\"/></p><p>π3,4,5(σ1＜6(R×S)=</p><p>3、4、5列对应的是R.C、S.A、S.B，其中第一列小于第6列的值(即1＜6)是第一、第三元组。故第24题的答案选B。</p><p>设A1，A2，...，An是R和S的公共属性，当且仅当R的元组r与S的元组s在1，A2，…，An上都一致时，元组s和r组合成为R和S自然连接的一个元组。</p><p>由此可得，R和S的公共属性为A、B、C，但R和S在属性A、B、C上的值不等，故自然连接后，属性列数为3，元组个数为0。<span style=\"font-size: 16px;\"></span></p>",
                    "like": 0,
                    "answer": [
                        "B"
                    ],
                    "option": [
                        "<img style=\"max-width:100%;height:auto\" src=\"https://s2.51cto.com/images/20200912/1599876703810265.jpg\" title=\"1599876703810265.jpg\" alt=\"1.jpg\"/>",
                        "<img style=\"max-width:100%;height:auto\" src=\"https://s2.51cto.com/images/20200912/1599876707861789.jpg\" title=\"1599876707861789.jpg\" alt=\"2.jpg\"/>",
                        "<img style=\"max-width:100%;height:auto\" src=\"https://s2.51cto.com/images/20200912/1599876710656774.jpg\" title=\"1599876710656774.jpg\" alt=\"3.jpg\"/>",
                        "<img style=\"max-width:100%;height:auto\" src=\"https://s2.51cto.com/images/20200912/1599876714327807.jpg\" title=\"1599876714327807.jpg\" alt=\"4.jpg\"/>"
                    ]
                },
                {
                    "index": 120,
                    "belong_page": 1,
                    "question_id": 281185,
                    "question_title": "关系R、S如下图所示，关系代数表达式π3,4,5(σ1＜6(R×S)= （ ） ，对关系R、S进行自然连接后的属性列数和元组个数分别为（ ）。<br/><img style=\"max-width:100%;height:auto\"  src=\"https://s2.51cto.com/images/20200912/1599876679352814.jpg\" title=\"1599876679352814.jpg\" alt=\"1.jpg\"/>",
                    "question_type": 9,
                    "answer_type": 1,
                    "show_type_name": "单选题",
                    "new_parent_id": 281183,
                    "score_rule": "",
                    "material_text": null,
                    "sort_son": "2",
                    "analyze": "<p>R×S后的结果如表7.6所示。</p><p><img style=\"max-width:100%;height:auto\"  src=\"https://s2.51cto.com/images/20200912/1599876784750089.jpg\" title=\"1599876784750089.jpg\" alt=\"1.jpg\"/></p><p>π3,4,5(σ1＜6(R×S)=</p><p>3、4、5列对应的是R.C、S.A、S.B，其中第一列小于第6列的值(即1＜6)是第一、第三元组。故第24题的答案选B。</p><p>设A1，A2，...，An是R和S的公共属性，当且仅当R的元组r与S的元组s在1，A2，…，An上都一致时，元组s和r组合成为R和S自然连接的一个元组。</p><p>由此可得，R和S的公共属性为A、B、C，但R和S在属性A、B、C上的值不等，故自然连接后，属性列数为3，元组个数为0。</p>",
                    "like": 0,
                    "answer": [
                        "A"
                    ],
                    "option": [
                        "3和0",
                        "3和2",
                        "6和0",
                        "6和2"
                    ]
                },
                {
                    "index": 121,
                    "belong_page": 1,
                    "question_id": 281317,
                    "question_title": "分布透明性指用户不必关心数据的逻辑分片，不必关心数据存储的物理位置分配细节，也不必关心局部场地上数据库的数据模型。（ ）是分布透明性的最高层次。（ ）指用户或应用程序应当了解分片情况，但不必了解片段的存储场地。（ ）透明性是指用户或应用程序应当了解分片及各片断存储的场地，但不必了解局部场地上使用的是何种数据模型。",
                    "question_type": 9,
                    "answer_type": 1,
                    "show_type_name": "单选题",
                    "new_parent_id": 281316,
                    "score_rule": "",
                    "material_text": null,
                    "sort_son": "1",
                    "analyze": "<p>分布透明性包括：分片透明性、位置透明性和局部数据模型透明性。</p><p>（1）分片透明性是分布透明性的最高层次。所谓分片透明性是指用户或应用程序只对全局关系进行操作而不必考虑数据的分片。当分片模式改变时，只要改变全局模式到分片模式的映像（映像 2），而不影响全局模式和应用程序。全局模式不变，应用程序不必改写，这就是分片透明性。</p><p>（2）位置透明性是分布透明性的下一层次。所谓位置透明性是指，用户或应用程序应当了解分片情况，但不必了解片段的存储场地。当存储场地改变时，只要改变分片模式到分配模式的映像（映像 3），而不影响应用程序。同时，若片段的重复副本数目改变了，那么数据的冗余也会改变，但用户不必关心如何保持各副本的一致性，这也提供了重复副本的透明性。</p><p>（3）局部数据模型（逻辑透明）透明性是指用户或应用程序应当了解分片及各片断存储的场地，但不必了解局部场地上使用的是何种数据模型。<span style=\"font-size: 16px;\"></span></p>",
                    "like": 0,
                    "answer": [
                        "A"
                    ],
                    "option": [
                        "分片透明性",
                        "逻辑透明性",
                        "位置透明性",
                        "全局透明性"
                    ]
                },
                {
                    "index": 122,
                    "belong_page": 1,
                    "question_id": 281318,
                    "question_title": "分布透明性指用户不必关心数据的逻辑分片，不必关心数据存储的物理位置分配细节，也不必关心局部场地上数据库的数据模型。（ ）是分布透明性的最高层次。（ ）指用户或应用程序应当了解分片情况，但不必了解片段的存储场地。（ ）透明性是指用户或应用程序应当了解分片及各片断存储的场地，但不必了解局部场地上使用的是何种数据模型。",
                    "question_type": 9,
                    "answer_type": 1,
                    "show_type_name": "单选题",
                    "new_parent_id": 281316,
                    "score_rule": "",
                    "material_text": null,
                    "sort_son": "2",
                    "analyze": "<p>分布透明性包括：分片透明性、位置透明性和局部数据模型透明性。</p><p>（1）分片透明性是分布透明性的最高层次。所谓分片透明性是指用户或应用程序只对全局关系进行操作而不必考虑数据的分片。当分片模式改变时，只要改变全局模式到分片模式的映像（映像 2），而不影响全局模式和应用程序。全局模式不变，应用程序不必改写，这就是分片透明性。</p><p>（2）位置透明性是分布透明性的下一层次。所谓位置透明性是指，用户或应用程序应当了解分片情况，但不必了解片段的存储场地。当存储场地改变时，只要改变分片模式到分配模式的映像（映像 3），而不影响应用程序。同时，若片段的重复副本数目改变了，那么数据的冗余也会改变，但用户不必关心如何保持各副本的一致性，这也提供了重复副本的透明性。</p><p>（3）局部数据模型（逻辑透明）透明性是指用户或应用程序应当了解分片及各片断存储的场地，但不必了解局部场地上使用的是何种数据模型。</p>",
                    "like": 0,
                    "answer": [
                        "C"
                    ],
                    "option": [
                        "分片透明性",
                        "逻辑透明性",
                        "位置透明性",
                        "全局透明性"
                    ]
                },
                {
                    "index": 123,
                    "belong_page": 1,
                    "question_id": 281319,
                    "question_title": "分布透明性指用户不必关心数据的逻辑分片，不必关心数据存储的物理位置分配细节，也不必关心局部场地上数据库的数据模型。（ ）是分布透明性的最高层次。（ ）指用户或应用程序应当了解分片情况，但不必了解片段的存储场地。（ ）透明性是指用户或应用程序应当了解分片及各片断存储的场地，但不必了解局部场地上使用的是何种数据模型。",
                    "question_type": 9,
                    "answer_type": 1,
                    "show_type_name": "单选题",
                    "new_parent_id": 281316,
                    "score_rule": "",
                    "material_text": null,
                    "sort_son": "3",
                    "analyze": "<p>分布透明性包括：分片透明性、位置透明性和局部数据模型透明性。</p><p>（1）分片透明性是分布透明性的最高层次。所谓分片透明性是指用户或应用程序只对全局关系进行操作而不必考虑数据的分片。当分片模式改变时，只要改变全局模式到分片模式的映像（映像 2），而不影响全局模式和应用程序。全局模式不变，应用程序不必改写，这就是分片透明性。</p><p>（2）位置透明性是分布透明性的下一层次。所谓位置透明性是指，用户或应用程序应当了解分片情况，但不必了解片段的存储场地。当存储场地改变时，只要改变分片模式到分配模式的映像（映像 3），而不影响应用程序。同时，若片段的重复副本数目改变了，那么数据的冗余也会改变，但用户不必关心如何保持各副本的一致性，这也提供了重复副本的透明性。</p><p>（3）局部数据模型（逻辑透明）透明性是指用户或应用程序应当了解分片及各片断存储的场地，但不必了解局部场地上使用的是何种数据模型。<span style=\"font-size: 16px;\"></span></p>",
                    "like": 0,
                    "answer": [
                        "B"
                    ],
                    "option": [
                        "分片透明性",
                        "逻辑透明性",
                        "位置透明性",
                        "全局透明性"
                    ]
                },
                {
                    "index": 124,
                    "belong_page": 1,
                    "question_id": 281581,
                    "question_title": "<p>某商场商品数据库的商品关系模式P(商品代码，商品名称，供应商，联系方式，库存量)，函数依赖集F={商品代码→商品名称，(商品代码，供应商)→库存量，供应商→联系方式}。商品关系模式P达到 （ ） ；该关系模式分解成 （ ） 后，具有无损连接的特性，并能够保持函数依赖。</p>",
                    "question_type": 9,
                    "answer_type": 1,
                    "show_type_name": "单选题",
                    "new_parent_id": 281580,
                    "score_rule": "",
                    "material_text": null,
                    "sort_son": "1",
                    "analyze": "<p>根据题意，P关系中的(商品代码，供应商)可决定的P关系的所有属性，所以P关系的主键为(商品代码，供应商)；又因为，根据题意(商品代码，供应商)→商品名称，而商品代码→商品名称，存在部分依赖关系不满足2NF，因此该关系模式属于1NF。</p><p>由于关系模式P属于1NF，1NF存在冗余度大、修改操作的不一致性、插入异常和删除异常四个问题。所以需要对模式分解，其中选项A、选项B和选项C分解后的P1∩P2=?，是有损连接，并且分解后的关系式丢失了函数依赖，如选项A中的P1(商品代码，联系方式)与原F关系式中的“商品代码→商品”不相符，即不保持函数依赖。</p>",
                    "like": 0,
                    "answer": [
                        "A"
                    ],
                    "option": [
                        "1NF",
                        "2NF",
                        "3NF",
                        "BCNF"
                    ]
                },
                {
                    "index": 125,
                    "belong_page": 1,
                    "question_id": 281582,
                    "question_title": "<p>某商场商品数据库的商品关系模式P(商品代码，商品名称，供应商，联系方式，库存量)，函数依赖集F={商品代码→商品名称，(商品代码，供应商)→库存量，供应商→联系方式}。商品关系模式P达到 （ ） ；该关系模式分解成 （ ） 后，具有无损连接的特性，并能够保持函数依赖。</p>",
                    "question_type": 9,
                    "answer_type": 1,
                    "show_type_name": "单选题",
                    "new_parent_id": 281580,
                    "score_rule": "",
                    "material_text": null,
                    "sort_son": "2",
                    "analyze": "<p>根据题意，P关系中的(商品代码，供应商)可决定的P关系的所有属性，所以P关系的主键为(商品代码，供应商)；又因为，根据题意(商品代码，供应商)→商品名称，而商品代码→商品名称，存在部分依赖关系不满足2NF，因此该关系模式属于1NF。</p><p>由于关系模式P属于1NF，1NF存在冗余度大、修改操作的不一致性、插入异常和删除异常四个问题。所以需要对模式分解，其中选项A、选项B和选项C分解后的P1∩P2=?，是有损连接，并且分解后的关系式丢失了函数依赖，如选项A中的P1(商品代码，联系方式)与原F关系式中的“商品代码→商品”不相符，即不保持函数依赖。</p>",
                    "like": 0,
                    "answer": [
                        "D"
                    ],
                    "option": [
                        "P1(商品代码，联系方式)，P2(商品名称，供应商，库存量)",
                        "P1(商品名称，联系方式)，P2(商品代码，供应商，库存量)",
                        "P1(商品代码，商品名称，联系方式)，P2(供应商，库存量)",
                        "P1(商品代码，商品名称)，P2(商品代码，供应商，库存量)，P3(供应商，联系方式)"
                    ]
                },
                {
                    "index": 126,
                    "belong_page": 1,
                    "question_id": 281583,
                    "question_title": "<p>设关系模式R(U, F)，其中U为属性集，F是U上的一组函数依赖，那么函数依赖的公理系统(Armstrong公理系统)中的合并规则是指（ ）为F所蕴涵。</p>",
                    "question_type": 1,
                    "answer_type": 1,
                    "show_type_name": "单选题",
                    "new_parent_id": 281583,
                    "score_rule": "",
                    "material_text": "",
                    "sort_son": "0",
                    "analyze": "<p>本题考查函数依赖推理规则。</p><p>函数依赖的公理系统(即Armstrong公理系统)为：设关系模式R(U, F)，其中U为属性集，F是U上的一组函数依赖，那么有如下推理规则：</p><p>A1自反律：若Y⊆X⊆U，则X→Y为F所蕴涵。</p><p>A2增广律：若X→Y为F所蕴涵，且Z⊆U，则XZ→YZ为F所蕴涵。</p><p>A3传递律：若X→Y，Y→Z为F所蕴涵，X→Z为F所蕴涵。</p><p>根据上述三条推理规则又可推出下述三条推理规则：</p><p>A4合并规则：若X→Y，X→Z，则X→YZ为F所蕴涵。</p><p>A5伪传递律：若X→Y，WY→Z，则XW→Z为F所蕴涵。</p><p>A6分解规则：若X→Y，Z⊆Y，则X→Z为F所蕴涵。&nbsp;</p><p>选项A符合规则为A3，即传递规则；选项B符合规则为A1，即为自反规则；选项C符合规则为A4，即为合并规则；选项D符合规则为A6，即为分解规则。</p>",
                    "like": 0,
                    "answer": [
                        "C"
                    ],
                    "option": [
                        " 若A→B，B→C，则A→C ",
                        " 若Y⊆X⊆U，则X→Y ",
                        " 若A→B，A→C，则A→BC ",
                        " 若A→B，C⊆B，则A→C "
                    ]
                },
                {
                    "index": 127,
                    "belong_page": 1,
                    "question_id": 281585,
                    "question_title": "<p>假设有关系模式R（A1，A2，A3，A4，A5，A6），函数依赖集F={A1→A3，A1 A2→A4，A5 A6→A1，A3 A5→A6，A2 A5→A6}。关系模式R的一个主键是（ ）， 从函数依赖集F可以推出关系模式R（ ）。</p><p><br/></p>",
                    "question_type": 9,
                    "answer_type": 1,
                    "show_type_name": "单选题",
                    "new_parent_id": 281584,
                    "score_rule": "",
                    "material_text": null,
                    "sort_son": "1",
                    "analyze": "<p>把每个选项代入题干中，只有A2A5能推出所有属性，因此为主键。</p>",
                    "like": 0,
                    "answer": [
                        "B"
                    ],
                    "option": [
                        " A1A4 ",
                        " A2A5 ",
                        " A3A4 ",
                        " A4A5 "
                    ]
                },
                {
                    "index": 128,
                    "belong_page": 1,
                    "question_id": 281586,
                    "question_title": "<p>假设有关系模式R（A1，A2，A3，A4，A5，A6），函数依赖集F={A1→A3，A1 A2→A4，A5 A6→A1，A3 A5→A6，A2 A5→A6}。关系模式R的一个主键是（ ）， 从函数依赖集F可以推出关系模式R（ ）。</p><p><br/></p>",
                    "question_type": 9,
                    "answer_type": 1,
                    "show_type_name": "单选题",
                    "new_parent_id": 281584,
                    "score_rule": "",
                    "material_text": null,
                    "sort_son": "2",
                    "analyze": "<p>根据第一空可知R的一个主键为A2A5，由函数依赖集F可知，存在A2A5→A6，A5A6→A1，A1→A3，这里存在传递函数依赖，故A、B选项均不正确，C选项本身不正确，存在非主属性对候选键的传递函数依赖，是不满足3NF的。因此本题选择D选项。<br/></p><p>A1，A3，A6都可以通过A2A5得到，尽管这个过程有传递依赖，但是三个非主属性也都是完全依赖主键的。</p><p><br/></p>",
                    "like": 0,
                    "answer": [
                        "D"
                    ],
                    "option": [
                        " 不存在传递依赖，故R为1NF ",
                        " 不存在传递依赖，故R为2NF ",
                        " 存在传递依赖，故R为3NF ",
                        " 每个非主属性完全函数依赖于主键，故R为2NF "
                    ]
                },
                {
                    "index": 129,
                    "belong_page": 1,
                    "question_id": 281588,
                    "question_title": "<p>若关系模式R和S分别为：R(A, B, C, D)、S(B, C, E, F)，则关系R与S自然连接运算后的属性列有（ ）个，与表达式&nbsp;<img style=\"max-width:100%;height:auto\"  src=\"https://s2.51cto.com/images/20211201/1638330360182900.png\" title=\"1638330360182900.png\" alt=\"屏幕截图 2021-12-01.png\"/> 等价的SQL语句为：<br/></p><p>SELECT（ ）FROM R, S WHERE（ ）</p>",
                    "question_type": 9,
                    "answer_type": 1,
                    "show_type_name": "单选题",
                    "new_parent_id": 281587,
                    "score_rule": "",
                    "material_text": null,
                    "sort_son": "1",
                    "analyze": "<p>本题考查关系代数运算与SQL查询方面的基础知识。</p><p>自然连接<img style=\"max-width:100%;height:auto\"  src=\"https://s2.51cto.com/images/20200914/1600074892211617.jpg\" title=\"1600074892211617.jpg\" alt=\"1.jpg\"/>是指R与S关系中相同属性列名的等值连接运算后，再去掉右边重复的属性列名S.B、S.C，所以经<img style=\"max-width:100%;height:auto\"  src=\"https://s2.51cto.com/images/20200914/1600074892211617.jpg\" title=\"1600074892211617.jpg\" alt=\"1.jpg\"/>运算后的属性列名为：R.A、R.B、R.C、R.D、S.E和S.F，共有6个属性列。</p><p>π1, 3, 5, 6(σ3＜6(<img style=\"max-width:100%;height:auto\"  src=\"https://s2.51cto.com/images/20200914/1600074892211617.jpg\" title=\"1600074892211617.jpg\" alt=\"1.jpg\"/>))的含义是从<img style=\"max-width:100%;height:auto\"  src=\"https://s2.51cto.com/images/20200914/1600074892211617.jpg\" title=\"1600074892211617.jpg\" alt=\"1.jpg\"/>结果集中选取R.C＜S.F的元组，再进行R.A、R.C、S.E和S.F投影，故选项A是正确的。</p><p>由于自然连接<img style=\"max-width:100%;height:auto\"  src=\"https://s2.51cto.com/images/20200914/1600074892211617.jpg\" title=\"1600074892211617.jpg\" alt=\"1.jpg\"/>是指R与S关系中相同属性列名的等值连接，故需要用条件“WHERE R.B=S.B AND R.C=S.C”来限定；又由于经自然连接<img style=\"max-width:100%;height:auto\"  src=\"https://s2.51cto.com/images/20200914/1600074892211617.jpg\" title=\"1600074892211617.jpg\" alt=\"1.jpg\"/>运算后，去掉了右边重复的属性列名S.B、S.C，使得第三列属性列名和第六列属性列名分别为R.C、S.F，所以选取运算σ3＜6需要用条件“WHERE R.C＜S.F”来限定。</p>",
                    "like": 0,
                    "answer": [
                        "B"
                    ],
                    "option": [
                        " 4 ",
                        "6",
                        "7",
                        "8"
                    ]
                },
                {
                    "index": 130,
                    "belong_page": 1,
                    "question_id": 281589,
                    "question_title": "<p>若关系模式R和S分别为：R(A, B, C, D)、S(B, C, E, F)，则关系R与S自然连接运算后的属性列有（ ）个，与表达式&nbsp;<img style=\"max-width:100%;height:auto\"  src=\"https://s2.51cto.com/images/20211201/1638330360182900.png\" title=\"1638330360182900.png\" alt=\"屏幕截图 2021-12-01.png\"/> 等价的SQL语句为：<br/></p><p>SELECT（ ）FROM R, S WHERE（ ）</p>",
                    "question_type": 9,
                    "answer_type": 1,
                    "show_type_name": "单选题",
                    "new_parent_id": 281587,
                    "score_rule": "",
                    "material_text": null,
                    "sort_son": "2",
                    "analyze": "<p>本题考查关系代数运算与SQL查询方面的基础知识。</p><p>自然连接<img style=\"max-width:100%;height:auto\"  src=\"https://s2.51cto.com/images/20200914/1600074892211617.jpg\" title=\"1600074892211617.jpg\" alt=\"1.jpg\"/>是指R与S关系中相同属性列名的等值连接运算后，再去掉右边重复的属性列名S.B、S.C，所以经<img style=\"max-width:100%;height:auto\"  src=\"https://s2.51cto.com/images/20200914/1600074892211617.jpg\" title=\"1600074892211617.jpg\" alt=\"1.jpg\"/>运算后的属性列名为：R.A、R.B、R.C、R.D、S.E和S.F，共有6个属性列。</p><p>π1, 3, 5, 6(σ3＜6(<img style=\"max-width:100%;height:auto\"  src=\"https://s2.51cto.com/images/20200914/1600074892211617.jpg\" title=\"1600074892211617.jpg\" alt=\"1.jpg\"/>))的含义是从<img style=\"max-width:100%;height:auto\"  src=\"https://s2.51cto.com/images/20200914/1600074892211617.jpg\" title=\"1600074892211617.jpg\" alt=\"1.jpg\"/>结果集中选取R.C＜S.F的元组，再进行R.A、R.C、S.E和S.F投影，故选项A是正确的。</p><p>由于自然连接<img style=\"max-width:100%;height:auto\"  src=\"https://s2.51cto.com/images/20200914/1600074892211617.jpg\" title=\"1600074892211617.jpg\" alt=\"1.jpg\"/>是指R与S关系中相同属性列名的等值连接，故需要用条件“WHERE R.B=S.B AND R.C=S.C”来限定；又由于经自然连接<img style=\"max-width:100%;height:auto\"  src=\"https://s2.51cto.com/images/20200914/1600074892211617.jpg\" title=\"1600074892211617.jpg\" alt=\"1.jpg\"/>运算后，去掉了右边重复的属性列名S.B、S.C，使得第三列属性列名和第六列属性列名分别为R.C、S.F，所以选取运算σ3＜6需要用条件“WHERE R.C＜S.F”来限定。<span style=\"font-size: 16px;\"></span></p>",
                    "like": 0,
                    "answer": [
                        "A"
                    ],
                    "option": [
                        " R.A, R.C, E, F ",
                        " A, C, S.B, S.E ",
                        " A, C, S.B, S.C ",
                        " R.A, R.C, S.B, S.C "
                    ]
                },
                {
                    "index": 131,
                    "belong_page": 1,
                    "question_id": 281590,
                    "question_title": "<p>若关系模式R和S分别为：R(A, B, C, D)、S(B, C, E, F)，则关系R与S自然连接运算后的属性列有（ ）个，与表达式&nbsp;<img style=\"max-width:100%;height:auto\"  src=\"https://s2.51cto.com/images/20211201/1638330360182900.png\" title=\"1638330360182900.png\" alt=\"屏幕截图 2021-12-01.png\"/> 等价的SQL语句为：<br/></p><p>SELECT（ ）FROM R, S WHERE（ ）</p>",
                    "question_type": 9,
                    "answer_type": 1,
                    "show_type_name": "单选题",
                    "new_parent_id": 281587,
                    "score_rule": "",
                    "material_text": null,
                    "sort_son": "3",
                    "analyze": "<p>本题考查关系代数运算与SQL查询方面的基础知识。</p><p>自然连接<img style=\"max-width:100%;height:auto\"  src=\"https://s2.51cto.com/images/20200914/1600074892211617.jpg\" title=\"1600074892211617.jpg\" alt=\"1.jpg\"/>是指R与S关系中相同属性列名的等值连接运算后，再去掉右边重复的属性列名S.B、S.C，所以经<img style=\"max-width:100%;height:auto\"  src=\"https://s2.51cto.com/images/20200914/1600074892211617.jpg\" title=\"1600074892211617.jpg\" alt=\"1.jpg\"/>运算后的属性列名为：R.A、R.B、R.C、R.D、S.E和S.F，共有6个属性列。</p><p>π1, 3, 5, 6(σ3＜6(<img style=\"max-width:100%;height:auto\"  src=\"https://s2.51cto.com/images/20200914/1600074892211617.jpg\" title=\"1600074892211617.jpg\" alt=\"1.jpg\"/>))的含义是从<img style=\"max-width:100%;height:auto\"  src=\"https://s2.51cto.com/images/20200914/1600074892211617.jpg\" title=\"1600074892211617.jpg\" alt=\"1.jpg\"/>结果集中选取R.C＜S.F的元组，再进行R.A、R.C、S.E和S.F投影，故选项A是正确的。</p><p>由于自然连接<img style=\"max-width:100%;height:auto\"  src=\"https://s2.51cto.com/images/20200914/1600074892211617.jpg\" title=\"1600074892211617.jpg\" alt=\"1.jpg\"/>是指R与S关系中相同属性列名的等值连接，故需要用条件“WHERE R.B=S.B AND R.C=S.C”来限定；又由于经自然连接<img style=\"max-width:100%;height:auto\"  src=\"https://s2.51cto.com/images/20200914/1600074892211617.jpg\" title=\"1600074892211617.jpg\" alt=\"1.jpg\"/>运算后，去掉了右边重复的属性列名S.B、S.C，使得第三列属性列名和第六列属性列名分别为R.C、S.F，所以选取运算σ3＜6需要用条件“WHERE R.C＜S.F”来限定。<span style=\"font-size: 16px;\"></span></p>",
                    "like": 0,
                    "answer": [
                        "B"
                    ],
                    "option": [
                        "R.B=S.B AND R.C=S.C AND R.C＜S.B",
                        "R.B=S.B AND R.C=S.C AND R.C＜S.F",
                        "R.B=S.B OR R.C=S.C OR R.C＜S.B",
                        "R.B=S.B OR R.C=S.C OR RC＜S.F"
                    ]
                },
                {
                    "index": 132,
                    "belong_page": 1,
                    "question_id": 281592,
                    "question_title": "给定关系R(A,B,C,D,E)与S(A,B,C,F,G)，那么与表达式<img style=\"max-width:100%;height:auto\"  src=\"https://s2.51cto.com/images/20200914/1600075115916020.jpg\" title=\"1600075115916020.jpg\" alt=\"1.jpg\"/>等价的SQL语句如下：select ( &nbsp;) from R, S where ( &nbsp;)；",
                    "question_type": 9,
                    "answer_type": 1,
                    "show_type_name": "单选题",
                    "new_parent_id": 281591,
                    "score_rule": "",
                    "material_text": null,
                    "sort_son": "1",
                    "analyze": "<p>本题考查关系代数运算与SQL语言的对应关系。注意本题中R与S是做自然联接操作，操作时会将R与S中相同字段名做等值联接，并将结果集去重复。所以R与S自然联接后的结果包括以下属性：</p><p>R.A，R.B，R.C，D，E，F，G。</p><p>关系代数选择条件为“1&lt;6”，即R.A&lt;F。</p><p>关系代数投影操作条件为“1,2,4,6,7”，对应的属性为：R.A，R.B，D，F，G。</p>",
                    "like": 0,
                    "answer": [
                        "B"
                    ],
                    "option": [
                        "R.A，R.B，R.E，S.C，G",
                        "R.A，R.B，D，F，G",
                        "R.A，R.B，R.D，S.C，F",
                        "R.A，R.B，R.D，S.C，G"
                    ]
                },
                {
                    "index": 133,
                    "belong_page": 1,
                    "question_id": 281593,
                    "question_title": "给定关系R(A,B,C,D,E)与S(A,B,C,F,G)，那么与表达式<img style=\"max-width:100%;height:auto\"  src=\"https://s2.51cto.com/images/20200914/1600075115916020.jpg\" title=\"1600075115916020.jpg\" alt=\"1.jpg\"/>等价的SQL语句如下：select ( &nbsp;) from R, S where ( &nbsp;)；",
                    "question_type": 9,
                    "answer_type": 1,
                    "show_type_name": "单选题",
                    "new_parent_id": 281591,
                    "score_rule": "",
                    "material_text": null,
                    "sort_son": "2",
                    "analyze": "<p>本题考查关系代数运算与SQL语言的对应关系。注意本题中R与S是做自然联接操作，操作时会将R与S中相同字段名做等值联接，并将结果集去重复。所以R与S自然联接后的结果包括以下属性：</p><p>R.A，R.B，R.C，D，E，F，G。</p><p>关系代数选择条件为“1&lt;6”，即R.A&lt;F。</p><p>关系代数投影操作条件为“1,2,4,6,7”，对应的属性为：R.A，R.B，D，F，G。</p>",
                    "like": 0,
                    "answer": [
                        "C"
                    ],
                    "option": [
                        "R.A=S.A OR R.B=S.B OR R.C=S.C OR R.A&lt;S.F",
                        "R.A=S.A OR R.B=S.B OR R.C=S.C OR R.A&lt;S.B",
                        "R.A=S.A AND R.B=S.B AND R.C=S.C AND R.A&lt;S.F",
                        "R.A=S.A AND R.B=S.B AND R.C=S.C AND R.A&lt;S.B"
                    ]
                },
                {
                    "index": 134,
                    "belong_page": 1,
                    "question_id": 281594,
                    "question_title": "数据仓库中，数据（ &nbsp;）是指数据一旦进入数据仓库后，将被长期保留并定期加载和刷新，可以进行各种查询操作，但很少对数据进行修改和删除操作。",
                    "question_type": 1,
                    "answer_type": 1,
                    "show_type_name": "单选题",
                    "new_parent_id": 281594,
                    "score_rule": "",
                    "material_text": "",
                    "sort_son": "0",
                    "analyze": "<p>数据仓库4大特点如下：</p><p>①面向主题：数据按主题组织。</p><p>②集成的：消除了源数据中的不一致性，提供整个企业的一致性全局信息。</p><p>③相对稳定的：主要进行查询操作，只有少量的修改和删除操作（或不删除）。</p><p>④反映历史变化：记录了从过去某一时刻到当前各个阶段的信息，可对发展历程和未来趋势做定量分析和预测。</p>",
                    "like": 0,
                    "answer": [
                        "C"
                    ],
                    "option": [
                        "面向主题",
                        "集成性",
                        "相对稳定性",
                        "反映历史变化"
                    ]
                },
                {
                    "index": 135,
                    "belong_page": 1,
                    "question_id": 281596,
                    "question_title": "若关系R、S如下图所示，则关系R与S进行自然连接运算后的元组个数和属性列数分别为 （ ） ；关系代数表达式π1，4(σ3=6(R×S))与关系代数表达式 （ ） 等价。<br/><img style=\"max-width:100%;height:auto\"  src=\"https://s2.51cto.com/images/20200914/1600075236281981.jpg\" title=\"1600075236281981.jpg\" alt=\"1.jpg\"/>",
                    "question_type": 9,
                    "answer_type": 1,
                    "show_type_name": "单选题",
                    "new_parent_id": 281595,
                    "score_rule": "",
                    "material_text": null,
                    "sort_son": "1",
                    "analyze": "<p>本题考查关系运算方面的基础知识。</p><p>根据自然连接要求，两个关系中进行比较的分量必须是相同的属性组，并且在结果中将重复属性列去掉，故<img style=\"max-width:100%;height:auto\"  src=\"https://s2.51cto.com/images/20200914/1600075266961408.jpg\" title=\"1600075266961408.jpg\" alt=\"1.jpg\"/>后的属性列数为4。同时，自然连接是一种特殊的等值连接，即R关系中的C、D属性与S关系中的C、D属性进行等值连接，然后去掉复属性列，其结果为：<br/><img style=\"max-width:100%;height:auto\"  src=\"https://s2.51cto.com/images/20200914/1600075276447601.jpg\" title=\"1600075276447601.jpg\" alt=\"1.jpg\"/></p><p>可见后的元组个数为3。。</p><p><img style=\"max-width:100%;height:auto\"  src=\"https://s2.51cto.com/images/20200914/1600075266961408.jpg\" title=\"1600075266961408.jpg\" alt=\"1.jpg\"/>关系代数表达式π1,4(σ3=6(R×S))中，R×S的6个属性列为：R.A、R.B、R.C、R.D、S.C和S.D，σ3=6(R×S)表示R与S关系进行笛卡儿积运算后，选取第三个属性R.C等于第六个属性S.D的元组；π1,4(σ3=6(R×S))表示从σ3=6(R×S)的结果中投影第一个和第四个属性列，即投影R.A和R.D属性列。<span style=\"font-size: 16px;\"></span></p>",
                    "like": 0,
                    "answer": [
                        "D"
                    ],
                    "option": [
                        "6和6",
                        "4和6",
                        "3和6",
                        "3和4"
                    ]
                },
                {
                    "index": 136,
                    "belong_page": 1,
                    "question_id": 281597,
                    "question_title": "若关系R、S如下图所示，则关系R与S进行自然连接运算后的元组个数和属性列数分别为 （ ） ；关系代数表达式π1，4(σ3=6(R×S))与关系代数表达式 （ ） 等价。<br/><img style=\"max-width:100%;height:auto\"  src=\"https://s2.51cto.com/images/20200914/1600075236281981.jpg\" title=\"1600075236281981.jpg\" alt=\"1.jpg\"/>",
                    "question_type": 9,
                    "answer_type": 1,
                    "show_type_name": "单选题",
                    "new_parent_id": 281595,
                    "score_rule": "",
                    "material_text": null,
                    "sort_son": "2",
                    "analyze": "<p>本题考查关系运算方面的基础知识。</p><p>根据自然连接要求，两个关系中进行比较的分量必须是相同的属性组，并且在结果中将重复属性列去掉，故<img style=\"max-width:100%;height:auto\"  src=\"https://s2.51cto.com/images/20200914/1600075266961408.jpg\" title=\"1600075266961408.jpg\" alt=\"1.jpg\"/>后的属性列数为4。同时，自然连接是一种特殊的等值连接，即R关系中的C、D属性与S关系中的C、D属性进行等值连接，然后去掉复属性列，其结果为：<br/><img style=\"max-width:100%;height:auto\"  src=\"https://s2.51cto.com/images/20200914/1600075276447601.jpg\" title=\"1600075276447601.jpg\" alt=\"1.jpg\"/></p><p>可见后的元组个数为3。。</p><p><img style=\"max-width:100%;height:auto\"  src=\"https://s2.51cto.com/images/20200914/1600075266961408.jpg\" title=\"1600075266961408.jpg\" alt=\"1.jpg\"/>关系代数表达式π1,4(σ3=6(R×S))中，R×S的6个属性列为：R.A、R.B、R.C、R.D、S.C和S.D，σ3=6(R×S)表示R与S关系进行笛卡儿积运算后，选取第三个属性R.C等于第六个属性S.D的元组；π1,4(σ3=6(R×S))表示从σ3=6(R×S)的结果中投影第一个和第四个属性列，即投影R.A和R.D属性列。</p>",
                    "like": 0,
                    "answer": [
                        "C"
                    ],
                    "option": [
                        "πA，D(σC=D(R×S))",
                        "πA,R.D(σS.C=R.D(R×S))",
                        "πA,R.D(σR.C=S.D(R×S))&nbsp;",
                        "πR.A,R.D(σS.C=S.D(R×S))"
                    ]
                },
                {
                    "index": 137,
                    "belong_page": 1,
                    "question_id": 281598,
                    "question_title": "描述企业应用中的实体及其联系，属于数据库设计的（）阶段。",
                    "question_type": 1,
                    "answer_type": 1,
                    "show_type_name": "单选题",
                    "new_parent_id": 281598,
                    "score_rule": "",
                    "material_text": "",
                    "sort_son": "0",
                    "analyze": "概念设计也称为概念结构设计，其任务是在需求分析阶段产生的需求说明书的基础上，按照特定的方法将它们抽象为一个不依赖于任何DBMS的数据模型，即概念模型（ER模型）。",
                    "like": 0,
                    "answer": [
                        "B"
                    ],
                    "option": [
                        "需求分析",
                        "概念设计",
                        "逻辑设计",
                        "物理设计"
                    ]
                },
                {
                    "index": 138,
                    "belong_page": 1,
                    "question_id": 281599,
                    "question_title": "<p>设有员工关系Emp（员工号，姓名，性别，年龄，电话，家庭住址，家庭成员，关系，联系电话）。其中，“家庭成员，关系，联系电话”分别记录了员工亲属的姓名、与员工的关系以及联系电话，且一个员工允许有多个家庭成员。为使数据库模式设计更合理，对于员工关系Emp ( )。</p>",
                    "question_type": 1,
                    "answer_type": 1,
                    "show_type_name": "单选题",
                    "new_parent_id": 281599,
                    "score_rule": "",
                    "material_text": "",
                    "sort_son": "0",
                    "analyze": "<p>因为每个员工允许有多个家庭成员，如果将这么多家庭成员都记录下来，势必造成表中数据的冗余，所以应该将家庭成员、关系及联系电话加上员工号设计成一个独立的模式。</p>",
                    "like": 0,
                    "answer": [
                        "D"
                    ],
                    "option": [
                        " 只允许记录一个亲属的姓名、与员工的关系以及联系电话 ",
                        " 可以不作任何处理，因为该关系模式达到了3NF ",
                        " 增加多个家庭成员、关系及联系电话字段 ",
                        " 应该将家庭成员、关系及联系电话加上员工号设计成一个独立的模式 "
                    ]
                },
                {
                    "index": 139,
                    "belong_page": 1,
                    "question_id": 284661,
                    "question_title": "<p>某公司销售数据库的商品、仓库关系模式及函数依赖集F1、F2如下：</p><p>商品（商品号，商品名称，生产商，单价），F1={商品号→商品名称，商品号→生产商，商品号→单价）}，商品关系的主键是 （19）。仓库（仓库号，地址，电话，商品号，库存量），F2={仓库号→（地址，电话），（仓库号，商品号）→库存量}。仓库关系的主键是（20），外键是（21）。</p><p>仓库关系模式（22），为了解决这一问题，需要将仓库关系分解为（23）。</p>",
                    "question_type": 9,
                    "answer_type": 1,
                    "show_type_name": "单选题",
                    "new_parent_id": 284660,
                    "score_rule": "",
                    "material_text": null,
                    "sort_son": "1",
                    "analyze": "<p>从商品关系的函数依赖集F1可以导出商品号决定商品关系的全属性，所以商品号是商品关系的主键。</p><p>从仓库关系的函数依赖集F2可以导出（仓库号，商品号）决定仓库关系的全属性，所以仓库关系的主键是（仓库号，商品号）。又由于商品号是商品关系的主键，故商品号是仓库关系的外键。</p><p>仓库关系存在冗余、插入异常和删除异常，以及修改操作的不一致。例如，仓库号为“12”的商品有3种，其地址就要重复3次，如下表所示，故仓库关系存在冗余</p><p><img style=\"max-width:100%;height:auto\"  src=\"https://s2.51cto.com/images/20201014/1602643239314838.jpg\" title=\"1602643239314838.jpg\" alt=\"1.jpg\"/></p><p>试题（23）正确的答案D。为了解决仓库关系模式存在的问题需要进行模式分解，其中，选项A分解存在的问题是仓库2不属于第三范式，因为存在非主属性对码的部分函数依赖，即仓库号→电话。选项B分解存在的问题是分解有损连接，即分解的新关系模式仓库1和仓库2无法恢复到原关系。选项C分解存在的问题与A类同，分析略。</p><p>选项D分解是即保持函数依赖，又无损连接，分解的结果如下：<br/><img style=\"max-width:100%;height:auto\"  src=\"https://s2.51cto.com/images/20201014/1602643408835354.jpg\" title=\"1602643408835354.jpg\" alt=\"1.jpg\"/></p>",
                    "like": 0,
                    "answer": [
                        "A"
                    ],
                    "option": [
                        "商品号",
                        "商品号，商品名称",
                        "商品号，生产商",
                        "商品名称，生产商"
                    ]
                },
                {
                    "index": 140,
                    "belong_page": 1,
                    "question_id": 284662,
                    "question_title": "<p>某公司销售数据库的商品、仓库关系模式及函数依赖集F1、F2如下：</p><p>商品（商品号，商品名称，生产商，单价），F1={商品号→商品名称，商品号→生产商，商品号→单价）}，商品关系的主键是 （19）。仓库（仓库号，地址，电话，商品号，库存量），F2={仓库号→（地址，电话），（仓库号，商品号）→库存量}。仓库关系的主键是（20），外键是（21）。</p><p>仓库关系模式（22），为了解决这一问题，需要将仓库关系分解为（23）。</p>",
                    "question_type": 9,
                    "answer_type": 1,
                    "show_type_name": "单选题",
                    "new_parent_id": 284660,
                    "score_rule": "",
                    "material_text": null,
                    "sort_son": "2",
                    "analyze": "<p>从商品关系的函数依赖集F1可以导出商品号决定商品关系的全属性，所以商品号是商品关系的主键。</p><p>从仓库关系的函数依赖集F2可以导出（仓库号，商品号）决定仓库关系的全属性，所以仓库关系的主键是（仓库号，商品号）。又由于商品号是商品关系的主键，故商品号是仓库关系的外键。</p><p>仓库关系存在冗余、插入异常和删除异常，以及修改操作的不一致。例如，仓库号为“12”的商品有3种，其地址就要重复3次，如下表所示，故仓库关系存在冗余</p><p><img style=\"max-width:100%;height:auto\"  src=\"https://s2.51cto.com/images/20201014/1602643239314838.jpg\" title=\"1602643239314838.jpg\" alt=\"1.jpg\"/></p><p>试题（23）正确的答案D。为了解决仓库关系模式存在的问题需要进行模式分解，其中，选项A分解存在的问题是仓库2不属于第三范式，因为存在非主属性对码的部分函数依赖，即仓库号→电话。选项B分解存在的问题是分解有损连接，即分解的新关系模式仓库1和仓库2无法恢复到原关系。选项C分解存在的问题与A类同，分析略。</p><p>选项D分解是即保持函数依赖，又无损连接，分解的结果如下：<br/><img style=\"max-width:100%;height:auto\"  src=\"https://s2.51cto.com/images/20201014/1602643408835354.jpg\" title=\"1602643408835354.jpg\" alt=\"1.jpg\"/></p><p><br/></p>",
                    "like": 0,
                    "answer": [
                        "B"
                    ],
                    "option": [
                        "仓库号",
                        "仓库号，商品号",
                        "仓库号，电话",
                        "地址，电话"
                    ]
                },
                {
                    "index": 141,
                    "belong_page": 1,
                    "question_id": 284663,
                    "question_title": "<p>某公司销售数据库的商品、仓库关系模式及函数依赖集F1、F2如下：</p><p>商品（商品号，商品名称，生产商，单价），F1={商品号→商品名称，商品号→生产商，商品号→单价）}，商品关系的主键是 （19）。仓库（仓库号，地址，电话，商品号，库存量），F2={仓库号→（地址，电话），（仓库号，商品号）→库存量}。仓库关系的主键是（20），外键是（21）。</p><p>仓库关系模式（22），为了解决这一问题，需要将仓库关系分解为（23）。</p>",
                    "question_type": 9,
                    "answer_type": 1,
                    "show_type_name": "单选题",
                    "new_parent_id": 284660,
                    "score_rule": "",
                    "material_text": null,
                    "sort_son": "3",
                    "analyze": "<p>从商品关系的函数依赖集F1可以导出商品号决定商品关系的全属性，所以商品号是商品关系的主键。</p><p>从仓库关系的函数依赖集F2可以导出（仓库号，商品号）决定仓库关系的全属性，所以仓库关系的主键是（仓库号，商品号）。又由于商品号是商品关系的主键，故商品号是仓库关系的外键。</p><p>仓库关系存在冗余、插入异常和删除异常，以及修改操作的不一致。例如，仓库号为“12”的商品有3种，其地址就要重复3次，如下表所示，故仓库关系存在冗余</p><p><img style=\"max-width:100%;height:auto\"  src=\"https://s2.51cto.com/images/20201014/1602643239314838.jpg\" title=\"1602643239314838.jpg\" alt=\"1.jpg\"/></p><p>试题（23）正确的答案D。为了解决仓库关系模式存在的问题需要进行模式分解，其中，选项A分解存在的问题是仓库2不属于第三范式，因为存在非主属性对码的部分函数依赖，即仓库号→电话。选项B分解存在的问题是分解有损连接，即分解的新关系模式仓库1和仓库2无法恢复到原关系。选项C分解存在的问题与A类同，分析略。</p><p>选项D分解是即保持函数依赖，又无损连接，分解的结果如下：<br/><img style=\"max-width:100%;height:auto\"  src=\"https://s2.51cto.com/images/20201014/1602643408835354.jpg\" title=\"1602643408835354.jpg\" alt=\"1.jpg\"/></p><p><br/></p>",
                    "like": 0,
                    "answer": [
                        "D"
                    ],
                    "option": [
                        "仓库号",
                        "地址",
                        "电话",
                        " 商品号 "
                    ]
                },
                {
                    "index": 142,
                    "belong_page": 1,
                    "question_id": 284664,
                    "question_title": "<p>某公司销售数据库的商品、仓库关系模式及函数依赖集F1、F2如下：</p><p>商品（商品号，商品名称，生产商，单价），F1={商品号→商品名称，商品号→生产商，商品号→单价）}，商品关系的主键是 （19）。仓库（仓库号，地址，电话，商品号，库存量），F2={仓库号→（地址，电话），（仓库号，商品号）→库存量}。仓库关系的主键是（20），外键是（21）。</p><p>仓库关系模式（22），为了解决这一问题，需要将仓库关系分解为（23）。</p>",
                    "question_type": 9,
                    "answer_type": 1,
                    "show_type_name": "单选题",
                    "new_parent_id": 284660,
                    "score_rule": "",
                    "material_text": null,
                    "sort_son": "4",
                    "analyze": "<p>从商品关系的函数依赖集F1可以导出商品号决定商品关系的全属性，所以商品号是商品关系的主键。</p><p>从仓库关系的函数依赖集F2可以导出（仓库号，商品号）决定仓库关系的全属性，所以仓库关系的主键是（仓库号，商品号）。又由于商品号是商品关系的主键，故商品号是仓库关系的外键。</p><p>仓库关系存在冗余、插入异常和删除异常，以及修改操作的不一致。例如，仓库号为“12”的商品有3种，其地址就要重复3次，如下表所示，故仓库关系存在冗余</p><p><img style=\"max-width:100%;height:auto\"  src=\"https://s2.51cto.com/images/20201014/1602643239314838.jpg\" title=\"1602643239314838.jpg\" alt=\"1.jpg\"/></p><p>试题（23）正确的答案D。为了解决仓库关系模式存在的问题需要进行模式分解，其中，选项A分解存在的问题是仓库2不属于第三范式，因为存在非主属性对码的部分函数依赖，即仓库号→电话。选项B分解存在的问题是分解有损连接，即分解的新关系模式仓库1和仓库2无法恢复到原关系。选项C分解存在的问题与A类同，分析略。</p><p>选项D分解是即保持函数依赖，又无损连接，分解的结果如下：<br/><img style=\"max-width:100%;height:auto\"  src=\"https://s2.51cto.com/images/20201014/1602643408835354.jpg\" title=\"1602643408835354.jpg\" alt=\"1.jpg\"/></p><p><br/></p>",
                    "like": 0,
                    "answer": [
                        "A"
                    ],
                    "option": [
                        "存在冗余、插入异常和删除异常，以及修改操作的不一致",
                        "不存在冗余，但存在插入异常和删除异常",
                        "不存在修改操作的不一致，但存在冗余和插入异常",
                        "不存在冗余、插入异常，但存在删除异常和修改操作的不一致"
                    ]
                },
                {
                    "index": 143,
                    "belong_page": 1,
                    "question_id": 284665,
                    "question_title": "<p>某公司销售数据库的商品、仓库关系模式及函数依赖集F1、F2如下：</p><p>商品（商品号，商品名称，生产商，单价），F1={商品号→商品名称，商品号→生产商，商品号→单价）}，商品关系的主键是 （19）。仓库（仓库号，地址，电话，商品号，库存量），F2={仓库号→（地址，电话），（仓库号，商品号）→库存量}。仓库关系的主键是（20），外键是（21）。</p><p>仓库关系模式（22），为了解决这一问题，需要将仓库关系分解为（23）。</p>",
                    "question_type": 9,
                    "answer_type": 1,
                    "show_type_name": "单选题",
                    "new_parent_id": 284660,
                    "score_rule": "",
                    "material_text": null,
                    "sort_son": "5",
                    "analyze": "<p>从商品关系的函数依赖集F1可以导出商品号决定商品关系的全属性，所以商品号是商品关系的主键。</p><p>从仓库关系的函数依赖集F2可以导出（仓库号，商品号）决定仓库关系的全属性，所以仓库关系的主键是（仓库号，商品号）。又由于商品号是商品关系的主键，故商品号是仓库关系的外键。</p><p>仓库关系存在冗余、插入异常和删除异常，以及修改操作的不一致。例如，仓库号为“12”的商品有3种，其地址就要重复3次，如下表所示，故仓库关系存在冗余</p><p><img style=\"max-width:100%;height:auto\"  src=\"https://s2.51cto.com/images/20201014/1602643239314838.jpg\" title=\"1602643239314838.jpg\" alt=\"1.jpg\"/></p><p>试题（23）正确的答案D。为了解决仓库关系模式存在的问题需要进行模式分解，其中，选项A分解存在的问题是仓库2不属于第三范式，因为存在非主属性对码的部分函数依赖，即仓库号→电话。选项B分解存在的问题是分解有损连接，即分解的新关系模式仓库1和仓库2无法恢复到原关系。选项C分解存在的问题与A类同，分析略。</p><p>选项D分解是即保持函数依赖，又无损连接，分解的结果如下：<br/><img style=\"max-width:100%;height:auto\"  src=\"https://s2.51cto.com/images/20201014/1602643408835354.jpg\" title=\"1602643408835354.jpg\" alt=\"1.jpg\"/></p><p><br/></p>",
                    "like": 0,
                    "answer": [
                        "D"
                    ],
                    "option": [
                        "仓库1（仓库号，地址）和仓库2（仓库号，电话，商品号，库存量）",
                        "仓库1（仓库号，地址，电话）和仓库2（商品号，库存量）",
                        "仓库1（仓库号，电话）和仓库2（仓库号，地址，商品号，库存量）",
                        "仓库1（仓库号，地址，电话）和仓库2（仓库号，商品号，库存量）"
                    ]
                },
                {
                    "index": 144,
                    "belong_page": 1,
                    "question_id": 284667,
                    "question_title": "关系R、S如下图所示，关系代数表达式<img style=\"max-width:100%;height:auto\"  src=\"https://s2.51cto.com/images/20201014/1602643467458443.jpg\" title=\"1602643467458443.jpg\" alt=\"1.jpg\"/>，对关系R、S进行自然连接后的属性列数和元组个数分别为（25）。<br/><img style=\"max-width:100%;height:auto\"  src=\"https://s2.51cto.com/images/20201014/1602643490587614.jpg\" title=\"1602643490587614.jpg\" alt=\"1.jpg\"/>",
                    "question_type": 9,
                    "answer_type": 1,
                    "show_type_name": "单选题",
                    "new_parent_id": 284666,
                    "score_rule": "",
                    "material_text": null,
                    "sort_son": "1",
                    "analyze": "<p>R×S后的结果如表7.6所示。</p><p><img style=\"max-width:100%;height:auto\"  src=\"https://s2.51cto.com/images/20201014/1602643581514486.jpg\" title=\"1602643581514486.jpg\" alt=\"1.jpg\"/></p><p>π3,4,5(σ1＜6(R×S)=</p><p>3、4、5列对应的是R.C、S.A、S.B，其中第一列小于第6列的值(即1＜6)是第一、第三元组。故第24题的答案选B。</p><p>设A1，A2，...，An是R和S的公共属性，当且仅当R的元组r与S的元组s在1，A2，…，An上都一致时，元组s和r组合成为R和S自然连接的一个元组。</p><p>由此可得，R和S的公共属性为A、B、C，但R和S在属性A、B、C上的值不等，故自然连接后，属性列数为3，元组个数为0。</p>",
                    "like": 0,
                    "answer": [
                        "B"
                    ],
                    "option": [
                        "<img style=\"max-width:100%;height:auto\" src=\"https://s2.51cto.com/images/20201014/1602643526416377.jpg\" title=\"1602643526416377.jpg\" alt=\"1.jpg\"/>",
                        "<img style=\"max-width:100%;height:auto\" src=\"https://s2.51cto.com/images/20201014/1602643529743137.jpg\" title=\"1602643529743137.jpg\" alt=\"2.jpg\"/>",
                        "<img style=\"max-width:100%;height:auto\" src=\"https://s2.51cto.com/images/20201014/1602643532500043.jpg\" title=\"1602643532500043.jpg\" alt=\"3.jpg\"/>",
                        "<img style=\"max-width:100%;height:auto\" src=\"https://s2.51cto.com/images/20201014/1602643535178457.jpg\" title=\"1602643535178457.jpg\" alt=\"4.jpg\"/>"
                    ]
                },
                {
                    "index": 145,
                    "belong_page": 1,
                    "question_id": 284668,
                    "question_title": "关系R、S如下图所示，关系代数表达式<img style=\"max-width:100%;height:auto\"  src=\"https://s2.51cto.com/images/20201014/1602643467458443.jpg\" title=\"1602643467458443.jpg\" alt=\"1.jpg\"/>，对关系R、S进行自然连接后的属性列数和元组个数分别为（25）。<br/><img style=\"max-width:100%;height:auto\"  src=\"https://s2.51cto.com/images/20201014/1602643490587614.jpg\" title=\"1602643490587614.jpg\" alt=\"1.jpg\"/>",
                    "question_type": 9,
                    "answer_type": 1,
                    "show_type_name": "单选题",
                    "new_parent_id": 284666,
                    "score_rule": "",
                    "material_text": null,
                    "sort_son": "2",
                    "analyze": "<p>R×S后的结果如表7.6所示。</p><p><img style=\"max-width:100%;height:auto\"  src=\"https://s2.51cto.com/images/20201014/1602643581514486.jpg\" title=\"1602643581514486.jpg\" alt=\"1.jpg\"/></p><p>π3,4,5(σ1＜6(R×S)=</p><p>3、4、5列对应的是R.C、S.A、S.B，其中第一列小于第6列的值(即1＜6)是第一、第三元组。故第24题的答案选B。</p><p>设A1，A2，...，An是R和S的公共属性，当且仅当R的元组r与S的元组s在1，A2，…，An上都一致时，元组s和r组合成为R和S自然连接的一个元组。</p><p>由此可得，R和S的公共属性为A、B、C，但R和S在属性A、B、C上的值不等，故自然连接后，属性列数为3，元组个数为0。</p>",
                    "like": 0,
                    "answer": [
                        "A"
                    ],
                    "option": [
                        "3和0",
                        "3和2",
                        "6和0",
                        "6和2"
                    ]
                },
                {
                    "index": 146,
                    "belong_page": 1,
                    "question_id": 284670,
                    "question_title": "分布透明性指用户不必关心数据的逻辑分片，不必关心数据存储的物理位置分配细节，也不必关心局部场地上数据库的数据模型。（26）是分布透明性的最高层次。（27）指用户或应用程序应当了解分片情况，但不必了解片段的存储场地。（28）透明性是指用户或应用程序应当了解分片及各片断存储的场地，但不必了解局部场地上使用的是何种数据模型。",
                    "question_type": 9,
                    "answer_type": 1,
                    "show_type_name": "单选题",
                    "new_parent_id": 284669,
                    "score_rule": "",
                    "material_text": null,
                    "sort_son": "1",
                    "analyze": "<p>分布透明性包括：分片透明性、位置透明性和局部数据模型透明性。</p><p>（1）分片透明性是分布透明性的最高层次。所谓分片透明性是指用户或应用程序只对全局关系进行操作而不必考虑数据的分片。当分片模式改变时，只要改变全局模式到分片模式的映像（映像 2），而不影响全局模式和应用程序。全局模式不变，应用程序不必改写，这就是分片透明性。</p><p>（2）位置透明性是分布透明性的下一层次。所谓位置透明性是指，用户或应用程序应当了解分片情况，但不必了解片段的存储场地。当存储场地改变时，只要改变分片模式到分配模式的映像（映像 3），而不影响应用程序。同时，若片段的重复副本数目改变了，那么数据的冗余也会改变，但用户不必关心如何保持各副本的一致性，这也提供了重复副本的透明性。</p><p>（3）局部数据模型（逻辑透明）透明性是指用户或应用程序应当了解分片及各片断存储的场地，但不必了解局部场地上使用的是何种数据模型。</p>",
                    "like": 0,
                    "answer": [
                        "A"
                    ],
                    "option": [
                        "分片透明性",
                        "逻辑透明性",
                        "位置透明性",
                        "全局透明性"
                    ]
                },
                {
                    "index": 147,
                    "belong_page": 1,
                    "question_id": 284671,
                    "question_title": "分布透明性指用户不必关心数据的逻辑分片，不必关心数据存储的物理位置分配细节，也不必关心局部场地上数据库的数据模型。（26）是分布透明性的最高层次。（27）指用户或应用程序应当了解分片情况，但不必了解片段的存储场地。（28）透明性是指用户或应用程序应当了解分片及各片断存储的场地，但不必了解局部场地上使用的是何种数据模型。",
                    "question_type": 9,
                    "answer_type": 1,
                    "show_type_name": "单选题",
                    "new_parent_id": 284669,
                    "score_rule": "",
                    "material_text": null,
                    "sort_son": "2",
                    "analyze": "分布透明性包括：分片透明性、位置透明性和局部数据模型透明性。<p>（1）分片透明性是分布透明性的最高层次。所谓分片透明性是指用户或应用程序只对全局关系进行操作而不必考虑数据的分片。当分片模式改变时，只要改变全局模式到分片模式的映像（映像 2），而不影响全局模式和应用程序。全局模式不变，应用程序不必改写，这就是分片透明性。</p><p>（2）位置透明性是分布透明性的下一层次。所谓位置透明性是指，用户或应用程序应当了解分片情况，但不必了解片段的存储场地。当存储场地改变时，只要改变分片模式到分配模式的映像（映像 3），而不影响应用程序。同时，若片段的重复副本数目改变了，那么数据的冗余也会改变，但用户不必关心如何保持各副本的一致性，这也提供了重复副本的透明性。</p><p>（3）局部数据模型（逻辑透明）透明性是指用户或应用程序应当了解分片及各片断存储的场地，但不必了解局部场地上使用的是何种数据模型。</p>",
                    "like": 0,
                    "answer": [
                        "C"
                    ],
                    "option": [
                        "分片透明性",
                        "逻辑透明性",
                        "位置透明性",
                        "全局透明性"
                    ]
                },
                {
                    "index": 148,
                    "belong_page": 1,
                    "question_id": 284672,
                    "question_title": "分布透明性指用户不必关心数据的逻辑分片，不必关心数据存储的物理位置分配细节，也不必关心局部场地上数据库的数据模型。（26）是分布透明性的最高层次。（27）指用户或应用程序应当了解分片情况，但不必了解片段的存储场地。（28）透明性是指用户或应用程序应当了解分片及各片断存储的场地，但不必了解局部场地上使用的是何种数据模型。",
                    "question_type": 9,
                    "answer_type": 1,
                    "show_type_name": "单选题",
                    "new_parent_id": 284669,
                    "score_rule": "",
                    "material_text": null,
                    "sort_son": "3",
                    "analyze": "<p>分布透明性包括：分片透明性、位置透明性和局部数据模型透明性。</p><p>（1）分片透明性是分布透明性的最高层次。所谓分片透明性是指用户或应用程序只对全局关系进行操作而不必考虑数据的分片。当分片模式改变时，只要改变全局模式到分片模式的映像（映像 2），而不影响全局模式和应用程序。全局模式不变，应用程序不必改写，这就是分片透明性。</p><p>（2）位置透明性是分布透明性的下一层次。所谓位置透明性是指，用户或应用程序应当了解分片情况，但不必了解片段的存储场地。当存储场地改变时，只要改变分片模式到分配模式的映像（映像 3），而不影响应用程序。同时，若片段的重复副本数目改变了，那么数据的冗余也会改变，但用户不必关心如何保持各副本的一致性，这也提供了重复副本的透明性。</p><p>（3）局部数据模型（逻辑透明）透明性是指用户或应用程序应当了解分片及各片断存储的场地，但不必了解局部场地上使用的是何种数据模型。</p>",
                    "like": 0,
                    "answer": [
                        "B"
                    ],
                    "option": [
                        "分片透明性",
                        "逻辑透明性",
                        "位置透明性",
                        "全局透明性"
                    ]
                },
                {
                    "index": 149,
                    "belong_page": 1,
                    "question_id": 284951,
                    "question_title": "某数据库中有员工关系E、产品关系P、仓库关系W和库存关系I，其中：员工关系E(employeeID，name，department)中的属性为：员工编号，姓名，部门：产品关系P (productID，name，model，size，color)中的属性为：产品编号，产品名称，型号，尺寸，颜色：仓库关系W(warehouseID，name，address，employeeID.中的属性为：仓库编号，仓库名称，地址，负责人编号；库存关系I(warehouseID，productlD，quantity)中的属性为仓库编号，产品编号和产品数量。<p>&nbsp;&nbsp; &nbsp;a．若要求仓库关系的负责人引用员工关系的员工编号，员工关系E的员工编号、仓库关系w的仓库编号和产品关系P的产品编号不能为空且唯一标识一个记录，并且仓库的地址不能为空，则依次要满足的完整性约束是（&nbsp; &nbsp;）。</p><p>&nbsp;</p><p>&nbsp;&nbsp; &nbsp;b．若需得到每种产品的名称和该产品的总库存量，则对应的查询语句为：</p><p>&nbsp;&nbsp; SELELCT name, SUM(quantity)</p><p>&nbsp;&nbsp; FROM P, I</p><p>&nbsp;&nbsp; WHERE （&nbsp; &nbsp;）</p>",
                    "question_type": 9,
                    "answer_type": 1,
                    "show_type_name": "单选题",
                    "new_parent_id": 284950,
                    "score_rule": "",
                    "material_text": null,
                    "sort_son": "1",
                    "analyze": "关系模型的完整性规则是对关系的某种约束条件，关系模型中可以有三类完整性约束：实体完整性、参照完整性和用户定义的完整性。实体完整性规定基本关系的主属性不能取空值。由于员工关系E中的员工编号、仓库关系w中的仓库编号和产品关系P中的产品编号都不能为空且唯一标识一个记录，所以应满足实体完整性约束：参照完整性规定实体间引用的完整性，本表中外码的值必须取空值或者在被引用的表中存在的相对应的主码值。由于仓库关系的负责人引用了员工关系的员工编号，所以应满足参照完整性约束；实体完整性和参照完整性是所有数据库系统都要支持的完整性约束。而用户定义的完整性是针对某一具体关系数据库的约束条件，它反映某一具体应用所涉及的数据必须满足的语义要求。根据题目要求：仓库的地址不能为空，所以也应满足用户定义完整性约束。从上述完整性说明来看，正确答案应为B。",
                    "like": 0,
                    "answer": [
                        "B"
                    ],
                    "option": [
                        " 实体完整性、参照完整性、用户定义完整性 ",
                        " 参照完整性、实体完整性、用户定义完整性 ",
                        " 用户定义完整性、实体完整性、参照完整性 ",
                        " 实体完整性、用户定义完整性、参照完整性 "
                    ]
                },
                {
                    "index": 150,
                    "belong_page": 1,
                    "question_id": 284952,
                    "question_title": "某数据库中有员工关系E、产品关系P、仓库关系W和库存关系I，其中：员工关系E(employeeID，name，department)中的属性为：员工编号，姓名，部门：产品关系P (productID，name，model，size，color)中的属性为：产品编号，产品名称，型号，尺寸，颜色：仓库关系W(warehouseID，name，address，employeeID.中的属性为：仓库编号，仓库名称，地址，负责人编号；库存关系I(warehouseID，productlD，quantity)中的属性为仓库编号，产品编号和产品数量。<p>&nbsp;&nbsp; &nbsp;a．若要求仓库关系的负责人引用员工关系的员工编号，员工关系E的员工编号、仓库关系w的仓库编号和产品关系P的产品编号不能为空且唯一标识一个记录，并且仓库的地址不能为空，则依次要满足的完整性约束是（&nbsp; &nbsp;）。</p><p>&nbsp;</p><p>&nbsp;&nbsp; &nbsp;b．若需得到每种产品的名称和该产品的总库存量，则对应的查询语句为：</p><p>&nbsp;&nbsp; SELELCT name, SUM(quantity)</p><p>&nbsp;&nbsp; FROM P, I</p><p>&nbsp;&nbsp; WHERE （&nbsp; &nbsp;）</p>",
                    "question_type": 9,
                    "answer_type": 1,
                    "show_type_name": "单选题",
                    "new_parent_id": 284950,
                    "score_rule": "",
                    "material_text": null,
                    "sort_son": "2",
                    "analyze": "<p>&nbsp;SQL查询是数据库中非常重要的内容。该SQL查询要求对查询结果进行分组，即具有相同名称的产品的元组为一组，然后计算每组的库存数量。由此可排除A、B和D，所以23题正确答案为C。&nbsp;</p>",
                    "like": 0,
                    "answer": [
                        "C"
                    ],
                    "option": [
                        " P. productID=l.productID; ",
                        " P. productID=I.productID ORDER BY name; ",
                        " P. productID=I.productID GROUP BY name; ",
                        " P. productlD=I.productlD GROUP BY name, quantity; "
                    ]
                },
                {
                    "index": 151,
                    "belong_page": 1,
                    "question_id": 284953,
                    "question_title": "<p>建立一个供应商、零件数据库。其中“供应商”表S(Sno，Sname，Zip，City)分别表示：供应商代码、供应商名、供应商邮编、供应商所在城市，其函数依赖为：Sno→(Sname，Zip，City)，Zip→City。“供应商”表S属于（&nbsp; ）。</p>",
                    "question_type": 1,
                    "answer_type": 1,
                    "show_type_name": "单选题",
                    "new_parent_id": 284953,
                    "score_rule": "",
                    "material_text": "",
                    "sort_son": "0",
                    "analyze": "<p>本题考查的是范式的基础知识。“供应商”表S属于2NF，因为表S的主键是Sno，非主属性Snmne、Zip、City不存在对键的部分函数依赖。但是，当2NF消除了非主属性对码的传递函数依赖，则称为3NF。“供应商”表S不属于3NF，因为存在传递依赖，即Sno→Zip，Zip→City。</p>",
                    "like": 0,
                    "answer": [
                        "D"
                    ],
                    "option": [
                        " 3NF ",
                        " BCNF ",
                        " 1NF ",
                        " 2NF "
                    ]
                },
                {
                    "index": 152,
                    "belong_page": 1,
                    "question_id": 302372,
                    "question_title": "<p>数据库的安全机制中，通过提供 （5） 供第三方开发人员调用进行数据更新，从而保证数据库的关系模式不被第三方所获取。<span style=\"font-size: 16px;\"></span></p>",
                    "question_type": 1,
                    "answer_type": 1,
                    "show_type_name": "单选题",
                    "new_parent_id": 302372,
                    "score_rule": "",
                    "material_text": "",
                    "sort_son": "0",
                    "analyze": "<p>存储过程(Stored Procedure)是在大型数据库系统中，一组为了完成特定功能的SQL语句集，它存储在数据库中，一次编译后永久有效，用户通过指定存储过程的名字并给出参数（如果该存储过程带有参数）来执行它。</p><p>存储过程是数据库所提供的一种数据库对象，通过存储过程定 义一段代码，提供给应用程序调用来执行。 从安全性的角度考虑，更新数据时，通过提供存储过程让第三方调用，将需要更新的数据传入存储过程，而在存储过程内部用代码分别对需要的多个表进行更新，从而避免了向第三方提供系统的表结构，保证了系统的数据安全。</p>",
                    "like": 0,
                    "answer": [
                        "C"
                    ],
                    "option": [
                        " 索引 ",
                        " 视图 ",
                        " 存储过程 ",
                        " 触发器 "
                    ]
                },
                {
                    "index": 153,
                    "belong_page": 1,
                    "question_id": 302374,
                    "question_title": "给出关系R(U,F)，U={A,B,C,D,E}，F={A→BC,B→D,D→E}。以下关于F说法正确的是 （6） 。若将关系R分解为ρ={R1(U1,F1)，R2(U2,F2)}，其中：U1={A,B,C}、U2={B,D,E}，则分解ρ （7） 。",
                    "question_type": 9,
                    "answer_type": 1,
                    "show_type_name": "单选题",
                    "new_parent_id": 302373,
                    "score_rule": "",
                    "material_text": null,
                    "sort_son": "1",
                    "analyze": "<p>根据Armstrong公理的传递律，可以判断出F蕴涵A→D、A→E、B→E，故F存在传递依赖。</p><p>U1∩U2=B，B可以唯一确定U2的D、E。因此分解ρ是无损连接。</p><p>U1蕴含A→BC，U2蕴含B→D,D→E。因此该分解也保持了函数依赖。</p>",
                    "like": 0,
                    "answer": [
                        "D"
                    ],
                    "option": [
                        "F蕴涵A→B、A→C，但F不存在传递依赖",
                        "F蕴涵E→A、A→C，故F存在传递依赖",
                        "F蕴涵A→D、E→A、A→C，但F不存在传递依赖",
                        "F蕴涵A→D、A→E、B→E，故F存在传递依赖"
                    ]
                },
                {
                    "index": 154,
                    "belong_page": 1,
                    "question_id": 302375,
                    "question_title": "给出关系R(U,F)，U={A,B,C,D,E}，F={A→BC,B→D,D→E}。以下关于F说法正确的是 （6） 。若将关系R分解为ρ={R1(U1,F1)，R2(U2,F2)}，其中：U1={A,B,C}、U2={B,D,E}，则分解ρ （7） 。",
                    "question_type": 9,
                    "answer_type": 1,
                    "show_type_name": "单选题",
                    "new_parent_id": 302373,
                    "score_rule": "",
                    "material_text": null,
                    "sort_son": "2",
                    "analyze": "<p>根据Armstrong公理的传递律，可以判断出F蕴涵A→D、A→E、B→E，故F存在传递依赖。</p><p>U1∩U2=B，B可以唯一确定U2的D、E。因此分解ρ是无损连接。</p><p>U1蕴含A→BC，U2蕴含B→D,D→E。因此该分解也保持了函数依赖。</p>",
                    "like": 0,
                    "answer": [
                        "A"
                    ],
                    "option": [
                        "无损连接并保持函数依赖",
                        "无损连接但不保持函数依赖",
                        "有损连接并保持函数依赖",
                        "有损连接但不保持函数依赖"
                    ]
                },
                {
                    "index": 155,
                    "belong_page": 1,
                    "question_id": 302376,
                    "question_title": "分布式数据库系统除了包含集中式数据库系统的模式结构之外，还增加了几个模式级别，其中 （8）定义分布式数据库中数据的整体逻辑结构，使得数据使用方便，如同没有分布一样。",
                    "question_type": 1,
                    "answer_type": 1,
                    "show_type_name": "单选题",
                    "new_parent_id": 302376,
                    "score_rule": "",
                    "material_text": "",
                    "sort_son": "0",
                    "analyze": "<p>在分布式数据库中，局部DBMS中的内模式与概念模式与集中数据库是完全一致的，不同之处在于新增的全局DBMS，而整个全局DBMS，可以看作是相对于局部概念模式的外模式。由于外模式部分有一系列的分布模式、分片模式、全局概念模式和全局外模式，以及多级映射使得用户在使用分布式数据库时，可以使用集中式数据库同样的方式。</p><p>（1）全局外模式。全局外模式是全局应用的用户视图，是全局概念模式的子集，该层直接与用户（或应用程序）交互。</p><p>（2）全局概念模式。全局概念模式定义分布式数据库中数据的整体逻辑结构，数据就如同根本没有分布一样，可用传统的集中式数据库中所采用的方法进行定义。</p><p>（3）分片模式。在某些情况下，需要将一个关系模式分解成为几个数据片，分片模式正是用于完成此项工作的。</p><p>（4）分布模式。分布式数据库的本质特性就是数据分布在不同的物理位置。分布模式的主要职责是定义数据片段（即分片模式的处理结果）的存放节点。</p><p>（5）局部概念模式。局部概念模式是局部数据库的概念模式。</p><p>（6）局部内模式。局部内模式是局部数据库的内模式。</p><br/><img style=\"max-width:100%;height:auto\"  src=\"https://s2.51cto.com/images/20210701/1625139696325144.jpg\" title=\"1625139696325144.jpg\" alt=\"1.jpg\"/>",
                    "like": 0,
                    "answer": [
                        "D"
                    ],
                    "option": [
                        "分片模式",
                        "全局外模式",
                        "分布模式",
                        "全局概念模式"
                    ]
                },
                {
                    "index": 156,
                    "belong_page": 1,
                    "question_id": 310871,
                    "question_title": "<p>某销售公司员工关系E（工号、姓名、部门名、电话、住址）、商品关系C（商品号、商品名、库存数）和销售关系EC（工号、商品号、销售数、销售日期）。查询“销售部1”在2020年11月11日销售“HUWEI Mate40”商品的员工的工号、姓名、部门名及其销售的商品名、销售数的关系代数表达式为</p><p>Π1,2,3,7,8（&nbsp;（36） ⊳⊲&nbsp;（37） ⊳⊲&nbsp;（38） ）</p>",
                    "question_type": 9,
                    "answer_type": 1,
                    "show_type_name": "单选题",
                    "new_parent_id": 310870,
                    "score_rule": "",
                    "material_text": null,
                    "sort_son": "1",
                    "analyze": "<p>销售部在员工关系E的第3个属性列。</p><p>根据题干的信息“σ2=’HUAWEI Mate40’”，商品名在第2个属性列的关系是商品关系C，执行完选择操作后投影1、2列的商品号、商品名跟其他表进行连接，因此37题选择B。销售日期在销售关系EC的第4个属性列。</p>",
                    "like": 0,
                    "answer": [
                        "C"
                    ],
                    "option": [
                        " σ3=销售部1(E) ",
                        " σ3=销售部1(C) ",
                        " σ3=’销售部1’(E) ",
                        " σ3=’销售部1’(C) "
                    ]
                },
                {
                    "index": 157,
                    "belong_page": 1,
                    "question_id": 310872,
                    "question_title": "<p>某销售公司员工关系E（工号、姓名、部门名、电话、住址）、商品关系C（商品号、商品名、库存数）和销售关系EC（工号、商品号、销售数、销售日期）。查询“销售部1”在2020年11月11日销售“HUWEI Mate40”商品的员工的工号、姓名、部门名及其销售的商品名、销售数的关系代数表达式为</p><p>Π1,2,3,7,8（&nbsp;（36） ⊳⊲&nbsp;（37） ⊳⊲&nbsp;（38） ）</p>",
                    "question_type": 9,
                    "answer_type": 1,
                    "show_type_name": "单选题",
                    "new_parent_id": 310870,
                    "score_rule": "",
                    "material_text": null,
                    "sort_son": "2",
                    "analyze": "<p>销售部在员工关系E的第3个属性列。</p><p>根据题干的信息“σ2=’HUAWEI Mate40’”，商品名在第2个属性列的关系是商品关系C，执行完选择操作后投影1、2列的商品号、商品名跟其他表进行连接，因此37题选择B。销售日期在销售关系EC的第4个属性列。</p>",
                    "like": 0,
                    "answer": [
                        "B"
                    ],
                    "option": [
                        " π2,3(σ2=’HUAWEI Mate40’(C)) ",
                        " π1,2(σ2=’HUAWEI Mate40’(C)) ",
                        " π2,3(σ2=’HUAWEI Mate40’(EC)) ",
                        " &nbsp;π1,2(σ2=’HUAWEI Mate40’(EC)) "
                    ]
                },
                {
                    "index": 158,
                    "belong_page": 1,
                    "question_id": 310873,
                    "question_title": "<p>某销售公司员工关系E（工号、姓名、部门名、电话、住址）、商品关系C（商品号、商品名、库存数）和销售关系EC（工号、商品号、销售数、销售日期）。查询“销售部1”在2020年11月11日销售“HUWEI Mate40”商品的员工的工号、姓名、部门名及其销售的商品名、销售数的关系代数表达式为</p><p>Π1,2,3,7,8（&nbsp;（36） ⊳⊲&nbsp;（37） ⊳⊲&nbsp;（38） ）</p>",
                    "question_type": 9,
                    "answer_type": 1,
                    "show_type_name": "单选题",
                    "new_parent_id": 310870,
                    "score_rule": "",
                    "material_text": null,
                    "sort_son": "3",
                    "analyze": "<p>销售部在员工关系E的第3个属性列。</p><p>根据题干的信息“σ2=’HUAWEI Mate40’”，商品名在第2个属性列的关系是商品关系C，执行完选择操作后投影1、2列的商品号、商品名跟其他表进行连接，因此37题选择B。销售日期在销售关系EC的第4个属性列。</p>",
                    "like": 0,
                    "answer": [
                        "C"
                    ],
                    "option": [
                        " σ4=’2020年11月11日’(C)&nbsp; ",
                        " &nbsp;σ3=’2020年11月11日’(C) ",
                        " σ4=’2020年11月11日’(EC)&nbsp; ",
                        " σ3=’2020年11月11日’(EC) "
                    ]
                },
                {
                    "index": 159,
                    "belong_page": 1,
                    "question_id": 310875,
                    "question_title": "在数据库设计的需求分析阶段应当形成（39），这些文档可以作为（40）阶段的设计依据。",
                    "question_type": 9,
                    "answer_type": 1,
                    "show_type_name": "单选题",
                    "new_parent_id": 310874,
                    "score_rule": "",
                    "material_text": null,
                    "sort_son": "1",
                    "analyze": "数据库设计主要分为用户需求分析、概念结构、逻辑结构和物理结构设计四个阶段。其中，在用户需求分析阶段中，数据库设计人员采用一定的辅助工具对应用对象的功能、性能、 限制等要求所进行的科学分析，并形成需求说明文档、数据字典和数据流程图。用户需求分析阶段形成的相关文档用以作为概念结构设计的设计依据。",
                    "like": 0,
                    "answer": [
                        "C"
                    ],
                    "option": [
                        "程序文档、数据字典和数据流图",
                        "需求说明文档、程序文档和数据流图",
                        "需求说明文档、数据字典和数据流图",
                        "需求说明文档、数据字典和程序文档"
                    ]
                },
                {
                    "index": 160,
                    "belong_page": 1,
                    "question_id": 310876,
                    "question_title": "在数据库设计的需求分析阶段应当形成（39），这些文档可以作为（40）阶段的设计依据。",
                    "question_type": 9,
                    "answer_type": 1,
                    "show_type_name": "单选题",
                    "new_parent_id": 310874,
                    "score_rule": "",
                    "material_text": null,
                    "sort_son": "2",
                    "analyze": "数据库设计主要分为用户需求分析、概念结构、逻辑结构和物理结构设计四个阶段。其中，在用户需求分析阶段中，数据库设计人员采用一定的辅助工具对应用对象的功能、性能、 限制等要求所进行的科学分析，并形成需求说明文档、数据字典和数据流程图。用户需求分析阶段形成的相关文档用以作为概念结构设计的设计依据。",
                    "like": 0,
                    "answer": [
                        "B"
                    ],
                    "option": [
                        "逻辑结构设计",
                        "概念结构设计",
                        "物理结构设计",
                        "数据库运行和维护"
                    ]
                },
                {
                    "index": 161,
                    "belong_page": 1,
                    "question_id": 312928,
                    "question_title": "关系R、S如下图所示，关系代数表达式π1，5，6(σ1＞5(R×S))= （）?。<br/><img style=\"max-width:100%;height:auto\"  src=\"https://s2.51cto.com/images/20211013/1634137695316372.jpg\" title=\"1634137695316372.jpg\" alt=\"55.jpg\"/><br/>",
                    "question_type": 1,
                    "answer_type": 1,
                    "show_type_name": "单选题",
                    "new_parent_id": 312928,
                    "score_rule": "",
                    "material_text": "",
                    "sort_son": "0",
                    "analyze": "<p>分析关系表达式π1，5，6(σ1＞5(R×S))：关系表达式σ1＞5(R×S)意为从关系中选取满足条件R.A大于S.B的元组，从关系R中可以看出只有元组(10，11，12)满足条件，而关系S中可以看出只有元组(3，7，11)和元组(4，7，6)满足条件，即σ1＞5(R×S)的结果如下所示。</p><p><img style=\"max-width:100%;height:auto\"  src=\"https://s2.51cto.com/images/20211013/1634137836564500.jpg\" title=\"1634137836564500.jpg\" alt=\"1.jpg\"/></p><p>π1，5，6意为投影R的第一个属性列A，S的第二个属性列B和S的第三个属性列C。从上分析可见正确的答案是选项B。</p>",
                    "like": 0,
                    "answer": [
                        "B"
                    ],
                    "option": [
                        "<img style=\"max-width:100%;height:auto\" src=\"https://s2.51cto.com/images/20211013/1634137731883923.jpg\" title=\"1634137731883923.jpg\" alt=\"1.jpg\"/>",
                        "<img style=\"max-width:100%;height:auto\" src=\"https://s2.51cto.com/images/20211013/1634137735763505.jpg\" title=\"1634137735763505.jpg\" alt=\"2.jpg\"/>",
                        "<img style=\"max-width:100%;height:auto\" src=\"https://s2.51cto.com/images/20211013/1634137740737472.jpg\" title=\"1634137740737472.jpg\" alt=\"3.jpg\"/>",
                        "<img style=\"max-width:100%;height:auto\" src=\"https://s2.51cto.com/images/20211013/1634137744923743.jpg\" title=\"1634137744923743.jpg\" alt=\"4.jpg\"/>"
                    ]
                },
                {
                    "index": 162,
                    "belong_page": 1,
                    "question_id": 312930,
                    "question_title": "<p>某数据库中有员工关系E、产品关系P、仓库关系W和库存关系I，其中：员工关系E(employeeID，name，department)中的属性为：员工编号，姓名，部门：产品关系P (productID，name，model，size，color)中的属性为：产品编号，产品名称，型号，尺寸，颜色：仓库关系W(warehouseID，name，address，employeeID.中的属性为：仓库编号，仓库名称，地址，负责人编号；库存关系I(warehouseID，productlD，quantity)中的属性为仓库编号，产品编号和产品数量。</p><p>a．若要求仓库关系的负责人引用员工关系的员工编号，员工关系E的员工编号、仓库关系w的仓库编号和产品关系P的产品编号不能为空且唯一标识一个记录，并且仓库的地址不能为空，则依次要满足的完整性约束是（）。<br/></p><p>&nbsp;b．若需得到每种产品的名称和该产品的总库存量，则对应的查询语句为：</p><p>&nbsp;&nbsp; SELELCT name, SUM(quantity)</p><p>&nbsp;&nbsp; FROM P, I</p><p>&nbsp;&nbsp; WHERE （）</p><p>&nbsp;c．若需得到在所有仓库中都存在的产品的名称，则对应的查询语句为：</p><p>&nbsp;&nbsp; &nbsp;SELECT name FROM P</p><p>&nbsp;&nbsp; &nbsp;WHERE &nbsp;(50) &nbsp;</p><p>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; (SELECT * FROM W</p><p>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;WHERE NOT EXISTS</p><p>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(SELECT * FROM 1</p><p>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; WHERE P. productID=l.productID AND W. warehouselD=l.warehouseID.)</p>",
                    "question_type": 9,
                    "answer_type": 1,
                    "show_type_name": "单选题",
                    "new_parent_id": 312929,
                    "score_rule": "",
                    "material_text": null,
                    "sort_son": "1",
                    "analyze": "<p>关系模型的完整性规则是对关系的某种约束条件，关系模型中可以有三类完整性约束：实体完整性、参照完整性和用户定义的完整性。实体完整性规定基本关系的主属性不能取空值。由于员工关系E中的员工编号、仓库关系w中的仓库编号和产品关系P中的产品编号都不能为空且唯一标识一个记录，所以应满足实体完整性约束：参照完整性规定实体间引用的完整性，本表中外码的值必须取空值或者在被引用的表中存在的相对应的主码值。由于仓库关系的负责人引用了员工关系的员工编号，所以应满足参照完整性约束；实体完整性和参照完整性是所有数据库系统都要支持的完整性约束。而用户定义的完整性是针对某一具体关系数据库的约束条件，它反映某一具体应用所涉及的数据必须满足的语义要求。根据题目要求：仓库的地址不能为空，所以也应满足用户定义完整性约束。从上述完整性说明来看，正确答案应为B。</p><p>SQL查询是数据库中非常重要的内容。该SQL查询要求对查询结果进行分组，即具有相同名称的产品的元组为一组，然后计算每组的库存数量。由此可排除A、B和D，所以23题正确答案为C。</p><p>得到在所有仓库中都存在的产品的名称的查询要求可等价理解为：查询这样的产品，没有一个仓库不保存该产品。所以24题正确答案为B。</p>",
                    "like": 0,
                    "answer": [
                        "B"
                    ],
                    "option": [
                        "实体完整性、参照完整性、用户定义完整性",
                        "参照完整性、实体完整性、用户定义完整性",
                        "用户定义完整性、实体完整性、参照完整性",
                        "实体完整性、用户定义完整性、参照完整性"
                    ]
                },
                {
                    "index": 163,
                    "belong_page": 1,
                    "question_id": 312931,
                    "question_title": "<p>某数据库中有员工关系E、产品关系P、仓库关系W和库存关系I，其中：员工关系E(employeeID，name，department)中的属性为：员工编号，姓名，部门：产品关系P (productID，name，model，size，color)中的属性为：产品编号，产品名称，型号，尺寸，颜色：仓库关系W(warehouseID，name，address，employeeID.中的属性为：仓库编号，仓库名称，地址，负责人编号；库存关系I(warehouseID，productlD，quantity)中的属性为仓库编号，产品编号和产品数量。</p><p>a．若要求仓库关系的负责人引用员工关系的员工编号，员工关系E的员工编号、仓库关系w的仓库编号和产品关系P的产品编号不能为空且唯一标识一个记录，并且仓库的地址不能为空，则依次要满足的完整性约束是（）。<br/></p><p>&nbsp;b．若需得到每种产品的名称和该产品的总库存量，则对应的查询语句为：</p><p>&nbsp;&nbsp; SELELCT name, SUM(quantity)</p><p>&nbsp;&nbsp; FROM P, I</p><p>&nbsp;&nbsp; WHERE （）</p><p>&nbsp;c．若需得到在所有仓库中都存在的产品的名称，则对应的查询语句为：</p><p>&nbsp;&nbsp; &nbsp;SELECT name FROM P</p><p>&nbsp;&nbsp; &nbsp;WHERE &nbsp;(50) &nbsp;</p><p>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; (SELECT * FROM W</p><p>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;WHERE NOT EXISTS</p><p>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(SELECT * FROM 1</p><p>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; WHERE P. productID=l.productID AND W. warehouselD=l.warehouseID.)</p>",
                    "question_type": 9,
                    "answer_type": 1,
                    "show_type_name": "单选题",
                    "new_parent_id": 312929,
                    "score_rule": "",
                    "material_text": null,
                    "sort_son": "2",
                    "analyze": "<p>关系模型的完整性规则是对关系的某种约束条件，关系模型中可以有三类完整性约束：实体完整性、参照完整性和用户定义的完整性。实体完整性规定基本关系的主属性不能取空值。由于员工关系E中的员工编号、仓库关系w中的仓库编号和产品关系P中的产品编号都不能为空且唯一标识一个记录，所以应满足实体完整性约束：参照完整性规定实体间引用的完整性，本表中外码的值必须取空值或者在被引用的表中存在的相对应的主码值。由于仓库关系的负责人引用了员工关系的员工编号，所以应满足参照完整性约束；实体完整性和参照完整性是所有数据库系统都要支持的完整性约束。而用户定义的完整性是针对某一具体关系数据库的约束条件，它反映某一具体应用所涉及的数据必须满足的语义要求。根据题目要求：仓库的地址不能为空，所以也应满足用户定义完整性约束。从上述完整性说明来看，正确答案应为B。</p><p>SQL查询是数据库中非常重要的内容。该SQL查询要求对查询结果进行分组，即具有相同名称的产品的元组为一组，然后计算每组的库存数量。由此可排除A、B和D，所以23题正确答案为C。</p><p>得到在所有仓库中都存在的产品的名称的查询要求可等价理解为：查询这样的产品，没有一个仓库不保存该产品。所以24题正确答案为B。</p>",
                    "like": 0,
                    "answer": [
                        "C"
                    ],
                    "option": [
                        " P. productID=l.productID; ",
                        " P. productID=I.productID ORDER BY name; ",
                        "P. productID=I.productID GROUP BY name;",
                        "P. productlD=I.productlD GROUP BY name, quantity;"
                    ]
                },
                {
                    "index": 164,
                    "belong_page": 1,
                    "question_id": 312932,
                    "question_title": "<p>某数据库中有员工关系E、产品关系P、仓库关系W和库存关系I，其中：员工关系E(employeeID，name，department)中的属性为：员工编号，姓名，部门：产品关系P (productID，name，model，size，color)中的属性为：产品编号，产品名称，型号，尺寸，颜色：仓库关系W(warehouseID，name，address，employeeID.中的属性为：仓库编号，仓库名称，地址，负责人编号；库存关系I(warehouseID，productlD，quantity)中的属性为仓库编号，产品编号和产品数量。</p><p>a．若要求仓库关系的负责人引用员工关系的员工编号，员工关系E的员工编号、仓库关系w的仓库编号和产品关系P的产品编号不能为空且唯一标识一个记录，并且仓库的地址不能为空，则依次要满足的完整性约束是（）。<br/></p><p>&nbsp;b．若需得到每种产品的名称和该产品的总库存量，则对应的查询语句为：</p><p>&nbsp;&nbsp; SELELCT name, SUM(quantity)</p><p>&nbsp;&nbsp; FROM P, I</p><p>&nbsp;&nbsp; WHERE （）</p><p>&nbsp;c．若需得到在所有仓库中都存在的产品的名称，则对应的查询语句为：</p><p>&nbsp;&nbsp; &nbsp;SELECT name FROM P</p><p>&nbsp;&nbsp; &nbsp;WHERE &nbsp;(50) &nbsp;</p><p>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; (SELECT * FROM W</p><p>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;WHERE NOT EXISTS</p><p>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(SELECT * FROM 1</p><p>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; WHERE P. productID=l.productID AND W. warehouselD=l.warehouseID.)</p>",
                    "question_type": 9,
                    "answer_type": 1,
                    "show_type_name": "单选题",
                    "new_parent_id": 312929,
                    "score_rule": "",
                    "material_text": null,
                    "sort_son": "3",
                    "analyze": "<p>关系模型的完整性规则是对关系的某种约束条件，关系模型中可以有三类完整性约束：实体完整性、参照完整性和用户定义的完整性。实体完整性规定基本关系的主属性不能取空值。由于员工关系E中的员工编号、仓库关系w中的仓库编号和产品关系P中的产品编号都不能为空且唯一标识一个记录，所以应满足实体完整性约束：参照完整性规定实体间引用的完整性，本表中外码的值必须取空值或者在被引用的表中存在的相对应的主码值。由于仓库关系的负责人引用了员工关系的员工编号，所以应满足参照完整性约束；实体完整性和参照完整性是所有数据库系统都要支持的完整性约束。而用户定义的完整性是针对某一具体关系数据库的约束条件，它反映某一具体应用所涉及的数据必须满足的语义要求。根据题目要求：仓库的地址不能为空，所以也应满足用户定义完整性约束。从上述完整性说明来看，正确答案应为B。</p><p>SQL查询是数据库中非常重要的内容。该SQL查询要求对查询结果进行分组，即具有相同名称的产品的元组为一组，然后计算每组的库存数量。由此可排除A、B和D，所以23题正确答案为C。</p><p>得到在所有仓库中都存在的产品的名称的查询要求可等价理解为：查询这样的产品，没有一个仓库不保存该产品。所以24题正确答案为B。&nbsp;</p>",
                    "like": 0,
                    "answer": [
                        "B"
                    ],
                    "option": [
                        "EXISTS",
                        "NOTEXISTS",
                        "IN",
                        "NOTIN"
                    ]
                },
                {
                    "index": 165,
                    "belong_page": 1,
                    "question_id": 312959,
                    "question_title": "<p>进程P1、P2、P3、P4、P5的前趋图如图所示。</p><p><img style=\"max-width:100%;height:auto\"  src=\"https://s2.51cto.com/images/20211013/1634139200190472.jpg\" title=\"1634139200190472.jpg\" alt=\"1.jpg\"/></p><p>若用PV操作控制进程并发执行的过程，则需要设置4个信号量S1、S2、S3和S4，且信号量初值都等于零。图中a和b应分别填写（），c和d应分别填写（），e和f应分别填写（）。<br/><img style=\"max-width:100%;height:auto\"  src=\"https://s2.51cto.com/images/20211013/1634139205865868.jpg\" title=\"1634139205865868.jpg\" alt=\"2.jpg\"/></p>",
                    "question_type": 9,
                    "answer_type": 1,
                    "show_type_name": "单选题",
                    "new_parent_id": 312958,
                    "score_rule": "",
                    "material_text": null,
                    "sort_son": "1",
                    "analyze": "根据题意，进程P3等待P1、P2的结果，因此，当P1、P2执行完毕需要使用V操作来通知P3，即a处填V(S1)，b处填V(S2)。进程P3的执行需要测试P1、P2有没有消息，应该在c处填P(S1)、P(S2)；当P3执行完毕后需要使用V操作通知P4和P5，即在d处填v(S3)、V(S4)。进程P4和P5的执行需要测试P3有没有消息，故应该在e处填P(S3)，在f处填P(S4)。",
                    "like": 0,
                    "answer": [
                        "C"
                    ],
                    "option": [
                        "P(S1)和P(S2)",
                        "P(S1)和V(S2)",
                        "V(S1)和V(S2)",
                        "V(S1)和P(S2)"
                    ]
                },
                {
                    "index": 166,
                    "belong_page": 1,
                    "question_id": 312960,
                    "question_title": "<p>进程P1、P2、P3、P4、P5的前趋图如图所示。</p><p><img style=\"max-width:100%;height:auto\"  src=\"https://s2.51cto.com/images/20211013/1634139200190472.jpg\" title=\"1634139200190472.jpg\" alt=\"1.jpg\"/></p><p>若用PV操作控制进程并发执行的过程，则需要设置4个信号量S1、S2、S3和S4，且信号量初值都等于零。图中a和b应分别填写（），c和d应分别填写（），e和f应分别填写（）。<br/><img style=\"max-width:100%;height:auto\"  src=\"https://s2.51cto.com/images/20211013/1634139205865868.jpg\" title=\"1634139205865868.jpg\" alt=\"2.jpg\"/></p>",
                    "question_type": 9,
                    "answer_type": 1,
                    "show_type_name": "单选题",
                    "new_parent_id": 312958,
                    "score_rule": "",
                    "material_text": null,
                    "sort_son": "2",
                    "analyze": "根据题意，进程P3等待P1、P2的结果，因此，当P1、P2执行完毕需要使用V操作来通知P3，即a处填V(S1)，b处填V(S2)。进程P3的执行需要测试P1、P2有没有消息，应该在c处填P(S1)、P(S2)；当P3执行完毕后需要使用V操作通知P4和P5，即在d处填v(S3)、V(S4)。进程P4和P5的执行需要测试P3有没有消息，故应该在e处填P(S3)，在f处填P(S4)。",
                    "like": 0,
                    "answer": [
                        "A"
                    ],
                    "option": [
                        "P(S1)、P(S2)和V(S3)、V(S4)",
                        "P(S1)、P(S2)和P(S3)、P(S4)",
                        "V(S1)、V(S2)和P(S3)、P(S4)&nbsp;",
                        "V(S1)、V(S2)和V(S3)、V(S4)"
                    ]
                },
                {
                    "index": 167,
                    "belong_page": 1,
                    "question_id": 312961,
                    "question_title": "<p>进程P1、P2、P3、P4、P5的前趋图如图所示。</p><p><img style=\"max-width:100%;height:auto\"  src=\"https://s2.51cto.com/images/20211013/1634139200190472.jpg\" title=\"1634139200190472.jpg\" alt=\"1.jpg\"/></p><p>若用PV操作控制进程并发执行的过程，则需要设置4个信号量S1、S2、S3和S4，且信号量初值都等于零。图中a和b应分别填写（），c和d应分别填写（），e和f应分别填写（）。<br/><img style=\"max-width:100%;height:auto\"  src=\"https://s2.51cto.com/images/20211013/1634139205865868.jpg\" title=\"1634139205865868.jpg\" alt=\"2.jpg\"/></p>",
                    "question_type": 9,
                    "answer_type": 1,
                    "show_type_name": "单选题",
                    "new_parent_id": 312958,
                    "score_rule": "",
                    "material_text": null,
                    "sort_son": "3",
                    "analyze": "根据题意，进程P3等待P1、P2的结果，因此，当P1、P2执行完毕需要使用V操作来通知P3，即a处填V(S1)，b处填V(S2)。进程P3的执行需要测试P1、P2有没有消息，应该在c处填P(S1)、P(S2)；当P3执行完毕后需要使用V操作通知P4和P5，即在d处填v(S3)、V(S4)。进程P4和P5的执行需要测试P3有没有消息，故应该在e处填P(S3)，在f处填P(S4)。",
                    "like": 0,
                    "answer": [
                        "A"
                    ],
                    "option": [
                        "P(S3)和P(S4)&nbsp;",
                        "P(S3)和V(S4)",
                        "V(S3)和V(S4)&nbsp;",
                        "V(S3)和P(S4)"
                    ]
                },
                {
                    "index": 168,
                    "belong_page": 1,
                    "question_id": 315903,
                    "question_title": "<p>某企业开发信息管理系统平台进行 E-R 图设计，人力部门定义的是员工实体具有属性：员工号、姓名、性别、出生日期、联系方式和部门,培训部门定义的培训师实体具有属性:培训师号，姓名和职称，其中职称={初级培训师，中级培训师，高级培训师},这种情况属于(5)，在合并E-R图时，解决这一冲突的方法是(6)</p>",
                    "question_type": 9,
                    "answer_type": 1,
                    "show_type_name": "单选题",
                    "new_parent_id": 315902,
                    "score_rule": "",
                    "material_text": null,
                    "sort_son": "1",
                    "analyze": "<p>ER图集成时产生的冲突及解决办法</p><p>属性冲突：包括属性域和属性取值的冲突。</p><p>命名冲突：包括同名异义和异名同义。</p><p>结构冲突：包括同一对象在不同应用中具有不同的抽象，以及统一实体在不同的局部E-R图中所包含的属性个数和属性排列次序不完全相同。</p><p>本题中，培训师属于员工的一种，所以不应该抽象为两个不同的实体，这种冲突属于结构冲突，解决方案是员工实体中加入职称属性，然后把培训教师实体删除。</p>",
                    "like": 0,
                    "answer": [
                        "B"
                    ],
                    "option": [
                        "属性冲突",
                        "结构冲突",
                        "命名冲突",
                        "实体冲突"
                    ]
                },
                {
                    "index": 169,
                    "belong_page": 1,
                    "question_id": 315904,
                    "question_title": "<p>某企业开发信息管理系统平台进行 E-R 图设计，人力部门定义的是员工实体具有属性：员工号、姓名、性别、出生日期、联系方式和部门,培训部门定义的培训师实体具有属性:培训师号，姓名和职称，其中职称={初级培训师，中级培训师，高级培训师},这种情况属于(5)，在合并E-R图时，解决这一冲突的方法是(6)</p>",
                    "question_type": 9,
                    "answer_type": 1,
                    "show_type_name": "单选题",
                    "new_parent_id": 315902,
                    "score_rule": "",
                    "material_text": null,
                    "sort_son": "2",
                    "analyze": "<p>ER图集成时产生的冲突及解决办法</p><p>属性冲突：包括属性域和属性取值的冲突。</p><p>命名冲突：包括同名异义和异名同义。</p><p>结构冲突：包括同一对象在不同应用中具有不同的抽象，以及统一实体在不同的局部E-R图中所包含的属性个数和属性排列次序不完全相同。</p><p>本题中，培训师属于员工的一种，所以不应该抽象为两个不同的实体，这种冲突属于结构冲突，解决方案是员工实体中加入职称属性，然后把培训教师实体删除。</p>",
                    "like": 0,
                    "answer": [
                        "C"
                    ],
                    "option": [
                        "员工实体和培训师实体均保持不变",
                        "保留员工实体、删除培训师实体",
                        "员工实体中加入职称属性，删除培训师实体",
                        "将培训师实体所有属性并入员工实体，删除培训师实体"
                    ]
                },
                {
                    "index": 170,
                    "belong_page": 1,
                    "question_id": 350286,
                    "question_title": "<p>某商场商品数据库的商品关系模式P(商品代码，商品名称，供应商，联系方式，库存量)，函数依赖集F={商品代码→商品名称，(商品代码，供应商)→库存量，供应商→联系方式}。商品关系模式P达到&nbsp;（6） ；该关系模式分解成&nbsp;（7） 后，具有无损连接的特性，并能够保持函数依赖。</p>",
                    "question_type": 9,
                    "answer_type": 1,
                    "show_type_name": "单选题",
                    "new_parent_id": 350285,
                    "score_rule": "",
                    "material_text": null,
                    "sort_son": "1",
                    "analyze": "<p>根据题意，零件P关系中的(商品代码，供应商)可决定的零件P关系的所有属性，所以零件P关系的主键为(商品代码，供应商)；又因为，根据题意(商品代码，供应商)→商品名称，而商品代码→商品名称，存在部分依赖关系不满足2NF，因此该关系模式属于1NF。</p><p>由于关系模式P属于1NF，1NF存在冗余度大、修改操作的不一致性、插入异常和删除异常四个问题。所以需要对模式分解，其中选项A、选项B和选项C分解后的P1∩P2=∅，是有损连接，并且分解后的关系式丢失了函数依赖，如选项A中的P1(商品代码，联系方式)与原F关系式中的“商品代码→商品”不相符，即不保持函数依赖。</p>",
                    "like": 0,
                    "answer": [
                        "A"
                    ],
                    "option": [
                        " 1NF ",
                        " 2NF ",
                        " 3NF ",
                        " BCNF "
                    ]
                },
                {
                    "index": 171,
                    "belong_page": 1,
                    "question_id": 350287,
                    "question_title": "<p>某商场商品数据库的商品关系模式P(商品代码，商品名称，供应商，联系方式，库存量)，函数依赖集F={商品代码→商品名称，(商品代码，供应商)→库存量，供应商→联系方式}。商品关系模式P达到&nbsp;（6） ；该关系模式分解成&nbsp;（7） 后，具有无损连接的特性，并能够保持函数依赖。</p>",
                    "question_type": 9,
                    "answer_type": 1,
                    "show_type_name": "单选题",
                    "new_parent_id": 350285,
                    "score_rule": "",
                    "material_text": null,
                    "sort_son": "2",
                    "analyze": "<p>根据题意，零件P关系中的(商品代码，供应商)可决定的零件P关系的所有属性，所以零件P关系的主键为(商品代码，供应商)；又因为，根据题意(商品代码，供应商)→商品名称，而商品代码→商品名称，存在部分依赖关系不满足2NF，因此该关系模式属于1NF。</p><p>由于关系模式P属于1NF，1NF存在冗余度大、修改操作的不一致性、插入异常和删除异常四个问题。所以需要对模式分解，其中选项A、选项B和选项C分解后的P1∩P2=∅，是有损连接，并且分解后的关系式丢失了函数依赖，如选项A中的P1(商品代码，联系方式)与原F关系式中的“商品代码→商品”不相符，即不保持函数依赖。</p>",
                    "like": 0,
                    "answer": [
                        "D"
                    ],
                    "option": [
                        " P1(商品代码，联系方式)，P2(商品名称，供应商，库存量) ",
                        " P1(商品名称，联系方式)，P2(商品代码，供应商，库存量) ",
                        " P1(商品代码，商品名称，联系方式)，P2(供应商，库存量) ",
                        " P1(商品代码，商品名称)，P2(商品代码，供应商，库存量)，P3(供应商，联系方式) "
                    ]
                },
                {
                    "index": 172,
                    "belong_page": 1,
                    "question_id": 350288,
                    "question_title": "<p>典型的事务服务器系统包括多个在共享内存中访问数据的进程，其中&nbsp;（8） 监控其它进程，一旦进程失败，它将为该失败进程执行恢复动作，并重启该进程。</p>",
                    "question_type": 1,
                    "answer_type": 1,
                    "show_type_name": "单选题",
                    "new_parent_id": 350288,
                    "score_rule": "",
                    "material_text": "",
                    "sort_son": "0",
                    "analyze": "<p>事务服务器包括多个在共享内存中访问数据的进程：</p><p>服务器进程：接收用户查询（事务）、执行查询并返回结果的进程。</p><p>锁管理器进程：包括锁授予、释放锁和死锁检测。</p><p>数据库写进程：有一个或多个进程用来将修改过的缓冲块输出到基于连续方式的磁盘中。</p><p>日志写进程：该进程将日志记录从日志记录缓冲区输出到稳定存储器上。</p><p>检查点进程：定期执行检查点操作。</p><p>进程监控进程：监控其他进程。一旦有进程失败，它将为失败进程执行恢复动作。</p>",
                    "like": 0,
                    "answer": [
                        "C"
                    ],
                    "option": [
                        " 检查点进程 ",
                        " 数据库写进程&nbsp; ",
                        " 进程监控进程 ",
                        " 锁管理器进程 "
                    ]
                },
                {
                    "index": 173,
                    "belong_page": 1,
                    "question_id": 350289,
                    "question_title": "<p>设有职务工资关系P（职务，最低工资，最高工资），员工关系EMP（员工号，职务，工资），要求任何一名员工，其工资值必须大于或等于政府规定的社会最低工资标准，实现该需求的方法是&nbsp;（9） 。</p>",
                    "question_type": 1,
                    "answer_type": 1,
                    "show_type_name": "单选题",
                    "new_parent_id": 350289,
                    "score_rule": "",
                    "material_text": "",
                    "sort_son": "0",
                    "analyze": "<p>数据库的完整性是指数据库中数据的正确性和相容性。数据库完整性由各种各样的完整性约束来保证，完整性约束可以通过DBMS或应用程序来实现，基于DBMS的完整性约束作为关系模式的一部分存入数据库中。</p><p>常见的完整性约束有以下几种。</p><p>1. 实体完整性</p><p>实体完整性要求主键中的任一属性不能为空，所谓空值是“不知道”或“无意义”的值。</p><p>2. 参照完整性</p><p>若基本关系 R 中含有与另一基本关系 S 的主键 PK 相对应的属性组 FK（FK 称为 R的外键），则参照完整性要求，对 R 中的每个元组在 FK 上的值必须是 S 中某个元组的PK 值，或者为空值。</p><p>3. 用户定义的完整性</p><p>实体完整性和参照完整性适用于任何关系型 DBMS。除此之外，不同的数据库系统根据其应用环境的不同，往往还需要一些特殊的约束条件。用户定义的完整性就是针对某一具体数据库的约束条件，反映某一具体应用所涉及的数据必须满足的语义要求。</p><p>4. 触发器</p><p>触发器是在关系型 DBMS 中应用得比较多的一种完整性保护措施，其功能比完整性约束要强得多。一般而言，在完整性约束功能中，当系统检查出数据中有违反完整性约束条件时，则仅给出必要提示以通知用户，仅此而已。而触发器的功能则不仅起到提示作用，还会引起系统自动进行某些操作，以消除违反完整性约束条件所引起的负面影响。</p><p>本题中要求字段的值必须大于或等于某个预定义的值，这可以用用户定义的完整性约束来实现，在数据库定义时常常体现为check(Field &gt;= PREDEFINED_VALUE)。</p>",
                    "like": 0,
                    "answer": [
                        "C"
                    ],
                    "option": [
                        " 建立“EMP.职务”向“P.职务”的参照完整性约束 ",
                        " 建立“P.职务”向“EMP.职务”的参照完整性约束 ",
                        " 建立EMP上的用户定义完整性约束 ",
                        " 建立P上的触发器程序审定该需求 "
                    ]
                },
                {
                    "index": 174,
                    "belong_page": 1,
                    "question_id": 350290,
                    "question_title": "<p>事务的隔离性保证操作并发执行后的系统状态与这些操作以某种次序顺序执行（即可串行化执行）后的状态是等价的。两阶段锁协议是实现隔离性的常见方案，该协议&nbsp;（10）&nbsp;。</p>",
                    "question_type": 1,
                    "answer_type": 1,
                    "show_type_name": "单选题",
                    "new_parent_id": 350290,
                    "score_rule": "",
                    "material_text": "",
                    "sort_son": "0",
                    "analyze": "<p>两阶段锁协议是实现事务隔离性的常见方案，该协议通过定义锁的增长和收缩两个阶段约束事务的加锁和解锁过程，能够保证事务的串行化执行，但由于事务不能一次得到所有需要的锁，因此该协议会可能会导致死锁。</p>",
                    "like": 0,
                    "answer": [
                        "A"
                    ],
                    "option": [
                        " 能够保证事务的可串行化执行，可能发生死锁 ",
                        " 不能保证事务的可串行化执行，不会发生死锁 ",
                        " 不能保证事务的可串行化执行，可能发生死锁 ",
                        " 能够保证事务的可串行化执行，不会发生死锁 "
                    ]
                },
                {
                    "index": 175,
                    "belong_page": 1,
                    "question_id": 352247,
                    "question_title": "<p>&nbsp;给定关系模式R（U,F），其中属性集U={A1,A2,A3,A4,A5,A6}，函数依赖集F={A1→A2，A1→A3，A3→A5，A1A5→A6}。关系模式R的候选码为&nbsp;（6） ，R属于&nbsp;（7） 。</p>",
                    "question_type": 9,
                    "answer_type": 1,
                    "show_type_name": "单选题",
                    "new_parent_id": 352246,
                    "score_rule": "",
                    "material_text": null,
                    "sort_son": "1",
                    "analyze": "<p>由于属性A1、A4的入度为0，所以候选码必然包含这两个属性，而从这两个属性能推出所有属性，所以A1A4组合键为候选码。</p><p>2NF的规定是消除非主属性对码的部分函数依赖，本题未消除该依赖，说明未达到2NF，只能选1NF。</p>",
                    "like": 0,
                    "answer": [
                        "B"
                    ],
                    "option": [
                        " A1A3 ",
                        " A1A4 ",
                        " A1A5 ",
                        " A1A6 "
                    ]
                },
                {
                    "index": 176,
                    "belong_page": 1,
                    "question_id": 352248,
                    "question_title": "<p>&nbsp;给定关系模式R（U,F），其中属性集U={A1,A2,A3,A4,A5,A6}，函数依赖集F={A1→A2，A1→A3，A3→A5，A1A5→A6}。关系模式R的候选码为&nbsp;（6） ，R属于&nbsp;（7） 。</p>",
                    "question_type": 9,
                    "answer_type": 1,
                    "show_type_name": "单选题",
                    "new_parent_id": 352246,
                    "score_rule": "",
                    "material_text": null,
                    "sort_son": "2",
                    "analyze": "<p>由于属性A1、A4的入度为0，所以候选码必然包含这两个属性，而从这两个属性能推出所有属性，所以A1A4组合键为候选码。</p><p>2NF的规定是消除非主属性对码的部分函数依赖，本题未消除该依赖，说明未达到2NF，只能选1NF。</p>",
                    "like": 0,
                    "answer": [
                        "A"
                    ],
                    "option": [
                        " 1NF ",
                        " 2NF ",
                        " 3NF ",
                        " BCNF "
                    ]
                },
                {
                    "index": 177,
                    "belong_page": 1,
                    "question_id": 352250,
                    "question_title": "<p>&nbsp;给定关系R（A,B,C,D,E）与S（A,B,C,F,G），那么与表达式π1,2,3,6,7（σ1&lt;7（R⋈S））等价的SQL语句为select &nbsp;（8） &nbsp;from R,S where &nbsp;（9） 。</p>",
                    "question_type": 9,
                    "answer_type": 1,
                    "show_type_name": "单选题",
                    "new_parent_id": 352249,
                    "score_rule": "",
                    "material_text": null,
                    "sort_son": "1",
                    "analyze": "<p>本题考查关系代数运算与SQL语言的对应关系，注意本题中R与S是执行自然连接操作。操作时会将R与S中相同字段名进行等值连接，并将结果集去重复，所以R与S自然连接后的结果包括以下属性：</p><p>R.A，R.B，R.C，D，E，F，G。</p><p>关系代数选择条件为“1&lt;7”，即R.A&lt;G。</p><p>关系代数投影操作条件为“1,2,3,6,7”，对应的属性为R.A，R.B，S.C，F，G。</p>",
                    "like": 0,
                    "answer": [
                        "D"
                    ],
                    "option": [
                        " R.A，R.B，S.C，R.E，G ",
                        " R.A，R.B，D，F，G ",
                        " R.A，R.B，S.C，R.D，F ",
                        " R.A，R.B，S.C，F，G "
                    ]
                },
                {
                    "index": 178,
                    "belong_page": 1,
                    "question_id": 352251,
                    "question_title": "<p>&nbsp;给定关系R（A,B,C,D,E）与S（A,B,C,F,G），那么与表达式π1,2,3,6,7（σ1&lt;7（R⋈S））等价的SQL语句为select &nbsp;（8） &nbsp;from R,S where &nbsp;（9） 。</p>",
                    "question_type": 9,
                    "answer_type": 1,
                    "show_type_name": "单选题",
                    "new_parent_id": 352249,
                    "score_rule": "",
                    "material_text": null,
                    "sort_son": "2",
                    "analyze": "<p>本题考查关系代数运算与SQL语言的对应关系，注意本题中R与S是执行自然连接操作。操作时会将R与S中相同字段名进行等值连接，并将结果集去重复，所以R与S自然连接后的结果包括以下属性：</p><p>R.A，R.B，R.C，D，E，F，G。</p><p>关系代数选择条件为“1&lt;7”，即R.A&lt;G。</p><p>关系代数投影操作条件为“1,2,3,6,7”，对应的属性为R.A，R.B，S.C，F，G。</p>",
                    "like": 0,
                    "answer": [
                        "D"
                    ],
                    "option": [
                        " R.A=S.A OR R.B=S.B OR R.C=S.C OR R.A&lt;S.F ",
                        " R.A=S.A OR R.B=S.B OR R.C=S.C OR R.A&lt;S.B ",
                        " R.A=S.A AND R.B=S.B AND R.C=S.C AND R.A&lt;S.F ",
                        " R.A=S.A AND R.B=S.B AND R.C=S.C AND R.A&lt;S.G "
                    ]
                },
                {
                    "index": 179,
                    "belong_page": 1,
                    "question_id": 352252,
                    "question_title": "<p>&nbsp;分布式数据库两阶段提交协议中的两个阶段是指&nbsp;（10） 。</p>",
                    "question_type": 1,
                    "answer_type": 1,
                    "show_type_name": "单选题",
                    "new_parent_id": 352252,
                    "score_rule": "",
                    "material_text": "",
                    "sort_son": "0",
                    "analyze": "<p>两阶段提交是指在计算机网络，以及数据库领域内，为了使基于分布式系统架构下的所 有节点在进行事务提交时保持一致性而设计的一种算法。通常， 两阶段提交也被称为是“一 种协议”。在分布式系统中， 每个节点虽然可以知晓自己的操作的成功或者失败， 却无法知 道其他节点的操作的成功或失败。当一个事务跨越多个节点时，为了保持事务的 ACID 特性， 需要引入一个作为协调者的组件来统一掌控所有节点(称为“参与者”)的操作结果并最终 指示这些节点是否要把操作结果进行真正的提交(如将更新后的数据写入磁盘等) 。因此两 阶段提交的算法思路可以概括为参与者将操作成败通知协调者， 再由协调者根据所有参与者 的反馈决定各参与者是否要执行提交操作还是中止操作。</p><p>所谓的两个阶段是指准备阶段(表决阶段)和提交阶段(执行阶段)。</p><p>(1) &nbsp;准备阶段：事务协调者(事务管理器)为每个参与者(资源管理器)发送 Prepare 消息，每个参与者要么直接返回失败(如权限验证失败)； 要么在本地执行事务，写本地的redo 和undo 日志，但不提交。到达一种万事俱备，只欠东风的状态。</p><p>(2) 提交阶段：如果协调者收到了参与者的失败消息或者超时，直接为每个参与者发送 回滚(Rollback)消息；否则发送提交(Commit)消息。参与者根据协调者的指令执行提交或者回滚操作，释放所有事务处理过程中使用的锁资源(注意必须在最后阶段释放锁资源)。。</p>",
                    "like": 0,
                    "answer": [
                        "C"
                    ],
                    "option": [
                        " 加锁阶段、解锁阶段 ",
                        " 获取阶段、运行阶段 ",
                        " 表决阶段、执行阶段 ",
                        " 扩展阶段、收缩阶段 "
                    ]
                },
                {
                    "index": 180,
                    "belong_page": 1,
                    "question_id": 352253,
                    "question_title": "<p>&nbsp;在分布式数据库中包括分片透明、复制透明、位置透明和逻辑透明等基本概念， 其中&nbsp;（11） 是指用户不需要知道数据是复制到哪些节点及如何复制的。</p>",
                    "question_type": 1,
                    "answer_type": 1,
                    "show_type_name": "单选题",
                    "new_parent_id": 352253,
                    "score_rule": "",
                    "material_text": "",
                    "sort_son": "0",
                    "analyze": "<p>本题考查对分布式数据库基本概念的理解，分片透明是指用户或应用程序不需要知道逻 辑上访问的表具体是如何分块存储的；复制透明是指采用复制技术的分布方法，用户不需要 知道数据是复制到哪些节点及如何复制的；位置透明是指用户无须知道数据存放的物理位置； 逻辑透明，即局部数据模型透明，是指用户或应用程序无须知道局部场地使用的是哪种数据 模型。</p>",
                    "like": 0,
                    "answer": [
                        "B"
                    ],
                    "option": [
                        " 分片透明 ",
                        " 复制透明 ",
                        " 位置透明 ",
                        " 逻辑透明 "
                    ]
                },
                {
                    "index": 181,
                    "belong_page": 1,
                    "question_id": 352367,
                    "question_title": "<p>数据库系统运行的基本工作单位是事务，事务相当于操作系统中的进程，是用户定义的一个数据库操作序列，这些操作序列要么全做要么全不做，是一个不可分割的工作单位。数据库的（10）是指操作序列要么全做要么全不做。设计时用（11）实现。数据库从一个一致性状态变到另一个一致性状态的性质称为（12）。设计时用（13）检查实现。</p>",
                    "question_type": 9,
                    "answer_type": 1,
                    "show_type_name": "单选题",
                    "new_parent_id": 352366,
                    "score_rule": "",
                    "material_text": null,
                    "sort_son": "1",
                    "analyze": "<p>数据库的原子性是指操作序列要么全做要么全不做。设计时用影子拷贝（浅拷贝）实现。浅拷贝就是你的影子,深拷贝是你的克隆人,你没了影子也就没了,但是克隆人还活着。数据库从一个一致性状态变到另一个一致性状态称为一致性。设计时用完整性约束检查实现。</p>",
                    "like": 0,
                    "answer": [
                        "C"
                    ],
                    "option": [
                        " 一致性 ",
                        " 可用性 ",
                        " 原子性 ",
                        " 隔离性 "
                    ]
                },
                {
                    "index": 182,
                    "belong_page": 1,
                    "question_id": 352368,
                    "question_title": "<p>数据库系统运行的基本工作单位是事务，事务相当于操作系统中的进程，是用户定义的一个数据库操作序列，这些操作序列要么全做要么全不做，是一个不可分割的工作单位。数据库的（10）是指操作序列要么全做要么全不做。设计时用（11）实现。数据库从一个一致性状态变到另一个一致性状态的性质称为（12）。设计时用（13）检查实现。</p>",
                    "question_type": 9,
                    "answer_type": 1,
                    "show_type_name": "单选题",
                    "new_parent_id": 352366,
                    "score_rule": "",
                    "material_text": null,
                    "sort_son": "2",
                    "analyze": "<p>数据库的原子性是指操作序列要么全做要么全不做。设计时用影子拷贝（浅拷贝）实现。浅拷贝就是你的影子,深拷贝是你的克隆人,你没了影子也就没了,但是克隆人还活着。数据库从一个一致性状态变到另一个一致性状态称为一致性。设计时用完整性约束检查实现。</p>",
                    "like": 0,
                    "answer": [
                        "A"
                    ],
                    "option": [
                        " 影子拷贝 ",
                        " 差异备份 ",
                        " 深拷贝 ",
                        " 完全备份 "
                    ]
                },
                {
                    "index": 183,
                    "belong_page": 1,
                    "question_id": 352369,
                    "question_title": "<p>数据库系统运行的基本工作单位是事务，事务相当于操作系统中的进程，是用户定义的一个数据库操作序列，这些操作序列要么全做要么全不做，是一个不可分割的工作单位。数据库的（10）是指操作序列要么全做要么全不做。设计时用（11）实现。数据库从一个一致性状态变到另一个一致性状态的性质称为（12）。设计时用（13）检查实现。</p>",
                    "question_type": 9,
                    "answer_type": 1,
                    "show_type_name": "单选题",
                    "new_parent_id": 352366,
                    "score_rule": "",
                    "material_text": null,
                    "sort_son": "3",
                    "analyze": "<p>数据库的原子性是指操作序列要么全做要么全不做。设计时用影子拷贝（浅拷贝）实现。浅拷贝就是你的影子,深拷贝是你的克隆人,你没了影子也就没了,但是克隆人还活着。数据库从一个一致性状态变到另一个一致性状态称为一致性。设计时用完整性约束检查实现。</p>",
                    "like": 0,
                    "answer": [
                        "A"
                    ],
                    "option": [
                        " 一致性 ",
                        " 完整性&nbsp; ",
                        " 原子性 ",
                        " 隔离性 "
                    ]
                },
                {
                    "index": 184,
                    "belong_page": 1,
                    "question_id": 352370,
                    "question_title": "<p>数据库系统运行的基本工作单位是事务，事务相当于操作系统中的进程，是用户定义的一个数据库操作序列，这些操作序列要么全做要么全不做，是一个不可分割的工作单位。数据库的（10）是指操作序列要么全做要么全不做。设计时用（11）实现。数据库从一个一致性状态变到另一个一致性状态的性质称为（12）。设计时用（13）检查实现。</p>",
                    "question_type": 9,
                    "answer_type": 1,
                    "show_type_name": "单选题",
                    "new_parent_id": 352366,
                    "score_rule": "",
                    "material_text": null,
                    "sort_son": "4",
                    "analyze": "<p>数据库的原子性是指操作序列要么全做要么全不做。设计时用影子拷贝（浅拷贝）实现。浅拷贝就是你的影子,深拷贝是你的克隆人,你没了影子也就没了,但是克隆人还活着。数据库从一个一致性状态变到另一个一致性状态称为一致性。设计时用完整性约束检查实现。</p>",
                    "like": 0,
                    "answer": [
                        "B"
                    ],
                    "option": [
                        " 封锁协议 ",
                        " 完整性约束 ",
                        " 影子拷贝 ",
                        " 测试 "
                    ]
                },
                {
                    "index": 185,
                    "belong_page": 1,
                    "question_id": 352371,
                    "question_title": "<p>&nbsp;数据仓库不包括（）</p>",
                    "question_type": 1,
                    "answer_type": 1,
                    "show_type_name": "单选题",
                    "new_parent_id": 352371,
                    "score_rule": "",
                    "material_text": "",
                    "sort_son": "0",
                    "analyze": "<p>数据仓库包括数据源、数据的存储与管理、OLAP 服务器与各种报表工具、查询工具、数据分析工具、数据挖掘工具及各种基于数据仓库或数据集市的应用开发工具。OLTP是传统的关系型数据库联机事务处理过程。</p>",
                    "like": 0,
                    "answer": [
                        "C"
                    ],
                    "option": [
                        " 数据源 ",
                        " OLAP 服务器 ",
                        " OLTP 服务器&nbsp;&nbsp;&nbsp; ",
                        " 报表工具 "
                    ]
                },
                {
                    "index": 186,
                    "belong_page": 1,
                    "question_id": 352372,
                    "question_title": "<p>&nbsp;分布式数据库缓存技术有Memcache与Redis，关于两者的说法正确的是（）</p>",
                    "question_type": 1,
                    "answer_type": 1,
                    "show_type_name": "单选题",
                    "new_parent_id": 352372,
                    "score_rule": "",
                    "material_text": "",
                    "sort_son": "0",
                    "analyze": "<p>两者的对比如下所示：</p><img style=\"max-width:100%;height:auto\"  src=\"https://s2.51cto.com/images/20220923/1663934574539480.png\" title=\"1663934574539480.png\" alt=\"image.png\"/>",
                    "like": 0,
                    "answer": [
                        "D"
                    ],
                    "option": [
                        " Memcache不仅仅支持简单的k/v类型的数据，同时还提供list，set，hash等数据结构的存储。 ",
                        " Redis支持多线程 ",
                        " Memcache不能进行内存管理 ",
                        " Redis支持主从、sentinel、cluster等分布式存储方式 "
                    ]
                },
                {
                    "index": 187,
                    "belong_page": 1,
                    "question_id": 352373,
                    "question_title": "<p>&nbsp;数据仓库中的（）消除了源数据中的不一致性，提供整个企业的一致性全局信息。</p>",
                    "question_type": 1,
                    "answer_type": 1,
                    "show_type_name": "单选题",
                    "new_parent_id": 352373,
                    "score_rule": "",
                    "material_text": "",
                    "sort_son": "0",
                    "analyze": "<p>数据仓库4大特点：</p><p>面向主题：数据按主题组织。</p><p>集成的：消除了源数据中的不一致性，提供整个企业的一致性全局信息。</p><p>相对稳定的(非易失的)：主要进行查询操作，只有少量的修改和删除操作（或是不删除）。</p><p>反映历史变化(随着时间变化)：记录了企业从过去某一时刻到当前各个阶段的信息，可对发展历程和未来趋势做定量分析和预测。</p>",
                    "like": 0,
                    "answer": [
                        "B"
                    ],
                    "option": [
                        " 面向主题性 ",
                        " 集成性 ",
                        " 稳定性 ",
                        " 反映历史变化性 "
                    ]
                },
                {
                    "index": 188,
                    "belong_page": 1,
                    "question_id": 352375,
                    "question_title": "<p>&nbsp;分布透明性指用户不必关心数据的逻辑分片，不必关心数据存储的物理位置分配细节，也不必关心局部场地上数据库的数据模型。（）是分布透明性的最高层次。（）指用户或应用程序应当了解分片情况，但不必了解片段的存储场地。（）透明性是指用户或应用程序应当了解分片及各片断存储的场地，但不必了解局部场地上使用的是何种数据模型。</p>",
                    "question_type": 9,
                    "answer_type": 1,
                    "show_type_name": "单选题",
                    "new_parent_id": 352374,
                    "score_rule": "",
                    "material_text": null,
                    "sort_son": "1",
                    "analyze": "<p>&nbsp; &nbsp;分布透明性包括：分片透明性、位置透明性和局部数据模型透明性。</p><p>（1）分片透明性是分布透明性的最高层次。所谓分片透明性是指用户或应用程序只对全局关系进行操作而不必考虑数据的分片。当分片模式改变时，只要改变全局模式到分片模式的映像，而不影响全局模式和应用程序。全局模式不变，应用程序不必改写，这就是分片透明性。</p><p>&nbsp;（2）位置透明性是分布透明性的下一层次。所谓位置透明性是指，用户或应用程序应当了解分片情况，但不必了解片段的存储场地。</p><p>&nbsp;（3）局部数据模型（逻辑透明）透明性是指用户或应用程序应当了解分片及各片断存储的场地，但不必了解局部场地上使用的是何种数据模型。</p>",
                    "like": 0,
                    "answer": [
                        "A"
                    ],
                    "option": [
                        " 分片透明性 ",
                        " 逻辑透明性 ",
                        " 位置透明性 ",
                        " 全局透明性 "
                    ]
                },
                {
                    "index": 189,
                    "belong_page": 1,
                    "question_id": 352376,
                    "question_title": "<p>&nbsp;分布透明性指用户不必关心数据的逻辑分片，不必关心数据存储的物理位置分配细节，也不必关心局部场地上数据库的数据模型。（）是分布透明性的最高层次。（）指用户或应用程序应当了解分片情况，但不必了解片段的存储场地。（）透明性是指用户或应用程序应当了解分片及各片断存储的场地，但不必了解局部场地上使用的是何种数据模型。</p>",
                    "question_type": 9,
                    "answer_type": 1,
                    "show_type_name": "单选题",
                    "new_parent_id": 352374,
                    "score_rule": "",
                    "material_text": null,
                    "sort_son": "2",
                    "analyze": "<p>&nbsp; &nbsp;分布透明性包括：分片透明性、位置透明性和局部数据模型透明性。</p><p>（1）分片透明性是分布透明性的最高层次。所谓分片透明性是指用户或应用程序只对全局关系进行操作而不必考虑数据的分片。当分片模式改变时，只要改变全局模式到分片模式的映像，而不影响全局模式和应用程序。全局模式不变，应用程序不必改写，这就是分片透明性。</p><p>&nbsp;（2）位置透明性是分布透明性的下一层次。所谓位置透明性是指，用户或应用程序应当了解分片情况，但不必了解片段的存储场地。</p><p>&nbsp;（3）局部数据模型（逻辑透明）透明性是指用户或应用程序应当了解分片及各片断存储的场地，但不必了解局部场地上使用的是何种数据模型。</p>",
                    "like": 0,
                    "answer": [
                        "C"
                    ],
                    "option": [
                        " &nbsp;分片透明性 ",
                        " &nbsp;逻辑透明性 ",
                        " &nbsp;位置透明性 ",
                        " &nbsp;全局透明性 "
                    ]
                },
                {
                    "index": 190,
                    "belong_page": 1,
                    "question_id": 352377,
                    "question_title": "<p>&nbsp;分布透明性指用户不必关心数据的逻辑分片，不必关心数据存储的物理位置分配细节，也不必关心局部场地上数据库的数据模型。（）是分布透明性的最高层次。（）指用户或应用程序应当了解分片情况，但不必了解片段的存储场地。（）透明性是指用户或应用程序应当了解分片及各片断存储的场地，但不必了解局部场地上使用的是何种数据模型。</p>",
                    "question_type": 9,
                    "answer_type": 1,
                    "show_type_name": "单选题",
                    "new_parent_id": 352374,
                    "score_rule": "",
                    "material_text": null,
                    "sort_son": "3",
                    "analyze": "<p>&nbsp; &nbsp;分布透明性包括：分片透明性、位置透明性和局部数据模型透明性。</p><p>（1）分片透明性是分布透明性的最高层次。所谓分片透明性是指用户或应用程序只对全局关系进行操作而不必考虑数据的分片。当分片模式改变时，只要改变全局模式到分片模式的映像，而不影响全局模式和应用程序。全局模式不变，应用程序不必改写，这就是分片透明性。</p><p>&nbsp;（2）位置透明性是分布透明性的下一层次。所谓位置透明性是指，用户或应用程序应当了解分片情况，但不必了解片段的存储场地。</p><p>&nbsp;（3）局部数据模型（逻辑透明）透明性是指用户或应用程序应当了解分片及各片断存储的场地，但不必了解局部场地上使用的是何种数据模型。</p>",
                    "like": 0,
                    "answer": [
                        "B"
                    ],
                    "option": [
                        " 分片透明性&nbsp; &nbsp;",
                        " 逻辑透明性&nbsp; ",
                        " 位置透明性&nbsp; ",
                        " 全局透明性&nbsp; "
                    ]
                },
                {
                    "index": 191,
                    "belong_page": 1,
                    "question_id": 352378,
                    "question_title": "<p>&nbsp;给定关系模式 R&lt;U,F&gt;;其中 U 为属性集，F 是 U 上的一组函数依赖，那么 Armstroog 公理系统的增广律是指（ ）。&nbsp;</p>",
                    "question_type": 1,
                    "answer_type": 1,
                    "show_type_name": "单选题",
                    "new_parent_id": 352378,
                    "score_rule": "",
                    "material_text": "",
                    "sort_son": "0",
                    "analyze": "<p>从已知的一些函数依赖，可以推导出另外一些函数依赖，这就需要一系列推理规则。函数依赖的推理规则最早出现在1974年W.W.Armstrong 的论文里，这些规则常被称作“Armstrong 公理”</p><p>设U 是关系模式R 的属性集，F 是R 上成立的只涉及U 中属性的函数依赖集。函数依赖的推理规则有以下三条：</p><p>自反律：若属性集Y 包含于属性集X，属性集X 包含于U，则X→Y 在R 上成立。(此处X→Y是平凡函数依赖)</p><p>增广律：若X→Y 在R 上成立，且属性集Z 包含于属性集U，则XZ→YZ 在R 上成立。</p><p>传递律：若X→Y 和 Y→Z在R 上成立，则X →Z 在R 上成立。</p><p>其他的所有函数依赖的推理规则可以使用这三条规则推导出。。</p>",
                    "like": 0,
                    "answer": [
                        "D"
                    ],
                    "option": [
                        " 若 X→Y，X→Z，则 X→YZ 为 F 所蕴涵&nbsp; ",
                        " 若 X→Y，WY→Z，则 XW→Z 为 F 所蕴涵&nbsp; ",
                        " 若 X→Y，Y→Z 为 F 所蕴涵，则 X→Z 为 F 所蕴涵&nbsp; ",
                        " 若 X→Y，为 F 所蕴涵，且 Z⊆U,则入 XZ→YZ 为 F 所蕴涵 "
                    ]
                },
                {
                    "index": 192,
                    "belong_page": 1,
                    "question_id": 352380,
                    "question_title": "<p>&nbsp;给定关系模式R(A，B，C，D）、S(C，D，E），与π1,3,5(σ2=‘软件工程’(RS))等价的SQL语句如下：SELECT（ ）FROM S WHERE（ ）；</p><p>下列查询B=“信息”且E=“北京”的A、B、E的关系代数表达式中，查询效率最高的是（ ）。</p>",
                    "question_type": 9,
                    "answer_type": 1,
                    "show_type_name": "单选题",
                    "new_parent_id": 352379,
                    "score_rule": "",
                    "material_text": null,
                    "sort_son": "1",
                    "analyze": "<p>B的最长查询语句最短，因此可以并行执行，提高效率。</p>",
                    "like": 0,
                    "answer": [
                        "C"
                    ],
                    "option": [
                        " A,C,S.C ",
                        " A,B,E&nbsp; ",
                        " A,R.C,E&nbsp; ",
                        " A,R.C,S,D "
                    ]
                },
                {
                    "index": 193,
                    "belong_page": 1,
                    "question_id": 352381,
                    "question_title": "<p>&nbsp;给定关系模式R(A，B，C，D）、S(C，D，E），与π1,3,5(σ2=‘软件工程’(RS))等价的SQL语句如下：SELECT（ ）FROM S WHERE（ ）；</p><p>下列查询B=“信息”且E=“北京”的A、B、E的关系代数表达式中，查询效率最高的是（ ）。</p>",
                    "question_type": 9,
                    "answer_type": 1,
                    "show_type_name": "单选题",
                    "new_parent_id": 352379,
                    "score_rule": "",
                    "material_text": null,
                    "sort_son": "2",
                    "analyze": "<p>B的最长查询语句最短，因此可以并行执行，提高效率。</p>",
                    "like": 0,
                    "answer": [
                        "D"
                    ],
                    "option": [
                        " B=软件工程OR R. C=S. C AND R. D=S. D ",
                        " B=‘软件工程’OR R. C=S. C AND R. D=S. D ",
                        " B=‘软件工程’OR R. C=S. C OR R. D=S. D&nbsp; ",
                        " B=‘软件工程’AND R. C=S. C AND R. D=S. D "
                    ]
                },
                {
                    "index": 194,
                    "belong_page": 1,
                    "question_id": 352382,
                    "question_title": "<p>&nbsp;给定关系模式R(A，B，C，D）、S(C，D，E），与π1,3,5(σ2=‘软件工程’(RS))等价的SQL语句如下：SELECT（ ）FROM S WHERE（ ）；</p><p>下列查询B=“信息”且E=“北京”的A、B、E的关系代数表达式中，查询效率最高的是（ ）。</p>",
                    "question_type": 9,
                    "answer_type": 1,
                    "show_type_name": "单选题",
                    "new_parent_id": 352379,
                    "score_rule": "",
                    "material_text": null,
                    "sort_son": "3",
                    "analyze": "<p>B的最长查询语句最短，因此可以并行执行，提高效率。</p>",
                    "like": 0,
                    "answer": [
                        "B"
                    ],
                    "option": [
                        " <img style=\"max-width:100%;height:auto\" src=\"https://s2.51cto.com/images/20220923/1663934772609910.png\" title=\"1663934772609910.png\" alt=\"image.png\"/> ",
                        "<img style=\"max-width:100%;height:auto\" src=\"https://s2.51cto.com/images/20220923/1663934784362983.png\" title=\"1663934784362983.png\" alt=\"image.png\"/>",
                        "<img style=\"max-width:100%;height:auto\" src=\"https://s2.51cto.com/images/20220923/1663934797635231.png\" title=\"1663934797635231.png\" alt=\"image.png\"/>",
                        "<img style=\"max-width:100%;height:auto\" src=\"https://s2.51cto.com/images/20220923/1663934807550311.png\" title=\"1663934807550311.png\" alt=\"image.png\"/>"
                    ]
                },
                {
                    "index": 195,
                    "belong_page": 1,
                    "question_id": 356102,
                    "question_title": "<p>通常在设计关系模式时,派生属性不会作为关系中的属性来存储。按照这个原则,假设</p><p>原设计的学生关系模式为Students（学号,姓名,性别,出生日期,年龄,家庭地址）,那么</p><p>该关系模式正确的设计应为（）。</p>",
                    "question_type": 1,
                    "answer_type": 1,
                    "show_type_name": "单选题",
                    "new_parent_id": 356102,
                    "score_rule": "",
                    "material_text": "",
                    "sort_son": "0",
                    "analyze": "<p>本题考查关系数据库方面的基本概念。</p><p>在概念设计中,需要概括应用系统中的实体及其联系,确定实体和联系的属性。派生</p><p>属性是指可以由其他属性通过计算来获得,若在系统中存储派生属性,会引起数据冗余,</p><p>增加额外存储和维护负担,还可能导致数据的不一致性,故派生属性不会作为关系中的属</p><p>性来存储。</p><p>本题中“年龄”是派生属性,该属性可以由“系统当前时间-出生日期”计算获得,故</p><p>关系模式Students正确的设计是“年龄”不作为关系中的属性来存储。&nbsp;</p>",
                    "like": 0,
                    "answer": [
                        "C"
                    ],
                    "option": [
                        " A. Students （学号,性别, 出生日期,年龄,家庭地址）&nbsp; ",
                        " B. Students （学号,姓名,性别, 出生日期,年龄）&nbsp; ",
                        " C. Students （学号,姓名,性别, 出生日期,家庭地址）&nbsp; ",
                        " D. Students （学号,姓名, 出生日期,年龄,家庭地址） "
                    ]
                },
                {
                    "index": 196,
                    "belong_page": 1,
                    "question_id": 356106,
                    "question_title": "<p>给定关系模式R &lt;U,F&gt;，其中，属性集U={A、B、C、D、E}。函数依赖集F={AC→B,B→DE}。关系R（）。</p>",
                    "question_type": 1,
                    "answer_type": 1,
                    "show_type_name": "单选题",
                    "new_parent_id": 356106,
                    "score_rule": "",
                    "material_text": "",
                    "sort_son": "0",
                    "analyze": "<p>由“AC→B,B→DE”，可以判断AC是唯一候选键（候选关键字），通过AC可以获得其他全部属性。</p>",
                    "like": 0,
                    "answer": [
                        "A"
                    ],
                    "option": [
                        " A.只有一个候选关键字AC ",
                        " B.只有一个候选关键字AB ",
                        " C.有两个候选关键字AC、BC ",
                        " D.有两个候选关键字AC、AB "
                    ]
                },
                {
                    "index": 197,
                    "belong_page": 1,
                    "question_id": 356107,
                    "question_title": "<p>给定关系模式 R&lt;U,F&gt;;其中 U 为属性集，F 是 U 上的一组函数依赖，那么 Armstrong 公理系统的增广律是指（）。&nbsp;</p>",
                    "question_type": 1,
                    "answer_type": 1,
                    "show_type_name": "单选题",
                    "new_parent_id": 356107,
                    "score_rule": "",
                    "material_text": "",
                    "sort_son": "0",
                    "analyze": "<p>从已知的一些函数依赖，可以推导出另外一些函数依赖，这就需要一系列推理规则。函数依赖的推理规则最早出现在1974年W.W.Armstrong 的论文里，这些规则常被称作“Armstrong 公理”如下：</p><p>设U 是关系模式R 的属性集，F 是R 上成立的只涉及U 中属性的函数依赖集。函数依赖的推理规则有以下三条：</p><p>① A1自反律：若Y⊆X⊆U，则X→Y为F所蕴含；</p><p>② A2增广律：若X→Y为F所蕴含，且Z⊆U，则XZ→YZ为F所蕴含；</p><p>③ A3传递律：若X→Y，Y→Z为F所蕴含，则X→Z为F所蕴含。</p><p>根据上面三条推理规则，又可推出下面三条推理规则：</p><p>④ 合并规则：若X→Y，X→Z，则X→YZ为F所蕴含；</p><p>⑤ 伪传递规则：若X→Y，WY→Z，则XW→Z为F所蕴含；</p><p>⑥ 分解规则：若X→Y，Z⊆Y，则X→Z为F所蕴含。</p>",
                    "like": 0,
                    "answer": [
                        "D"
                    ],
                    "option": [
                        " A. 若 X→Y，X→Z，则 X→YZ 为 F 所蕴涵&nbsp; ",
                        " B. 若 X→Y，WY→Z，则 XW→Z 为 F 所蕴涵 ",
                        " C. 若 X→Y，Y→Z 为 F 所蕴涵，则 X→Z 为 F 所蕴涵&nbsp; ",
                        " D. 若 X→Y，为 F 所蕴涵，且 Z⊆U,则入 XZ→YZ 为 F 所蕴涵 "
                    ]
                },
                {
                    "index": 198,
                    "belong_page": 1,
                    "question_id": 356108,
                    "question_title": "<p>给定关系R（ABCDE）和关系S（ACEFG）。对其进行自然连接运算R▷◁S后其结果集的属性列为（）。</p>",
                    "question_type": 1,
                    "answer_type": 1,
                    "show_type_name": "单选题",
                    "new_parent_id": 356108,
                    "score_rule": "",
                    "material_text": "",
                    "sort_son": "0",
                    "analyze": "<p>自然连接会去掉右边关系S中重复的属性列。</p>",
                    "like": 0,
                    "answer": [
                        "B"
                    ],
                    "option": [
                        " A.R.A，R.C，R.E，S.A，S.C，S.E ",
                        " B.R.A，R.B，R.C，R.D，R.E，S.F，S.G ",
                        " C.R.A，R.B，R.C，R.D，R.E，S.A，S.C，S.E ",
                        " D.R.A，R.B，R.C，R.D，R.E，S.A，S.C，S.E，S.F，S.G "
                    ]
                },
                {
                    "index": 199,
                    "belong_page": 1,
                    "question_id": 356109,
                    "question_title": "<p>设有关系模式R(A1，A2，A3，A4，A5，A6)，其中：函数依赖集F={A1→A2，A1A3→A4，A5A6→A1，A2A5→A6，A3A5→A6}，则（）&nbsp;是关系模式R的一个主键。</p>",
                    "question_type": 1,
                    "answer_type": 1,
                    "show_type_name": "单选题",
                    "new_parent_id": 356109,
                    "score_rule": "",
                    "material_text": "",
                    "sort_son": "0",
                    "analyze": "<p>因为根据函数依赖集F可知属性A3和A5只出现在函数依赖的左部，故必为候选关键字属性，又因为A3A5可以决定关系R中的全部属性，故关系模式R的一个主键是A3A5。</p>",
                    "like": 0,
                    "answer": [
                        "C"
                    ],
                    "option": [
                        " A．A1 A4 ",
                        " B．A2 A4 ",
                        " C．A3 A5 ",
                        " D．A4 A5 "
                    ]
                },
                {
                    "index": 200,
                    "belong_page": 1,
                    "question_id": 356110,
                    "question_title": "<p>设有关系模式R(A1，A2，A3，A4，A5，A6)，其中：函数依赖集F={A1→A2，A1A3→A4，A5A6→A1，A2A5→A6，A3A5→A6}，则R规范化程度最高达到（）&nbsp;。</p>",
                    "question_type": 1,
                    "answer_type": 1,
                    "show_type_name": "单选题",
                    "new_parent_id": 356110,
                    "score_rule": "",
                    "material_text": "",
                    "sort_son": "0",
                    "analyze": "<p>接上题，因为根据函数依赖集F可知，R中的每个非主属性完全函数依赖于A3A5，但该函数依赖集中存在传递依赖，所以R是2NF。</p>",
                    "like": 0,
                    "answer": [
                        "B"
                    ],
                    "option": [
                        " A．1NF ",
                        " B．2NF ",
                        " C．3NF ",
                        " D．BCNF "
                    ]
                },
                {
                    "index": 201,
                    "belong_page": 1,
                    "question_id": 356189,
                    "question_title": "<p>采用三级模式结构的数据库系统中，如果对一个表创建聚索引，那么改变的是数据库的（5）</p>",
                    "question_type": 1,
                    "answer_type": 1,
                    "show_type_name": "单选题",
                    "new_parent_id": 356189,
                    "score_rule": "",
                    "material_text": "",
                    "sort_son": "0",
                    "analyze": "<p>内模式定义的是存储记录的类型、存储域的表示、存储记录的物理顺序，指引元、索引和存储路径等数据的存储组织。</p>",
                    "like": 0,
                    "answer": [
                        "C"
                    ],
                    "option": [
                        " 外模式 ",
                        " 模式 ",
                        " 内模式 ",
                        " 用户模式 "
                    ]
                },
                {
                    "index": 202,
                    "belong_page": 1,
                    "question_id": 356190,
                    "question_title": "<p>假设系统中有正在运行的事务，若要转储全部数据库，则应采用（6）方式.</p>",
                    "question_type": 1,
                    "answer_type": 1,
                    "show_type_name": "单选题",
                    "new_parent_id": 356190,
                    "score_rule": "",
                    "material_text": "",
                    "sort_son": "0",
                    "analyze": "<p>动态备份是指备份期间允许对数据库进行存取或修改，即备份和用户事务可以并发执行。</p>",
                    "like": 0,
                    "answer": [
                        "D"
                    ],
                    "option": [
                        " 静态全局转储 ",
                        " 动态增量转储 ",
                        " 静态增量转储 ",
                        " 动态全局转储 "
                    ]
                },
                {
                    "index": 203,
                    "belong_page": 1,
                    "question_id": 356191,
                    "question_title": "<p>给定关系模式R（U，F），其中U为属性集，F是U上的一组函数依赖，那么函数依赖的公理系统 （Armstrong 公理系统）中的分解规则是指（7）为F所蕴涵</p>",
                    "question_type": 1,
                    "answer_type": 1,
                    "show_type_name": "单选题",
                    "new_parent_id": 356191,
                    "score_rule": "",
                    "material_text": "",
                    "sort_son": "0",
                    "analyze": "<p>Armstrong公理系统设关系模式R&lt;U，F&gt;，其中U为属性集，F是U上的一组函数依赖，那么有如下推理规则：</p><p>①&nbsp;A1自反律：若Y⊆X⊆U，则X→Y为F所蕴含；</p><p>②&nbsp;A2增广律：若X→Y为F所蕴含，且Z⊆U，则XZ→YZ为F所蕴含；</p><p>③&nbsp;A3传递律：若X→Y，Y→Z为F所蕴含，则X→Z为F所蕴含。</p><p>&nbsp;</p><p>根据上面三条推理规则，又可推出下面三条推理规则：</p><p>④&nbsp;合并规则：若X→Y，X→Z，则X→YZ为F所蕴含；</p><p>⑤&nbsp;伪传递规则：若X→Y，WY→Z，则XW→Z为F所蕴含；</p><p>⑥&nbsp;分解规则：若X→Y，Z⊆Y，则X→Z为F所蕴含。</p>",
                    "like": 0,
                    "answer": [
                        "C"
                    ],
                    "option": [
                        " 若X→Y，Y→Z，则X→Y&nbsp; ",
                        " 若Y⊆X⊆U.则X→Y&nbsp; ",
                        " 若X→Y，Z⊆Y，则X→Z ",
                        " 若X→Y，Y→Z，则X→YZ "
                    ]
                },
                {
                    "index": 204,
                    "belong_page": 1,
                    "question_id": 356192,
                    "question_title": "<p>给定关系R（A，B，C，D）和S（A，C，E，F），以下（8）与<img style=\"max-width:100%;height:auto\"  src=\"https://s2.51cto.com/images/20221122/1669104880394176.png\" title=\"1669104880394176.png\" alt=\"image.png\"/>等价，</p>",
                    "question_type": 1,
                    "answer_type": 1,
                    "show_type_name": "单选题",
                    "new_parent_id": 356192,
                    "score_rule": "",
                    "material_text": "",
                    "sort_son": "0",
                    "analyze": "<p>首先，R与S中未提及具体值&#39;7&#39;，因此排除C、D选项；</p><p>其次，A选项未考虑自然连接，排除A；</p><p>最后，只有B选项中R×S做选择时，第一列与第五列（R.A=S.A）、第三列与第六列（R.C=S.C），才考虑了自然连接，B选择符合。</p>",
                    "like": 0,
                    "answer": [
                        "B"
                    ],
                    "option": [
                        " <img style=\"max-width:100%;height:auto\" src=\"https://s2.51cto.com/images/20221122/1669104047345754.png\" title=\"1669104047345754.png\" alt=\"image.png\"/> ",
                        " <img style=\"max-width:100%;height:auto\" src=\"https://s2.51cto.com/images/20221122/1669104057806273.png\" title=\"1669104057806273.png\" alt=\"image.png\"/> ",
                        " <img style=\"max-width:100%;height:auto\" src=\"https://s2.51cto.com/images/20221122/1669104135537538.png\" title=\"1669104135537538.png\" alt=\"image.png\"/> ",
                        " <img style=\"max-width:100%;height:auto\" src=\"https://s2.51cto.com/images/20221122/1669104091432156.png\" title=\"1669104091432156.png\" alt=\"image.png\"/> "
                    ]
                },
                {
                    "index": 205,
                    "belong_page": 1,
                    "question_id": 356104,
                    "question_title": "<p>给定关系R(A,B,C,D,E)与S(A,B,C,F,G)，那么与表达式<img style=\"max-width:100%;height:auto\"  width=\"135\" height=\"26\" src=\"https://static2.51cto.com/edu/exam/ueditor1.4.3/themes/default/images/spacer.gif\"/>等价的SQL语句如下：select（）from R, S where（）；</p>",
                    "question_type": 8,
                    "answer_type": 1,
                    "show_type_name": "完形填空题",
                    "new_parent_id": 356103,
                    "score_rule": "",
                    "material_text": null,
                    "sort_son": "1",
                    "analyze": "<p>本题考查关系代数运算与SQL语言的对应关系。注意本题中R与S是做自然联接操作，操作时会将R与S中相同字段名做等值联接，并将结果集去重复。所以R与S自然联接后的结果包括以下属性：</p><p>R.A，R.B，R.C，D，E，F，G。</p><p>关系代数选择条件为“1&lt;6”，即R.A&lt;F。</p><p>关系代数投影操作条件为“1,2,4,6,7”，对应的属性为：R.A，R.B，D，F，G。</p>",
                    "like": 0,
                    "answer": [
                        "B"
                    ],
                    "option": [
                        " A. R.A，R.B，R.E，S.C，G ",
                        " B. R.A，R.B，D，F，G ",
                        " C. R.A，R.B，R.D，S.C，F ",
                        " D. R.A，R.B，R.D，S.C，G "
                    ]
                },
                {
                    "index": 206,
                    "belong_page": 1,
                    "question_id": 356105,
                    "question_title": "<p>给定关系R(A,B,C,D,E)与S(A,B,C,F,G)，那么与表达式<img style=\"max-width:100%;height:auto\"  width=\"135\" height=\"26\" src=\"https://static2.51cto.com/edu/exam/ueditor1.4.3/themes/default/images/spacer.gif\"/>等价的SQL语句如下：select（）from R, S where（）；</p>",
                    "question_type": 8,
                    "answer_type": 1,
                    "show_type_name": "完形填空题",
                    "new_parent_id": 356103,
                    "score_rule": "",
                    "material_text": null,
                    "sort_son": "2",
                    "analyze": "<p>本题考查关系代数运算与SQL语言的对应关系。注意本题中R与S是做自然联接操作，操作时会将R与S中相同字段名做等值联接，并将结果集去重复。所以R与S自然联接后的结果包括以下属性：</p><p>R.A，R.B，R.C，D，E，F，G。</p><p>关系代数选择条件为“1&lt;6”，即R.A&lt;F。</p><p>关系代数投影操作条件为“1,2,4,6,7”，对应的属性为：R.A，R.B，D，F，G。</p>",
                    "like": 0,
                    "answer": [
                        "C"
                    ],
                    "option": [
                        " A. R.A=S.A OR R.B=S.B OR R.C=S.C OR R.A&lt;S.F ",
                        " B. R.A=S.A OR R.B=S.B OR R.C=S.C OR R.A&lt;S.B ",
                        " C. R.A=S.A AND R.B=S.B AND R.C=S.C AND R.A&lt;S.F ",
                        " D. R.A=S.A AND R.B=S.B AND R.C=S.C AND R.A&lt;S.B "
                    ]
                },
                {
                    "index": 207,
                    "belong_page": 1,
                    "question_id": 43814,
                    "question_title": "<p>阅读以下关于应用系统数据架构的说明，回答下列问题。<br/></p><p>某软件公司拟开发一套贸易综合管理系统，包括客户关系管理子系统和商品信息管理子系统两部分。客户关系管理子系统主要管理客户信息，并根据贸易业务需要频繁向客户发送相关的电子邮件、短信等提醒信息。商品信息管理子系统主要为客户提供商品信息在线查询功能，包括商品基本信息、实时库存与价格等。<br/>在对系统进行数据架构设计时，公司项目组的架构师王工主张采用文件系统进行数据管理，原因是目前公司客户和商品数量不大，且系统功能较为简单，采用文件系统进行数据管理简单直观，开发周期短。架构师李工则建议采用关系数据库进行数据管理，原因在于公司目前正处在高速扩张期，虽然目前的客户和商品数量不大，但随着公司快速发展，需要管理的数据必然飞速膨胀，采用关系数据库作为数据存储层，系统的扩展性更强，并能够对未来可能增加的复杂业务提供有效支持。经过讨论，项目组初步采纳了李工的意见，决定采用关系数据库存储客户数据，并针对业务特征对系统性能进行优化。</p><p>【问题1】</p><p>请从设计难度、数据冗余程度、数据架构、应用扩展性等4个方面对关系型数据库管理系统和文件系统两种数据存储方式进行比较，填写下表中(1)～(4)。</p><p><img style=\"max-width:100%;height:auto\"  src=\"https://s2.51cto.com/images/201807/0157614983c0076f7f33994fd909f88cfd205a.png\"/></p><p><img style=\"max-width:100%;height:auto\"  src=\"https://s2.51cto.com/images/201807/476ab5385e915d614318809a7c0a5c2f897b9f.png\"/></p><p><br/></p><p><img style=\"max-width:100%;height:auto\"  src=\"https://s2.51cto.com/images/201807/246006196151d3643998307a4051362c6367ec.png\"/></p>",
                    "question_type": 5,
                    "answer_type": 5,
                    "show_type_name": null,
                    "new_parent_id": 43814,
                    "score_rule": "",
                    "material_text": null,
                    "sort_son": "0",
                    "analyze": "<p>略</p><p><br/></p>",
                    "like": 0,
                    "answer": [
                        "<p>问题一：</p><p>(1)数据结构需要符合关系模式，设计难度较大</p><p>&nbsp; &nbsp; (2)可能在多个文件中复制相同的数据属性，数据冗余较大</p><p>&nbsp; &nbsp; (3)以应用系统为中心组织、管理数据</p><p>&nbsp; &nbsp; (4)数据独立于应用系统，很容易在不同的应用系统之间共享数据</p><p><br/></p><p>问题二：</p><p>(1)Key-Value模式(键-值对模式)</p><p>&nbsp; &nbsp; (2)外存读写，性能相对较低</p><p>&nbsp; &nbsp; (3)基于内存存储，存储容量受限</p><p>&nbsp; &nbsp; (4)恢复机制复杂，可靠性较低</p><p>&nbsp; &nbsp; (5)内存数据库</p><p>&nbsp; &nbsp; (6)内存数据库</p><p>&nbsp; &nbsp; (7)关系数据库</p><p>&nbsp; &nbsp; (8)内存数据库</p><p>&nbsp; &nbsp; (9)内存数据库</p><p><br/></p><p>问题三：</p><p>(1)提升&nbsp; &nbsp; (2)降低&nbsp; &nbsp; (3)降低&nbsp; &nbsp; (4)提升</p><p><br/></p>"
                    ],
                    "option": "[]"
                },
                {
                    "index": 208,
                    "belong_page": 1,
                    "question_id": 45922,
                    "question_title": "<p>试题四 (共 2S 分)</p><p>阅读以下关于数据库设计的叙述，在答题纸上回答问题 1 至问题 3。</p><p>【说明】</p><p>某制造企业为拓展网上销售业务，委托某软件企业开发一套电子商务网站。初期仅解决基本的网上销售、订单等功能需求。该软件企业很快决定基于.NET 平台和 SQL Server 数据库进行开发，但在数据库访问方式上出现了争议。王工认为应该采用程序在线访问的方式访问数据库:而李工认为本企业内部程序员缺乏数据库开发经验，而且应用筒单，应该采用 ORM&lt;对象关系映射&gt;方式。最终经过综合考虑，该软件企业采用了李工的建议。</p><p>随着业务的发展，该电子商务网站逐渐发展成一个通用的电子商务平台，销售多家制造企业的产品，电子商务平台的功能也日益复杂。目前急需对该电子商务网站进行改造，以支持对多种异构数据库平台的数据访问，同时满足复杂的数据管理需求。该软件企业针对上述需求，对电子商务网站的架构进行了重新设计，新增加了数据访问层，同时采用工厂设计模式解决异构数据库访问的问题。新设计的系统架构如图 4-1 所示。</p><p><img style=\"max-width:100%;height:auto\"  src=\"http://s2.51cto.com/images/20180827/1535368635404342.png\" title=\"1535368635404342.png\" alt=\"图片.png\"/><br/></p><p>【问题 1】 (9 分)</p><p>请用 300 字以内的文字分别说明数据库程序在线访问方式和 ORM 方式的优缺点，说明该软件企业采用 ORM 的原因。<br/></p><p>【问题 2】 (9 分)</p><p>请用 100 宇以内的文字说明新体系架构中增加数据访问层的原因。请根据图 4-1 所示，填写图中空白处(1) - (3)。</p><p>【问题 3】 (7 分) -</p><p>应用程序设计中，数据库访问需要良好的封装性和可维护性，因此经常使用工厂设计模式来实现对数据库访问的封装。请解释工厂设计模式，并说明其优点和应用场景: 请解释说明工厂模式在数据访问层中的应用。</p><p>请用 100 宇以内的文字说明新体系架构中增加数据访问层的原因。请根据图 4-1 所示，填写图中空白处(1) - (3)。<br/></p><p><br/></p>",
                    "question_type": 5,
                    "answer_type": 5,
                    "show_type_name": null,
                    "new_parent_id": 45922,
                    "score_rule": "",
                    "material_text": null,
                    "sort_son": "0",
                    "analyze": "<p>略<br/></p>",
                    "like": 0,
                    "answer": [
                        "<p>参考答案：</p><p>数据库程序在线访问方式优点：</p><p>1.&nbsp;性能比直接SQL好；</p><p>2.&nbsp;可以处理复杂的查询语句。</p><p>数据库程序在线访问方式不足：</p><p>1.&nbsp;程序员必须懂SQL语句；</p><p>2.&nbsp;修改维护相对困难。</p><p>&nbsp;&nbsp;&nbsp;ORM方式优点：</p><p>1.&nbsp;降低学习和开发成本；</p><p>2.&nbsp;程序员不用再写SQL进行数据库操作；</p><p>3.&nbsp;减少程序代码量；</p><p>4.&nbsp;降低由于SQL代码质量差带来的影响。</p><p>&nbsp;ORM方式缺点：</p><p>1.&nbsp;性能比直接用SQL差</p><p>2.&nbsp;处理复杂查询比较困难。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;采用ORM原因：（1）缺乏数据库开发经验，因此SQL语句编写质量有潜在风险；（2）学习成本高；（3）应用比较简单，没有太复杂功能。</p><p>参考答案：</p><p>（1）涉及多种异构数据库平台，数据访问复杂性增加，不宜与业务逻辑混合在一起；</p><p>（2）数据管理变复杂之后，需要使用代码量增加，分层次有利于逻辑更加清晰，程序维护更加方便；</p><p>（3）业务逻辑应以相同的方式应对异构数据库，为了做好隐蔽性需要单独设计数据访问层。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;（1）~（3）分别填入：执行业务逻辑 、工厂层（factory）、数据访问接口层。</p><p>工厂模式分为：抽象工厂和工厂方法，本题为抽象工厂设计模式。</p><p>抽象工厂设计模式提供一个接口，可以创建一系列或相互依赖的 对象，而无需指定他们具体的类。</p><p>优点：方便创建一系列的对象，其使用场景也是创建系列对象的情况。该题目中，可以针对oracle,mysql,sqlserver分别抽象建立抽象工厂，若指定当前工厂为oracle工厂，则创建出来的数据库连接，数据集等一系列对象都是符合oracle操作要求的，这样便于数据库之间的切换。</p><p><br/></p>"
                    ],
                    "option": "[]"
                },
                {
                    "index": 209,
                    "belong_page": 1,
                    "question_id": 303749,
                    "question_title": "<p>【问题1】（11分）</p><p>该系统使用过程中，由于同样的数据分别存在于数据库和缓存系统中，必然会造成数据同步或数据不一致性的问题。该企业团队为解决这个问题，提出了如下解决思路：应用程序读数据时，首先读缓存，当该数据不在缓存时,再读取数据库；应用程序写数据吋，先写缓存，成功后再写数据库；或者先写数据库，再写缓存。</p><p>王工认为该解决思路并未解决数据同步或数据不一致性的问题，请用100字以内的文字解释其原因。</p>",
                    "question_type": 14,
                    "answer_type": 5,
                    "show_type_name": "问答题",
                    "new_parent_id": 303748,
                    "score_rule": "",
                    "material_text": "<p>试题四（共25分）</p><p>阅读以下关于数据系统方面的叙述，在答题纸上回答问题1至问题3。</p><p><br/></p><p>【说明】</p><p>某初创企业的主营业务是为用户提供高度个性化的商品订购业务，其业务系统支持PC端、手机App等多种访问方式。系统上线后受到用户普遍欢迎，在线用户数和订单数量迅速增长，原有的关系数据库服务器不能满足高速并发的业务要求。</p><p>为了减轻数据库服务器的压力，该企业采用了分布式缓存系统，将应用系统经常使用的数据放置在内存，降低对数据库服务器的查询请求，提高了系统性能。在使用缓存系统的过程中，企业碰到了一系列技术问题。</p>",
                    "sort_son": "1",
                    "analyze": "<p>在缓存和数据库双写过程中：</p><p>如果是先修改数据库，再删除缓存的方案，当删除缓存失败时数据库中是新数据，缓存中是旧数据，出现数据不一致。</p><p>如果先删除缓存，再修改数据库。缓存读不到数据，查数据库更新缓存的时候就拿到了最新的库存数据。</p><p>如果删除缓存成功了，而修改数据库失败了，那么数据库中依旧是旧数据，缓存中是空的，那么数据不会不一致。</p>",
                    "like": 0,
                    "answer": [
                        "<p>本题主要考查分布式架构中数据库和缓存双写一致性的架构策略和方案。</p><p>Redis是企业级系统高性能、高并发、高可用架构中非常重要的一个环节。Redis主要解决了关系型数据库并发量低的问题，有助于缓解关系型数据库在高并发场景下的压力，提高系统的吞吐量。而在Redis的实际使用过程中，难免会遇到缓存与数据库双写时数据不一致的问题，这是架构策略必须要考虑的问题。</p><p><br/></p><p>【问题1】</p><p>答案：</p><p>在高并发条件下存在不同线程间网络延迟不同的情况，且缓存和数据库数据不同写入请求的速度也存在差异，并且缓存和数据库删除和写入均存在失败的可能性，这些会导致解决思路无法解决数据同步和不一致性问题。</p><p>(a)读数据库，</p><p>(b)写缓存</p><p>(c)数据库</p><p>(d)更新缓存key值/删除缓存key值/使缓存key值失效</p>"
                    ],
                    "option": ""
                },
                {
                    "index": 210,
                    "belong_page": 1,
                    "question_id": 303750,
                    "question_title": "<p>【问题2】（8分）</p><p>缓存系统一般以key/value形式存储数据，在系统运维中发现,部分针对缓存的查询，未在缓存系统中找到对应的key,从而引发了大量对数据库服务器的查询请求，最严重时甚至导致了数据库服务器的宕机。 经过运维人员的深入分析，发现存在两种情况：</p><p>(1) 用户请求的key值在系统中不存在时，会查询数据库系统，加大了数据库服务器的压力；</p><p>(2) 系统运行期间，发生了黑客攻击，以大量系统不存在的随机key发起了査询请求，从而导致了</p><p>数据库服务器的宕机。</p><p>经过研究，研发团队决定，当在数据库中也未查找到该key时，在缓存系统中为key设置空值，防止对数据库服务器发起重复查询。 请用100字以内文字说明该设置空值方案存在的问题，并给出解决思路。</p>",
                    "question_type": 14,
                    "answer_type": 5,
                    "show_type_name": "问答题",
                    "new_parent_id": 303748,
                    "score_rule": "",
                    "material_text": "<p>试题四（共25分）</p><p>阅读以下关于数据系统方面的叙述，在答题纸上回答问题1至问题3。</p><p><br/></p><p>【说明】</p><p>某初创企业的主营业务是为用户提供高度个性化的商品订购业务，其业务系统支持PC端、手机App等多种访问方式。系统上线后受到用户普遍欢迎，在线用户数和订单数量迅速增长，原有的关系数据库服务器不能满足高速并发的业务要求。</p><p>为了减轻数据库服务器的压力，该企业采用了分布式缓存系统，将应用系统经常使用的数据放置在内存，降低对数据库服务器的查询请求，提高了系统性能。在使用缓存系统的过程中，企业碰到了一系列技术问题。</p>",
                    "sort_son": "2",
                    "analyze": "<p>缓存穿透是指缓存和数据库中都没有的数据，而用户或攻击者不断发起请求会导致缓存数据库压力过大。缓存穿透的常规策略有：</p><p>1.接口层增加校验，如用户鉴权校验，键校验；</p><p>2.缩短无效键有效时间，以防止攻击用户的暴力攻击。</p><p><br/></p>",
                    "like": 0,
                    "answer": [
                        "<p>【问题2】</p><p>答案：</p><p>存在问题：空值缓存需要更多的键，浪费内存空间</p><p>解决思路：查询缓存前，对 key 值进行过滤，只允许系统中存在的 key 进行后续操作（例如采用 key 的 bitmap 进行过滤）</p>"
                    ],
                    "option": ""
                },
                {
                    "index": 211,
                    "belong_page": 1,
                    "question_id": 303751,
                    "question_title": "<p>【问题3】（6分）</p><p>缓存系统中的key—般会存在有效期，超过有效期则key失效；有时也会根据LRU算法将某些key移出内存。当应用软件查询key时，如key失效或不在内存，会重新读取数据库，并更新缓存中的key。</p><p>运维团队发现在某些情况下，若大量的key设置了相同的失效时间，导致缓存在同一时刻众多key同时失效，或者瞬间产生对缓存系统不存在key的大量访问，或者缓存系统重启等原因，都会造成数据库服务器请求瞬时爆量，引起大量缓存更新操作，导致整个系统性能急剧下降，进而造成整个系统崩溃。</p><p>请用100字以内文字，给出解决该问题的两种不同思路。</p>",
                    "question_type": 14,
                    "answer_type": 5,
                    "show_type_name": "问答题",
                    "new_parent_id": 303748,
                    "score_rule": "",
                    "material_text": "<p>试题四（共25分）</p><p>阅读以下关于数据系统方面的叙述，在答题纸上回答问题1至问题3。</p><p><br/></p><p>【说明】</p><p>某初创企业的主营业务是为用户提供高度个性化的商品订购业务，其业务系统支持PC端、手机App等多种访问方式。系统上线后受到用户普遍欢迎，在线用户数和订单数量迅速增长，原有的关系数据库服务器不能满足高速并发的业务要求。</p><p>为了减轻数据库服务器的压力，该企业采用了分布式缓存系统，将应用系统经常使用的数据放置在内存，降低对数据库服务器的查询请求，提高了系统性能。在使用缓存系统的过程中，企业碰到了一系列技术问题。</p>",
                    "sort_son": "3",
                    "analyze": "缓存雪崩是指缓存中数据大批量到过期时间，而查询数据量巨大，引起数据库压力过大甚至宕机。缓存雪崩的常见策略有：<p>1.缓存数据的过期时间随机设置，防止同一时间大量数据过期现象发生；</p><p>2.在分布式缓存数据库部署条件下，将热点数据均匀分布在不同的缓存数据库中；</p><p>3.热点数据设置为永不过期。</p>",
                    "like": 0,
                    "answer": [
                        "<p>【问题3】</p><p>答案：</p><p>1.搭建高可用Redis集群，正式部署前提前进行数据预热，在大并发访问前加载缓存键并尽量均匀分布缓存过期时间；</p><p>2.将热点数据设置为永不过期，开启Redis的持久化功能，当Redis启动时，从磁盘恢复数据到缓存中。</p>"
                    ],
                    "option": ""
                },
                {
                    "index": 212,
                    "belong_page": 1,
                    "question_id": 316002,
                    "question_title": "<p>【问题1】（9分）</p><p>在系统初步运行后，发现系统数据访问性能较差。经过分析，刘工认为原来数据库规范化设计后，关系表过于细分，造成了大量的多表关联查询，影响了性能。例如当用户查询商品信息时，需要同时显示该药品的信息、供应商的信息、当前库存等信息。</p><p>为此，刘工认为可以采用反规范化设计来改造药品关系的结构，以提高查询性能。修改后的药品关系结构为：</p><p>药品（药品ID，药品名称，药品型号，药品价格，供应商ID，供应商名称，当前库存数量）；</p><p>请用200字以内的文字说明常见的反规范化设计方法，并说明用户查询商品信息应该采用哪种反规范化设计方法。</p>",
                    "question_type": 14,
                    "answer_type": 5,
                    "show_type_name": "问答题",
                    "new_parent_id": 316001,
                    "score_rule": "",
                    "material_text": "<p>试题四（共25分）</p><p>阅读以下关于数据库设计的叙述，在答题纸上回答问题1至问题3。</p><p>【说明】</p><p>某医药销售企业因业务发展，需要建立线上药品销售系统，为用户提供便捷的互联网药品销售服务、该系统除了常规药品展示、订单、用户交流与反馈功能外，还需要提供当前热销产品排名、评价分类管理等功能。</p><p>通过对需求的分析，在数据管理上初步决定采用关系数据库（MySQL）和数据库缓存（Redis）的混合架构实现。</p><p>经过规范化设计之后，该系统的部分数据库表结构如下所示。</p><p>供应商（供应商ID，供应商名称，联系方式，供应商地址）；</p><p>药品（药品ID，药品名称，药品型号，药品价格，供应商ID）；</p><p>药品库存（药品ID，当前库存数量）；</p><p>订单（订单号码，药品ID，供应商ID，药品数量，订单金额）；</p>",
                    "sort_son": "1",
                    "analyze": "无",
                    "like": 0,
                    "answer": [
                        "<p>（1）增加冗余列：增加冗余列是指在多个表中具有相同的列，它常用来在查询时避免连接操作。例如：以规范化设计的理念，学生成绩表中不需要字段“姓名”，因为“姓名”字段可以通过学号查询到，但在反规范化设计中，会将“姓名”字段加入表中。这样查询一个学生的成绩时，不需要与学生表进行连接操作，便可得到对应的“姓名”。</p><p>&nbsp;（2）增加派生列：增加派生列指增加的列可以通过表中其他数据计算生成。它的作用是在查询时减少计算量，从而加快查询速度。例如：订单表中，有商品号、商品单价、采购数量，我们需要订单总价时，可以通过计算得到总价，所以规范化设计的理念是无须在订单表中设计“订单总价”字段。但反规范化则不这样考虑，由于订单总价在每次查询都需要计算，这样会占用系统大量资源，所以在此表中增加派生列“订单总价”以提高查询效率。</p><p>&nbsp;&nbsp;&nbsp; （3）重新组表：重新组表指如果许多用户需要查看两个表连接出来的结果数据，则把这两个表重新组成一个表来减少连接而提高性能。</p><p>（4）分割表</p><p>&nbsp;&nbsp;&nbsp; 有时对表做分割可以提高性能。表分割有两种方式。</p><p>&nbsp;&nbsp;&nbsp; 水平分割：根据一列或多列数据的值把数据行放到两个独立的表中。水平分割通常在下面的情况下使用。</p><p>&nbsp;&nbsp;&nbsp; 情况 1：表很大，分割后可以降低在查询时需要读的数据和索引的页数，同时也降低了索引的层数，提高查询效率。</p><p>&nbsp;&nbsp;&nbsp; 情况 2：表中的数据本来就有独立性，例如表中分别记录各个地区的数据或不同时期的数据，特别是有些数据常用，而另外一些数据不常用。</p><p>&nbsp;&nbsp;&nbsp; 情况 3：需要把数据存放到多个介质上。</p><p>&nbsp;垂直分割：把主码和一些列放到一个表，然后把主码和另外的列放到另一个表中。如果一个表中某些列常用，而另外一些列不常用，则可以采用垂直分割，另外垂直分割可以使得数据行变小，一个数据页就能存放更多的数据，在查询时就会减少 I/O 次数。其缺点是需要管理冗余列，查询所有数据需要连接操作。</p><p>本题中用到了重新组表得方式。</p>"
                    ],
                    "option": ""
                },
                {
                    "index": 213,
                    "belong_page": 1,
                    "question_id": 316003,
                    "question_title": "<p>【问题2】（9分）</p><p>王工认为，反规范化设计可提高查询的性能，但必然会带来数据的不一致性问题。请用200字以内的文字说明在反规范化设计中，解决数据不一致性问题的三种常见方法，并说明该系统应该采用哪种方法。</p>",
                    "question_type": 14,
                    "answer_type": 5,
                    "show_type_name": "问答题",
                    "new_parent_id": 316001,
                    "score_rule": "",
                    "material_text": "<p>试题四（共25分）</p><p>阅读以下关于数据库设计的叙述，在答题纸上回答问题1至问题3。</p><p>【说明】</p><p>某医药销售企业因业务发展，需要建立线上药品销售系统，为用户提供便捷的互联网药品销售服务、该系统除了常规药品展示、订单、用户交流与反馈功能外，还需要提供当前热销产品排名、评价分类管理等功能。</p><p>通过对需求的分析，在数据管理上初步决定采用关系数据库（MySQL）和数据库缓存（Redis）的混合架构实现。</p><p>经过规范化设计之后，该系统的部分数据库表结构如下所示。</p><p>供应商（供应商ID，供应商名称，联系方式，供应商地址）；</p><p>药品（药品ID，药品名称，药品型号，药品价格，供应商ID）；</p><p>药品库存（药品ID，当前库存数量）；</p><p>订单（订单号码，药品ID，供应商ID，药品数量，订单金额）；</p>",
                    "sort_son": "2",
                    "analyze": "无",
                    "like": 0,
                    "answer": [
                        "<p>批处理维护、应用逻辑和触发器</p>"
                    ],
                    "option": ""
                },
                {
                    "index": 214,
                    "belong_page": 1,
                    "question_id": 316004,
                    "question_title": "<p>【问题3】（7分）</p><p>该系统采用了Redis来实现某些特定功能（如当前热销药品排名等），同时将药品关系数据放到内存以提高商品查询的性能，但必然会造成Redis和MySQL的数据实时同步问题。</p><p>（1）Redis的数据类型包括String、Hash、List、Set和ZSet等，请说明实现当前热销药品排名的功能应该选择使用哪种数据类型。</p><p>（2）请用200字以内的文字解释说明解决Redis和MySQL数据实时同步问题的常见方案。</p>",
                    "question_type": 14,
                    "answer_type": 5,
                    "show_type_name": "问答题",
                    "new_parent_id": 316001,
                    "score_rule": "",
                    "material_text": "<p>试题四（共25分）</p><p>阅读以下关于数据库设计的叙述，在答题纸上回答问题1至问题3。</p><p>【说明】</p><p>某医药销售企业因业务发展，需要建立线上药品销售系统，为用户提供便捷的互联网药品销售服务、该系统除了常规药品展示、订单、用户交流与反馈功能外，还需要提供当前热销产品排名、评价分类管理等功能。</p><p>通过对需求的分析，在数据管理上初步决定采用关系数据库（MySQL）和数据库缓存（Redis）的混合架构实现。</p><p>经过规范化设计之后，该系统的部分数据库表结构如下所示。</p><p>供应商（供应商ID，供应商名称，联系方式，供应商地址）；</p><p>药品（药品ID，药品名称，药品型号，药品价格，供应商ID）；</p><p>药品库存（药品ID，当前库存数量）；</p><p>订单（订单号码，药品ID，供应商ID，药品数量，订单金额）；</p>",
                    "sort_son": "3",
                    "analyze": "无",
                    "like": 0,
                    "answer": [
                        "<p>（1）ZSet</p><p>（2）①引用Mysql的事务，因为事务有一致性保证，事务提交成功后再更新缓存</p><p>②在缓存里面引用一些访问控制位，数据库数据变化后，同步变更对应的访问控制位，然后从缓存查询时，率先判断该访问控制位，有变化就从数据库查，无变化直接从缓存返回数据</p><p>③三是通过数据库中间件产品保证缓存和数据库数据时时同步</p>"
                    ],
                    "option": ""
                },
                {
                    "index": 215,
                    "belong_page": 1,
                    "question_id": 347227,
                    "question_title": "1、哪种分布透明性不用考虑数据的分片？<p><br/></p><p>2、“若X→Y，X→Z，则X→YZ为F所蕴含”是属于Armstrong公理的什么规则？</p><p><br/></p><p>3、“每个结点对本地数据都能独立管理”属于分布式数据库的什么特点？<br/><br/></p><p>4、给定关系模式R&lt;U,F&gt;，其中，属性集U={A、B、C、D、E}。函数依赖集F={AC→B,B→DE}，关系R的主键是什么？<br/><br/></p><p>5、设关系模式R(U,F), U={A1，A2，A3，A4}，函数依赖集F={A1→A2，A1→A3 ，A2→A4}，该关系模式属于第几范式？</p><p><br/></p>",
                    "question_type": 5,
                    "answer_type": 5,
                    "show_type_name": "问答题",
                    "new_parent_id": 347227,
                    "score_rule": "",
                    "material_text": "",
                    "sort_son": "0",
                    "analyze": "<p>详见答案</p>",
                    "like": 0,
                    "answer": [
                        "<p>1、哪种分布透明性不用考虑数据的分片？</p><p>答：分片透明性<br/><br/></p><p>2、“若X→Y，X→Z，则X→YZ为F所蕴含”是属于Armstrong公理的什么规则？</p><p>答：合并规则<br/><br/></p><p>3、“每个结点对本地数据都能独立管理”属于分布式数据库的什么特点？</p><p>答：自治性<br/><br/></p><p>4、给定关系模式R&lt;U,F&gt;，其中，属性集U={A、B、C、D、E}。函数依赖集F={AC→B,B→DE}，关系R的主键是什么？</p><p>答：AC<br/><br/></p><p>5、设关系模式R(U,F), U={A1，A2，A3，A4}，函数依赖集F={A1→A2，A1→A3 ，A2→A4}，该关系模式属于第几范式？</p><p>答：该关系模式的主键为A1，非主属性是A2、A3、A4，其中A4是由A2传递得来的，而非A1直接得到的，因此不满足3NF。</p>"
                    ],
                    "option": ""
                }
            ],
            "total_question": 215,
            "summary": {
                "radio": {
                    "total_question": 204,
                    "total_score": 0
                },
                "multiple": {
                    "total_question": 0,
                    "total_score": 0
                },
                "fill": {
                    "total_question": 0,
                    "total_score": 0
                },
                "program": {
                    "total_question": 0,
                    "total_score": 0
                },
                "qanda": {
                    "total_question": 9,
                    "total_score": 0
                },
                "cloze": {
                    "total_question": 2,
                    "total_score": 0
                },
                "budingxiang": {
                    "total_question": 0,
                    "total_score": 0
                },
                "material": {
                    "total_question": 0,
                    "total_score": 0
                }
            },
            "title": "数据库基础"
        },
        "pagination": {
            "curPage": 1,
            "pageSize": 1000,
            "total": 215,
            "hasNextPage": false
        },
        "totalOrder": [
            {
                "index": 1,
                "question_type": "1",
                "belong_page": 1,
                "question_id": "4606",
                "answer_type": 1
            },
            {
                "index": 2,
                "question_type": "1",
                "belong_page": 1,
                "question_id": "4609",
                "answer_type": 1
            },
            {
                "index": 3,
                "question_type": "1",
                "belong_page": 1,
                "question_id": "4612",
                "answer_type": 1
            },
            {
                "index": 4,
                "question_type": "1",
                "belong_page": 1,
                "question_id": "4613",
                "answer_type": 1
            },
            {
                "index": 5,
                "question_type": "1",
                "belong_page": 1,
                "question_id": "4614",
                "answer_type": 1
            },
            {
                "index": 6,
                "question_type": "1",
                "belong_page": 1,
                "question_id": "4617",
                "answer_type": 1
            },
            {
                "index": 7,
                "question_type": "1",
                "belong_page": 1,
                "question_id": "4618",
                "answer_type": 1
            },
            {
                "index": 8,
                "question_type": "1",
                "belong_page": 1,
                "question_id": "4619",
                "answer_type": 1
            },
            {
                "index": 9,
                "question_type": "1",
                "belong_page": 1,
                "question_id": "43237",
                "answer_type": 1
            },
            {
                "index": 10,
                "question_type": "1",
                "belong_page": 1,
                "question_id": "43740",
                "answer_type": 1
            },
            {
                "index": 11,
                "question_type": "1",
                "belong_page": 1,
                "question_id": "43741",
                "answer_type": 1
            },
            {
                "index": 12,
                "question_type": "1",
                "belong_page": 1,
                "question_id": "43742",
                "answer_type": 1
            },
            {
                "index": 13,
                "question_type": "1",
                "belong_page": 1,
                "question_id": "43743",
                "answer_type": 1
            },
            {
                "index": 14,
                "question_type": "1",
                "belong_page": 1,
                "question_id": "43756",
                "answer_type": 1
            },
            {
                "index": 15,
                "question_type": "1",
                "belong_page": 1,
                "question_id": "43759",
                "answer_type": 1
            },
            {
                "index": 16,
                "question_type": "1",
                "belong_page": 1,
                "question_id": "43806",
                "answer_type": 1
            },
            {
                "index": 17,
                "question_type": "1",
                "belong_page": 1,
                "question_id": "43807",
                "answer_type": 1
            },
            {
                "index": 18,
                "question_type": "1",
                "belong_page": 1,
                "question_id": "43808",
                "answer_type": 1
            },
            {
                "index": 19,
                "question_type": "1",
                "belong_page": 1,
                "question_id": "43809",
                "answer_type": 1
            },
            {
                "index": 20,
                "question_type": "1",
                "belong_page": 1,
                "question_id": "43810",
                "answer_type": 1
            },
            {
                "index": 21,
                "question_type": "1",
                "belong_page": 1,
                "question_id": "43832",
                "answer_type": 1
            },
            {
                "index": 22,
                "question_type": "1",
                "belong_page": 1,
                "question_id": "43834",
                "answer_type": 1
            },
            {
                "index": 23,
                "question_type": "1",
                "belong_page": 1,
                "question_id": "43835",
                "answer_type": 1
            },
            {
                "index": 24,
                "question_type": "1",
                "belong_page": 1,
                "question_id": "43836",
                "answer_type": 1
            },
            {
                "index": 25,
                "question_type": "1",
                "belong_page": 1,
                "question_id": "43859",
                "answer_type": 1
            },
            {
                "index": 26,
                "question_type": "1",
                "belong_page": 1,
                "question_id": "46857",
                "answer_type": 1
            },
            {
                "index": 27,
                "question_type": "1",
                "belong_page": 1,
                "question_id": "46858",
                "answer_type": 1
            },
            {
                "index": 28,
                "question_type": "1",
                "belong_page": 1,
                "question_id": "46859",
                "answer_type": 1
            },
            {
                "index": 29,
                "question_type": "1",
                "belong_page": 1,
                "question_id": "46860",
                "answer_type": 1
            },
            {
                "index": 30,
                "question_type": "1",
                "belong_page": 1,
                "question_id": "46883",
                "answer_type": 1
            },
            {
                "index": 31,
                "question_type": "1",
                "belong_page": 1,
                "question_id": "46884",
                "answer_type": 1
            },
            {
                "index": 32,
                "question_type": "1",
                "belong_page": 1,
                "question_id": "46885",
                "answer_type": 1
            },
            {
                "index": 33,
                "question_type": "1",
                "belong_page": 1,
                "question_id": "46890",
                "answer_type": 1
            },
            {
                "index": 34,
                "question_type": "1",
                "belong_page": 1,
                "question_id": "46982",
                "answer_type": 1
            },
            {
                "index": 35,
                "question_type": "1",
                "belong_page": 1,
                "question_id": "46984",
                "answer_type": 1
            },
            {
                "index": 36,
                "question_type": "1",
                "belong_page": 1,
                "question_id": "46985",
                "answer_type": 1
            },
            {
                "index": 37,
                "question_type": "1",
                "belong_page": 1,
                "question_id": "49832",
                "answer_type": 1
            },
            {
                "index": 38,
                "question_type": "1",
                "belong_page": 1,
                "question_id": "49833",
                "answer_type": 1
            },
            {
                "index": 39,
                "question_type": "1",
                "belong_page": 1,
                "question_id": "49834",
                "answer_type": 1
            },
            {
                "index": 40,
                "question_type": "1",
                "belong_page": 1,
                "question_id": "49835",
                "answer_type": 1
            },
            {
                "index": 41,
                "question_type": "1",
                "belong_page": 1,
                "question_id": "49907",
                "answer_type": 1
            },
            {
                "index": 42,
                "question_type": "1",
                "belong_page": 1,
                "question_id": "49908",
                "answer_type": 1
            },
            {
                "index": 43,
                "question_type": "1",
                "belong_page": 1,
                "question_id": "49909",
                "answer_type": 1
            },
            {
                "index": 44,
                "question_type": "1",
                "belong_page": 1,
                "question_id": "50872",
                "answer_type": 1
            },
            {
                "index": 45,
                "question_type": "1",
                "belong_page": 1,
                "question_id": "54216",
                "answer_type": 1
            },
            {
                "index": 46,
                "question_type": "1",
                "belong_page": 1,
                "question_id": "54243",
                "answer_type": 1
            },
            {
                "index": 47,
                "question_type": "1",
                "belong_page": 1,
                "question_id": "54244",
                "answer_type": 1
            },
            {
                "index": 48,
                "question_type": "1",
                "belong_page": 1,
                "question_id": "54245",
                "answer_type": 1
            },
            {
                "index": 49,
                "question_type": "1",
                "belong_page": 1,
                "question_id": "54246",
                "answer_type": 1
            },
            {
                "index": 50,
                "question_type": "1",
                "belong_page": 1,
                "question_id": "54248",
                "answer_type": 1
            },
            {
                "index": 51,
                "question_type": "1",
                "belong_page": 1,
                "question_id": "54249",
                "answer_type": 1
            },
            {
                "index": 52,
                "question_type": "1",
                "belong_page": 1,
                "question_id": "54267",
                "answer_type": 1
            },
            {
                "index": 53,
                "question_type": "1",
                "belong_page": 1,
                "question_id": "54278",
                "answer_type": 1
            },
            {
                "index": 54,
                "question_type": "1",
                "belong_page": 1,
                "question_id": "54284",
                "answer_type": 1
            },
            {
                "index": 55,
                "question_type": "1",
                "belong_page": 1,
                "question_id": "54285",
                "answer_type": 1
            },
            {
                "index": 56,
                "question_type": "1",
                "belong_page": 1,
                "question_id": "54290",
                "answer_type": 1
            },
            {
                "index": 57,
                "question_type": "1",
                "belong_page": 1,
                "question_id": "54292",
                "answer_type": 1
            },
            {
                "index": 58,
                "question_type": "1",
                "belong_page": 1,
                "question_id": "54293",
                "answer_type": 1
            },
            {
                "index": 59,
                "question_type": "1",
                "belong_page": 1,
                "question_id": "54294",
                "answer_type": 1
            },
            {
                "index": 60,
                "question_type": "1",
                "belong_page": 1,
                "question_id": "54296",
                "answer_type": 1
            },
            {
                "index": 61,
                "question_type": "1",
                "belong_page": 1,
                "question_id": "54297",
                "answer_type": 1
            },
            {
                "index": 62,
                "question_type": "1",
                "belong_page": 1,
                "question_id": "54342",
                "answer_type": 1
            },
            {
                "index": 63,
                "question_type": "1",
                "belong_page": 1,
                "question_id": "63590",
                "answer_type": 1
            },
            {
                "index": 64,
                "question_type": "1",
                "belong_page": 1,
                "question_id": "63591",
                "answer_type": 1
            },
            {
                "index": 65,
                "question_type": "1",
                "belong_page": 1,
                "question_id": "63593",
                "answer_type": 1
            },
            {
                "index": 66,
                "question_type": "1",
                "belong_page": 1,
                "question_id": "63595",
                "answer_type": 1
            },
            {
                "index": 67,
                "question_type": "1",
                "belong_page": 1,
                "question_id": "63694",
                "answer_type": 1
            },
            {
                "index": 68,
                "question_type": "1",
                "belong_page": 1,
                "question_id": "63696",
                "answer_type": 1
            },
            {
                "index": 69,
                "question_type": "1",
                "belong_page": 1,
                "question_id": "103093",
                "answer_type": 1
            },
            {
                "index": 70,
                "question_type": "1",
                "belong_page": 1,
                "question_id": "103094",
                "answer_type": 1
            },
            {
                "index": 71,
                "question_type": "1",
                "belong_page": 1,
                "question_id": "103095",
                "answer_type": 1
            },
            {
                "index": 72,
                "question_type": "1",
                "belong_page": 1,
                "question_id": "103096",
                "answer_type": 1
            },
            {
                "index": 73,
                "question_type": "1",
                "belong_page": 1,
                "question_id": "103097",
                "answer_type": 1
            },
            {
                "index": 74,
                "question_type": "1",
                "belong_page": 1,
                "question_id": "103098",
                "answer_type": 1
            },
            {
                "index": 75,
                "question_type": "1",
                "belong_page": 1,
                "question_id": "103099",
                "answer_type": 1
            },
            {
                "index": 76,
                "question_type": "1",
                "belong_page": 1,
                "question_id": "103100",
                "answer_type": 1
            },
            {
                "index": 77,
                "question_type": "1",
                "belong_page": 1,
                "question_id": "103101",
                "answer_type": 1
            },
            {
                "index": 78,
                "question_type": "1",
                "belong_page": 1,
                "question_id": "103102",
                "answer_type": 1
            },
            {
                "index": 79,
                "question_type": "1",
                "belong_page": 1,
                "question_id": "103103",
                "answer_type": 1
            },
            {
                "index": 80,
                "question_type": "1",
                "belong_page": 1,
                "question_id": "103104",
                "answer_type": 1
            },
            {
                "index": 81,
                "question_type": "1",
                "belong_page": 1,
                "question_id": "103105",
                "answer_type": 1
            },
            {
                "index": 82,
                "question_type": "1",
                "belong_page": 1,
                "question_id": "103106",
                "answer_type": 1
            },
            {
                "index": 83,
                "question_type": "1",
                "belong_page": 1,
                "question_id": "103107",
                "answer_type": 1
            },
            {
                "index": 84,
                "question_type": "1",
                "belong_page": 1,
                "question_id": "151193",
                "answer_type": 1
            },
            {
                "index": 85,
                "question_type": "1",
                "belong_page": 1,
                "question_id": "151194",
                "answer_type": 1
            },
            {
                "index": 86,
                "question_type": "1",
                "belong_page": 1,
                "question_id": "151195",
                "answer_type": 1
            },
            {
                "index": 87,
                "question_type": "1",
                "belong_page": 1,
                "question_id": "151196",
                "answer_type": 1
            },
            {
                "index": 88,
                "question_type": "1",
                "belong_page": 1,
                "question_id": "151197",
                "answer_type": 1
            },
            {
                "index": 89,
                "question_type": "1",
                "belong_page": 1,
                "question_id": "151198",
                "answer_type": 1
            },
            {
                "index": 90,
                "question_type": "1",
                "belong_page": 1,
                "question_id": "151200",
                "answer_type": 1
            },
            {
                "index": 91,
                "question_type": "1",
                "belong_page": 1,
                "question_id": "151201",
                "answer_type": 1
            },
            {
                "index": 92,
                "question_type": "1",
                "belong_page": 1,
                "question_id": "151202",
                "answer_type": 1
            },
            {
                "index": 93,
                "question_type": "1",
                "belong_page": 1,
                "question_id": "151203",
                "answer_type": 1
            },
            {
                "index": 94,
                "question_type": "1",
                "belong_page": 1,
                "question_id": "151204",
                "answer_type": 1
            },
            {
                "index": 95,
                "question_type": "1",
                "belong_page": 1,
                "question_id": "151206",
                "answer_type": 1
            },
            {
                "index": 96,
                "question_type": "1",
                "belong_page": 1,
                "question_id": "159227",
                "answer_type": 1
            },
            {
                "index": 97,
                "question_type": "1",
                "belong_page": 1,
                "question_id": "159228",
                "answer_type": 1
            },
            {
                "index": 98,
                "question_type": "1",
                "belong_page": 1,
                "question_id": "159229",
                "answer_type": 1
            },
            {
                "index": 99,
                "question_type": "1",
                "belong_page": 1,
                "question_id": "159230",
                "answer_type": 1
            },
            {
                "index": 100,
                "question_type": "1",
                "belong_page": 1,
                "question_id": "159231",
                "answer_type": 1
            },
            {
                "index": 101,
                "question_type": "1",
                "belong_page": 1,
                "question_id": "159232",
                "answer_type": 1
            },
            {
                "index": 102,
                "question_type": "1",
                "belong_page": 1,
                "question_id": "159247",
                "answer_type": 1
            },
            {
                "index": 103,
                "question_type": "1",
                "belong_page": 1,
                "question_id": "208398",
                "answer_type": 1
            },
            {
                "index": 104,
                "question_type": "1",
                "belong_page": 1,
                "question_id": "208399",
                "answer_type": 1
            },
            {
                "index": 105,
                "question_type": "1",
                "belong_page": 1,
                "question_id": "208400",
                "answer_type": 1
            },
            {
                "index": 106,
                "question_type": "1",
                "belong_page": 1,
                "question_id": "208401",
                "answer_type": 1
            },
            {
                "index": 107,
                "question_type": "1",
                "belong_page": 1,
                "question_id": "208437",
                "answer_type": 1
            },
            {
                "index": 108,
                "question_type": "1",
                "belong_page": 1,
                "question_id": "208438",
                "answer_type": 1
            },
            {
                "index": 109,
                "question_type": "1",
                "belong_page": 1,
                "question_id": "208439",
                "answer_type": 1
            },
            {
                "index": 110,
                "question_type": "1",
                "belong_page": 1,
                "question_id": "208440",
                "answer_type": 1
            },
            {
                "index": 111,
                "question_type": "1",
                "belong_page": 1,
                "question_id": "208441",
                "answer_type": 1
            },
            {
                "index": 112,
                "question_type": "1",
                "belong_page": 1,
                "question_id": "208473",
                "answer_type": 1
            },
            {
                "index": 113,
                "question_type": "1",
                "belong_page": 1,
                "question_id": "208474",
                "answer_type": 1
            },
            {
                "index": 114,
                "question_type": "1",
                "belong_page": 1,
                "question_id": "208475",
                "answer_type": 1
            },
            {
                "index": 115,
                "question_type": "1",
                "belong_page": 1,
                "question_id": "208476",
                "answer_type": 1
            },
            {
                "index": 116,
                "question_type": "9",
                "belong_page": 1,
                "question_id": "281180",
                "answer_type": 1
            },
            {
                "index": 117,
                "question_type": "9",
                "belong_page": 1,
                "question_id": "281181",
                "answer_type": 1
            },
            {
                "index": 118,
                "question_type": "9",
                "belong_page": 1,
                "question_id": "281182",
                "answer_type": 1
            },
            {
                "index": 119,
                "question_type": "9",
                "belong_page": 1,
                "question_id": "281184",
                "answer_type": 1
            },
            {
                "index": 120,
                "question_type": "9",
                "belong_page": 1,
                "question_id": "281185",
                "answer_type": 1
            },
            {
                "index": 121,
                "question_type": "9",
                "belong_page": 1,
                "question_id": "281317",
                "answer_type": 1
            },
            {
                "index": 122,
                "question_type": "9",
                "belong_page": 1,
                "question_id": "281318",
                "answer_type": 1
            },
            {
                "index": 123,
                "question_type": "9",
                "belong_page": 1,
                "question_id": "281319",
                "answer_type": 1
            },
            {
                "index": 124,
                "question_type": "9",
                "belong_page": 1,
                "question_id": "281581",
                "answer_type": 1
            },
            {
                "index": 125,
                "question_type": "9",
                "belong_page": 1,
                "question_id": "281582",
                "answer_type": 1
            },
            {
                "index": 126,
                "question_type": "1",
                "belong_page": 1,
                "question_id": "281583",
                "answer_type": 1
            },
            {
                "index": 127,
                "question_type": "9",
                "belong_page": 1,
                "question_id": "281585",
                "answer_type": 1
            },
            {
                "index": 128,
                "question_type": "9",
                "belong_page": 1,
                "question_id": "281586",
                "answer_type": 1
            },
            {
                "index": 129,
                "question_type": "9",
                "belong_page": 1,
                "question_id": "281588",
                "answer_type": 1
            },
            {
                "index": 130,
                "question_type": "9",
                "belong_page": 1,
                "question_id": "281589",
                "answer_type": 1
            },
            {
                "index": 131,
                "question_type": "9",
                "belong_page": 1,
                "question_id": "281590",
                "answer_type": 1
            },
            {
                "index": 132,
                "question_type": "9",
                "belong_page": 1,
                "question_id": "281592",
                "answer_type": 1
            },
            {
                "index": 133,
                "question_type": "9",
                "belong_page": 1,
                "question_id": "281593",
                "answer_type": 1
            },
            {
                "index": 134,
                "question_type": "1",
                "belong_page": 1,
                "question_id": "281594",
                "answer_type": 1
            },
            {
                "index": 135,
                "question_type": "9",
                "belong_page": 1,
                "question_id": "281596",
                "answer_type": 1
            },
            {
                "index": 136,
                "question_type": "9",
                "belong_page": 1,
                "question_id": "281597",
                "answer_type": 1
            },
            {
                "index": 137,
                "question_type": "1",
                "belong_page": 1,
                "question_id": "281598",
                "answer_type": 1
            },
            {
                "index": 138,
                "question_type": "1",
                "belong_page": 1,
                "question_id": "281599",
                "answer_type": 1
            },
            {
                "index": 139,
                "question_type": "9",
                "belong_page": 1,
                "question_id": "284661",
                "answer_type": 1
            },
            {
                "index": 140,
                "question_type": "9",
                "belong_page": 1,
                "question_id": "284662",
                "answer_type": 1
            },
            {
                "index": 141,
                "question_type": "9",
                "belong_page": 1,
                "question_id": "284663",
                "answer_type": 1
            },
            {
                "index": 142,
                "question_type": "9",
                "belong_page": 1,
                "question_id": "284664",
                "answer_type": 1
            },
            {
                "index": 143,
                "question_type": "9",
                "belong_page": 1,
                "question_id": "284665",
                "answer_type": 1
            },
            {
                "index": 144,
                "question_type": "9",
                "belong_page": 1,
                "question_id": "284667",
                "answer_type": 1
            },
            {
                "index": 145,
                "question_type": "9",
                "belong_page": 1,
                "question_id": "284668",
                "answer_type": 1
            },
            {
                "index": 146,
                "question_type": "9",
                "belong_page": 1,
                "question_id": "284670",
                "answer_type": 1
            },
            {
                "index": 147,
                "question_type": "9",
                "belong_page": 1,
                "question_id": "284671",
                "answer_type": 1
            },
            {
                "index": 148,
                "question_type": "9",
                "belong_page": 1,
                "question_id": "284672",
                "answer_type": 1
            },
            {
                "index": 149,
                "question_type": "9",
                "belong_page": 1,
                "question_id": "284951",
                "answer_type": 1
            },
            {
                "index": 150,
                "question_type": "9",
                "belong_page": 1,
                "question_id": "284952",
                "answer_type": 1
            },
            {
                "index": 151,
                "question_type": "1",
                "belong_page": 1,
                "question_id": "284953",
                "answer_type": 1
            },
            {
                "index": 152,
                "question_type": "1",
                "belong_page": 1,
                "question_id": "302372",
                "answer_type": 1
            },
            {
                "index": 153,
                "question_type": "9",
                "belong_page": 1,
                "question_id": "302374",
                "answer_type": 1
            },
            {
                "index": 154,
                "question_type": "9",
                "belong_page": 1,
                "question_id": "302375",
                "answer_type": 1
            },
            {
                "index": 155,
                "question_type": "1",
                "belong_page": 1,
                "question_id": "302376",
                "answer_type": 1
            },
            {
                "index": 156,
                "question_type": "9",
                "belong_page": 1,
                "question_id": "310871",
                "answer_type": 1
            },
            {
                "index": 157,
                "question_type": "9",
                "belong_page": 1,
                "question_id": "310872",
                "answer_type": 1
            },
            {
                "index": 158,
                "question_type": "9",
                "belong_page": 1,
                "question_id": "310873",
                "answer_type": 1
            },
            {
                "index": 159,
                "question_type": "9",
                "belong_page": 1,
                "question_id": "310875",
                "answer_type": 1
            },
            {
                "index": 160,
                "question_type": "9",
                "belong_page": 1,
                "question_id": "310876",
                "answer_type": 1
            },
            {
                "index": 161,
                "question_type": "1",
                "belong_page": 1,
                "question_id": "312928",
                "answer_type": 1
            },
            {
                "index": 162,
                "question_type": "9",
                "belong_page": 1,
                "question_id": "312930",
                "answer_type": 1
            },
            {
                "index": 163,
                "question_type": "9",
                "belong_page": 1,
                "question_id": "312931",
                "answer_type": 1
            },
            {
                "index": 164,
                "question_type": "9",
                "belong_page": 1,
                "question_id": "312932",
                "answer_type": 1
            },
            {
                "index": 165,
                "question_type": "9",
                "belong_page": 1,
                "question_id": "312959",
                "answer_type": 1
            },
            {
                "index": 166,
                "question_type": "9",
                "belong_page": 1,
                "question_id": "312960",
                "answer_type": 1
            },
            {
                "index": 167,
                "question_type": "9",
                "belong_page": 1,
                "question_id": "312961",
                "answer_type": 1
            },
            {
                "index": 168,
                "question_type": "9",
                "belong_page": 1,
                "question_id": "315903",
                "answer_type": 1
            },
            {
                "index": 169,
                "question_type": "9",
                "belong_page": 1,
                "question_id": "315904",
                "answer_type": 1
            },
            {
                "index": 170,
                "question_type": "9",
                "belong_page": 1,
                "question_id": "350286",
                "answer_type": 1
            },
            {
                "index": 171,
                "question_type": "9",
                "belong_page": 1,
                "question_id": "350287",
                "answer_type": 1
            },
            {
                "index": 172,
                "question_type": "1",
                "belong_page": 1,
                "question_id": "350288",
                "answer_type": 1
            },
            {
                "index": 173,
                "question_type": "1",
                "belong_page": 1,
                "question_id": "350289",
                "answer_type": 1
            },
            {
                "index": 174,
                "question_type": "1",
                "belong_page": 1,
                "question_id": "350290",
                "answer_type": 1
            },
            {
                "index": 175,
                "question_type": "9",
                "belong_page": 1,
                "question_id": "352247",
                "answer_type": 1
            },
            {
                "index": 176,
                "question_type": "9",
                "belong_page": 1,
                "question_id": "352248",
                "answer_type": 1
            },
            {
                "index": 177,
                "question_type": "9",
                "belong_page": 1,
                "question_id": "352250",
                "answer_type": 1
            },
            {
                "index": 178,
                "question_type": "9",
                "belong_page": 1,
                "question_id": "352251",
                "answer_type": 1
            },
            {
                "index": 179,
                "question_type": "1",
                "belong_page": 1,
                "question_id": "352252",
                "answer_type": 1
            },
            {
                "index": 180,
                "question_type": "1",
                "belong_page": 1,
                "question_id": "352253",
                "answer_type": 1
            },
            {
                "index": 181,
                "question_type": "9",
                "belong_page": 1,
                "question_id": "352367",
                "answer_type": 1
            },
            {
                "index": 182,
                "question_type": "9",
                "belong_page": 1,
                "question_id": "352368",
                "answer_type": 1
            },
            {
                "index": 183,
                "question_type": "9",
                "belong_page": 1,
                "question_id": "352369",
                "answer_type": 1
            },
            {
                "index": 184,
                "question_type": "9",
                "belong_page": 1,
                "question_id": "352370",
                "answer_type": 1
            },
            {
                "index": 185,
                "question_type": "1",
                "belong_page": 1,
                "question_id": "352371",
                "answer_type": 1
            },
            {
                "index": 186,
                "question_type": "1",
                "belong_page": 1,
                "question_id": "352372",
                "answer_type": 1
            },
            {
                "index": 187,
                "question_type": "1",
                "belong_page": 1,
                "question_id": "352373",
                "answer_type": 1
            },
            {
                "index": 188,
                "question_type": "9",
                "belong_page": 1,
                "question_id": "352375",
                "answer_type": 1
            },
            {
                "index": 189,
                "question_type": "9",
                "belong_page": 1,
                "question_id": "352376",
                "answer_type": 1
            },
            {
                "index": 190,
                "question_type": "9",
                "belong_page": 1,
                "question_id": "352377",
                "answer_type": 1
            },
            {
                "index": 191,
                "question_type": "1",
                "belong_page": 1,
                "question_id": "352378",
                "answer_type": 1
            },
            {
                "index": 192,
                "question_type": "9",
                "belong_page": 1,
                "question_id": "352380",
                "answer_type": 1
            },
            {
                "index": 193,
                "question_type": "9",
                "belong_page": 1,
                "question_id": "352381",
                "answer_type": 1
            },
            {
                "index": 194,
                "question_type": "9",
                "belong_page": 1,
                "question_id": "352382",
                "answer_type": 1
            },
            {
                "index": 195,
                "question_type": "1",
                "belong_page": 1,
                "question_id": "356102",
                "answer_type": 1
            },
            {
                "index": 196,
                "question_type": "1",
                "belong_page": 1,
                "question_id": "356106",
                "answer_type": 1
            },
            {
                "index": 197,
                "question_type": "1",
                "belong_page": 1,
                "question_id": "356107",
                "answer_type": 1
            },
            {
                "index": 198,
                "question_type": "1",
                "belong_page": 1,
                "question_id": "356108",
                "answer_type": 1
            },
            {
                "index": 199,
                "question_type": "1",
                "belong_page": 1,
                "question_id": "356109",
                "answer_type": 1
            },
            {
                "index": 200,
                "question_type": "1",
                "belong_page": 1,
                "question_id": "356110",
                "answer_type": 1
            },
            {
                "index": 201,
                "question_type": "1",
                "belong_page": 1,
                "question_id": "356189",
                "answer_type": 1
            },
            {
                "index": 202,
                "question_type": "1",
                "belong_page": 1,
                "question_id": "356190",
                "answer_type": 1
            },
            {
                "index": 203,
                "question_type": "1",
                "belong_page": 1,
                "question_id": "356191",
                "answer_type": 1
            },
            {
                "index": 204,
                "question_type": "1",
                "belong_page": 1,
                "question_id": "356192",
                "answer_type": 1
            },
            {
                "index": 205,
                "question_type": "8",
                "belong_page": 1,
                "question_id": "356104",
                "answer_type": 1
            },
            {
                "index": 206,
                "question_type": "8",
                "belong_page": 1,
                "question_id": "356105",
                "answer_type": 1
            },
            {
                "index": 207,
                "question_type": "5",
                "belong_page": 1,
                "question_id": "43814",
                "answer_type": 5
            },
            {
                "index": 208,
                "question_type": "5",
                "belong_page": 1,
                "question_id": "45922",
                "answer_type": 5
            },
            {
                "index": 209,
                "question_type": "14",
                "belong_page": 1,
                "question_id": "303749",
                "answer_type": 5
            },
            {
                "index": 210,
                "question_type": "14",
                "belong_page": 1,
                "question_id": "303750",
                "answer_type": 5
            },
            {
                "index": 211,
                "question_type": "14",
                "belong_page": 1,
                "question_id": "303751",
                "answer_type": 5
            },
            {
                "index": 212,
                "question_type": "14",
                "belong_page": 1,
                "question_id": "316002",
                "answer_type": 5
            },
            {
                "index": 213,
                "question_type": "14",
                "belong_page": 1,
                "question_id": "316003",
                "answer_type": 5
            },
            {
                "index": 214,
                "question_type": "14",
                "belong_page": 1,
                "question_id": "316004",
                "answer_type": 5
            },
            {
                "index": 215,
                "question_type": "5",
                "belong_page": 1,
                "question_id": "347227",
                "answer_type": 5
            }
        ],
        "progress": []
    }
}
