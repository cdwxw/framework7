{
    "msg": "成功",
    "status": 0,
    "data": {
        "data": {
            "question": [
                {
                    "index": 1,
                    "belong_page": 1,
                    "question_id": 43752,
                    "question_title": "<p><br/></p><p><br/></p><p class=\"MsoNormal\" style=\"text-indent:20.7000pt;text-align:left;\"><span style=\"mso-spacerun:&#39;yes&#39;;font-family:宋体;font-size:10.5000pt;mso-font-kerning:1.0000pt;\"><span style=\"font-family:宋体\">为了测试新系统的性能，用户必须依靠评价程序来评价机器的性能，以下</span></span><span style=\"mso-spacerun:&#39;yes&#39;;font-family:宋体;font-size:10.5000pt;mso-font-kerning:1.0000pt;\">4</span><span style=\"mso-spacerun:&#39;yes&#39;;font-family:宋体;font-size:10.5000pt;mso-font-kerning:1.0000pt;\"><span style=\"font-family:宋体\">种评价程序，</span></span><span style=\"text-decoration:underline;\"><span style=\"mso-spacerun:&#39;yes&#39;;font-family:宋体;text-decoration:underline;text-underline:single;font-size:10.5000pt;mso-font-kerning:1.0000pt;\"><span style=\"font-family:宋体\">（</span></span></span><span style=\"text-decoration:underline;\"><span style=\"mso-spacerun:&#39;yes&#39;;font-family:宋体;text-decoration:underline;text-underline:single;font-size:10.5000pt;mso-font-kerning:1.0000pt;\">17</span></span><span style=\"text-decoration:underline;\"><span style=\"mso-spacerun:&#39;yes&#39;;font-family:宋体;text-decoration:underline;text-underline:single;font-size:10.5000pt;mso-font-kerning:1.0000pt;\"><span style=\"font-family:宋体\">）</span></span></span><span style=\"mso-spacerun:&#39;yes&#39;;font-family:宋体;font-size:10.5000pt;mso-font-kerning:1.0000pt;\"><span style=\"font-family:宋体\">评测的准确程度最低。</span></span><span style=\"mso-spacerun:&#39;yes&#39;;font-family:宋体;mso-hansi-font-family:&#39;Times New Roman&#39;;font-size:10.5000pt;mso-font-kerning:1.0000pt;\"></span></p><p><br/></p>",
                    "question_type": 1,
                    "answer_type": 1,
                    "show_type_name": null,
                    "new_parent_id": 43752,
                    "score_rule": "",
                    "material_text": null,
                    "sort_son": "0",
                    "analyze": "<p>略</p>",
                    "like": 0,
                    "answer": [
                        "D"
                    ],
                    "option": [
                        " 小型基准程序 ",
                        " 真实程序&nbsp; ",
                        " 核心程序&nbsp; ",
                        " 合成基准程序 "
                    ]
                },
                {
                    "index": 2,
                    "belong_page": 1,
                    "question_id": 43773,
                    "question_title": "<p>（请作答此空)的目的是检查模块之间，以及模块和已集成的软件之间的接口关系，并验证已集成的软件是否符合设计要求。其测试的技术依据是( )。<br/></p><p><br/></p>",
                    "question_type": 1,
                    "answer_type": 1,
                    "show_type_name": null,
                    "new_parent_id": 43773,
                    "score_rule": "",
                    "material_text": null,
                    "sort_son": "0",
                    "analyze": "<p><br/></p><p><br/></p><p>软件测试可分为单元测试、集成测试、配置项测试、系统测试、验收测试和回归测试等类别。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;单元测试也称为模块测试，测试的对象是可独立编译或汇编的程序模块、软件构件或面向对象软件中的类(统称为模块)，其目的是检查每个模块能否正确地实现设计说明中的功能、性能、接口和其他设计约束等条件，发现模块内可能存在的各种差错。单元测试的技术依据是软件详细设计说明书。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;集成测试的目的是检查模块之间，以及模块和已集成的软件之间的接口关系，并验证已集成的软件是否符合设计要求。集成测试的技术依据是软件概要设计文档。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;系统测试的对象是完整的、集成的计算机系统，系统测试的目的是在真实系统工作环境下，验证完整的软件配置项能否和系统正确连接，并满足系统/子系统设计文档和软件开发合同规定的要求。系统测试的技术依据是用户需求或开发合同。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;配置项测试的对象是软件配置项，配置项测试的目的是检验软件配置项与软件需求规格说明的一致性。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;确认测试主要验证软件的功能、性能和其他特性是否与用户需求一致。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;验收测试是指针对软件需求规格说明，在交付前以用户为主进行的测试。</p><p>回归测试的目的是测试软件变更之后，变更部分的正确性和对变更需求的复合型，以及软件原有的、正确的功能、性能和其他规定的要求的不损害性。</p><p><br/></p>",
                    "like": 0,
                    "answer": [
                        "B"
                    ],
                    "option": [
                        " 单元测试&nbsp;&nbsp; ",
                        " 集成测试&nbsp; ",
                        " 系统测试 &nbsp; ",
                        " 回归测试 "
                    ]
                },
                {
                    "index": 3,
                    "belong_page": 1,
                    "question_id": 43774,
                    "question_title": "<p>（ ）的目的是检查模块之间，以及模块和已集成的软件之间的接口关系，并验证已集成的软件是否符合设计要求。其测试的技术依据是（请作答此空）。</p>",
                    "question_type": 1,
                    "answer_type": 1,
                    "show_type_name": null,
                    "new_parent_id": 43774,
                    "score_rule": "",
                    "material_text": null,
                    "sort_son": "0",
                    "analyze": "<p>软件测试可分为单元测试、集成测试、配置项测试、系统测试、验收测试和回归测试等类别。<br/></p><p>单元测试也称为模块测试，测试的对象是可独立编译或汇编的程序模块、软件构件或面向对象软件中的类(统称为模块)，其目的是检查每个模块能否正确地实现设计说明中的功能、性能、接口和其他设计约束等条件，发现模块内可能存在的各种差错。单元测试的技术依据是软件详细设计说明书。</p><p>集成测试的目的是检查模块之间，以及模块和已集成的软件之间的接口关系，并验证已集成的软件是否符合设计要求。集成测试的技术依据是软件概要设计文档。</p><p>系统测试的对象是完整的、集成的计算机系统，系统测试的目的是在真实系统工作环境下，验证完整的软件配置项能否和系统正确连接，并满足系统/子系统设计文档和软件开发合同规定的要求。系统测试的技术依据是用户需求或开发合同。</p><p>配置项测试的对象是软件配置项，配置项测试的目的是检验软件配置项与软件需求规格说明的一致性。</p><p>确认测试主要验证软件的功能、性能和其他特性是否与用户需求一致。</p><p>验收测试是指针对软件需求规格说明，在交付前以用户为主进行的测试。</p><p>回归测试的目的是测试软件变更之后，变更部分的正确性和对变更需求的复合型，以及软件原有的、正确的功能、性能和其他规定的要求的不损害性。</p>",
                    "like": 0,
                    "answer": [
                        "C"
                    ],
                    "option": [
                        " 软件详细设计说明书&nbsp; ",
                        " 技术开发合同 ",
                        " 软件概要设计文档&nbsp; ",
                        " 软件配置文档 "
                    ]
                },
                {
                    "index": 4,
                    "belong_page": 1,
                    "question_id": 43873,
                    "question_title": "<p><span style=\"font-family: 宋体; font-size: 10.5pt; text-align: justify;\">系统维护的分类不包括（</span><span style=\"font-family: 宋体; font-size: 10.5pt; text-align: justify;\"> </span><span style=\"font-family: 宋体; font-size: 10.5pt; text-align: justify;\">）</span><br/></p><p class=\"MsoNormal\" style=\"text-align:justify;text-justify:inter-ideograph;\"><span style=\"mso-spacerun:&#39;yes&#39;;font-family:宋体;font-size:10.5000pt;mso-font-kerning:1.0000pt;\"></span></p>",
                    "question_type": 1,
                    "answer_type": 1,
                    "show_type_name": null,
                    "new_parent_id": 43873,
                    "score_rule": "",
                    "material_text": null,
                    "sort_son": "0",
                    "analyze": "<p>略<br/></p>",
                    "like": 0,
                    "answer": [
                        "B"
                    ],
                    "option": [
                        " 更正性维护 ",
                        " 可靠性维护 ",
                        " 适应性维护 ",
                        " 预防性维护 "
                    ]
                },
                {
                    "index": 5,
                    "belong_page": 1,
                    "question_id": 46953,
                    "question_title": "<p>软件确认测试也称为有效性测试，主要验证（）</p>",
                    "question_type": 1,
                    "answer_type": 1,
                    "show_type_name": null,
                    "new_parent_id": 46953,
                    "score_rule": "",
                    "material_text": null,
                    "sort_son": "0",
                    "analyze": "<p>软件确认测试一种针对需求的测试，是用户参与的测试。它主要验证软件功能、性能及其它特性是否与用户需求一致。</p>",
                    "like": 0,
                    "answer": [
                        "C"
                    ],
                    "option": [
                        " 系统中各个单元模块之间的协作性 ",
                        " 软件与硬件在实际运行环境中能否有效集成 ",
                        " 软件功能、性能及其它特性是否与用户需求一致 ",
                        " 程序模块能否正确实现详细设计说明中的功能、性能和设计约束等要求 "
                    ]
                },
                {
                    "index": 6,
                    "belong_page": 1,
                    "question_id": 46954,
                    "question_title": "<p>软件确认测试也称为有效性测试，确认测试计划通常是在需求分析阶段完成的。根据用户的参与程度不同，软件确认测试通常包括（）</p>",
                    "question_type": 1,
                    "answer_type": 1,
                    "show_type_name": null,
                    "new_parent_id": 46954,
                    "score_rule": "",
                    "material_text": null,
                    "sort_son": "0",
                    "analyze": "<p>软件确认测试包括：内部确认测试、Alpha、Beta和验收测试。</p>",
                    "like": 0,
                    "answer": [
                        "C"
                    ],
                    "option": [
                        " 黑盒测试和白盒测试 ",
                        " 一次性组装测试和增量式组装测试 ",
                        " 内部测试、Alpha、Beta 和验收测试 ",
                        " 功能测试、性能测试、用户界面测试和安全性测试 "
                    ]
                },
                {
                    "index": 7,
                    "belong_page": 1,
                    "question_id": 49864,
                    "question_title": "<p>系统移植也是系统构建的一种实现方法，在移植工作中，( )需要最终确定移植方法。</p>",
                    "question_type": 1,
                    "answer_type": 1,
                    "show_type_name": null,
                    "new_parent_id": 49864,
                    "score_rule": "",
                    "material_text": null,
                    "sort_son": "0",
                    "analyze": "<p>移植工作大体上分为计划阶段、准备阶段、转换阶段、测试阶段、验证阶段。</p><p>1、计划阶段，在计划阶段，要进行现有系统的调查整理，从移植技术、系统内容（是否进行系统提炼等）、系统运行三个方面，探讨如何转换成新系统，决定移植方法，确立移植工作体制及移植日程。</p><p>2、准备阶段，在准备阶段要进行移植方面的研究，准备转换所需的资料。该阶段的作业质量将对以后的生产效率产生很大的影响。</p><p>3、转换阶段，这一阶段是将程序设计和数据转换成新机器能根据需要工作的阶段。提高转换工作的精度，减轻下一阶段的测试负担是提高移植工作效率的基本内容。</p><p>4、测试阶段，这一阶段是进行程序单元、工作单元测试的阶段。在本阶段要核实程序能否在新系统中准确地工作。所以，当有不能准确工作的程序时，就要回到转换阶段重新工作。</p><p>5、验证阶段，这是测试完的程序使新系统工作，最后核实系统，准备正式运行的阶段。</p>",
                    "like": 0,
                    "answer": [
                        "A"
                    ],
                    "option": [
                        " 计划阶段 ",
                        " 准备阶段 ",
                        " 转换阶段 ",
                        " 验证阶段 "
                    ]
                },
                {
                    "index": 8,
                    "belong_page": 1,
                    "question_id": 49865,
                    "question_title": "<p>软件确认测试也称为有效性测试，主要验证（请作答此空 ）。确认测试计划通常是在需求分析阶段完成的。根据用户的参与程度不同，软件确认测试通常包括（）。</p>",
                    "question_type": 1,
                    "answer_type": 1,
                    "show_type_name": null,
                    "new_parent_id": 49865,
                    "score_rule": "",
                    "material_text": null,
                    "sort_son": "0",
                    "analyze": "<p>软件确认测试一种针对需求的测试，是用户参与的测试。它主要验证软件功能、性能及其它特性是否与用户需求一致。</p><p>软件确认测试包括：内部确认测试、Alpha、Beta和验收测试。</p>",
                    "like": 0,
                    "answer": [
                        "C"
                    ],
                    "option": [
                        " 系统中各个单元模块之间的协作性 ",
                        " 软件与硬件在实际运行环境中能否有效集成 ",
                        " 软件功能、性能及其它特性是否与用户需求一致 ",
                        " 程序模块能否正确实现详细设计说明中的功能、性能和设计约束等要求 "
                    ]
                },
                {
                    "index": 9,
                    "belong_page": 1,
                    "question_id": 49866,
                    "question_title": "<p>软件确认测试也称为有效性测试，主要验证（）。确认测试计划通常是在需求分析阶段完成的。根据用户的参与程度不同，软件确认测试通常包括（请作答此空 ）。</p>",
                    "question_type": 1,
                    "answer_type": 1,
                    "show_type_name": null,
                    "new_parent_id": 49866,
                    "score_rule": "",
                    "material_text": null,
                    "sort_son": "0",
                    "analyze": "<p>软件确认测试一种针对需求的测试，是用户参与的测试。它主要验证软件功能、性能及其它特性是否与用户需求一致。</p><p>软件确认测试包括：内部确认测试、Alpha、Beta和验收测试。</p>",
                    "like": 0,
                    "answer": [
                        "C"
                    ],
                    "option": [
                        " 黑盒测试和白盒测试 ",
                        " 一次性组装测试和增量式组装测试 ",
                        " 内部测试、Alpha、Beta 和验收测试 ",
                        " 功能测试、性能测试、用户界面测试和安全性测试 "
                    ]
                },
                {
                    "index": 10,
                    "belong_page": 1,
                    "question_id": 49914,
                    "question_title": "<p>把应用程序中应用最频繁的那部分核心程序作为评价计算机性能的标准程序，称为（ &nbsp;）程序。</p>",
                    "question_type": 1,
                    "answer_type": 1,
                    "show_type_name": null,
                    "new_parent_id": 49914,
                    "score_rule": "",
                    "material_text": null,
                    "sort_son": "0",
                    "analyze": "<p>考查基准测试程序的概念：把应用程序中应用最频繁的那部分核心程序作为评价计算机性能的标准程序，称为基准测试程序。</p>",
                    "like": 0,
                    "answer": [
                        "C"
                    ],
                    "option": [
                        " 仿真测试 ",
                        " 核心测试 ",
                        " 基准测试 ",
                        " 标准测试 "
                    ]
                },
                {
                    "index": 11,
                    "belong_page": 1,
                    "question_id": 49940,
                    "question_title": "<p>软件集成测试将已通过单元测试的模块集成在一起，主要测试模块之间的协作性。从组装策略而言，可以分为（ ）。</p>",
                    "question_type": 1,
                    "answer_type": 1,
                    "show_type_name": null,
                    "new_parent_id": 49940,
                    "score_rule": "",
                    "material_text": null,
                    "sort_son": "0",
                    "analyze": "<p>集成测试可以分为一次性组装和增量式组装，增量式组装测试效果更好。集成测试计划一般在概要设计阶段完成。</p>",
                    "like": 0,
                    "answer": [
                        "C"
                    ],
                    "option": [
                        " 批量式组装和增量式组装 ",
                        " 自顶向下和自底向上组装 ",
                        " 一次性组装和增量式组装 ",
                        " 整体性组装和混合式组装 "
                    ]
                },
                {
                    "index": 12,
                    "belong_page": 1,
                    "question_id": 49941,
                    "question_title": "<p>集成测试计划通常是在（ ）阶段完成，集成测试一般采用黑盒测试方法。</p>",
                    "question_type": 1,
                    "answer_type": 1,
                    "show_type_name": null,
                    "new_parent_id": 49941,
                    "score_rule": "",
                    "material_text": null,
                    "sort_son": "0",
                    "analyze": "<p>集成测试可以分为一次性组装和增量式组装，增量式组装测试效果更好。集成测试计划一般在概要设计阶段完成。</p>",
                    "like": 0,
                    "answer": [
                        "B"
                    ],
                    "option": [
                        " 软件方案建议 ",
                        " 软件概要设计 ",
                        " 软件详细设计 ",
                        " 软件模块集成 "
                    ]
                },
                {
                    "index": 13,
                    "belong_page": 1,
                    "question_id": 49945,
                    "question_title": "<p>（ &nbsp;）不属于可修改性考虑的内容。</p>",
                    "question_type": 1,
                    "answer_type": 1,
                    "show_type_name": null,
                    "new_parent_id": 49945,
                    "score_rule": "",
                    "material_text": null,
                    "sort_son": "0",
                    "analyze": "<p>可修改性(modifiability)是指能够快速地以较高的性能价格比对系统进行变更的能力。通常以某些具体的变更为基准，通过考察这些变更的代价衡量可修改性。可修改性包含四个方面。</p><p>(1)可维护性(maintainability)。这主要体现在问题的修复上：在错误发生后&quot;修复&quot;软件系统。为可维护性做好准备的软件体系结构往往能做局部性的修改并能使对其他构件的负面影响最小化。</p><p>(2)可扩展性(extendibility)。这一点关注的是使用新特性来扩展软件系统，以及使用改进版本来替换构件并删除不需要或不必要的特性和构件。为了实现可扩展性，软件系统需要松散耦合的构件。其目标是实现一种体系结构，它能使开发人员在不影响构件客户的情况下替换构件。支持把新构件集成到现有的体系结构中也是必要的。</p><p>(3)结构重组(reassemble）。这一点处理的是重新组织软件系统的构件及构件间的关系，例如通过将构件移动到一个不同的子系统而改变它的位置。为了支持结构重组，软件系统需要精心设计构件之间的关系。理想情况下，它们允许开发人员在不影响实现的主体部分的情况下灵活地配置构件。</p><p>(4)可移植性(portability)。可移植性使软件系统适用于多种硬件平台、用户界面、操作系统、编程语言或编译器。为了实现可移植，需要按照硬件无关的方式组织软件系统，其他软件系统和环境被提取出。可移植性是系统能够在不同计算环境下运行的能力。这些环境可能是硬件、软件，也可能是两者的结合。在关于某个特定计算环境的所有假设都集中在一个构件中时，系统是可移植的。 如果移植到新的系统需要做些更改，则可移植性就是一种特殊的可修改性。</p>",
                    "like": 0,
                    "answer": [
                        "D"
                    ],
                    "option": [
                        " 可维护性 ",
                        " 可扩展性 ",
                        " 结构重构 ",
                        " 可变性 "
                    ]
                },
                {
                    "index": 14,
                    "belong_page": 1,
                    "question_id": 50899,
                    "question_title": "<p>在软件的使用过程中，用户往往会对软件提出新的功能与性能要求。为了满足这些要求，需要修改或再开发软件。在这种情况下进行的维护活动称为()。</p>",
                    "question_type": 1,
                    "answer_type": 1,
                    "show_type_name": null,
                    "new_parent_id": 50899,
                    "score_rule": "",
                    "material_text": null,
                    "sort_son": "0",
                    "analyze": "<p>在系统运行过程中，软件需要维护的原因是多样的。根据维护的原因不同，可以将软件维护分为以下4种：①改正性维护。为了识别和纠正软件错误、改正软件性能上的缺陷、排除实施中的误使用，应当进行的诊断和改正错误的过程称为改正性维护。②适应性维护。在使用过程中，外部环境(新的硬、软件配置)、数据环境(数据库、数据格式、数据输入/输出方法、数据存储介质)可能发生变化。为使软件适应这种变化而修改软件的过程称为适用性维护。③完善性维护。在软件的使用过程中，用户往往会对软件提出新的功能与性能要求。为了满足这些要求，需要修改或再开发软件，以扩充软件功能、增强软件性能、改进加工效率、提高软件的可维护性。这种情况下进行的维护活动成为完善性维护。④预防性维护。指预先提高软件的可维护性、可靠性等，为以后进一步改进软件打下良好基础。采用先进的软件工程方法对需要维护的软件或软件中的某一部分(重新)进行设计、编码和测试。</p>",
                    "like": 0,
                    "answer": [
                        "C"
                    ],
                    "option": [
                        " 改正性维护 ",
                        " 适应性维护 ",
                        " 完善性维护 ",
                        " 预防性维护 "
                    ]
                },
                {
                    "index": 15,
                    "belong_page": 1,
                    "question_id": 50907,
                    "question_title": "<p>在单元测试中，说法正确的是（）。</p>",
                    "question_type": 1,
                    "answer_type": 1,
                    "show_type_name": null,
                    "new_parent_id": 50907,
                    "score_rule": "",
                    "material_text": null,
                    "sort_son": "0",
                    "analyze": "<p>单元测试也称为模块测试，测试的对象是可独立编译或汇编的程序模块、软件构件或面向对象软件中的类(统称为模块)，其目的是检查每个模块能否正确地实现设计说明中的功能、性能、接口和其他设计约束等条件，发现模块内可能存在的各种差错。单元测试的技术依据是软件详细设计说明书。&nbsp;测试一个模块时，可能需要为该模块编写一个驱动模块和若干个桩模块。驱动模块用来调用被测模块，它接收测试者提供的测试数据，并把这些数据传送给被测模块，然后从被测模块接收测试结果，并以某种可见的方式将测试结果返回给测试人员；桩模块用来模拟被测模块所调用的子模块，它接受被测模块的调用，检验调用参数，并以尽可能简单的操作模拟被调用的子程序模块功能，把结果送回被测模块。项层模块测试时不需要驱动模块，底层模块测试时不要桩模块。&nbsp;单元测试策略主要包括自顶向下的单元测试、自底向上的单元测试、孤立测试和综合测试策略。&nbsp;①自顶向下的单元测试先测试上层模块，再测试下层模块。测试下层模块时由于它的上层模块已测试过，所以不必另外编写驱动模块。&nbsp;②自底向上的单元测试。自底向上的单元测试先测试下层模块，再测试上层模块。测试上层模块由于它的下层模块已经测试过，所以不必另外编写桩模块。&nbsp;③孤立测试不需要考虑每个模块与其他模块之间的关系，逐一完成所有模块的测试。由于各模块之间不存在依赖性，单元测试可以并行进行，但因为需要为每个模块单独设计驱动模块和桩模块，增加了额外的测试成本。&nbsp;④综合测试。上述三种单元测试策略各有利弊，实际测试时可以根据软件特点和进度安排情况，将几种测试方法混合使用，</p>",
                    "like": 0,
                    "answer": [
                        "A"
                    ],
                    "option": [
                        " 驱动模块用来调用被测模块，自顶向下的单元测试中不需要另外编写驱动模块 ",
                        " 桩模块用来模拟被测模块所调用的子模块，自顶向下的单元测试中不需要另外编写桩模块 ",
                        " 驱动模块用来模拟被测模块所调用的子模块，自底向上的单元测试中不需要另外编写驱动模块 ",
                        " 桩模块用来调用被测模块，自底向上的单元测试中不需要另外编写桩模块 "
                    ]
                },
                {
                    "index": 16,
                    "belong_page": 1,
                    "question_id": 54204,
                    "question_title": "<p>以下关于基准测试的叙述中，正确的是（ &nbsp;）。</p>",
                    "question_type": 1,
                    "answer_type": 1,
                    "show_type_name": null,
                    "new_parent_id": 54204,
                    "score_rule": "",
                    "material_text": null,
                    "sort_son": "0",
                    "analyze": "<p>各种类型的计算机都具有自己的性能指标，计算机厂商当然希望自己研制的计算机有较高的性能。同样的计算机，如果采用不同的评价方法，所获得的性能指标也会不同。因此，用户希望能有一些公正的机构采用公认的评价方法来测试计算机的性能。这样的测试称为基准测试，基准测试采用的测试程序称为基准程序(Benchmark）。基准程序就是公认的标准程序，用它能测试多种计算机系统，比较和评价它们的性能，定期公布测试结果，供用户选购计算机时参考。<br/>对计算机进行负载测试就是运行某种诊断程序，加大负载，检查哪个设备会发生故障。<br/>在程序模块测试后进行的集成测试，主要测试各模块之间的接口是否正常起作用。<br/>白盒测试就是根据程序内部结构和内部逻辑，测试其功能是否正确。</p>",
                    "like": 0,
                    "answer": [
                        "C"
                    ],
                    "option": [
                        " 运行某些诊断程序，加大负载，检查哪个设备会发生故障 ",
                        " 验证程序模块之间的接口是否正常起作用 ",
                        " 运行一个标准程序对多种计算机系统进行检查，以比较和评价它们的性能 ",
                        " 根据程序的内部结构和内部逻辑，评价程序是否正确 "
                    ]
                },
                {
                    "index": 17,
                    "belong_page": 1,
                    "question_id": 54224,
                    "question_title": "<p>测试用例由测试输入数据和与之对应的预期输出结果组成。 人们常用白盒法和黑盒法设计测试用例，其中白盒法主要是为了检查（ &nbsp;）等。</p>",
                    "question_type": 1,
                    "answer_type": 1,
                    "show_type_name": null,
                    "new_parent_id": 54224,
                    "score_rule": "",
                    "material_text": null,
                    "sort_son": "0",
                    "analyze": "<p>本题考查软件测试的基础知识。<br/>黑盒测试在完全不考虑软件的内部结构和特性的情况下，测试软件的外部特性。白盒测试则根据程序的内部结构和逻辑来设计测试用例，对程序的执行路径和执行过程进行测试，检查是否满足设计要求。</p>",
                    "like": 0,
                    "answer": [
                        "D"
                    ],
                    "option": [
                        " 是否有错误的功能或遗漏的功能 ",
                        " 性能是否能够接受 ",
                        " 是否有数据结构或外部数据库访问错误 ",
                        " 程序内部结构是否有效 "
                    ]
                },
                {
                    "index": 18,
                    "belong_page": 1,
                    "question_id": 54234,
                    "question_title": "<p>系统测试将软件、硬件、网络等其它因素结合，对整个软件进行测试。（ &nbsp;）不是系统测试的内容。</p>",
                    "question_type": 1,
                    "answer_type": 1,
                    "show_type_name": null,
                    "new_parent_id": 54234,
                    "score_rule": "",
                    "material_text": null,
                    "sort_son": "0",
                    "analyze": "<p>系统测试是将已经确认的软件、计算机硬件、外设和网络等其他因素结合在一起，进行信息系统的各种集成测试和确认测试，其目的是通过与系统的需求相比较，发现所开发的系统与用户需求不符或矛盾的地方。系统测试是根据系统方案说明书来设计测试用例，常见的系统测试主要有恢复测试、安全性测试、压力测试、性能测试、可靠性测试、可用性测试、可维护性测试和安装测试。</p>",
                    "like": 0,
                    "answer": [
                        "A"
                    ],
                    "option": [
                        " 路径测试 ",
                        " 可靠性测试 ",
                        " 安装测试 ",
                        " 安全测试 "
                    ]
                },
                {
                    "index": 19,
                    "belong_page": 1,
                    "question_id": 54325,
                    "question_title": "<p>人们根据软件维护的性质不同，将软件维护分为更正性维护、适应性维护、完善性维护、预防性维护等四类，（ ）是这四类软件维护的共同特征。</p>",
                    "question_type": 1,
                    "answer_type": 1,
                    "show_type_name": null,
                    "new_parent_id": 54325,
                    "score_rule": "",
                    "material_text": null,
                    "sort_son": "0",
                    "analyze": "<p>这四类软件维护的共同特征为都是交付后进行的。</p>",
                    "like": 0,
                    "answer": [
                        "B"
                    ],
                    "option": [
                        " 发现原产品中存在问题后采取的补救措施 ",
                        " 交付软件产品后进行的修改 ",
                        " 测试发现问题之后的应对措施 ",
                        " 软件产品交付前进行的质量管理活动 "
                    ]
                },
                {
                    "index": 20,
                    "belong_page": 1,
                    "question_id": 63650,
                    "question_title": "<p>软件测试一般分为两个大类：动态测试和静态测试。前者通过运行程序发现错误，包括（请作答此空）等方法；后者采用人工和计算机辅助静态分析的手段对程序进行检测，包括（　）等方法。</p>",
                    "question_type": 1,
                    "answer_type": 1,
                    "show_type_name": null,
                    "new_parent_id": 63650,
                    "score_rule": "",
                    "material_text": null,
                    "sort_son": "0",
                    "analyze": "<p>本题考查测试的分类，测试可以分为动态测试与静态测试。</p><p>动态测试是通过运行程序发现错误，包括黑盒测试（等价类划分、边界值分析法、错误推测法）与白盒测试（各种类型的覆盖测试）。</p><p>静态测试是人工测试方式，包括桌前检查（桌面检查）、代码走查、代码审查。</p>",
                    "like": 0,
                    "answer": [
                        "A"
                    ],
                    "option": [
                        " 边界值分析、逻辑覆盖、基本路径 ",
                        " 桌面检查、逻辑覆盖、错误推测 ",
                        " 桌面检查、代码审查、代码走查 ",
                        " 错误推测、代码审查、基本路径 "
                    ]
                },
                {
                    "index": 21,
                    "belong_page": 1,
                    "question_id": 63652,
                    "question_title": "<p>软件测试一般分为两个大类：动态测试和静态测试。前者通过运行程序发现错误，包括（　）等方法；后者采用人工和计算机辅助静态分析的手段对程序进行检测，包括（请作答此空）等方法。</p>",
                    "question_type": 1,
                    "answer_type": 1,
                    "show_type_name": null,
                    "new_parent_id": 63652,
                    "score_rule": "",
                    "material_text": null,
                    "sort_son": "0",
                    "analyze": "<p>本题考查测试的分类，测试可以分为动态测试与静态测试。</p><p>动态测试是通过运行程序发现错误，包括黑盒测试（等价类划分、边界值分析法、错误推测法）与白盒测试（各种类型的覆盖测试）。</p><p>静态测试是人工测试方式，包括桌前检查（桌面检查）、代码走查、代码审查。</p>",
                    "like": 0,
                    "answer": [
                        "C"
                    ],
                    "option": [
                        " 边界值分析、逻辑覆盖、基本路径 ",
                        " 桌面检查、逻辑覆盖、错误推测 ",
                        " 桌面检查、代码审查、代码走查 ",
                        " 错误推测、代码审查、基本路径 "
                    ]
                },
                {
                    "index": 22,
                    "belong_page": 1,
                    "question_id": 103119,
                    "question_title": "<p>图中的（ 1）是什么（）。<br/><img style=\"max-width:100%;height:auto\"  src=\"https://s2.51cto.com/images/20190622/1561194669829511.jpg\" title=\"1561194669829511.jpg\" alt=\"1.jpg\"/></p>",
                    "question_type": 1,
                    "answer_type": 1,
                    "show_type_name": null,
                    "new_parent_id": 103119,
                    "score_rule": "",
                    "material_text": null,
                    "sort_son": "0",
                    "analyze": "<p><img style=\"max-width:100%;height:auto\"  src=\"https://s2.51cto.com/images/20190622/1561194683841269.jpg\" title=\"1561194683841269.jpg\" alt=\"2.jpg\"/></p>",
                    "like": 0,
                    "answer": [
                        "A"
                    ],
                    "option": [
                        " 主块 ",
                        " 测试块 ",
                        " 表决块 ",
                        " 容错块 "
                    ]
                },
                {
                    "index": 23,
                    "belong_page": 1,
                    "question_id": 103120,
                    "question_title": "<p>图中的（2）是什么（）。<br/><img style=\"max-width:100%;height:auto\"  src=\"https://s2.51cto.com/images/20190622/1561194700833924.jpg\" title=\"1561194700833924.jpg\" alt=\"1.jpg\"/></p>",
                    "question_type": 1,
                    "answer_type": 1,
                    "show_type_name": null,
                    "new_parent_id": 103120,
                    "score_rule": "",
                    "material_text": null,
                    "sort_son": "0",
                    "analyze": "<p><img style=\"max-width:100%;height:auto\"  src=\"https://s2.51cto.com/images/20190622/1561194716660491.jpg\" title=\"1561194716660491.jpg\" alt=\"2.jpg\"/></p>",
                    "like": 0,
                    "answer": [
                        "B"
                    ],
                    "option": [
                        " 程序设计 ",
                        " 验证测试 ",
                        " 表决 ",
                        " 判断 "
                    ]
                },
                {
                    "index": 24,
                    "belong_page": 1,
                    "question_id": 103121,
                    "question_title": "<p>图中的（3）是什么（ ）。<br/><img style=\"max-width:100%;height:auto\"  src=\"https://s2.51cto.com/images/20190702/1562035644296998.png\" title=\"1562035644296998.png\" alt=\"image.png\"/><br/></p>",
                    "question_type": 1,
                    "answer_type": 1,
                    "show_type_name": null,
                    "new_parent_id": 103121,
                    "score_rule": "",
                    "material_text": null,
                    "sort_son": "0",
                    "analyze": "<p><img style=\"max-width:100%;height:auto\"  src=\"https://s2.51cto.com/images/20190622/1561194905193926.jpg\" title=\"1561194905193926.jpg\" alt=\"2.jpg\"/></p>",
                    "like": 0,
                    "answer": [
                        "A"
                    ],
                    "option": [
                        " 输出正确结果 ",
                        " 重新设计 ",
                        " 异常处理 ",
                        " 通过 "
                    ]
                },
                {
                    "index": 25,
                    "belong_page": 1,
                    "question_id": 103122,
                    "question_title": "关于集中式负载均衡的特点不正确的是",
                    "question_type": 1,
                    "answer_type": 1,
                    "show_type_name": null,
                    "new_parent_id": 103122,
                    "score_rule": "",
                    "material_text": null,
                    "sort_son": "0",
                    "analyze": "<p>与分布式负载均衡方式相比，集中式负载均衡实现简单，但也存在以下缺点：</p><p>（1）系统的可扩展性不强，均衡器需要记录所有计算机的负载信息。</p><p>（2）安全性较差，如果均衡器所在的计算机瘫痪，则会导致整个集群系统的瘫痪。</p><p>（3）实现不够灵活，负载均衡器很难根据不同脚手架的特性配置不同的均衡策略。</p>",
                    "like": 0,
                    "answer": [
                        "D"
                    ],
                    "option": [
                        " 系统的可扩展性不强，均衡器需要记录所有计算机的负载信息。 ",
                        " 安全性较差，如果均衡器所在的计算机瘫痪，则会导致整个集群系统的瘫痪。 ",
                        " 与分布式负载均衡方式相比，实现简单。 ",
                        " 实现灵活，负载均衡器可以根据不同脚手架的特性配置不同的均衡策略。 "
                    ]
                },
                {
                    "index": 26,
                    "belong_page": 1,
                    "question_id": 103123,
                    "question_title": "（）是一种静态的故障屏蔽技术，采用前向恢复的策略；N版本程序的设计思想是用N个具有相同功能的程序同时执行一项计算，结果通过多数表决来选择。",
                    "question_type": 1,
                    "answer_type": 1,
                    "show_type_name": null,
                    "new_parent_id": 103123,
                    "score_rule": "",
                    "material_text": null,
                    "sort_son": "0",
                    "analyze": "N版本程序的设计思想是用N个具有相同功能的程序同时执行一项计算，结果通过多数表决来选择。其中N个版本的程序必须由不同的人（小组）独立设计，使用不同的方法、不同的设计语言、不同的开发环境和工具来实现，目的是减少N个版本的程序在表决点上相关错误的概率。",
                    "like": 0,
                    "answer": [
                        "A"
                    ],
                    "option": [
                        " N版本程序设计 ",
                        " M模冗余 ",
                        " 恢复块方法 ",
                        " 防卫式程序设计等 "
                    ]
                },
                {
                    "index": 27,
                    "belong_page": 1,
                    "question_id": 103124,
                    "question_title": "<p>关于双机容错技术说法正确的是（）</p>",
                    "question_type": 1,
                    "answer_type": 1,
                    "show_type_name": null,
                    "new_parent_id": 103124,
                    "score_rule": "",
                    "material_text": null,
                    "sort_son": "0",
                    "analyze": "<p>（1）双机热备模式。正常情况下，一台服务器处于工作状态（主系统），另一台服务器处于监控准备状态（备用系统）。如果没有采用共享磁盘阵列，则用户数据同时往两台服务器中写入，以保证数据的即时同步。当主系统出现故障时，通过双机软件将备用系统激活，保证应用在短时间内完全恢复正常使用。当主系统修复后，可重新接入系统要回自己的应用。双机热备模式是目前采用较多的一种模式，典型应用有证券资金服务器或行情服务器等。双机热备模式的主要缺点在于，备用系统长期处于后备的状态，存在一定的计算资源浪费。</p><p>（2）双机互备模式。两台服务器均处于工作状态，为前端客户机提供各自不同的应用服务，并互相检测对方的运行情况。也就是说，两台服务器同时运行，但彼此均设为备用系统。当某一台服务器出现故障时，另一台服务器可以在短时间内将故障服务器的应用接管过来，从而保证了应用的持续性。双机互备模式的主要缺点是对服务器的性能要求比较高。</p><p>（3）双机双工模式。双机双工模式是集群（cluster）技术的一种形式，两台服务器均处于工作状态，同时为前端客户机提供相同的应用服务，以保证整体系统的性能，实现负载均衡和互为备份。</p><p>在双机容错系统中，双机软件是必不可少的。一切故障的诊断、服务的切换和硬件的控制都由双机软件来实现。为了使双机容错系统对外像一个单机系统一样，双机软件还可以为双机系统生成一个虚拟IP地址对外工作，客户机通过虚拟IP地址访问双机系统，从而避免因服务器IP地址改变导致客户机无法访问的问题。</p><p>双机软件还可以控制两台服务器对共享磁盘阵列的访问，同一时刻只能有一台服务器可以对其访问，避免了同时访问可能对数据造成的破坏。</p><p>双机软件通过侦测网卡或两台服务器之间互连的串口线，进行两台服务器的状态诊断，一旦主系统出现故障，双机软件立即激活备用系统，接管虚拟IP和共享磁盘阵列的控制权，并启动备用系统中的服务对外工作，从而保证系统的实时性和可靠性。</p>",
                    "like": 0,
                    "answer": [
                        "D"
                    ],
                    "option": [
                        " 双机互备模式的主要缺点在于，备用系统长期处于后备的状态，存在一定的计算资源浪费。 ",
                        " 双机热备模式两台服务器均处于工作状态，为前端客户机提供各自不同的应用服务，并互相检测对方的运行情况。 ",
                        " 双机双工模式两台服务器同时运行，但彼此均设为备用系统。当某一台服务器出现故障时，另一台服务器可以在短时间内将故障服务器的应用接管过来，从而保证了应用的持续性。双机双工模的主要缺点是对服务器的性能要求比较高。 ",
                        " 在双机容错系统中，双机软件是必不可少的。一切故障的诊断、服务的切换和硬件的控制都由双机软件来实现。 "
                    ]
                },
                {
                    "index": 28,
                    "belong_page": 1,
                    "question_id": 208429,
                    "question_title": "以下关于黑盒测试用例设计方法的叙述，错误的是（ ）。",
                    "question_type": 1,
                    "answer_type": 1,
                    "show_type_name": "单选题",
                    "new_parent_id": 208429,
                    "score_rule": "",
                    "material_text": "",
                    "sort_son": "0",
                    "analyze": "<p>黑盒测试也称为功能测试，主要用于集成测试，确认测试和系统测试阶段。黑盒测试根据软件需求规格说明所规定的功能来设计测试用例，一般包括功能分解、等价类划分、边界值分析、判定表、因果图、状态图、随机测试、错误推测和正交试验法等。</p><p>在设计测试用例时，等价类划分是用得最多的一种黑盒测试方法。所谓等价类就是某个输入域的集合，对每一个输入条件确定若干个有效等价类和若干个无效等价类，分别设计覆盖有效等价类和无效等价类的测试用例。无效等价类是用来测试非正常的输入数据的，所以要为每个无效等价类设计一个测试用例。</p><p>边界值分析通过选择等价类边界作为测试用例，不仅重视输入条件边界，而且也必须考虑输出域边界。在实际测试工作中，将等价类划分法和边界值分析结合使用，能更有效地发现软件中的错误。</p><p>因果图方法是从用自然语言书写的程序规格说明的描述中找出因(输入条件)和果(输出或程序状态的改变)，可以通过因果图转换为判定表。</p><p>正交试验设计法，就是使用已经造好了的正交表格来安排试验并进行数据分析的一种方法，目的是用最少的测试用例达到最高的测试覆盖率。<span style=\"font-size: 16px;\"></span></p>",
                    "like": 0,
                    "answer": [
                        "D"
                    ],
                    "option": [
                        " 边界值分析通过选择等价类边界作为测试用例，不仅重视输入条件边界，而且也必须考虑输出域边界 ",
                        " 因果图方法是从用自然语言书写的程序规格说明的描述中找出因(输入条件)和果(输出或程序状态的改变)，可以通过因果图转换为判定表 ",
                        " 正交试验设计法，就是使用已经造好了的正交表格来安排试验并进行数据分析的一种方法，目的是用最少的测试用例达到最高的测试覆盖率 ",
                        " 等价类划分法根据软件的功能说明，对每一个输入条件确定若干个有效等价类和无效等价类，但只能为有效等价类设计测试用例 "
                    ]
                },
                {
                    "index": 29,
                    "belong_page": 1,
                    "question_id": 208430,
                    "question_title": "以下关于软件测试工具的叙述，错误的是（ ）。",
                    "question_type": 1,
                    "answer_type": 1,
                    "show_type_name": "单选题",
                    "new_parent_id": 208430,
                    "score_rule": "",
                    "material_text": "",
                    "sort_son": "0",
                    "analyze": "测试工具根据工作原理不同可分为静态测试工具和动态测试工具。其中静态测试工具是对代码进行语法扫描，找到不符合编码规范的地方，根据某种质量模型评价代码的质量，生成系统的调用关系图等。它直接对代码进行分析，不需要运行代码，也不需要对代码编译链接和生成可执行文件，静态测试工具可用于对软件需求、结构设计、详细设计和代码进行评审、走审和审查，也可用于对软件的复杂度分析、数据流分析、控制流分析和接口分析提供支持；动态测试工具与静态测试工具不同，它需要运行被测试系统，并设置探针，向代码生成的可执行文件中插入检测代码，可用于软件的覆盖分析和性能分析，也可用于软件的模拟、建模、仿真测试和变异测试等。",
                    "like": 0,
                    "answer": [
                        "D"
                    ],
                    "option": [
                        " 静态测试工具可用于对软件需求、结构设计、详细设计和代码进行评审、走查和审查 ",
                        " 静态测试工具可对软件的复杂度分析、数据流分析、控制流分析和接口分析提供支持 ",
                        " 动态测试工具可用于软件的覆盖分析和性能分析 ",
                        " 动态测试工具不支持软件的仿真测试和变异测试 "
                    ]
                },
                {
                    "index": 30,
                    "belong_page": 1,
                    "question_id": 208496,
                    "question_title": "遗留系统的演化可以采用淘汰、继承、改造和集成四种策略。若企业中的遗留系统技术含量较高，业务价值较低，在局部领域中工作良好，形成了一个个信息孤岛时，适合于采用（ ）演化策略。",
                    "question_type": 1,
                    "answer_type": 1,
                    "show_type_name": "单选题",
                    "new_parent_id": 208496,
                    "score_rule": "",
                    "material_text": "",
                    "sort_son": "0",
                    "analyze": "<p>遗留系统的演化可以采用淘汰、继承、改造和集成四种策略。</p><p>淘汰策略适用于技术含量较低，且具有较低的业务价值的遗留系统，即通过全面重新开发新的系统以代替遗留系统。</p><p>若遗留系统的技术含量较低，能满足企业运作的功能或性能要求，但具有较高的商业机制，目前企业的业务上紧密依赖该系统，这种遗留系统的演化策略为继承。在开发新系统时，需要完全兼容遗留系统的功能模型和数据模型。为了保证业务的连续性，新老系统必须并行运行一段时间。</p><p>对于技术含量较高，本身还有极大的生命力，又具有较高的业务价值，基本上能够满足企业业务运作和决策支持需要的遗留系统，采用改造策略进行演化。改造包括系统功能的增强和数据模型的改造两个方面。</p><p>遗留系统的技术含量较高，但其业务价值较低，可能只完成某个部门(或子公司)的业务管理。这种系统在各自局部领域里工作良好，但对于整个企业来说，存在多个这样的系统，不同的系统基于不同的平台、不同的数据模型，形成了一个个信息孤岛。对于这种遗留系统的演化策略为集成。</p>",
                    "like": 0,
                    "answer": [
                        "D"
                    ],
                    "option": [
                        " 淘汰 ",
                        " 继承 ",
                        " 改造 ",
                        " 集成 "
                    ]
                },
                {
                    "index": 31,
                    "belong_page": 1,
                    "question_id": 208497,
                    "question_title": "逆向工程导出的信息可以分为实现级、结构级、功能级和领域级四个抽象层次。程序的抽象语法树属于（请作答此空）；反映程序分量之间相互依赖关系的信息属于（ ）。",
                    "question_type": 1,
                    "answer_type": 1,
                    "show_type_name": "单选题",
                    "new_parent_id": 208497,
                    "score_rule": "",
                    "material_text": "",
                    "sort_son": "0",
                    "analyze": "<p>逆向工程与重构工程是目前预防性维护采用的主要技术。所谓软件的逆向工程就是分析已有的程序，寻求比源代码更高级的抽象表现形式。一般认为，凡是在软件生命周期内将软件某种形式的描述转换成更为抽象形式的活动都可称为逆向工程。逆向工程导出的信息可以分为如下4个抽象层次。</p><p>①实现级：包括程序的抽象语法树、符号表等信息。</p><p>②结构级：包括反映程序分量之间相互依赖关系的信息，例如调用图、结构图等。</p><p>③功能级：包括反映程序段功能及程序段之间关系的信息。</p><p>④领域级：包括反映程序分量或程序诸实体与应用领域概念之间对应关系的信息。</p><p>显然，上述信息的抽象级别越高，它与代码的距离就越远，通过逆向工程恢复的难度亦越大，而自动工具支持的可能性相对变小，要求人参与判断和推理的工作增多。</p>",
                    "like": 0,
                    "answer": [
                        "A"
                    ],
                    "option": [
                        " 实现级 ",
                        " 结构级 ",
                        " 功能级 ",
                        " 领域级 "
                    ]
                },
                {
                    "index": 32,
                    "belong_page": 1,
                    "question_id": 208498,
                    "question_title": "逆向工程导出的信息可以分为实现级、结构级、功能级和领域级四个抽象层次。程序的抽象语法树属于（ ）；反映程序分量之间相互依赖关系的信息属于（请作答此空）。",
                    "question_type": 1,
                    "answer_type": 1,
                    "show_type_name": "单选题",
                    "new_parent_id": 208498,
                    "score_rule": "",
                    "material_text": "",
                    "sort_son": "0",
                    "analyze": "<p>逆向工程与重构工程是目前预防性维护采用的主要技术。所谓软件的逆向工程就是分析已有的程序，寻求比源代码更高级的抽象表现形式。一般认为，凡是在软件生命周期内将软件某种形式的描述转换成更为抽象形式的活动都可称为逆向工程。逆向工程导出的信息可以分为如下4个抽象层次。</p><p>①实现级：包括程序的抽象语法树、符号表等信息。</p><p>②结构级：包括反映程序分量之间相互依赖关系的信息，例如调用图、结构图等。</p><p>③功能级：包括反映程序段功能及程序段之间关系的信息。</p><p>④领域级：包括反映程序分量或程序诸实体与应用领域概念之间对应关系的信息。</p><p>显然，上述信息的抽象级别越高，它与代码的距离就越远，通过逆向工程恢复的难度亦越大，而自动工具支持的可能性相对变小，要求人参与判断和推理的工作增多。</p>",
                    "like": 0,
                    "answer": [
                        "B"
                    ],
                    "option": [
                        " 实现级 ",
                        " 结构级 ",
                        " 功能级 ",
                        " 领域级 "
                    ]
                },
                {
                    "index": 33,
                    "belong_page": 1,
                    "question_id": 208506,
                    "question_title": "以下关于白盒测试方法的叙述中，错误的是（ ）。",
                    "question_type": 1,
                    "answer_type": 1,
                    "show_type_name": "单选题",
                    "new_parent_id": 208506,
                    "score_rule": "",
                    "material_text": "",
                    "sort_son": "0",
                    "analyze": "<p>白盒测试也称为结构测试，主要用于软件单元测试阶段，测试人员按照程序内部逻辑结构设计测试用例，检测程序中的主要执行通路是否都能按预定要求正确工作。白盒测试方法主要有控制流测试、数据流测试和程序变异测试等。</p><p>控制流测试根据程序的内部逻辑结构设计测试用例，常用的技术是逻辑覆盖。主要的覆盖标准有语句覆盖、判定覆盖、条件覆盖、条件/判定覆盖、条件组合覆盖、修正的条件/判定覆盖和路径覆盖等。</p><p>语句覆盖是指选择足够多的测试用例，使得运行这些测试用例时，被测程序的每个语句至少执行一次。</p><p>判定覆盖也称为分支覆盖，它是指不仅每个语句至少执行一次，而且每个判定的每种可能的结果(分支)都至少执行一次。</p><p>条件覆盖是指不仅每个语句至少执行一次，而且使判定表达式中的每个条件都取得各种可能的结果。</p><p>条件/判定覆盖同时满足判定覆盖和条件覆盖。它的含义是选取足够的测试用例，使得判定表达式中每个条件的所有可能结果至少出现一次，而且每个判定本身的所有可能结果也至少出现一次。</p><p>条件组合覆盖是指选取足够的测试用例，使得每个判定表达式中条件结果的所有可能组合至少出现一次。</p><p>修正的条件/判定覆盖。需要足够的测试用例来确定各个条件能够影响到包含的判定结果。</p><p>路径覆盖是指选取足够的测试用例，使得程序的每条可能执行到的路径都至少经过一次(如果程序中有环路，则要求每条环路路径至少经过一次)。</p>",
                    "like": 0,
                    "answer": [
                        "D"
                    ],
                    "option": [
                        " 语句覆盖要求设计足够多的测试用例，使程序中每条语句至少被执行一次 ",
                        " 与判定覆盖相比，条件覆盖增加对符合判定情况的测试，增加了测试路径 ",
                        " 判定/条件覆盖准则的缺点是未考虑条件的组合情况 ",
                        " 组合覆盖要求设计足够多的测试用例，使得每个判定中条件结果的所有可能组合最多出现一次 "
                    ]
                },
                {
                    "index": 34,
                    "belong_page": 1,
                    "question_id": 208507,
                    "question_title": "以下关于面向对象软件测试的叙述中，正确的是（ ）。",
                    "question_type": 1,
                    "answer_type": 1,
                    "show_type_name": "单选题",
                    "new_parent_id": 208507,
                    "score_rule": "",
                    "material_text": "",
                    "sort_son": "0",
                    "analyze": "<p>面向对象系统的测试目标与传统信息系统的测试目标是一致的，但面向对象系统的测试策略与传统结构化系统的测试策略有很大的不同，这主要体现在两个方面，分别是测试的焦点从模块移向了类，以及测试的视角扩大到了分析和设计模型。</p><p>与传统的结构化系统相比，面向对象系统具有三个明显特征，即封装性、继承性与多态性。封装性决定了面向对象系统的测试必须考虑到信息隐蔽原则对测试的影响，以及对象状态与类的测试序列，因此在测试一个类时，仅对该类的每个方法进行测试是不够的；继承性决定了面向对象系统的测试必须考虑到继承对测试充分性的影响，以及误用引起的错误；多态性决定了面向对象系统的测试必须考虑到动态绑定对测试充分性的影响、抽象类的测试以及误用对测试的影响。</p>",
                    "like": 0,
                    "answer": [
                        "B"
                    ],
                    "option": [
                        " 在测试一个类时，只要对该类的每个成员方法都进行充分的测试就完成了对该类充分的测试 ",
                        " 存在多态的情况下，为了达到较高的测试充分性，应对所有可能的绑定都进行测试 ",
                        " 假设类B是类A的子类，如果类A已经进行了充分的测试，那么在测试类B时不必测试任何类B继承自类A的成员方法 ",
                        " 对于一棵继承树上的多个类，只有处于叶子节点的类需要测试 "
                    ]
                },
                {
                    "index": 35,
                    "belong_page": 1,
                    "question_id": 310846,
                    "question_title": "为了适应软件运行环境的变化而修改软件的活动称为（17）；根据用户在软件使用过程中提出的建设性意见而进行的维护活动称为（18）。",
                    "question_type": 9,
                    "answer_type": 1,
                    "show_type_name": "单选题",
                    "new_parent_id": 310845,
                    "score_rule": "",
                    "material_text": null,
                    "sort_son": "1",
                    "analyze": "<p>软件维护的类型有4种：改正性维护、适应性维护、完善性维护和预防性维护。</p><p>其中，改正性维护是要改正在特定的使用条件下暴露出来的一些潜在程序错误或设计缺陷；</p><p>适应性维护是要在软件使用过程中数据环境发生变化或处理环境发生变化时修改软件以适应这种变化；</p><p>完善性维护是在用户和数据处理人员使用软件过程中提出改进现有功能，增加新的功能，以及改善总体性能的要求后，修改软件以把这些要求纳入到软件之中；</p><p>预防性维护是为了提高软件的可维护性、可靠性等，事先采用先进的软件工程方法对需要维护的软件或软件中的某一部分（重新）进行设计、编制和测试，为以后进一步改进软件打下良好基础。</p>",
                    "like": 0,
                    "answer": [
                        "B"
                    ],
                    "option": [
                        "纠错性维护",
                        "适应性维护",
                        "改善性维护",
                        "预防性维护"
                    ]
                },
                {
                    "index": 36,
                    "belong_page": 1,
                    "question_id": 310847,
                    "question_title": "为了适应软件运行环境的变化而修改软件的活动称为（17）；根据用户在软件使用过程中提出的建设性意见而进行的维护活动称为（18）。",
                    "question_type": 9,
                    "answer_type": 1,
                    "show_type_name": "单选题",
                    "new_parent_id": 310845,
                    "score_rule": "",
                    "material_text": null,
                    "sort_son": "2",
                    "analyze": "<p>软件维护的类型有4种：改正性维护、适应性维护、完善性维护和预防性维护。</p><p>其中，改正性维护是要改正在特定的使用条件下暴露出来的一些潜在程序错误或设计缺陷；</p><p>适应性维护是要在软件使用过程中数据环境发生变化或处理环境发生变化时修改软件以适应这种变化；</p><p>完善性维护是在用户和数据处理人员使用软件过程中提出改进现有功能，增加新的功能，以及改善总体性能的要求后，修改软件以把这些要求纳入到软件之中；</p><p>预防性维护是为了提高软件的可维护性、可靠性等，事先采用先进的软件工程方法对需要维护的软件或软件中的某一部分（重新）进行设计、编制和测试，为以后进一步改进软件打下良好基础。</p>",
                    "like": 0,
                    "answer": [
                        "C"
                    ],
                    "option": [
                        "适应性维护",
                        "纠错性维护",
                        "改善性维护",
                        "预防性维护"
                    ]
                },
                {
                    "index": 37,
                    "belong_page": 1,
                    "question_id": 315931,
                    "question_title": "<p>在软件开发和维护过程中,一个软件会有多个版本,(29)工具用来存储、更新、恢复和管理一个软件的多个版本</p>",
                    "question_type": 1,
                    "answer_type": 1,
                    "show_type_name": "单选题",
                    "new_parent_id": 315931,
                    "score_rule": "",
                    "material_text": "",
                    "sort_son": "0",
                    "analyze": "<p>在软件开发和维护过程中一个软件会有多个版本，版本控制工具用来存储、更新、 恢复和管理一个软件的多个版本。</p>",
                    "like": 0,
                    "answer": [
                        "B"
                    ],
                    "option": [
                        "软件测试",
                        "版本控制",
                        "UML建模",
                        "逆向工程"
                    ]
                },
                {
                    "index": 38,
                    "belong_page": 1,
                    "question_id": 315948,
                    "question_title": "<p>软件测试是保障软件质量的重要手段。(42) 是指被测试程序不在机器上运行，而采用人工监测和计算机辅助分析的手段对程序进行监测。(43) 也称为功能测试，不考虑程序的内部结构和处理算法，只检查软件功能是否能按照要求正常使用。</p>",
                    "question_type": 9,
                    "answer_type": 1,
                    "show_type_name": "单选题",
                    "new_parent_id": 315947,
                    "score_rule": "",
                    "material_text": null,
                    "sort_son": "1",
                    "analyze": "<p>静态测试是指被测试程序不在机器上运行，而采用人工检测和计算机辅助静态分析的手段对程序进行检测。</p><p>动态测试是通过运行程序发现错误。动态测试可以采用黑盒测试和白盒测试。</p><p>白盒测试也称为结构测试，要根据程序内部逻辑结构设计测试用例，检测程序中的主要执行通路是否都能按预定要求正确工作。主要用于软件单元测试阶段。</p><p>黑盒测试也称为功能测试，不考虑程序的内部结构和处理算法，只检查软件功能是否能按照要求正常使用。主要用于集成测试、确认测试和系统测试阶段。</p>",
                    "like": 0,
                    "answer": [
                        "A"
                    ],
                    "option": [
                        "静态测试",
                        "动态测试",
                        "黑盒测试",
                        "白盒测试"
                    ]
                },
                {
                    "index": 39,
                    "belong_page": 1,
                    "question_id": 315949,
                    "question_title": "<p>软件测试是保障软件质量的重要手段。(42) 是指被测试程序不在机器上运行，而采用人工监测和计算机辅助分析的手段对程序进行监测。(43) 也称为功能测试，不考虑程序的内部结构和处理算法，只检查软件功能是否能按照要求正常使用。</p>",
                    "question_type": 9,
                    "answer_type": 1,
                    "show_type_name": "单选题",
                    "new_parent_id": 315947,
                    "score_rule": "",
                    "material_text": null,
                    "sort_son": "2",
                    "analyze": "<p>静态测试是指被测试程序不在机器上运行，而采用人工检测和计算机辅助静态分析的手段对程序进行检测。</p><p>动态测试是通过运行程序发现错误。动态测试可以采用黑盒测试和白盒测试。</p><p>白盒测试也称为结构测试，要根据程序内部逻辑结构设计测试用例，检测程序中的主要执行通路是否都能按预定要求正确工作。主要用于软件单元测试阶段。</p><p>黑盒测试也称为功能测试，不考虑程序的内部结构和处理算法，只检查软件功能是否能按照要求正常使用。主要用于集成测试、确认测试和系统测试阶段。</p>",
                    "like": 0,
                    "answer": [
                        "C"
                    ],
                    "option": [
                        "系统测试",
                        "集成测试",
                        "黑盒测试",
                        "自众测试"
                    ]
                },
                {
                    "index": 40,
                    "belong_page": 1,
                    "question_id": 350333,
                    "question_title": "<p>面向对象系统的单元测试包括方法层次的测试、类层次的测试和类树层次的测试。在常见的测试技术中，&nbsp;（42） 属于方法层次的测试，&nbsp;（43） 属于类层次的测试。</p>",
                    "question_type": 9,
                    "answer_type": 1,
                    "show_type_name": "单选题",
                    "new_parent_id": 350332,
                    "score_rule": "",
                    "material_text": null,
                    "sort_son": "1",
                    "analyze": "<p>本题考查面向对象系统测试的基本概念。</p><p>面向对象系统的单元测试包括方法层次的测试、类层次的测试和类树层次的测试。</p><p>（1）方法层次的测试类似于传统软件测试中对单个函数的测试，常用的测试技术包括等价类划分测试、组合功能测试、递归函数测试和多态消息测试等。</p><p>（2）类层次的测试主要包括不变式边界测试、模态类测试和非模态类测试。</p><p>（3）类树层次的测试主要包括多态服务测试和展平测试。</p>",
                    "like": 0,
                    "answer": [
                        "A"
                    ],
                    "option": [
                        " 等价类划分测试和多态消息测试 ",
                        " 不变式边界测试和递归函数测试 ",
                        " 组合功能测试和非模态类测试 ",
                        " 不变式边界测试和模态类测试 "
                    ]
                },
                {
                    "index": 41,
                    "belong_page": 1,
                    "question_id": 350334,
                    "question_title": "<p>面向对象系统的单元测试包括方法层次的测试、类层次的测试和类树层次的测试。在常见的测试技术中，&nbsp;（42） 属于方法层次的测试，&nbsp;（43） 属于类层次的测试。</p>",
                    "question_type": 9,
                    "answer_type": 1,
                    "show_type_name": "单选题",
                    "new_parent_id": 350332,
                    "score_rule": "",
                    "material_text": null,
                    "sort_son": "2",
                    "analyze": "<p>本题考查面向对象系统测试的基本概念。</p><p>面向对象系统的单元测试包括方法层次的测试、类层次的测试和类树层次的测试。</p><p>（1）方法层次的测试类似于传统软件测试中对单个函数的测试，常用的测试技术包括等价类划分测试、组合功能测试、递归函数测试和多态消息测试等。</p><p>（2）类层次的测试主要包括不变式边界测试、模态类测试和非模态类测试。</p><p>（3）类树层次的测试主要包括多态服务测试和展平测试。</p>",
                    "like": 0,
                    "answer": [
                        "D"
                    ],
                    "option": [
                        " 等价类划分测试和多态消息测试&nbsp; ",
                        " 不变式边界测试和递归函数测试 ",
                        " 组合功能测试和非模态类测试 ",
                        " 不变式边界测试和模态类测试 "
                    ]
                },
                {
                    "index": 42,
                    "belong_page": 1,
                    "question_id": 352295,
                    "question_title": "<p>&nbsp;以下关于面向对象软件测试的叙述中， 正确的是&nbsp;（43） 。</p>",
                    "question_type": 1,
                    "answer_type": 1,
                    "show_type_name": "单选题",
                    "new_parent_id": 352295,
                    "score_rule": "",
                    "material_text": "",
                    "sort_son": "0",
                    "analyze": "<p>面向对象系统的测试目标与传统信息系统的测试目标是一致的， 但面向对象系统的测试 策略与传统结构化信息系统的测试策略有很大的不同。这主要体现在两个方面，分别是测试 的焦点从模块移向类，以及测试的视角扩大到了分析和设计模型。</p><p>与传统的结构化信息系统相比，面向对象系统具有 3 个明显特征，即封装性、继承性与 多态性。封装性决定了面向对象系统的测试必须考虑信息隐蔽原则对测试的影响， 以及对象 状态与类的测试序列。因此在测试一个类时，仅对该类的每个方法进行测试是不够的； 继承性决定了面向对象系统的测试必须考虑继承对测试充分性的影响，以及误用引起的错误；多态性决定了面向对象系统的测试必须考虑动态绑定、抽象类的测试，以及误用对测试的影响。</p>",
                    "like": 0,
                    "answer": [
                        "D"
                    ],
                    "option": [
                        " 在测试一个类时，只要对该类的每个成员方法都进行充分的测试就完成了对 该类的充分测试 ",
                        " 存在多态的情况下，为了达到较高的测试效率， 不用对所有可能的绑定都进行测试 ",
                        " 假设类 B 是类 A 的子类， 如果类 A 已经进行了充分的测试，那么在测试类 B 时不必测试任何类 B 继承自类 A 的成员方法 ",
                        " 对于一棵继承树上的多个类，必须考虑继承对测试充分性的影响 "
                    ]
                },
                {
                    "index": 43,
                    "belong_page": 1,
                    "question_id": 352296,
                    "question_title": "<p>&nbsp;在静态测试中，主要是对程序代码进行静态分析， &nbsp;“引用未定义的变量、对以前未使用的变量再次赋值等”属于静态分析中的&nbsp;（44） 。</p>",
                    "question_type": 1,
                    "answer_type": 1,
                    "show_type_name": "单选题",
                    "new_parent_id": 352296,
                    "score_rule": "",
                    "material_text": "",
                    "sort_son": "0",
                    "analyze": "<p>静态测试是指被测试程序不在机器上运行，而采用人工检测和计算机辅助静态分析的手 段对程序进行检测，包括对文档和代码的静态测试， 对代码的静态测试包括控制流分析、数 据流分析、接口分析和表达式分析。</p><p>(1) 控制流分析：指使用控制流程图检查被测程序控制结构的过程，如检查被测程序是 否存在没有使用的语句或子程序、是否调用并不存在的子程序， 以及是否存在无法达到的语 句等。</p><p>(2) &nbsp;数据流分析： 指使用控制流程图分析数据各种异常情况的过程，包括数据初始化、 赋值或引用过程中的异常。例如，引用未定义的变量、对以前未使用的变量再次赋值等程序 差错或异常情况。</p><p>(3) 接口分析：主要包括模块之间接口的一致性分析、模块与外部数据库及其他软件配 置项之间的一致性分析、子程序和函数之间的接口一致性分析等。例如，可以检查函数形参 与实现的数量、顺序、类型和使用的一致性。</p><p>(4) &nbsp;表达式分析： 用于检查程序代码中的表达式错误，如括号不配对、数组引用越界、除数为零，以及浮点数变量比较时的误差等错误。</p>",
                    "like": 0,
                    "answer": [
                        "B"
                    ],
                    "option": [
                        " 控制流分析 ",
                        " 数据流分析 ",
                        " 接口分析 ",
                        " 表达式分析 "
                    ]
                },
                {
                    "index": 44,
                    "belong_page": 1,
                    "question_id": 356228,
                    "question_title": "<p>在白盒测试中，测试强度最高的是（40）</p>",
                    "question_type": 1,
                    "answer_type": 1,
                    "show_type_name": "单选题",
                    "new_parent_id": 356228,
                    "score_rule": "",
                    "material_text": "",
                    "sort_son": "0",
                    "analyze": "<p>路径覆盖实际上考虑了程序中各种判定结果的所有可能组合，因此是一种较强的覆盖标准。</p>",
                    "like": 0,
                    "answer": [
                        "D"
                    ],
                    "option": [
                        " 语句覆盖 ",
                        " 分支覆盖 ",
                        " 判定覆盖 ",
                        " 路径覆盖 "
                    ]
                },
                {
                    "index": 45,
                    "belong_page": 1,
                    "question_id": 356229,
                    "question_title": "<p>在黑盒测试中，（41）方法最适合描述在多个逻辑条件取值组合所构成的复杂情况下，分别要执行哪些不同的动作。</p>",
                    "question_type": 1,
                    "answer_type": 1,
                    "show_type_name": "单选题",
                    "new_parent_id": 356229,
                    "score_rule": "",
                    "material_text": "",
                    "sort_son": "0",
                    "analyze": "<p>详见系分教程原文14.3.3，判定表最适合描述在多个逻辑条件取值的组合所构成的复杂情况下，分别要执行哪些不同的动作。</p>",
                    "like": 0,
                    "answer": [
                        "C"
                    ],
                    "option": [
                        " 等价类 ",
                        " 边界类 ",
                        " 判定表 ",
                        " 因果图 "
                    ]
                },
                {
                    "index": 46,
                    "belong_page": 1,
                    "question_id": 356230,
                    "question_title": "<p>（42）的目的是测试软件变更之后，变更部分的正确性和对变更需求的符合性，以及软件原有的、正确的功能、性能和其它规定的要求的不损害性。</p>",
                    "question_type": 1,
                    "answer_type": 1,
                    "show_type_name": "单选题",
                    "new_parent_id": 356230,
                    "score_rule": "",
                    "material_text": "",
                    "sort_son": "0",
                    "analyze": "<p>详见系分教程原文14.4.4，回归测试的目的是测试软件变更之后，变更部分的正确性和对变更需求的符合性，以及软件原有的、正确的功能、性能和其他规定的要求的不损害性。</p>",
                    "like": 0,
                    "answer": [
                        "D"
                    ],
                    "option": [
                        " 验收测试 ",
                        " Alpha测试 ",
                        " Beta测试 ",
                        " 回归测试 "
                    ]
                },
                {
                    "index": 47,
                    "belong_page": 1,
                    "question_id": 356231,
                    "question_title": "<p>在对遗留系统进行评估时，对于技术含量较高、业务价值较低且仅能完成某个部门的业务管理的遗留系统，一般采用的遗留系统演化策略是（43）策略。</p>",
                    "question_type": 1,
                    "answer_type": 1,
                    "show_type_name": "单选题",
                    "new_parent_id": 356231,
                    "score_rule": "",
                    "material_text": "",
                    "sort_son": "0",
                    "analyze": "<p>详见系分教程15.1.2&nbsp;遗留系统的演化策略。</p><p><img style=\"max-width:100%;height:auto\"  width=\"266\" height=\"234\" src=\"https://static2.51cto.com/edu/exam/ueditor1.4.3/themes/default/images/spacer.gif\"/></p>",
                    "like": 0,
                    "answer": [
                        "C"
                    ],
                    "option": [
                        " 淘汰 ",
                        " 继承 ",
                        " 集成 ",
                        " 改造 "
                    ]
                },
                {
                    "index": 48,
                    "belong_page": 1,
                    "question_id": 348854,
                    "question_title": "1、某公司欲开发一个大型多人即时战略游戏，游戏设计的目标之一是能够支持玩家自行创建战役地图，定义游戏对象的行为和对象之间的关系。针对该需求，在层次风格、解释器风格、黑板和事件驱动风中公司应该采用什么架构风格最为合适？<br/><br/>2、在基于体系结构的软件设计方法中，采用什么来描述软件架构？<br/><br/>3、哪种视图能解决并发性、分布性等问题？<br/><br/>4、某公司欲开发一个在线教育平台。在架构设计阶段，公司的架构师识别出3&nbsp;个核心质量<br/>属性场景。其中“网站在并发用户数量10&nbsp;万的负载情况下，用户请求的平均响应时间应小<br/>于3&nbsp;秒”这一场景主要与什么质量属性相关？<br/><br/>5、ABSDM模型把整个基于体系结构的软件过程划分为体系结构需求、设计、文档化、复审、实现和什么等6个子过程？<br/><br/>",
                    "question_type": 5,
                    "answer_type": 5,
                    "show_type_name": "问答题",
                    "new_parent_id": 348854,
                    "score_rule": "",
                    "material_text": "",
                    "sort_son": "0",
                    "analyze": "详见答案",
                    "like": 0,
                    "answer": [
                        "1、某公司欲开发一个大型多人即时战略游戏，游戏设计的目标之一是能够支持玩家自行创建战役地图，定义游戏对象的行为和对象之间的关系。针对该需求，在层次风格、解释器风格、黑板和事件驱动风中公司应该采用什么架构风格最为合适？<br/>答：解释器风格<br/>2、在基于体系结构的软件设计方法中，采用什么来描述软件架构？<br/>答：采用视角与视图来描述软件架构<br/>3、哪种视图能解决并发性、分布性等问题？<br/>答：&nbsp;进程视图<br/>4、某公司欲开发一个在线教育平台。在架构设计阶段，公司的架构师识别出3&nbsp;个核心质量<br/>属性场景。其中“网站在并发用户数量10&nbsp;万的负载情况下，用户请求的平均响应时间应小<br/>于3&nbsp;秒”这一场景主要与什么质量属性相关？<br/>答：性能<br/>5、ABSDM模型把整个基于体系结构的软件过程划分为体系结构需求、设计、文档化、复审、实现和什么等6个子过程？<br/>答：体系结构演化"
                    ],
                    "option": ""
                }
            ],
            "total_question": 48,
            "summary": {
                "radio": {
                    "total_question": 47,
                    "total_score": 0
                },
                "multiple": {
                    "total_question": 0,
                    "total_score": 0
                },
                "fill": {
                    "total_question": 0,
                    "total_score": 0
                },
                "program": {
                    "total_question": 0,
                    "total_score": 0
                },
                "qanda": {
                    "total_question": 1,
                    "total_score": 0
                },
                "cloze": {
                    "total_question": 0,
                    "total_score": 0
                },
                "budingxiang": {
                    "total_question": 0,
                    "total_score": 0
                },
                "material": {
                    "total_question": 0,
                    "total_score": 0
                }
            },
            "title": "系统测试与运行维护"
        },
        "pagination": {
            "curPage": 1,
            "pageSize": 1000,
            "total": 48,
            "hasNextPage": false
        },
        "totalOrder": [
            {
                "index": 1,
                "question_type": "1",
                "belong_page": 1,
                "question_id": "43752",
                "answer_type": 1
            },
            {
                "index": 2,
                "question_type": "1",
                "belong_page": 1,
                "question_id": "43773",
                "answer_type": 1
            },
            {
                "index": 3,
                "question_type": "1",
                "belong_page": 1,
                "question_id": "43774",
                "answer_type": 1
            },
            {
                "index": 4,
                "question_type": "1",
                "belong_page": 1,
                "question_id": "43873",
                "answer_type": 1
            },
            {
                "index": 5,
                "question_type": "1",
                "belong_page": 1,
                "question_id": "46953",
                "answer_type": 1
            },
            {
                "index": 6,
                "question_type": "1",
                "belong_page": 1,
                "question_id": "46954",
                "answer_type": 1
            },
            {
                "index": 7,
                "question_type": "1",
                "belong_page": 1,
                "question_id": "49864",
                "answer_type": 1
            },
            {
                "index": 8,
                "question_type": "1",
                "belong_page": 1,
                "question_id": "49865",
                "answer_type": 1
            },
            {
                "index": 9,
                "question_type": "1",
                "belong_page": 1,
                "question_id": "49866",
                "answer_type": 1
            },
            {
                "index": 10,
                "question_type": "1",
                "belong_page": 1,
                "question_id": "49914",
                "answer_type": 1
            },
            {
                "index": 11,
                "question_type": "1",
                "belong_page": 1,
                "question_id": "49940",
                "answer_type": 1
            },
            {
                "index": 12,
                "question_type": "1",
                "belong_page": 1,
                "question_id": "49941",
                "answer_type": 1
            },
            {
                "index": 13,
                "question_type": "1",
                "belong_page": 1,
                "question_id": "49945",
                "answer_type": 1
            },
            {
                "index": 14,
                "question_type": "1",
                "belong_page": 1,
                "question_id": "50899",
                "answer_type": 1
            },
            {
                "index": 15,
                "question_type": "1",
                "belong_page": 1,
                "question_id": "50907",
                "answer_type": 1
            },
            {
                "index": 16,
                "question_type": "1",
                "belong_page": 1,
                "question_id": "54204",
                "answer_type": 1
            },
            {
                "index": 17,
                "question_type": "1",
                "belong_page": 1,
                "question_id": "54224",
                "answer_type": 1
            },
            {
                "index": 18,
                "question_type": "1",
                "belong_page": 1,
                "question_id": "54234",
                "answer_type": 1
            },
            {
                "index": 19,
                "question_type": "1",
                "belong_page": 1,
                "question_id": "54325",
                "answer_type": 1
            },
            {
                "index": 20,
                "question_type": "1",
                "belong_page": 1,
                "question_id": "63650",
                "answer_type": 1
            },
            {
                "index": 21,
                "question_type": "1",
                "belong_page": 1,
                "question_id": "63652",
                "answer_type": 1
            },
            {
                "index": 22,
                "question_type": "1",
                "belong_page": 1,
                "question_id": "103119",
                "answer_type": 1
            },
            {
                "index": 23,
                "question_type": "1",
                "belong_page": 1,
                "question_id": "103120",
                "answer_type": 1
            },
            {
                "index": 24,
                "question_type": "1",
                "belong_page": 1,
                "question_id": "103121",
                "answer_type": 1
            },
            {
                "index": 25,
                "question_type": "1",
                "belong_page": 1,
                "question_id": "103122",
                "answer_type": 1
            },
            {
                "index": 26,
                "question_type": "1",
                "belong_page": 1,
                "question_id": "103123",
                "answer_type": 1
            },
            {
                "index": 27,
                "question_type": "1",
                "belong_page": 1,
                "question_id": "103124",
                "answer_type": 1
            },
            {
                "index": 28,
                "question_type": "1",
                "belong_page": 1,
                "question_id": "208429",
                "answer_type": 1
            },
            {
                "index": 29,
                "question_type": "1",
                "belong_page": 1,
                "question_id": "208430",
                "answer_type": 1
            },
            {
                "index": 30,
                "question_type": "1",
                "belong_page": 1,
                "question_id": "208496",
                "answer_type": 1
            },
            {
                "index": 31,
                "question_type": "1",
                "belong_page": 1,
                "question_id": "208497",
                "answer_type": 1
            },
            {
                "index": 32,
                "question_type": "1",
                "belong_page": 1,
                "question_id": "208498",
                "answer_type": 1
            },
            {
                "index": 33,
                "question_type": "1",
                "belong_page": 1,
                "question_id": "208506",
                "answer_type": 1
            },
            {
                "index": 34,
                "question_type": "1",
                "belong_page": 1,
                "question_id": "208507",
                "answer_type": 1
            },
            {
                "index": 35,
                "question_type": "9",
                "belong_page": 1,
                "question_id": "310846",
                "answer_type": 1
            },
            {
                "index": 36,
                "question_type": "9",
                "belong_page": 1,
                "question_id": "310847",
                "answer_type": 1
            },
            {
                "index": 37,
                "question_type": "1",
                "belong_page": 1,
                "question_id": "315931",
                "answer_type": 1
            },
            {
                "index": 38,
                "question_type": "9",
                "belong_page": 1,
                "question_id": "315948",
                "answer_type": 1
            },
            {
                "index": 39,
                "question_type": "9",
                "belong_page": 1,
                "question_id": "315949",
                "answer_type": 1
            },
            {
                "index": 40,
                "question_type": "9",
                "belong_page": 1,
                "question_id": "350333",
                "answer_type": 1
            },
            {
                "index": 41,
                "question_type": "9",
                "belong_page": 1,
                "question_id": "350334",
                "answer_type": 1
            },
            {
                "index": 42,
                "question_type": "1",
                "belong_page": 1,
                "question_id": "352295",
                "answer_type": 1
            },
            {
                "index": 43,
                "question_type": "1",
                "belong_page": 1,
                "question_id": "352296",
                "answer_type": 1
            },
            {
                "index": 44,
                "question_type": "1",
                "belong_page": 1,
                "question_id": "356228",
                "answer_type": 1
            },
            {
                "index": 45,
                "question_type": "1",
                "belong_page": 1,
                "question_id": "356229",
                "answer_type": 1
            },
            {
                "index": 46,
                "question_type": "1",
                "belong_page": 1,
                "question_id": "356230",
                "answer_type": 1
            },
            {
                "index": 47,
                "question_type": "1",
                "belong_page": 1,
                "question_id": "356231",
                "answer_type": 1
            },
            {
                "index": 48,
                "question_type": "5",
                "belong_page": 1,
                "question_id": "348854",
                "answer_type": 5
            }
        ],
        "progress": []
    }
}
